Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The method has 164 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The method has 151 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,The method has 276 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The method has 431 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateStatement,The method has 273 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,Program,C:\repos\Reactive-Extensions_IL2JS\Compiler\Program.cs,Main,The method has 164 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,The method has 136 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitConstructObjectAndInstanceMethods,The method has 107 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitEquals,The method has 131 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The method has 115 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The method has 112 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The method has 102 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsImported,The method has 112 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalImport,The method has 164 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The method has 304 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalExport,The method has 126 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendExport,The method has 104 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The method has 384 lines of code.
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitEntryPoint,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,InlinedMethodCache,C:\repos\Reactive-Extensions_IL2JS\Compiler\InlinedMethodCache.cs,PrimIsInlinable,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendCallExportedMethod,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,NormalMethod,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,TypeHasAttribute,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromType,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,Program,C:\repos\Reactive-Extensions_IL2JS\Compiler\Program.cs,Main,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitVirtualAndInterfaceMethodRedirectors,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitSetupType,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,ConstructObjectFunction,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitConstructObjectAndInstanceMethods,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,MemberInfoExpression,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompilerEnvironment.cs,BindUsage,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DefaultImportingConstructor,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalImport,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalExport,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,Cyclomatic complexity of the method is 26
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The method has 5 parameters. Parameters: resolver' nameSupply' calleeMethEnv' isFactory' arguments
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,DefaultMethodCallExpression,The method has 5 parameters. Parameters: resolver' nameSupply' methodRef' isFactory' arguments
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructGenericEnumeratorAtDynamicType,The method has 5 parameters. Parameters: resolver' nameSupply' optBody' fallback' obj
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructGenericEnumeratorAtStaticType,The method has 6 parameters. Parameters: resolver' nameSupply' optBody' fallback' elemType' obj
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The method has 5 parameters. Parameters: resolver' nameSupply' optBody' calleeMethEnv' arguments
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,DefaultVirtualMethodCallExpression,The method has 5 parameters. Parameters: resolver' nameSupply' optBody' methodRef' arguments
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The method has 6 parameters. Parameters: resolver' nameSupply' optBody' optLvalue' methodRef' arguments
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendInvokeImportingConstructor,The method has 5 parameters. Parameters: resolver' nameSupply' parameters' body' unmanagedObjId
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendCallExportedMethod,The method has 7 parameters. Parameters: resolver' nameSupply' assemblyDef' typeDef' methodDef' body' arguments
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateCellReadWrite,The method has 5 parameters. Parameters: methCompEnv' optBody' ignoreResult' cell' mkRexp
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateCall,The method has 5 parameters. Parameters: methCompEnv' optBody' callFlavor' methodRef' arguments
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The method has 5 parameters. Parameters: methCompEnv' optBody' optLvalue' ignoreResult' expr
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,TypeHasAttribute,The method has 5 parameters. Parameters: assemblyDef' typeDef' attrType' inheritLexically' inheritSupertypes
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,FieldHasAttribute,The method has 6 parameters. Parameters: assemblyDef' typeDef' fieldDef' attrType' inheritLexically' inheritSupertypes
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,PropertyHasAttribute,The method has 6 parameters. Parameters: assemblyDef' typeDef' propDef' attrType' inheritLexically' inheritSupertypes
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,EventHasAttribute,The method has 6 parameters. Parameters: assemblyDef' typeDef' eventDef' attrType' inheritLexically' inheritSupertypes
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,MethodHasAttribute,The method has 6 parameters. Parameters: assemblyDef' typeDef' methodDef' attrType' inheritLexically' inheritSupertypes
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParameterHasAttribute,The method has 7 parameters. Parameters: assemblyDef' typeDef' methodDef' idx' attrType' inheritLexically' inheritSupertypes
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ResultHasAttribute,The method has 6 parameters. Parameters: assemblyDef' typeDef' methodDef' attrType' inheritLexically' inheritSupertypes
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValue,The method has 5 parameters. Parameters: ctxt' attr' attrType' property' value
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValue,The method has 5 parameters. Parameters: ctxt' attrs' attrType' property' value
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromAssembly,The method has 6 parameters. Parameters: assemblyDef' attrType' property' inheritLexically' inheritSupertypes' value
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromType,The method has 7 parameters. Parameters: assemblyDef' typeDef' attrType' property' inheritLexically' inheritSupertypes' value
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromField,The method has 8 parameters. Parameters: assemblyDef' typeDef' fieldDef' attrType' property' inheritLexically' inheritSupertypes' value
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromProperty,The method has 8 parameters. Parameters: assemblyDef' typeDef' propDef' attrType' property' inheritLexically' inheritSupertypes' value
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromEvent,The method has 8 parameters. Parameters: assemblyDef' typeDef' eventDef' attrType' property' inheritLexically' inheritSupertypes' value
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromMethod,The method has 8 parameters. Parameters: assemblyDef' typeDef' methodDef' attrType' property' inheritLexically' inheritSupertypes' value
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromParameter,The method has 9 parameters. Parameters: assemblyDef' typeDef' methodDef' idx' attrType' property' inheritLexically' inheritSupertypes' value
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromResult,The method has 8 parameters. Parameters: assemblyDef' typeDef' methodDef' attrType' property' inheritLexically' inheritSupertypes' value
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,MethodCompilerEnvironment,The method has 19 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments' method' methodBoundArguments' variables' valueParameterIds' localIds' env' nameSupply' rootId' assemblyId' typeDefinitionId' methodId' typeBoundTypeParameterIds' methodBoundTypeParameterIds' typeTrace
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,EnterUntranslatedMethod,The method has 8 parameters. Parameters: env' outerNameSupply' nameSupply' rootId' assemblyId' typeDefinitonId' methEnv' typeTrace
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,EnterMethod,The method has 8 parameters. Parameters: env' outerNameSupply' nameSupply' rootId' assemblyId' typeDefinitonId' compEnv' typeTrace
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,BindMap,The method has 5 parameters. Parameters: statements' usageMap' boundMap' mkName' mkExpression
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompilerEnvironment.cs,TypeCompilerEnvironment,The method has 12 parameters. Parameters: global' skolemDefs' assembly' type' typeBoundArguments' env' nameSupply' rootId' assemblyId' typeId' typeBoundTypeParameterIds' typeTrace
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompilerEnvironment.cs,EnterType,The method has 7 parameters. Parameters: env' nameSupply' rootId' assemblyId' typeId' typeEnv' typeTrace
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,EmitMethods,The method has 5 parameters. Parameters: body' lhs' outerNameSupply' target' isStatic
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,TypeMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,AddNames,The method has 7 parameters. Parameters: env' assemblyDef' typeDef' methodSlots' fieldSlots' eventSlots' propSlots
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,ImplementableInstruction,The method has 5 parameters. Parameters: ctxt' assemblyDef' typeDef' methodDef' instruction
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,TypeRepresentation,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,TypeRepresentation,The method has 6 parameters. Parameters: state' numExportsBoundToInstance' numStepsToRootType' keyField' typeClassifier' undefininedIsNotNull
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,GetterSetterAdderRemoverNameFromMethod,The method has 5 parameters. Parameters: assemblyDef' typeDef' methodDef' prefix' script
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,GetterSetterAdderRemoverNameFromPropertyEvent,The method has 5 parameters. Parameters: assemblyDef' typeDef' methodDef' prefix' script
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The method has 5 parameters. Parameters: assemblyDef' typeDef' methodDef' script' isExport
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalImport,The method has 8 parameters. Parameters: nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The method has 7 parameters. Parameters: nameSupply' rootId' assemblyDef' typeDef' methodDef' body' arguments
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalExport,The method has 9 parameters. Parameters: nameSupply' rootId' assemblyDef' typeDef' methodDef' script' instance' body' appendCallExported
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendExport,The method has 8 parameters. Parameters: nameSupply' rootId' assemblyDef' typeDef' methodDef' instance' body' appendCallExported
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,Constants,C:\repos\Reactive-Extensions_IL2JS\Compiler\Constants.cs,,The length of the parameter GenericEnumeratorTypeConstructorName is 36.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,Constants,C:\repos\Reactive-Extensions_IL2JS\Compiler\Constants.cs,,The length of the parameter RootAssertNonNullInvalidOperation is 33.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,Constants,C:\repos\Reactive-Extensions_IL2JS\Compiler\Constants.cs,,The length of the parameter RootBindInterfaceMethodToNonVirtual is 35.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,Constants,C:\repos\Reactive-Extensions_IL2JS\Compiler\Constants.cs,,The length of the parameter RootBindInterfaceMethodToVirtual is 32.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,Constants,C:\repos\Reactive-Extensions_IL2JS\Compiler\Constants.cs,,The length of the parameter RootIEnumerableTypeConstructor is 30.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,Constants,C:\repos\Reactive-Extensions_IL2JS\Compiler\Constants.cs,,The length of the parameter RootInheritPrototypeProperties is 30.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,Constants,C:\repos\Reactive-Extensions_IL2JS\Compiler\Constants.cs,,The length of the parameter RootCollectingBindMethodBuilder is 31.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,Constants,C:\repos\Reactive-Extensions_IL2JS\Compiler\Constants.cs,,The length of the parameter RootBindFKToHKMethodRedirectors is 31.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,Constants,C:\repos\Reactive-Extensions_IL2JS\Compiler\Constants.cs,,The length of the parameter RootNewStrictPointerToArrayElem is 31.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,Constants,C:\repos\Reactive-Extensions_IL2JS\Compiler\Constants.cs,,The length of the parameter RootNewPointerToMultiDimArrayElem is 33.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,Constants,C:\repos\Reactive-Extensions_IL2JS\Compiler\Constants.cs,,The length of the parameter RootManagedAndJavaScriptImporter is 32.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,Constants,C:\repos\Reactive-Extensions_IL2JS\Compiler\Constants.cs,,The length of the parameter RootManagedAndJavaScriptExporter is 32.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,Constants,C:\repos\Reactive-Extensions_IL2JS\Compiler\Constants.cs,,The length of the parameter TypeReflectionCustomAttributes is 30.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,,The length of the parameter TheRemoveAccessorPrefixProperty is 31.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,,The length of the parameter TheRemoveAccessorUnderscoreProperty is 35.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,,The length of the parameter ThePassInstanceAsArgumentProperty is 33.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,,The length of the parameter TheSimulateMulticastEventsProperty is 34.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerEnvironment.cs,,The length of the parameter GenericEnumeratorTypeConstructorRef is 35.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the parameter numInstanceFieldsAllSupertypes is 30.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the parameter numExportsBoundToInstanceNonRuntime is 35.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,Emit,The length of the statement  "                var assmFunc = new JST.FunctionExpression(new Seq<JST.Identifier> { rootId' assemblyId }' new JST.Statements(assmBody)); " is 120.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructGenericEnumeratorAtDynamicType,The length of the statement  "            var ctorRef = new CST.PolymorphicMethodRef(env.GenericEnumeratorTypeConstructorRef' ".ctor"' false' 0' new Seq<CST.TypeRef> { selfGenericEnumeratorRef' selfArrayRef }' null); " is 174.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,BoxExpressionForType,The length of the statement  "                return JST.Expression.DotCall(resolver.RootId.ToE()' Constants.RootNewPointerToValue' obj' resolver.ResolveType(typeRef' TypePhase.Id)); " is 136.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,StringIsTrue,The length of the statement  "            return new JST.BinaryExpression(e' JST.BinaryOp.LogicalOR' new JST.BinaryExpression(e' JST.BinaryOp.StrictEquals' new JST.StringLiteral(""))); " is 142.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateStatement,The length of the statement  "                        var els = ites.Else == null ? default(JST.Statements) : new JST.Statements(TranslateStatements(methCompEnv' ites.Else)); " is 120.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,Emit,The length of the statement  "                env.AttributeHelper.MethodHasAttribute(methEnv.Assembly' methEnv.Type' methEnv.Method' env.AttributeHelper.BreakAttributeRef' false' false)) " is 140.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParseScript,The length of the statement  "                env.Log(new InvalidInteropMessage(new MessageContext(ctxt' e.Loc' null)' "syntax error in " + e.Context + ": " + e.Details)); " is 125.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,Program,C:\repos\Reactive-Extensions_IL2JS\Compiler\Program.cs,Main,The length of the statement  "                if (env.CompilationMode == CompilationMode.Traced && env.TraceFileNames.Count == 0 && string.IsNullOrEmpty(env.FinalTraceName)) " is 127.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,Program,C:\repos\Reactive-Extensions_IL2JS\Compiler\Program.cs,Main,The length of the statement  "                    env.Log(new UsageMessage("'-mode traced' must be accompanied by at least on of '-trace' or '-finalTraceName' options.")); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitVirtualAndInterfaceMethodRedirectors,The length of the statement  "                    var virtSlotName = Env.GlobalMapping.ResolveMethodDefToSlot(virtPolyMethEnv.Assembly' virtPolyMethEnv.Type' virtPolyMethEnv.Method); " is 132.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitVirtualAndInterfaceMethodRedirectors,The length of the statement  "                    var implSlotName = Env.GlobalMapping.ResolveMethodDefToSlot(implPolyMethEnv.Assembly' implPolyMethEnv.Type' implPolyMethEnv.Method); " is 132.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitConstructObjectAndInstanceMethods,The length of the statement  "            else if (s is CST.InterfaceTypeStyle || s is CST.VoidTypeStyle || (TypeCompEnv.Type.IsAbstract && TypeCompEnv.Type.IsSealed)) " is 125.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitIsValidJavaScriptType,The length of the statement  "            if (s is CST.StringTypeStyle || s is CST.NumberTypeStyle || s is CST.EnumTypeStyle || TypeCompEnv.TypeRef.Equals(Env.Global.DecimalRef)) " is 136.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,Identity,The length of the statement  "            return new JST.FunctionExpression(new Seq<JST.Identifier> { id }' new JST.Statements(new JST.ReturnStatement(id.ToE()))); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The length of the statement  "                                            setMethodDef.Arity == 2 && !Env.InlinedMethods.IsInlinable(innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' setMethodDef)) " is 123.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,PropertyInfoFromProperty,The length of the statement  "                 propDef.Get == null || !sharedMethodInfos.ContainsKey(propDef.Get) ? (JST.Expression)new JST.NullExpression() : sharedMethodInfos[propDef.Get].ToE()' " is 149.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,PropertyInfoFromProperty,The length of the statement  "                 propDef.Set == null || !sharedMethodInfos.ContainsKey(propDef.Set) ? (JST.Expression)new JST.NullExpression() : sharedMethodInfos[propDef.Set].ToE()); " is 150.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompilerEnvironment.cs,BindBaseTypes,The length of the statement  "                        boundTypes.Add(baseTypeEnv.TypeConstructorRef' new ExpressionAndPhase(JST.Expression.Dot(baseType' Constants.TypeApplicand)' TypePhase.Slots)); " is 143.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompilerEnvironment.cs,BindSpecial,The length of the statement  "                    (TypeConstructorRef' new ExpressionAndPhase(JST.Expression.Dot(typeId.ToE()' Constants.TypeApplicand)' TypePhase.Constructed)); " is 127.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompilerEnvironment.cs,BindSpecial,The length of the statement  "                boundTypes.Add(TypeBoundArguments[i]' new ExpressionAndPhase(TypeBoundTypeParameterIds[i].ToE()' TypePhase.Constructed)); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The length of the statement  "                    else if (!Env.Validity.IsMustHaveADefinition(methodDef.QualifiedMemberName(Env.Global' TyconEnv.Assembly' TyconEnv.Type)) && " is 124.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,Emit,The length of the statement  "                Env.AttributeHelper.TypeHasAttribute(TyconEnv.Assembly' TyconEnv.Type' Env.AttributeHelper.BreakAttributeRef' false' false)) " is 124.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,FieldAlwaysUsed,The length of the statement  "            if (env.AttributeHelper.FieldHasAttribute(assemblyDef' typeDef' fieldDef' env.Global.CompilerGeneratedAttributeRef' false)) " is 123.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,FieldAlwaysUsed,The length of the statement  "            if (env.AttributeHelper.FieldHasAttribute(assemblyDef' typeDef' fieldDef' env.AttributeHelper.IgnoreAttributeRef' true' true)) " is 126.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,FieldAlwaysUsed,The length of the statement  "            env.AttributeHelper.GetValueFromField(assemblyDef' typeDef' fieldDef' env.AttributeHelper.UsedAttributeRef' env.AttributeHelper.TheIsUsedProperty' true' false' ref isUsed); " is 172.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,MethodAlwaysUsed,The length of the statement  "            if (env.AttributeHelper.MethodHasAttribute(assemblyDef' typeDef' methodDef' env.Global.CompilerGeneratedAttributeRef' false)) " is 125.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,IgnoreMethodDefBody,The length of the statement  "            return env.AttributeHelper.MethodHasAttribute(assemblyDef' typeDef' methodDef' env.AttributeHelper.InteropGeneratedAttributeRef' false' false); " is 143.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "                              "a type with state 'JavaScriptOnly' type cannot contain managed instance fields' either directly or inherited from supertypes")); " is 129.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The conditional expression  "s is CST.ObjectTypeStyle && !calleeMethEnv.Method.IsStatic &&                  calleeMethEnv.Method.Name.Equals(".ctor"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The conditional expression  "s is CST.NullableTypeStyle && !calleeMethEnv.Method.IsStatic &&                       calleeMethEnv.Method.Name.Equals(".ctor"' StringComparison.Ordinal) &&                       calleeMethEnv.Method.Arity == 2"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The conditional expression  "calleeMethEnv.TypeRef.Equals(env.Global.ArrayRef) &&                       calleeMethEnv.Method.Name.Equals("GetEnumerator"' StringComparison.Ordinal) &&                       calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The conditional expression  "calleeMethEnv.TypeRef.Equals(env.Global.IEnumerableRef) &&                       calleeMethEnv.Method.Name.Equals("GetEnumerator"' StringComparison.Ordinal) &&                       calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The conditional expression  "calleeMethEnv.TypeConstructorRef.Equals(env.Global.IEnumerableTypeConstructorRef) &&                       calleeMethEnv.Method.Name.Equals("GetEnumerator"' StringComparison.Ordinal) &&                       calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateConditionalExpression,The conditional expression  "s is CST.ObjectTypeStyle || s is CST.StringTypeStyle || s is CST.ParameterTypeStyle || s is CST.NullTypeStyle"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitConstructObjectAndInstanceMethods,The conditional expression  "s is CST.InterfaceTypeStyle || s is CST.VoidTypeStyle || (TypeCompEnv.Type.IsAbstract && TypeCompEnv.Type.IsSealed)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitIsValidJavaScriptType,The conditional expression  "s is CST.StringTypeStyle || s is CST.NumberTypeStyle || s is CST.EnumTypeStyle || TypeCompEnv.TypeRef.Equals(Env.Global.DecimalRef)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The conditional expression  "setMethodDef != null && setMethodDef.Invalid == null && setMethodDef.IsUsed &&                                              setMethodDef.Arity == 2 && !Env.InlinedMethods.IsInlinable(innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' setMethodDef)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The conditional expression  "state != InstanceState.JavaScriptOnly && state != InstanceState.ManagedAndJavaScript &&                               !methodDef.IsStatic && methodDef.IsConstructor && methodDef.Arity > 1 &&                               methodDef.ValueParameters[1].Equals(Env.JSContextRef)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The conditional expression  "!methodDef.IsStatic && methodDef.IsConstructor && methodDef.Arity == 1 &&                                   !Env.InteropManager.IsFactory(TyconEnv.Assembly' TyconEnv.Type' methodDef)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,PropogateExtraUsedFromMember,The conditional expression  "!methodDef.IsStatic && methodDef.IsConstructor &&                      env.InteropManager.IsImported(assemblyDef' typeDef' methodDef) &&                      !env.InteropManager.IsFactory(assemblyDef' typeDef' methodDef)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The conditional expression  "script == null && !methodDef.IsStatic && methodDef.IsConstructor && qual == Qualification.None"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The conditional expression  "isExport && !isNonInstance && !isProto && qual != Qualification.None"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The conditional expression  "isExport && !isNonInstance && isProto && qual == Qualification.None"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsExported,The conditional expression  "!methodDef.IsStatic && methodDef.IsConstructor && methodDef.Arity > 1 &&                  methodDef.ValueParameters[1].Type.Equals(env.JSContextRef)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The conditional expression  "s is CST.PointerTypeStyle || s is CST.CodePointerTypeStyle || s is CST.NullableTypeStyle ||                  s is CST.ArrayTypeStyle || s is CST.ValueTypeStyle || s is CST.DelegateTypeStyle ||                  s is CST.InterfaceTypeStyle"  is complex.
Virtual Method Call from Constructor,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,AssemblyMapping,The constructor "AssemblyMapping" calls a virtual method "EffectiveName".
Empty Catch Block,Microsoft.LiveLabs.JavaScript.IL2JS,Program,C:\repos\Reactive-Extensions_IL2JS\Compiler\Program.cs,Main,The method has an empty catch block.
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitTypeBindings,The following statement contains a magic number: switch (Env.CompilationMode)              {                  case CompilationMode.Plain:                  case CompilationMode.Collecting:                  {                      if (Env.DebugMode)                          body.Add(new JST.CommentStatement("Type builders"));                      var args = new Seq<JST.Expression>();                      args.Add(assemblyId.ToE());                      args.Add(new JST.NullExpression());                      foreach (var typeDef in typeDefs)                      {                          var slotName = Env.GlobalMapping.ResolveTypeDefToSlot(assmEnv.Assembly' typeDef);                          var typeName = CST.CSTWriter.WithAppend                              (Env.Global' CST.WriterStyle.Uniform' typeDef.EffectiveName(Env.Global).Append);                          args.Add(new JST.StringLiteral(slotName));                          args.Add(new JST.StringLiteral(typeName));                      }                      if (args.Count > 2)                          body.Add(JST.Statement.DotCall(rootId.ToE()' Constants.RootBindTypeBuilders' args));                      break;                  }              case CompilationMode.Traced:                  {                      // Types in the initial trace' this trace' or remainder trace are bound via builder with                      // null trace name. All other types are bound via builder with their containing trace name.                      var traceToArgs = new Map<string' Seq<JST.Expression>>();                      var remainingArgs = new Seq<JST.Expression>();                      remainingArgs.Add(assemblyId.ToE());                      remainingArgs.Add(new JST.NullExpression());                      foreach (var typeDef in typeDefs)                      {                          var typeName = CST.CSTWriter.WithAppend                              (Env.Global' CST.WriterStyle.Uniform' typeDef.EffectiveName(Env.Global).Append);                          var slotName = Env.GlobalMapping.ResolveTypeDefToSlot(assmEnv.Assembly' typeDef);                          var defTrace = Env.Traces.TypeToTrace[typeDef.QualifiedTypeName(Env.Global' assmEnv.Assembly)];                          if (defTrace.Flavor == TraceFlavor.OnDemand && defTrace != assemblyTrace.Parent)                          {                              var args = default(Seq<JST.Expression>);                              if (!traceToArgs.TryGetValue(defTrace.Name' out args))                              {                                  args = new Seq<JST.Expression>();                                  args.Add(assemblyId.ToE());                                  args.Add(new JST.StringLiteral(defTrace.Name));                                  traceToArgs.Add(defTrace.Name' args);                              }                              args.Add(new JST.StringLiteral(slotName));                              args.Add(new JST.StringLiteral(typeName));                          }                          else                          {                              remainingArgs.Add(new JST.StringLiteral(slotName));                              remainingArgs.Add(new JST.StringLiteral(typeName));                          }                      }                      foreach (var kv in traceToArgs)                          body.Add(JST.Statement.DotCall(rootId.ToE()' Constants.RootBindTypeBuilders' kv.Value));                      if (remainingArgs.Count > 2)                          body.Add(JST.Statement.DotCall(rootId.ToE()' Constants.RootBindTypeBuilders' remainingArgs));                      break;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitTypeBindings,The following statement contains a magic number: switch (Env.CompilationMode)              {                  case CompilationMode.Plain:                  case CompilationMode.Collecting:                  {                      if (Env.DebugMode)                          body.Add(new JST.CommentStatement("Type builders"));                      var args = new Seq<JST.Expression>();                      args.Add(assemblyId.ToE());                      args.Add(new JST.NullExpression());                      foreach (var typeDef in typeDefs)                      {                          var slotName = Env.GlobalMapping.ResolveTypeDefToSlot(assmEnv.Assembly' typeDef);                          var typeName = CST.CSTWriter.WithAppend                              (Env.Global' CST.WriterStyle.Uniform' typeDef.EffectiveName(Env.Global).Append);                          args.Add(new JST.StringLiteral(slotName));                          args.Add(new JST.StringLiteral(typeName));                      }                      if (args.Count > 2)                          body.Add(JST.Statement.DotCall(rootId.ToE()' Constants.RootBindTypeBuilders' args));                      break;                  }              case CompilationMode.Traced:                  {                      // Types in the initial trace' this trace' or remainder trace are bound via builder with                      // null trace name. All other types are bound via builder with their containing trace name.                      var traceToArgs = new Map<string' Seq<JST.Expression>>();                      var remainingArgs = new Seq<JST.Expression>();                      remainingArgs.Add(assemblyId.ToE());                      remainingArgs.Add(new JST.NullExpression());                      foreach (var typeDef in typeDefs)                      {                          var typeName = CST.CSTWriter.WithAppend                              (Env.Global' CST.WriterStyle.Uniform' typeDef.EffectiveName(Env.Global).Append);                          var slotName = Env.GlobalMapping.ResolveTypeDefToSlot(assmEnv.Assembly' typeDef);                          var defTrace = Env.Traces.TypeToTrace[typeDef.QualifiedTypeName(Env.Global' assmEnv.Assembly)];                          if (defTrace.Flavor == TraceFlavor.OnDemand && defTrace != assemblyTrace.Parent)                          {                              var args = default(Seq<JST.Expression>);                              if (!traceToArgs.TryGetValue(defTrace.Name' out args))                              {                                  args = new Seq<JST.Expression>();                                  args.Add(assemblyId.ToE());                                  args.Add(new JST.StringLiteral(defTrace.Name));                                  traceToArgs.Add(defTrace.Name' args);                              }                              args.Add(new JST.StringLiteral(slotName));                              args.Add(new JST.StringLiteral(typeName));                          }                          else                          {                              remainingArgs.Add(new JST.StringLiteral(slotName));                              remainingArgs.Add(new JST.StringLiteral(typeName));                          }                      }                      foreach (var kv in traceToArgs)                          body.Add(JST.Statement.DotCall(rootId.ToE()' Constants.RootBindTypeBuilders' kv.Value));                      if (remainingArgs.Count > 2)                          body.Add(JST.Statement.DotCall(rootId.ToE()' Constants.RootBindTypeBuilders' remainingArgs));                      break;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitAssemblyBindings,The following statement contains a magic number: switch (Env.CompilationMode)              {              case CompilationMode.Plain:              case CompilationMode.Collecting:                  {                      if (Env.DebugMode)                          body.Add(new JST.CommentStatement("Referenced assemblies"));                      var args = new Seq<JST.Expression>();                      args.Add(assemblyId.ToE());                      args.Add(new JST.NullExpression());                      foreach (var nm in assmEnv.AllAssembliesInLoadOrder())                      {                          if (!nm.Equals(Env.Global.MsCorLibName) && !nm.Equals(assmEnv.Assembly.Name))                          {                              var assmName = CST.CSTWriter.WithAppend(Env.Global' CST.WriterStyle.Uniform' nm.Append);                              var slotName = Env.GlobalMapping.ResolveAssemblyReferenceToSlot(assmEnv.Assembly' nm);                              args.Add(new JST.StringLiteral(slotName));                              args.Add(new JST.StringLiteral(assmName));                          }                          // else: don't need ref to mscorlib or self                      }                      if (args.Count > 2)                          body.Add                              (JST.Statement.DotCall(rootId.ToE()' Constants.RootBindAssemblyBuilders' args));                      break;                  }              case CompilationMode.Traced:                  {                      // Assemblies in the initial trace' this trace' or the remainder trace are bound via a builder                      // which is given the null trace name. All other assemblies are bound by a builder given their                      // containing trace name.                      var traceToArgs = new Map<string' Seq<JST.Expression>>();                      var remainingArgs = new Seq<JST.Expression>();                      remainingArgs.Add(assemblyId.ToE());                      remainingArgs.Add(new JST.NullExpression());                      foreach (var nm in assmEnv.AllAssembliesInLoadOrder())                      {                          if (!nm.Equals(Env.Global.MsCorLibName) && !nm.Equals(assmEnv.Assembly.Name))                          {                              var assmName = CST.CSTWriter.WithAppend(Env.Global' CST.WriterStyle.Uniform' nm.Append);                              var slotName = Env.GlobalMapping.ResolveAssemblyReferenceToSlot(assmEnv.Assembly' nm);                              var defTrace = Env.Traces.AssemblyToTrace[nm];                              if (defTrace.Flavor == TraceFlavor.OnDemand && defTrace != assemblyTrace.Parent)                              {                                  var args = default(Seq<JST.Expression>);                                  if (!traceToArgs.TryGetValue(defTrace.Name' out args))                                  {                                      args = new Seq<JST.Expression>();                                      args.Add(assemblyId.ToE());                                      args.Add(new JST.StringLiteral(defTrace.Name));                                      traceToArgs.Add(defTrace.Name' args);                                  }                                  args.Add(new JST.StringLiteral(slotName));                                  args.Add(new JST.StringLiteral(assmName));                              }                              else                              {                                  remainingArgs.Add(new JST.StringLiteral(slotName));                                  remainingArgs.Add(new JST.StringLiteral(assmName));                              }                          }                          // else: don't need ref to mscorlib or self                      }                      foreach (var kv in traceToArgs)                          body.Add(JST.Statement.DotCall(rootId.ToE()' Constants.RootBindAssemblyBuilders' kv.Value));                      if (remainingArgs.Count > 2)                          body.Add                              (JST.Statement.DotCall(rootId.ToE()' Constants.RootBindAssemblyBuilders' remainingArgs));                      break;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitAssemblyBindings,The following statement contains a magic number: switch (Env.CompilationMode)              {              case CompilationMode.Plain:              case CompilationMode.Collecting:                  {                      if (Env.DebugMode)                          body.Add(new JST.CommentStatement("Referenced assemblies"));                      var args = new Seq<JST.Expression>();                      args.Add(assemblyId.ToE());                      args.Add(new JST.NullExpression());                      foreach (var nm in assmEnv.AllAssembliesInLoadOrder())                      {                          if (!nm.Equals(Env.Global.MsCorLibName) && !nm.Equals(assmEnv.Assembly.Name))                          {                              var assmName = CST.CSTWriter.WithAppend(Env.Global' CST.WriterStyle.Uniform' nm.Append);                              var slotName = Env.GlobalMapping.ResolveAssemblyReferenceToSlot(assmEnv.Assembly' nm);                              args.Add(new JST.StringLiteral(slotName));                              args.Add(new JST.StringLiteral(assmName));                          }                          // else: don't need ref to mscorlib or self                      }                      if (args.Count > 2)                          body.Add                              (JST.Statement.DotCall(rootId.ToE()' Constants.RootBindAssemblyBuilders' args));                      break;                  }              case CompilationMode.Traced:                  {                      // Assemblies in the initial trace' this trace' or the remainder trace are bound via a builder                      // which is given the null trace name. All other assemblies are bound by a builder given their                      // containing trace name.                      var traceToArgs = new Map<string' Seq<JST.Expression>>();                      var remainingArgs = new Seq<JST.Expression>();                      remainingArgs.Add(assemblyId.ToE());                      remainingArgs.Add(new JST.NullExpression());                      foreach (var nm in assmEnv.AllAssembliesInLoadOrder())                      {                          if (!nm.Equals(Env.Global.MsCorLibName) && !nm.Equals(assmEnv.Assembly.Name))                          {                              var assmName = CST.CSTWriter.WithAppend(Env.Global' CST.WriterStyle.Uniform' nm.Append);                              var slotName = Env.GlobalMapping.ResolveAssemblyReferenceToSlot(assmEnv.Assembly' nm);                              var defTrace = Env.Traces.AssemblyToTrace[nm];                              if (defTrace.Flavor == TraceFlavor.OnDemand && defTrace != assemblyTrace.Parent)                              {                                  var args = default(Seq<JST.Expression>);                                  if (!traceToArgs.TryGetValue(defTrace.Name' out args))                                  {                                      args = new Seq<JST.Expression>();                                      args.Add(assemblyId.ToE());                                      args.Add(new JST.StringLiteral(defTrace.Name));                                      traceToArgs.Add(defTrace.Name' args);                                  }                                  args.Add(new JST.StringLiteral(slotName));                                  args.Add(new JST.StringLiteral(assmName));                              }                              else                              {                                  remainingArgs.Add(new JST.StringLiteral(slotName));                                  remainingArgs.Add(new JST.StringLiteral(assmName));                              }                          }                          // else: don't need ref to mscorlib or self                      }                      foreach (var kv in traceToArgs)                          body.Add(JST.Statement.DotCall(rootId.ToE()' Constants.RootBindAssemblyBuilders' kv.Value));                      if (remainingArgs.Count > 2)                          body.Add                              (JST.Statement.DotCall(rootId.ToE()' Constants.RootBindAssemblyBuilders' remainingArgs));                      break;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals(opt' "-allWarns"))                  env.NoWarns = new Set<string>();              else if (c.Equals(opt' "-assemblyNameResolution"))              {                  var f = getArgs(1)[0];                  if (c.Equals(f' "full"))                      env.AssemblyNameResolution = CST.AssemblyNameResolution.Full;                  else if (c.Equals(f' "nameVersion"))                      env.AssemblyNameResolution = CST.AssemblyNameResolution.NameVersion;                  else if (c.Equals(f' "name"))                      env.AssemblyNameResolution = CST.AssemblyNameResolution.Name;                  else                  {                      log(new UsageMessage("Unrecognised -assemblyNameResolution value"));                      throw new ExitException();                  }              }              else if (c.Equals(opt' "-augment"))                  env.AugmentationFileNames.Add(ExpandVars(getArgs(1)[0]));              else if (c.Equals(opt' "-breakOnBreak"))                  env.BreakOnBreak = false;              else if (c.Equals(opt' "+breakOnBreak"))                  env.BreakOnBreak = true;              else if (c.Equals(opt' "-clrArraySemantics"))                  env.CLRArraySemantics = false;              else if (c.Equals(opt' "+clrArraySemantics"))                  env.CLRArraySemantics = true;              else if (c.Equals(opt' "-clrInteropExceptions"))                  env.CLRInteropExceptions = false;              else if (c.Equals(opt' "+clrInteropExceptions"))                  env.CLRInteropExceptions = true;              else if (c.Equals(opt' "-clrNullVirtcallSemantics"))                  env.CLRNullVirtcallSemantics = false;              else if (c.Equals(opt' "+clrNullVirtcallSemantics"))                  env.CLRNullVirtcallSemantics = true;              else if (c.Equals(opt' "-compile"))                  env.CompileFileNames.Add(ExpandVars(getArgs(1)[0]));              else if (c.Equals(opt' "-debug"))              {                  env.DebugMode = false;                  env.PrettyPrint = false;                  env.DebugLevel = 0;              }              else if (c.Equals(opt' "+debug"))              {                  env.DebugMode = true;                  env.PrettyPrint = true;                  env.DebugLevel = 1;              }              else if (c.Equals(opt' "-debugLevel"))              {                  var n = default(int);                  if (!int.TryParse(getArgs(1)[0]' out n) || n < 0 || n > 2)                  {                      log(new UsageMessage("Invalid -debugLevel value"));                      throw new ExitException();                  }                  env.DebugLevel = n;              }              else if (c.Equals(opt' "-debugTrace"))                  env.DebugTraceFileName = getArgs(1)[0];              else if (c.Equals(opt' "-finalTraceName"))                  env.FinalTraceName = getArgs(1)[0];              else if (c.Equals(opt' "-help"))                  Usage(null);              else if (c.Equals(opt' "-inDir"))                  env.InputDirectory = ExpandVars(getArgs(1)[0]);              else if (c.Equals(opt' "-initialTrace"))                  env.InitialTraceFileName = getArgs(1)[0];              else if (c.Equals(opt' "-importInlineThreshold"))              {                  var i = default(int);                  if (!int.TryParse(getArgs(1)[0]' out i))                  {                      log(new UsageMessage("Invalid -importInlineThreshold value"));                      throw new ExitException();                  }                  env.ImportInlineThreshold = Math.Max(-1' i);              }              else if (c.Equals(opt' "-inlineThreshold"))              {                  var i = default(int);                  if (!int.TryParse(getArgs(1)[0]' out i))                  {                      log(new UsageMessage("Invalid -inlineThreshold value"));                      throw new ExitException();                  }                  env.InlineThreshold = Math.Max(-1' i);              }              else if (c.Equals(opt' "-loadPath"))                  env.LoadPaths.Add(getArgs(1)[0]);              else if (c.Equals(opt' "-mode"))              {                  var m = getArgs(1)[0];                  if (c.Equals(m' "plain"))                      env.CompilationMode = CompilationMode.Plain;                  else if (c.Equals(m' "collecting"))                      env.CompilationMode = CompilationMode.Collecting;                  else if (c.Equals(m' "traced"))                      env.CompilationMode = CompilationMode.Traced;                  else                  {                      log(new UsageMessage("Invalid -mode value"));                      throw new ExitException();                  }              }              else if (c.Equals(opt' "-noWarn"))              {                  var id = getArgs(1)[0].Trim().ToLowerInvariant();                  env.NoWarns.Add(id);              }              else if (c.Equals(opt' "-original"))                  env.OriginalStrongNames.Add(getArgs(1)[0]);              else if (c.Equals(opt' "-outDir"))                  env.OutputDirectory = ExpandVars(getArgs(1)[0]);              else if (c.Equals(opt' "+prettyPrint"))                  env.PrettyPrint = true;              else if (c.Equals(opt' "-prettyPrint"))                  env.PrettyPrint = false;              else if (c.Equals(opt' "-reference"))                  env.ReferenceFileNames.Add(ExpandVars(getArgs(1)[0]));              else if (c.Equals(opt' "-rename"))              {                  var args = getArgs(2);                  env.RenameRules.Add(new CST.RenameRule(args[0]' args[1]));              }              else if (c.Equals(opt' "-root"))                  env.Root = getArgs(1)[0];              else if (c.Equals(opt' "-safeInterop"))                  env.SafeInterop = false;              else if (c.Equals(opt' "+safeInterop"))                  env.SafeInterop = true;              else if (c.Equals(opt' "-skipUpToDate"))                  env.SkipUpToDate = false;              else if (c.Equals(opt' "+skipUpToDate"))                  env.SkipUpToDate = true;              else if (c.Equals(opt' "-target"))              {                  var str = getArgs(1)[0];                  if (c.Equals(str' "browser"))                      env.Target = Target.Browser;                  else if (c.Equals(str' "cscript"))                      env.Target = Target.CScript;                  else                  {                      log(new UsageMessage("Invalid -target value"));                      throw new ExitException();                  }              }              else if (c.Equals(opt' "-trace"))                  env.TraceFileNames.Add(getArgs(1)[0]);              else if (c.Equals(opt' "+warn"))              {                  var id = getArgs(1)[0].Trim().ToLowerInvariant();                  env.NoWarns = env.NoWarns.Where(id2 => !id2.Equals(id' StringComparison.Ordinal)).ToSet();              }              else              {                  log(new UsageMessage("Unrecognised option '" + opt + "'"));                  throw new ExitException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals(opt' "-allWarns"))                  env.NoWarns = new Set<string>();              else if (c.Equals(opt' "-assemblyNameResolution"))              {                  var f = getArgs(1)[0];                  if (c.Equals(f' "full"))                      env.AssemblyNameResolution = CST.AssemblyNameResolution.Full;                  else if (c.Equals(f' "nameVersion"))                      env.AssemblyNameResolution = CST.AssemblyNameResolution.NameVersion;                  else if (c.Equals(f' "name"))                      env.AssemblyNameResolution = CST.AssemblyNameResolution.Name;                  else                  {                      log(new UsageMessage("Unrecognised -assemblyNameResolution value"));                      throw new ExitException();                  }              }              else if (c.Equals(opt' "-augment"))                  env.AugmentationFileNames.Add(ExpandVars(getArgs(1)[0]));              else if (c.Equals(opt' "-breakOnBreak"))                  env.BreakOnBreak = false;              else if (c.Equals(opt' "+breakOnBreak"))                  env.BreakOnBreak = true;              else if (c.Equals(opt' "-clrArraySemantics"))                  env.CLRArraySemantics = false;              else if (c.Equals(opt' "+clrArraySemantics"))                  env.CLRArraySemantics = true;              else if (c.Equals(opt' "-clrInteropExceptions"))                  env.CLRInteropExceptions = false;              else if (c.Equals(opt' "+clrInteropExceptions"))                  env.CLRInteropExceptions = true;              else if (c.Equals(opt' "-clrNullVirtcallSemantics"))                  env.CLRNullVirtcallSemantics = false;              else if (c.Equals(opt' "+clrNullVirtcallSemantics"))                  env.CLRNullVirtcallSemantics = true;              else if (c.Equals(opt' "-compile"))                  env.CompileFileNames.Add(ExpandVars(getArgs(1)[0]));              else if (c.Equals(opt' "-debug"))              {                  env.DebugMode = false;                  env.PrettyPrint = false;                  env.DebugLevel = 0;              }              else if (c.Equals(opt' "+debug"))              {                  env.DebugMode = true;                  env.PrettyPrint = true;                  env.DebugLevel = 1;              }              else if (c.Equals(opt' "-debugLevel"))              {                  var n = default(int);                  if (!int.TryParse(getArgs(1)[0]' out n) || n < 0 || n > 2)                  {                      log(new UsageMessage("Invalid -debugLevel value"));                      throw new ExitException();                  }                  env.DebugLevel = n;              }              else if (c.Equals(opt' "-debugTrace"))                  env.DebugTraceFileName = getArgs(1)[0];              else if (c.Equals(opt' "-finalTraceName"))                  env.FinalTraceName = getArgs(1)[0];              else if (c.Equals(opt' "-help"))                  Usage(null);              else if (c.Equals(opt' "-inDir"))                  env.InputDirectory = ExpandVars(getArgs(1)[0]);              else if (c.Equals(opt' "-initialTrace"))                  env.InitialTraceFileName = getArgs(1)[0];              else if (c.Equals(opt' "-importInlineThreshold"))              {                  var i = default(int);                  if (!int.TryParse(getArgs(1)[0]' out i))                  {                      log(new UsageMessage("Invalid -importInlineThreshold value"));                      throw new ExitException();                  }                  env.ImportInlineThreshold = Math.Max(-1' i);              }              else if (c.Equals(opt' "-inlineThreshold"))              {                  var i = default(int);                  if (!int.TryParse(getArgs(1)[0]' out i))                  {                      log(new UsageMessage("Invalid -inlineThreshold value"));                      throw new ExitException();                  }                  env.InlineThreshold = Math.Max(-1' i);              }              else if (c.Equals(opt' "-loadPath"))                  env.LoadPaths.Add(getArgs(1)[0]);              else if (c.Equals(opt' "-mode"))              {                  var m = getArgs(1)[0];                  if (c.Equals(m' "plain"))                      env.CompilationMode = CompilationMode.Plain;                  else if (c.Equals(m' "collecting"))                      env.CompilationMode = CompilationMode.Collecting;                  else if (c.Equals(m' "traced"))                      env.CompilationMode = CompilationMode.Traced;                  else                  {                      log(new UsageMessage("Invalid -mode value"));                      throw new ExitException();                  }              }              else if (c.Equals(opt' "-noWarn"))              {                  var id = getArgs(1)[0].Trim().ToLowerInvariant();                  env.NoWarns.Add(id);              }              else if (c.Equals(opt' "-original"))                  env.OriginalStrongNames.Add(getArgs(1)[0]);              else if (c.Equals(opt' "-outDir"))                  env.OutputDirectory = ExpandVars(getArgs(1)[0]);              else if (c.Equals(opt' "+prettyPrint"))                  env.PrettyPrint = true;              else if (c.Equals(opt' "-prettyPrint"))                  env.PrettyPrint = false;              else if (c.Equals(opt' "-reference"))                  env.ReferenceFileNames.Add(ExpandVars(getArgs(1)[0]));              else if (c.Equals(opt' "-rename"))              {                  var args = getArgs(2);                  env.RenameRules.Add(new CST.RenameRule(args[0]' args[1]));              }              else if (c.Equals(opt' "-root"))                  env.Root = getArgs(1)[0];              else if (c.Equals(opt' "-safeInterop"))                  env.SafeInterop = false;              else if (c.Equals(opt' "+safeInterop"))                  env.SafeInterop = true;              else if (c.Equals(opt' "-skipUpToDate"))                  env.SkipUpToDate = false;              else if (c.Equals(opt' "+skipUpToDate"))                  env.SkipUpToDate = true;              else if (c.Equals(opt' "-target"))              {                  var str = getArgs(1)[0];                  if (c.Equals(str' "browser"))                      env.Target = Target.Browser;                  else if (c.Equals(str' "cscript"))                      env.Target = Target.CScript;                  else                  {                      log(new UsageMessage("Invalid -target value"));                      throw new ExitException();                  }              }              else if (c.Equals(opt' "-trace"))                  env.TraceFileNames.Add(getArgs(1)[0]);              else if (c.Equals(opt' "+warn"))              {                  var id = getArgs(1)[0].Trim().ToLowerInvariant();                  env.NoWarns = env.NoWarns.Where(id2 => !id2.Equals(id' StringComparison.Ordinal)).ToSet();              }              else              {                  log(new UsageMessage("Unrecognised option '" + opt + "'"));                  throw new ExitException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PhaseExpression,The following statement contains a magic number: switch (phase)              {                  case TypePhase.Id:                      return new JST.NumericLiteral(1);                  case TypePhase.Slots:                      return new JST.NumericLiteral(2);                  case TypePhase.Constructed:                      return new JST.NumericLiteral(3);                  default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PhaseExpression,The following statement contains a magic number: switch (phase)              {                  case TypePhase.Id:                      return new JST.NumericLiteral(1);                  case TypePhase.Slots:                      return new JST.NumericLiteral(2);                  case TypePhase.Constructed:                      return new JST.NumericLiteral(3);                  default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The following statement contains a magic number: if (s is CST.ObjectTypeStyle && !calleeMethEnv.Method.IsStatic &&                  calleeMethEnv.Method.Name.Equals(".ctor"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1)              {                  // SPECIAL CASE: Object constructor is the identity                  return null;              }              else if (s is CST.NullableTypeStyle && !calleeMethEnv.Method.IsStatic &&                       calleeMethEnv.Method.Name.Equals(".ctor"' StringComparison.Ordinal) &&                       calleeMethEnv.Method.Arity == 2)              {                  // SPECIAL CASE: Nullable`1::.ctor(ptr' x) is just ptr.W(x)                  return JST.Expression.DotCall(arguments[0]' Constants.PointerWrite' arguments[1]);              }              else if (s is CST.NullableTypeStyle &&                       calleeMethEnv.Method.Name.Equals("get_HasValue"' StringComparison.Ordinal))              {                  // SPECIAL CASE: Nullable`1::get_HasValue(ptr) becomes ptr.R() != null                  return JST.Expression.IsNotNull(JST.Expression.DotCall(arguments[0]' Constants.PointerRead));              }              else if (s is CST.NullableTypeStyle &&                       calleeMethEnv.Method.Name.Equals("get_Value"' StringComparison.Ordinal))              {                  // SPECIAL CASE: Nullable`1::get_Value(ptr) becomes AssertNonNullInvalidOperation(ptr.R())                  return JST.Expression.DotCall                      (resolver.RootId.ToE()'                       Constants.RootAssertNonNullInvalidOperation'                       JST.Expression.DotCall(arguments[0]' Constants.PointerRead));              }              else if (s is CST.MultiDimArrayTypeStyle &&                       calleeMethEnv.Method.Name.Equals("Get"' StringComparison.Ordinal))              {                  // SPECIAL CASE: Multi-dimensional array get                  return JST.Expression.DotCall                      (resolver.RootId.ToE()' Constants.RootGetMultiDimArrayValue' arguments);              }              else if (s is CST.MultiDimArrayTypeStyle &&                       calleeMethEnv.Method.Name.Equals("Set"' StringComparison.Ordinal))              {                  // SPECIAL CASE: Multi-dimensional array set                  return JST.Expression.DotCall                      (resolver.RootId.ToE()' Constants.RootSetMultiDimArrayValue' arguments);              }              else if (s is CST.MultiDimArrayTypeStyle &&                       calleeMethEnv.Method.Name.Equals("Address"' StringComparison.Ordinal))              {                  // SPECIAL CASE: Multi-dimensional array element address                  var elemType = resolver.ResolveType(calleeMethEnv.TypeBoundArguments[0]);                  var allArgs = new Seq<JST.Expression> { elemType };                  foreach (var a in arguments)                      allArgs.Add(a);                  return JST.Expression.DotCall                      (resolver.RootId.ToE()'                       Constants.RootNewPointerToMultiDimArrayElem'                       allArgs);              }              else if (calleeMethEnv.TypeRef.Equals(env.Global.DebuggerRef) &&                       calleeMethEnv.Method.Name.Equals("Break"' StringComparison.Ordinal))              {                  // SPECIAL CASE: Break into debugger directly                  return new JST.DebuggerExpression();              }              else if (calleeMethEnv.Method.IsStatic || isFactory)              {                  var type = resolver.ResolveType(calleeMethEnv.TypeRef);                  var args =                      calleeMethEnv.MethodBoundArguments.Select(resolver.ResolveType).Concat                          (arguments).ToSeq();                  return new JST.CallExpression                      (new JST.IndexExpression                           (type' MethodSlotName(resolver' calleeMethEnv.MethodRef' false))'                       args);              }              else              {                  if (arguments.Count == 0)                      throw new InvalidOperationException("mismatched method arity");                  var target = arguments[0];                  var args =                      calleeMethEnv.MethodBoundArguments.Select(resolver.ResolveType).Concat                          (arguments.Skip(1)).ToSeq();                  return new JST.CallExpression                      (new JST.IndexExpression                           (target' MethodSlotName(resolver' calleeMethEnv.MethodRef' false))'                       args);              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The following statement contains a magic number: if (s is CST.DelegateTypeStyle)              {                  var delTypeDef = (CST.DelegateTypeDef)calleeMethEnv.Type;                  if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 1 &&                      calleeMethEnv.Method.TypeArity == 0 &&                      calleeMethEnv.Method.Name.Equals("Invoke"' StringComparison.Ordinal))                  {                      // SPECIAL CASE: Invoke rewritten to direct function application                      return new JST.CallExpression(target' arguments.Skip(1).ToSeq());                  }                  else if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 3 &&                           calleeMethEnv.Method.TypeArity == 0 &&                           calleeMethEnv.Method.Name.Equals("BeginInvoke"' StringComparison.Ordinal))                  {                      // SPECIAL CASE: BeginInvoke rewritten to runtime call                      var resType = calleeMethEnv.SubstituteType(delTypeDef.Result.Type);                      var resTypeExpr = resType == null                                            ? null                                            : resolver.ResolveType(resType' TypePhase.Constructed);                      var args = new Seq<JST.Expression>();                      args.Add(new JST.NumericLiteral(delTypeDef.ValueParameters.Count));                      args.Add(resTypeExpr);                      args.Add(target);                      foreach (var a in arguments.Skip(1))                          args.Add(a);                      return JST.Expression.DotCall(resolver.RootId.ToE()' Constants.RootDelegateBeginInvoke' args);                  }                  else if (calleeMethEnv.Method.Arity == 2 && calleeMethEnv.Method.TypeArity == 0 &&                           calleeMethEnv.Method.Name.Equals("EndInvoke"' StringComparison.Ordinal))                  {                      // SPECIAL CASE: EndInvoke rewritten to runtime call                      var resType = calleeMethEnv.SubstituteType(delTypeDef.Result.Type);                      var resTypeExpr = resType == null                                            ? null                                            : resolver.ResolveType(resType' TypePhase.Constructed);                      var args = new Seq<JST.Expression>();                      args.Add(resTypeExpr);                      args.Add(target);                      foreach (var a in arguments.Skip(1))                          args.Add(a);                      return JST.Expression.DotCall                          (resolver.RootId.ToE()' Constants.RootDelegateEndInvoke' args);                  }                  else                      throw new InvalidOperationException("unrecognised virtual method of delegate");              }              else if (calleeMethEnv.TypeRef.Equals(env.Global.ArrayRef) &&                       calleeMethEnv.Method.Name.Equals("GetEnumerator"' StringComparison.Ordinal) &&                       calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0)              {                  // SPECIAL CASE: Construct a GenericEnumerator at array's run-time element type                  var fallback = new JST.ThrowStatement                      (JST.Expression.DotCall(resolver.RootId.ToE()' Constants.RootInvalidOperationException));                  return ConstructGenericEnumeratorAtDynamicType(resolver' nameSupply' optBody' fallback' target);              }              else if (calleeMethEnv.TypeRef.Equals(env.Global.IEnumerableRef) &&                       calleeMethEnv.Method.Name.Equals("GetEnumerator"' StringComparison.Ordinal) &&                       calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0)              {                  // SPECIAL CASE: If target is a built-in array' constructor a GenericEnumerator at array's                  //               run-time element type. Otherwise invoke original interface method.                  var fallback = new JST.ReturnStatement                      (new JST.CallExpression(func' arguments.Skip(1).ToSeq()));                  return ConstructGenericEnumeratorAtDynamicType                      (resolver' nameSupply' optBody' fallback' target);              }              else if (calleeMethEnv.TypeConstructorRef.Equals(env.Global.IEnumerableTypeConstructorRef) &&                       calleeMethEnv.Method.Name.Equals("GetEnumerator"' StringComparison.Ordinal) &&                       calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0)              {                  // SPECIAL CASE: If target is a built-in array' construct a GenericEnumerator at requested interface                  //               type. Otherwise invoke original interface method.                  // NOTE: We don't use array's runtime element type                  var fallback = new JST.CallExpression(func' arguments.Skip(1).ToSeq());                  return ConstructGenericEnumeratorAtStaticType                      (resolver' nameSupply' optBody' fallback' calleeMethEnv.TypeBoundArguments[0]' target);              }              else              {                  var args =                      calleeMethEnv.MethodBoundArguments.Select(resolver.ResolveType).Concat                          (arguments.Skip(1)).ToSeq();                  return new JST.CallExpression(func' args);              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The following statement contains a magic number: if (s is CST.DelegateTypeStyle)              {                  var delTypeDef = (CST.DelegateTypeDef)calleeMethEnv.Type;                  if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 1 &&                      calleeMethEnv.Method.TypeArity == 0 &&                      calleeMethEnv.Method.Name.Equals("Invoke"' StringComparison.Ordinal))                  {                      // SPECIAL CASE: Invoke rewritten to direct function application                      return new JST.CallExpression(target' arguments.Skip(1).ToSeq());                  }                  else if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 3 &&                           calleeMethEnv.Method.TypeArity == 0 &&                           calleeMethEnv.Method.Name.Equals("BeginInvoke"' StringComparison.Ordinal))                  {                      // SPECIAL CASE: BeginInvoke rewritten to runtime call                      var resType = calleeMethEnv.SubstituteType(delTypeDef.Result.Type);                      var resTypeExpr = resType == null                                            ? null                                            : resolver.ResolveType(resType' TypePhase.Constructed);                      var args = new Seq<JST.Expression>();                      args.Add(new JST.NumericLiteral(delTypeDef.ValueParameters.Count));                      args.Add(resTypeExpr);                      args.Add(target);                      foreach (var a in arguments.Skip(1))                          args.Add(a);                      return JST.Expression.DotCall(resolver.RootId.ToE()' Constants.RootDelegateBeginInvoke' args);                  }                  else if (calleeMethEnv.Method.Arity == 2 && calleeMethEnv.Method.TypeArity == 0 &&                           calleeMethEnv.Method.Name.Equals("EndInvoke"' StringComparison.Ordinal))                  {                      // SPECIAL CASE: EndInvoke rewritten to runtime call                      var resType = calleeMethEnv.SubstituteType(delTypeDef.Result.Type);                      var resTypeExpr = resType == null                                            ? null                                            : resolver.ResolveType(resType' TypePhase.Constructed);                      var args = new Seq<JST.Expression>();                      args.Add(resTypeExpr);                      args.Add(target);                      foreach (var a in arguments.Skip(1))                          args.Add(a);                      return JST.Expression.DotCall                          (resolver.RootId.ToE()' Constants.RootDelegateEndInvoke' args);                  }                  else                      throw new InvalidOperationException("unrecognised virtual method of delegate");              }              else if (calleeMethEnv.TypeRef.Equals(env.Global.ArrayRef) &&                       calleeMethEnv.Method.Name.Equals("GetEnumerator"' StringComparison.Ordinal) &&                       calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0)              {                  // SPECIAL CASE: Construct a GenericEnumerator at array's run-time element type                  var fallback = new JST.ThrowStatement                      (JST.Expression.DotCall(resolver.RootId.ToE()' Constants.RootInvalidOperationException));                  return ConstructGenericEnumeratorAtDynamicType(resolver' nameSupply' optBody' fallback' target);              }              else if (calleeMethEnv.TypeRef.Equals(env.Global.IEnumerableRef) &&                       calleeMethEnv.Method.Name.Equals("GetEnumerator"' StringComparison.Ordinal) &&                       calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0)              {                  // SPECIAL CASE: If target is a built-in array' constructor a GenericEnumerator at array's                  //               run-time element type. Otherwise invoke original interface method.                  var fallback = new JST.ReturnStatement                      (new JST.CallExpression(func' arguments.Skip(1).ToSeq()));                  return ConstructGenericEnumeratorAtDynamicType                      (resolver' nameSupply' optBody' fallback' target);              }              else if (calleeMethEnv.TypeConstructorRef.Equals(env.Global.IEnumerableTypeConstructorRef) &&                       calleeMethEnv.Method.Name.Equals("GetEnumerator"' StringComparison.Ordinal) &&                       calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0)              {                  // SPECIAL CASE: If target is a built-in array' construct a GenericEnumerator at requested interface                  //               type. Otherwise invoke original interface method.                  // NOTE: We don't use array's runtime element type                  var fallback = new JST.CallExpression(func' arguments.Skip(1).ToSeq());                  return ConstructGenericEnumeratorAtStaticType                      (resolver' nameSupply' optBody' fallback' calleeMethEnv.TypeBoundArguments[0]' target);              }              else              {                  var args =                      calleeMethEnv.MethodBoundArguments.Select(resolver.ResolveType).Concat                          (arguments.Skip(1)).ToSeq();                  return new JST.CallExpression(func' args);              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.NullableTypeStyle)              {                  // SPECIAL CASE: new Nullable<T>(x) is represented by x                  return arguments[0];              }              else if (s is CST.DelegateTypeStyle)              {                  var delegateType = resolver.ResolveType(methodRef.DefiningType);                  if (arguments == null || arguments.Count == 0)                      // SPECIAL CASE: Construct empty delegates directly                      return JST.Expression.DotCall                          (resolver.RootId.ToE()'                           Constants.RootNewDelegate'                           new JST.NullExpression()'                           new JST.NullExpression()'                           delegateType);                  else if (arguments.Count == 2)                      // SPECIAL CASE: Construct normal delegates directly                      return JST.Expression.DotCall                          (resolver.RootId.ToE()' Constants.RootNewDelegate' arguments[0]' arguments[1]' delegateType);                  else                      throw new InvalidOperationException("mismatched delegate constructor arity");              }              else if (s is CST.MultiDimArrayTypeStyle)              {                  // SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime                  var methEnv = methodRef.Enter(resolver.RootEnv);                  var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;                  var elemType = resolver.ResolveType(methodRef.DefiningType.Arguments[0]);                  var lowers = new Seq<JST.Expression>();                  var sizes = new Seq<JST.Expression>();                  if (arguments.Count == multiDef.Rank)                  {                      for (var i = 0; i < multiDef.Rank; i++)                      {                          lowers.Add(new JST.NumericLiteral(0));                          sizes.Add(arguments[i]);                      }                  }                  else if (arguments.Count == multiDef.Rank*2)                  {                      for (var i = 0; i < multiDef.Rank; i++)                      {                          lowers.Add(arguments[i*2]);                          sizes.Add(arguments[i*2 + 1]);                      }                  }                  else                      throw new InvalidOperationException("invalid multi-dimensional array constructor call");                  return JST.Expression.DotCall                      (resolver.RootId.ToE()'                       Constants.RootNewMultiDimArray'                       elemType'                       new JST.ArrayLiteral(lowers)'                       new JST.ArrayLiteral(sizes));              }              else              {                  if (optBody == null)                      optLvalue = null;                  var body = optBody ?? new Seq<JST.Statement>();                    var rep = env.InteropManager.GetTypeRepresentation(null' resolver.RootEnv' methodRef.DefiningType);                    // Share type if necessary                  var defType = resolver.ResolveType(methodRef.DefiningType);                  if (!defType.IsDuplicatable)                  {                      var id = nameSupply.GenSym();                      body.Add(JST.Statement.Var(id' defType));                      defType = id.ToE();                  }                    // Initialize an object of the right type                  var init = default(JST.Expression);                  if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)                      init = new JST.NumericLiteral(0);                  else if (s is CST.ValueTypeStyle)                      // Defer to type                      init = JST.Expression.DotCall(defType' Constants.TypeDefaultValue);                  else                      // Reference types: invoke ConstructObject function                      init = new JST.NewExpression(JST.Expression.DotCall(defType' Constants.TypeConstructObject));                  var lvalue = default(JST.Expression);                  if (optLvalue == null)                  {                      var objId = nameSupply.GenSym();                      body.Add(JST.Statement.Var(objId' init));                      lvalue = objId.ToE();                  }                  else                  {                      lvalue = optLvalue;                      body.Add(JST.Statement.Assignment(lvalue' init));                  }                    var tyconEnv = methodRef.DefiningType.EnterConstructor(resolver.RootEnv);                  if (rep.NumExportsBoundToInstance > 0)                  {                      if (rep.State == InstanceState.ManagedOnly)                      {                          // This must be a 'Runtime' type' bind it's instance exports before invoking ctor                          body.Add(JST.Statement.DotCall(defType' Constants.TypeBindInstanceExports' lvalue));                      }                      else                      {                          // Any instance exports will be bound into instance when object is first exported                          body.Add                              (JST.Statement.DotAssignment                                   (lvalue'                                    Constants.ObjectPrepareForExport'                                    JST.Expression.Dot(defType' Constants.TypeBindInstanceExports)));                      }                  }                    var args = new Seq<JST.Expression>();                  if (s is CST.ValueTypeStyle)                  {                      // Pass pointer to constructor as 'this'                      args.Add(PointerToLvalueExpression(resolver' nameSupply' lvalue' defType));                  }                  else if (s is CST.ReferenceTypeStyle)                  {                      // Pass object to constructor as 'this'                      args.Add(lvalue);                  }                  else if (s is CST.ParameterTypeStyle)                  {                      // Make pointer' ask runtime type to conditionally dereference it' and pass                      // result as 'this'. Works regardless of whether runtime type is value or ref.                      var ptrExp = PointerToLvalueExpression(resolver' nameSupply' lvalue' defType);                      var conPtrExp = JST.Expression.DotCall(defType' Constants.TypeConditionalDeref' ptrExp);                      args.Add(conPtrExp);                  }                  else                      throw new InvalidOperationException("cannot construct instances of this type");                    // Pass constructor arguments' if any                  if (arguments != null)                  {                      foreach (var arg in arguments)                          args.Add(arg);                  }                    // Call constructor' if any                  var call = resolver.MethodCallExpression(methodRef' nameSupply' false' args);                  if (call != null)                      body.Add(new JST.ExpressionStatement(call));                    if (optBody == null)                      return new JST.StatementsPseudoExpression(new JST.Statements(body)' lvalue);                  else if (optLvalue == null)                      return lvalue;                  else                      return null;              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.NullableTypeStyle)              {                  // SPECIAL CASE: new Nullable<T>(x) is represented by x                  return arguments[0];              }              else if (s is CST.DelegateTypeStyle)              {                  var delegateType = resolver.ResolveType(methodRef.DefiningType);                  if (arguments == null || arguments.Count == 0)                      // SPECIAL CASE: Construct empty delegates directly                      return JST.Expression.DotCall                          (resolver.RootId.ToE()'                           Constants.RootNewDelegate'                           new JST.NullExpression()'                           new JST.NullExpression()'                           delegateType);                  else if (arguments.Count == 2)                      // SPECIAL CASE: Construct normal delegates directly                      return JST.Expression.DotCall                          (resolver.RootId.ToE()' Constants.RootNewDelegate' arguments[0]' arguments[1]' delegateType);                  else                      throw new InvalidOperationException("mismatched delegate constructor arity");              }              else if (s is CST.MultiDimArrayTypeStyle)              {                  // SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime                  var methEnv = methodRef.Enter(resolver.RootEnv);                  var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;                  var elemType = resolver.ResolveType(methodRef.DefiningType.Arguments[0]);                  var lowers = new Seq<JST.Expression>();                  var sizes = new Seq<JST.Expression>();                  if (arguments.Count == multiDef.Rank)                  {                      for (var i = 0; i < multiDef.Rank; i++)                      {                          lowers.Add(new JST.NumericLiteral(0));                          sizes.Add(arguments[i]);                      }                  }                  else if (arguments.Count == multiDef.Rank*2)                  {                      for (var i = 0; i < multiDef.Rank; i++)                      {                          lowers.Add(arguments[i*2]);                          sizes.Add(arguments[i*2 + 1]);                      }                  }                  else                      throw new InvalidOperationException("invalid multi-dimensional array constructor call");                  return JST.Expression.DotCall                      (resolver.RootId.ToE()'                       Constants.RootNewMultiDimArray'                       elemType'                       new JST.ArrayLiteral(lowers)'                       new JST.ArrayLiteral(sizes));              }              else              {                  if (optBody == null)                      optLvalue = null;                  var body = optBody ?? new Seq<JST.Statement>();                    var rep = env.InteropManager.GetTypeRepresentation(null' resolver.RootEnv' methodRef.DefiningType);                    // Share type if necessary                  var defType = resolver.ResolveType(methodRef.DefiningType);                  if (!defType.IsDuplicatable)                  {                      var id = nameSupply.GenSym();                      body.Add(JST.Statement.Var(id' defType));                      defType = id.ToE();                  }                    // Initialize an object of the right type                  var init = default(JST.Expression);                  if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)                      init = new JST.NumericLiteral(0);                  else if (s is CST.ValueTypeStyle)                      // Defer to type                      init = JST.Expression.DotCall(defType' Constants.TypeDefaultValue);                  else                      // Reference types: invoke ConstructObject function                      init = new JST.NewExpression(JST.Expression.DotCall(defType' Constants.TypeConstructObject));                  var lvalue = default(JST.Expression);                  if (optLvalue == null)                  {                      var objId = nameSupply.GenSym();                      body.Add(JST.Statement.Var(objId' init));                      lvalue = objId.ToE();                  }                  else                  {                      lvalue = optLvalue;                      body.Add(JST.Statement.Assignment(lvalue' init));                  }                    var tyconEnv = methodRef.DefiningType.EnterConstructor(resolver.RootEnv);                  if (rep.NumExportsBoundToInstance > 0)                  {                      if (rep.State == InstanceState.ManagedOnly)                      {                          // This must be a 'Runtime' type' bind it's instance exports before invoking ctor                          body.Add(JST.Statement.DotCall(defType' Constants.TypeBindInstanceExports' lvalue));                      }                      else                      {                          // Any instance exports will be bound into instance when object is first exported                          body.Add                              (JST.Statement.DotAssignment                                   (lvalue'                                    Constants.ObjectPrepareForExport'                                    JST.Expression.Dot(defType' Constants.TypeBindInstanceExports)));                      }                  }                    var args = new Seq<JST.Expression>();                  if (s is CST.ValueTypeStyle)                  {                      // Pass pointer to constructor as 'this'                      args.Add(PointerToLvalueExpression(resolver' nameSupply' lvalue' defType));                  }                  else if (s is CST.ReferenceTypeStyle)                  {                      // Pass object to constructor as 'this'                      args.Add(lvalue);                  }                  else if (s is CST.ParameterTypeStyle)                  {                      // Make pointer' ask runtime type to conditionally dereference it' and pass                      // result as 'this'. Works regardless of whether runtime type is value or ref.                      var ptrExp = PointerToLvalueExpression(resolver' nameSupply' lvalue' defType);                      var conPtrExp = JST.Expression.DotCall(defType' Constants.TypeConditionalDeref' ptrExp);                      args.Add(conPtrExp);                  }                  else                      throw new InvalidOperationException("cannot construct instances of this type");                    // Pass constructor arguments' if any                  if (arguments != null)                  {                      foreach (var arg in arguments)                          args.Add(arg);                  }                    // Call constructor' if any                  var call = resolver.MethodCallExpression(methodRef' nameSupply' false' args);                  if (call != null)                      body.Add(new JST.ExpressionStatement(call));                    if (optBody == null)                      return new JST.StatementsPseudoExpression(new JST.Statements(body)' lvalue);                  else if (optLvalue == null)                      return lvalue;                  else                      return null;              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.NullableTypeStyle)              {                  // SPECIAL CASE: new Nullable<T>(x) is represented by x                  return arguments[0];              }              else if (s is CST.DelegateTypeStyle)              {                  var delegateType = resolver.ResolveType(methodRef.DefiningType);                  if (arguments == null || arguments.Count == 0)                      // SPECIAL CASE: Construct empty delegates directly                      return JST.Expression.DotCall                          (resolver.RootId.ToE()'                           Constants.RootNewDelegate'                           new JST.NullExpression()'                           new JST.NullExpression()'                           delegateType);                  else if (arguments.Count == 2)                      // SPECIAL CASE: Construct normal delegates directly                      return JST.Expression.DotCall                          (resolver.RootId.ToE()' Constants.RootNewDelegate' arguments[0]' arguments[1]' delegateType);                  else                      throw new InvalidOperationException("mismatched delegate constructor arity");              }              else if (s is CST.MultiDimArrayTypeStyle)              {                  // SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime                  var methEnv = methodRef.Enter(resolver.RootEnv);                  var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;                  var elemType = resolver.ResolveType(methodRef.DefiningType.Arguments[0]);                  var lowers = new Seq<JST.Expression>();                  var sizes = new Seq<JST.Expression>();                  if (arguments.Count == multiDef.Rank)                  {                      for (var i = 0; i < multiDef.Rank; i++)                      {                          lowers.Add(new JST.NumericLiteral(0));                          sizes.Add(arguments[i]);                      }                  }                  else if (arguments.Count == multiDef.Rank*2)                  {                      for (var i = 0; i < multiDef.Rank; i++)                      {                          lowers.Add(arguments[i*2]);                          sizes.Add(arguments[i*2 + 1]);                      }                  }                  else                      throw new InvalidOperationException("invalid multi-dimensional array constructor call");                  return JST.Expression.DotCall                      (resolver.RootId.ToE()'                       Constants.RootNewMultiDimArray'                       elemType'                       new JST.ArrayLiteral(lowers)'                       new JST.ArrayLiteral(sizes));              }              else              {                  if (optBody == null)                      optLvalue = null;                  var body = optBody ?? new Seq<JST.Statement>();                    var rep = env.InteropManager.GetTypeRepresentation(null' resolver.RootEnv' methodRef.DefiningType);                    // Share type if necessary                  var defType = resolver.ResolveType(methodRef.DefiningType);                  if (!defType.IsDuplicatable)                  {                      var id = nameSupply.GenSym();                      body.Add(JST.Statement.Var(id' defType));                      defType = id.ToE();                  }                    // Initialize an object of the right type                  var init = default(JST.Expression);                  if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)                      init = new JST.NumericLiteral(0);                  else if (s is CST.ValueTypeStyle)                      // Defer to type                      init = JST.Expression.DotCall(defType' Constants.TypeDefaultValue);                  else                      // Reference types: invoke ConstructObject function                      init = new JST.NewExpression(JST.Expression.DotCall(defType' Constants.TypeConstructObject));                  var lvalue = default(JST.Expression);                  if (optLvalue == null)                  {                      var objId = nameSupply.GenSym();                      body.Add(JST.Statement.Var(objId' init));                      lvalue = objId.ToE();                  }                  else                  {                      lvalue = optLvalue;                      body.Add(JST.Statement.Assignment(lvalue' init));                  }                    var tyconEnv = methodRef.DefiningType.EnterConstructor(resolver.RootEnv);                  if (rep.NumExportsBoundToInstance > 0)                  {                      if (rep.State == InstanceState.ManagedOnly)                      {                          // This must be a 'Runtime' type' bind it's instance exports before invoking ctor                          body.Add(JST.Statement.DotCall(defType' Constants.TypeBindInstanceExports' lvalue));                      }                      else                      {                          // Any instance exports will be bound into instance when object is first exported                          body.Add                              (JST.Statement.DotAssignment                                   (lvalue'                                    Constants.ObjectPrepareForExport'                                    JST.Expression.Dot(defType' Constants.TypeBindInstanceExports)));                      }                  }                    var args = new Seq<JST.Expression>();                  if (s is CST.ValueTypeStyle)                  {                      // Pass pointer to constructor as 'this'                      args.Add(PointerToLvalueExpression(resolver' nameSupply' lvalue' defType));                  }                  else if (s is CST.ReferenceTypeStyle)                  {                      // Pass object to constructor as 'this'                      args.Add(lvalue);                  }                  else if (s is CST.ParameterTypeStyle)                  {                      // Make pointer' ask runtime type to conditionally dereference it' and pass                      // result as 'this'. Works regardless of whether runtime type is value or ref.                      var ptrExp = PointerToLvalueExpression(resolver' nameSupply' lvalue' defType);                      var conPtrExp = JST.Expression.DotCall(defType' Constants.TypeConditionalDeref' ptrExp);                      args.Add(conPtrExp);                  }                  else                      throw new InvalidOperationException("cannot construct instances of this type");                    // Pass constructor arguments' if any                  if (arguments != null)                  {                      foreach (var arg in arguments)                          args.Add(arg);                  }                    // Call constructor' if any                  var call = resolver.MethodCallExpression(methodRef' nameSupply' false' args);                  if (call != null)                      body.Add(new JST.ExpressionStatement(call));                    if (optBody == null)                      return new JST.StatementsPseudoExpression(new JST.Statements(body)' lvalue);                  else if (optLvalue == null)                      return lvalue;                  else                      return null;              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.NullableTypeStyle)              {                  // SPECIAL CASE: new Nullable<T>(x) is represented by x                  return arguments[0];              }              else if (s is CST.DelegateTypeStyle)              {                  var delegateType = resolver.ResolveType(methodRef.DefiningType);                  if (arguments == null || arguments.Count == 0)                      // SPECIAL CASE: Construct empty delegates directly                      return JST.Expression.DotCall                          (resolver.RootId.ToE()'                           Constants.RootNewDelegate'                           new JST.NullExpression()'                           new JST.NullExpression()'                           delegateType);                  else if (arguments.Count == 2)                      // SPECIAL CASE: Construct normal delegates directly                      return JST.Expression.DotCall                          (resolver.RootId.ToE()' Constants.RootNewDelegate' arguments[0]' arguments[1]' delegateType);                  else                      throw new InvalidOperationException("mismatched delegate constructor arity");              }              else if (s is CST.MultiDimArrayTypeStyle)              {                  // SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime                  var methEnv = methodRef.Enter(resolver.RootEnv);                  var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;                  var elemType = resolver.ResolveType(methodRef.DefiningType.Arguments[0]);                  var lowers = new Seq<JST.Expression>();                  var sizes = new Seq<JST.Expression>();                  if (arguments.Count == multiDef.Rank)                  {                      for (var i = 0; i < multiDef.Rank; i++)                      {                          lowers.Add(new JST.NumericLiteral(0));                          sizes.Add(arguments[i]);                      }                  }                  else if (arguments.Count == multiDef.Rank*2)                  {                      for (var i = 0; i < multiDef.Rank; i++)                      {                          lowers.Add(arguments[i*2]);                          sizes.Add(arguments[i*2 + 1]);                      }                  }                  else                      throw new InvalidOperationException("invalid multi-dimensional array constructor call");                  return JST.Expression.DotCall                      (resolver.RootId.ToE()'                       Constants.RootNewMultiDimArray'                       elemType'                       new JST.ArrayLiteral(lowers)'                       new JST.ArrayLiteral(sizes));              }              else              {                  if (optBody == null)                      optLvalue = null;                  var body = optBody ?? new Seq<JST.Statement>();                    var rep = env.InteropManager.GetTypeRepresentation(null' resolver.RootEnv' methodRef.DefiningType);                    // Share type if necessary                  var defType = resolver.ResolveType(methodRef.DefiningType);                  if (!defType.IsDuplicatable)                  {                      var id = nameSupply.GenSym();                      body.Add(JST.Statement.Var(id' defType));                      defType = id.ToE();                  }                    // Initialize an object of the right type                  var init = default(JST.Expression);                  if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)                      init = new JST.NumericLiteral(0);                  else if (s is CST.ValueTypeStyle)                      // Defer to type                      init = JST.Expression.DotCall(defType' Constants.TypeDefaultValue);                  else                      // Reference types: invoke ConstructObject function                      init = new JST.NewExpression(JST.Expression.DotCall(defType' Constants.TypeConstructObject));                  var lvalue = default(JST.Expression);                  if (optLvalue == null)                  {                      var objId = nameSupply.GenSym();                      body.Add(JST.Statement.Var(objId' init));                      lvalue = objId.ToE();                  }                  else                  {                      lvalue = optLvalue;                      body.Add(JST.Statement.Assignment(lvalue' init));                  }                    var tyconEnv = methodRef.DefiningType.EnterConstructor(resolver.RootEnv);                  if (rep.NumExportsBoundToInstance > 0)                  {                      if (rep.State == InstanceState.ManagedOnly)                      {                          // This must be a 'Runtime' type' bind it's instance exports before invoking ctor                          body.Add(JST.Statement.DotCall(defType' Constants.TypeBindInstanceExports' lvalue));                      }                      else                      {                          // Any instance exports will be bound into instance when object is first exported                          body.Add                              (JST.Statement.DotAssignment                                   (lvalue'                                    Constants.ObjectPrepareForExport'                                    JST.Expression.Dot(defType' Constants.TypeBindInstanceExports)));                      }                  }                    var args = new Seq<JST.Expression>();                  if (s is CST.ValueTypeStyle)                  {                      // Pass pointer to constructor as 'this'                      args.Add(PointerToLvalueExpression(resolver' nameSupply' lvalue' defType));                  }                  else if (s is CST.ReferenceTypeStyle)                  {                      // Pass object to constructor as 'this'                      args.Add(lvalue);                  }                  else if (s is CST.ParameterTypeStyle)                  {                      // Make pointer' ask runtime type to conditionally dereference it' and pass                      // result as 'this'. Works regardless of whether runtime type is value or ref.                      var ptrExp = PointerToLvalueExpression(resolver' nameSupply' lvalue' defType);                      var conPtrExp = JST.Expression.DotCall(defType' Constants.TypeConditionalDeref' ptrExp);                      args.Add(conPtrExp);                  }                  else                      throw new InvalidOperationException("cannot construct instances of this type");                    // Pass constructor arguments' if any                  if (arguments != null)                  {                      foreach (var arg in arguments)                          args.Add(arg);                  }                    // Call constructor' if any                  var call = resolver.MethodCallExpression(methodRef' nameSupply' false' args);                  if (call != null)                      body.Add(new JST.ExpressionStatement(call));                    if (optBody == null)                      return new JST.StatementsPseudoExpression(new JST.Statements(body)' lvalue);                  else if (optLvalue == null)                      return lvalue;                  else                      return null;              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendInvokeImportingConstructor,The following statement contains a magic number: if (bestCtor.ValueParameters.Count == 1 && bestCtor.DefiningType.Style(typeEnv) is CST.ObjectTypeStyle)              {                  // Ignore' since Object::.ctor is no-op              }              else              {                  var callArgs = new Seq<JST.Expression>();                  // this                  callArgs.Add(parameters[0].ToE());                  if (bestCtor.ValueParameters.Count >= 2)                  {                      // JSContext                      callArgs.Add(unmanagedObjId.ToE());                      if (bestCtor.ValueParameters.Count > 2)                      {                          // Constructor args                          for (var i = 1; i < parameters.Count; i++)                              callArgs.Add(parameters[i].ToE());                      }                  }                  body.Add(new JST.ExpressionStatement(resolver.MethodCallExpression(bestCtor' nameSupply' false' callArgs)));              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendInvokeImportingConstructor,The following statement contains a magic number: if (bestCtor.ValueParameters.Count == 1 && bestCtor.DefiningType.Style(typeEnv) is CST.ObjectTypeStyle)              {                  // Ignore' since Object::.ctor is no-op              }              else              {                  var callArgs = new Seq<JST.Expression>();                  // this                  callArgs.Add(parameters[0].ToE());                  if (bestCtor.ValueParameters.Count >= 2)                  {                      // JSContext                      callArgs.Add(unmanagedObjId.ToE());                      if (bestCtor.ValueParameters.Count > 2)                      {                          // Constructor args                          for (var i = 1; i < parameters.Count; i++)                              callArgs.Add(parameters[i].ToE());                      }                  }                  body.Add(new JST.ExpressionStatement(resolver.MethodCallExpression(bestCtor' nameSupply' false' callArgs)));              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,HandlerLiteral,The following statement contains a magic number: switch (handler.Flavor)              {                  case CST.HandlerFlavor.Catch:                  {                      var catchh = (CST.CatchTryPseudoStatementHandler)handler;                      var exid = nameSupply.GenSym();                      var type = methCompEnv.ResolveType(catchh.ExceptionType);                      var match = JST.Expression.IsNotNull                          (JST.Expression.DotCall(rootId.ToE()' Constants.RootIsInst' exid.ToE()' type));                      var pred = new JST.FunctionExpression                          (new Seq<JST.Identifier> { exid }'                           new JST.Statements                               (new JST.IfStatement                                    (match'                                     new JST.Statements                                         (JST.Statement.Assignment(catchh.ExceptionId.ToE()' exid.ToE())'                                          new JST.ReturnStatement(new JST.BooleanLiteral(true)))'                                     new JST.Statements(new JST.ReturnStatement(new JST.BooleanLiteral(false))))));                      return new JST.ObjectLiteral                          (new OrdMap<JST.Identifier' JST.Expression>                           {                               { Constants.HandlerStyle' new JST.NumericLiteral(0) }'                               { Constants.HandlerTarget' new JST.NumericLiteral(catchh.HandlerId) }'                               { Constants.HandlerPred' pred }                           });                  }                  case CST.HandlerFlavor.Fault:                      return new JST.ObjectLiteral                          (new OrdMap<JST.Identifier' JST.Expression>                           {                               { Constants.HandlerStyle' new JST.NumericLiteral(1) }'                               { Constants.HandlerTarget' new JST.NumericLiteral(handler.HandlerId) }                           });                  case CST.HandlerFlavor.Finally:                      return new JST.ObjectLiteral                          (new OrdMap<JST.Identifier' JST.Expression>                           {                               { Constants.HandlerStyle' new JST.NumericLiteral(2) }'                               { Constants.HandlerTarget' new JST.NumericLiteral(handler.HandlerId) }                           });                  case CST.HandlerFlavor.Filter:                      throw new InvalidOperationException("filter blocks not supported");                  default:                      throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParseCreation,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 2)              {                  env.Log(new InvalidInteropMessage(ctxt' "expecting creation flag"));                  throw new DefinitionException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParseQualification,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 4)              {                  env.Log(new InvalidInteropMessage(ctxt' "expecting qualification flag"));                  throw new DefinitionException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParseCasing,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 2)              {                  env.Log(new InvalidInteropMessage(ctxt' "expecting casing flag"));                  throw new DefinitionException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParseInstanceState,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 3)              {                  env.Log(new InvalidInteropMessage(ctxt' "expecting instance state flag"));                  throw new DefinitionException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParseReflectionLevel,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 2)              {                  env.Log(new InvalidInteropMessage(ctxt' "expecting reflection level flag"));                  throw new DefinitionException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: foreach (var s in prog.Body.Body)              {                  var ctxt = CompMsgContext.TraceFile(s.Loc);                  var ok = false;                  if (s.Flavor == JST.StatementFlavor.Comment)                      ok = true;                  else if (s.Flavor == JST.StatementFlavor.Expression)                  {                      var e = ((JST.ExpressionStatement)s).Expression;                      if (e.Flavor == JST.ExpressionFlavor.Call)                      {                          var call = (JST.CallExpression)e;                          if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier)                          {                              var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;                              var callargs = new Seq<string>();                              ok = true;                              foreach (var a in call.Arguments)                              {                                  if (a.Flavor == JST.ExpressionFlavor.String)                                      callargs.Add(((JST.StringLiteral)a).Value);                                  else                                      ok = false;                              }                              if (ok)                              {                                  var n = callargs.Count;                                  if (callid.Equals(Constants.TraceFileAssembly) && n == 1)                                      AddAssembly(ctxt' callargs[0]);                                  else if (callid.Equals(Constants.TraceFileType) && n == 2)                                      AddType(ctxt' callargs[0]' callargs[1]);                                  else if (callid.Equals(Constants.TraceFileMethod) && n == 3)                                      AddMethod(ctxt' callargs[0]' callargs[1]' callargs[2]);                                  else                                      ok = false;                              }                          }                      }                  }                  if (!ok)                  {                      traces.Env.Log(new InvalidTraceMessage(ctxt' "syntax error"));                      throw new ExitException();                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: foreach (var s in prog.Body.Body)              {                  var ctxt = CompMsgContext.TraceFile(s.Loc);                  var ok = false;                  if (s.Flavor == JST.StatementFlavor.Comment)                      ok = true;                  else if (s.Flavor == JST.StatementFlavor.Expression)                  {                      var e = ((JST.ExpressionStatement)s).Expression;                      if (e.Flavor == JST.ExpressionFlavor.Call)                      {                          var call = (JST.CallExpression)e;                          if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier)                          {                              var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;                              var callargs = new Seq<string>();                              ok = true;                              foreach (var a in call.Arguments)                              {                                  if (a.Flavor == JST.ExpressionFlavor.String)                                      callargs.Add(((JST.StringLiteral)a).Value);                                  else                                      ok = false;                              }                              if (ok)                              {                                  var n = callargs.Count;                                  if (callid.Equals(Constants.TraceFileAssembly) && n == 1)                                      AddAssembly(ctxt' callargs[0]);                                  else if (callid.Equals(Constants.TraceFileType) && n == 2)                                      AddType(ctxt' callargs[0]' callargs[1]);                                  else if (callid.Equals(Constants.TraceFileMethod) && n == 3)                                      AddMethod(ctxt' callargs[0]' callargs[1]' callargs[2]);                                  else                                      ok = false;                              }                          }                      }                  }                  if (!ok)                  {                      traces.Env.Log(new InvalidTraceMessage(ctxt' "syntax error"));                      throw new ExitException();                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: foreach (var s in prog.Body.Body)              {                  var ctxt = CompMsgContext.TraceFile(s.Loc);                  var ok = false;                  if (s.Flavor == JST.StatementFlavor.Comment)                      ok = true;                  else if (s.Flavor == JST.StatementFlavor.Expression)                  {                      var e = ((JST.ExpressionStatement)s).Expression;                      if (e.Flavor == JST.ExpressionFlavor.Call)                      {                          var call = (JST.CallExpression)e;                          if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier)                          {                              var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;                              var callargs = new Seq<string>();                              ok = true;                              foreach (var a in call.Arguments)                              {                                  if (a.Flavor == JST.ExpressionFlavor.String)                                      callargs.Add(((JST.StringLiteral)a).Value);                                  else                                      ok = false;                              }                              if (ok)                              {                                  var n = callargs.Count;                                  if (callid.Equals(Constants.TraceFileAssembly) && n == 1)                                      AddAssembly(ctxt' callargs[0]);                                  else if (callid.Equals(Constants.TraceFileType) && n == 2)                                      AddType(ctxt' callargs[0]' callargs[1]);                                  else if (callid.Equals(Constants.TraceFileMethod) && n == 3)                                      AddMethod(ctxt' callargs[0]' callargs[1]' callargs[2]);                                  else                                      ok = false;                              }                          }                      }                  }                  if (!ok)                  {                      traces.Env.Log(new InvalidTraceMessage(ctxt' "syntax error"));                      throw new ExitException();                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitVirtualAndInterfaceMethodRedirectors,The following statement contains a magic number: if (defaultArgs.Count > 2)                  body.Add(JST.Statement.DotCall(RootId.ToE()' Constants.RootBindVirtualMethods' defaultArgs));
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitFKToHKMethodRedirectors,The following statement contains a magic number: if (args.Count > 2)                  body.Add(JST.Statement.DotCall(RootId.ToE()' Constants.RootBindFKToHKMethodRedirectors' args));
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,The following statement contains a magic number: if (s is CST.ClassTypeStyle || s is CST.StructTypeStyle)              {                  var fields = new Seq<CST.FieldRef>();                  AccumInstanceFields(TypeCompEnv' fields);                  var trivFields = new Seq<CST.FieldRef>();                  var nonTrivFields = new Seq<CST.FieldRef>();                  foreach (var fieldRef in fields)                  {                      var fieldType = ((CST.FieldSignature)fieldRef.ExternalSignature).FieldType;                      if (Env.JSTHelpers.CloneIsNonTrivial(TypeCompEnv' fieldType))                          nonTrivFields.Add(fieldRef);                      else                          trivFields.Add(fieldRef);                  }                    if (nonTrivFields.Count > 0)                  {                      var innerTypeCompEnv = TypeCompEnv.EnterFunction();                        var parameters = new Seq<JST.Identifier>();                      parameters.Add(innerTypeCompEnv.NameSupply.GenSym());                      var oldObj = parameters[0].ToE();                      var innerBody = new Seq<JST.Statement>();                        var usage = new CST.Usage();                      foreach (var fieldRef in nonTrivFields)                          fieldRef.ExternalFieldType.AccumUsage(usage' true);                      innerTypeCompEnv.BindUsage(innerBody' usage' TypePhase.Constructed);                        var newObjId = innerTypeCompEnv.NameSupply.GenSym();                      if (s is CST.ClassTypeStyle)                          // Reference type' object Id is allocated lazily                          innerBody.Add                              (JST.Statement.Var                                   (newObjId' JST.Expression.DotCall(TypeId.ToE()' Constants.TypeConstructObject)));                      else                          // Value type                          innerBody.Add(JST.Statement.Var(newObjId' new JST.ObjectLiteral()));                      var newObj = newObjId.ToE();                        // Explicity clone non-trivial fields                      foreach (var fieldRef in nonTrivFields)                      {                          var fieldId = Env.JSTHelpers.ResolveFieldToIdentifier(innerTypeCompEnv' fieldRef' false);                          innerBody.Add                              (JST.Statement.DotAssignment                                   (newObj'                                    fieldId'                                    Env.JSTHelpers.CloneExpressionForType                                        (innerTypeCompEnv'                                         fieldRef.ExternalFieldType'                                         JST.Expression.Dot(oldObj' fieldId))));                      }                      if (trivFields.Count < 3)                      {                          // Explicity copy the remaining trivial fields                          foreach (var fieldRef in trivFields)                          {                              var fieldId = Env.JSTHelpers.ResolveFieldToIdentifier(innerTypeCompEnv' fieldRef' false);                              innerBody.Add                                  (JST.Statement.DotAssignment(newObj' fieldId' JST.Expression.Dot(oldObj' fieldId)));                          }                      }                      else                      {                          // Generically copy the remaining trivial fields                          innerBody.Add                              (JST.Statement.DotCall(RootId.ToE()' Constants.RootInheritProperties' newObj' oldObj));                      }                      innerBody.Add(new JST.ReturnStatement(newObj));                        body.Add                          (JST.Statement.DotAssignment                               (lhs' Constants.TypeMemberwiseClone' new JST.FunctionExpression(parameters' new JST.Statements(innerBody))));                  }                  else                  {                      // default generic clone with no inner cloning is ok                      return;                  }              }              else              {                  var innerNameSupply = NameSupply.Fork();                  var parameters = new Seq<JST.Identifier>();                  parameters.Add(innerNameSupply.GenSym());                  var oldObj = parameters[0].ToE();                  var innerBody = new Seq<JST.Statement>();                    if (s is CST.VoidTypeStyle)                  {                      innerBody.Add                          (new JST.ThrowStatement                               (JST.Expression.DotCall(RootId.ToE()' Constants.RootInvalidOperationException)));                  }                  else if (s is CST.ArrayTypeStyle)                  {                      var newObjId = innerNameSupply.GenSym();                      innerBody.Add                          (JST.Statement.Var                               (newObjId'                                new JST.NewExpression                                    (new JST.CallExpression                                         (Constants.Array.ToE()' JST.Expression.Dot(oldObj' Constants.length)))));                      innerBody.Add(JST.Statement.DotAssignment(newObjId.ToE()' Constants.ObjectType' TypeId.ToE()));                      // Object Id is allocated lazily                      var iId = innerNameSupply.GenSym();                      var loopClause = new JST.ForVarLoopClause                          (iId'                           new JST.BinaryExpression                               (iId.ToE()' JST.BinaryOp.LessThan' JST.Expression.Dot(oldObj' Constants.length))'                           new JST.UnaryExpression(iId.ToE()' JST.UnaryOp.PostIncrement));                      var loopBody = JST.Statement.IndexAssignment                          (newObjId.ToE()'                           iId.ToE()'                           Env.JSTHelpers.CloneExpressionForType                               (TypeCompEnv'                                TypeCompEnv.TypeBoundArguments[0]'                                new JST.IndexExpression(oldObj' iId.ToE())));                      innerBody.Add(new JST.ForStatement(loopClause' new JST.Statements(loopBody)));                      innerBody.Add(new JST.ReturnStatement(newObjId.ToE()));                  }                  else if (s is CST.NullableTypeStyle)                  {                      innerBody.Add                          (new JST.IfStatement                               (JST.Expression.IsNull(oldObj)'                                new JST.Statements(new JST.ReturnStatement(new JST.NullExpression()))'                                new JST.Statements(new JST.ReturnStatement                                    (Env.JSTHelpers.CloneExpressionForType                                         (TypeCompEnv' TypeCompEnv.TypeBoundArguments[0]' oldObj)))));                  }                  else                  {                      innerBody.Add(new JST.ReturnStatement(oldObj));                  }                    body.Add                      (JST.Statement.DotAssignment                           (lhs' Constants.TypeMemberwiseClone' new JST.FunctionExpression(parameters' new JST.Statements(innerBody))));              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: if (s is CST.VoidTypeStyle || s is CST.ManagedPointerTypeStyle)                  innerBody.Add                      (new JST.ThrowStatement                           (JST.Expression.DotCall(RootId.ToE()' Constants.RootInvalidOperationException)));              else if (s is CST.NumberTypeStyle || s is CST.EnumTypeStyle || TypeCompEnv.TypeRef.Equals(Env.Global.DecimalRef))                  innerBody.Add(new JST.ReturnStatement(obj));              else if (s is CST.HandleTypeStyle)              {                  innerBody.Add                      (new JST.IfStatement                           (JST.Expression.IsNull(obj)' new JST.Statements(new JST.ReturnStatement(new JST.NumericLiteral(0)))));                  var objid = JST.Expression.Dot(obj' Constants.ObjectId);                  innerBody.Add                      (new JST.IfStatement                           (JST.Expression.IsNull(objid)'                            new JST.Statements(JST.Statement.Assignment                                (objid'                                 new JST.UnaryExpression                                     (JST.Expression.Dot(RootId.ToE()' Constants.RootNextObjectId)'                                      JST.UnaryOp.PostIncrement)))));                  innerBody.Add(new JST.ReturnStatement(objid));              }              else if (s is CST.NullableTypeStyle)              {                  innerBody.Add                      (new JST.IfStatement                           (JST.Expression.IsNull(obj)' new JST.Statements(new JST.ReturnStatement(new JST.NumericLiteral(0)))));                  innerBody.Add                      (new JST.ReturnStatement                           (JST.Expression.DotCall                                (TypeCompEnv.ResolveType(TypeCompEnv.TypeBoundArguments[0]' TypePhase.Slots)'                                 Constants.TypeHash'                                 obj)));              }              else if (s is CST.StructTypeStyle)              {                  var hashId = innerNameSupply.GenSym();                  innerBody.Add(JST.Statement.Var(hashId' new JST.NumericLiteral(0)));                  var hash = hashId.ToE();                  foreach (var fieldDef in Parent.Fields.Where(f => !f.IsStatic))                  {                      innerBody.Add                          (JST.Statement.Assignment                               (hash'                                new JST.BinaryExpression                                    (new JST.BinaryExpression(hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral(3))'                                     JST.BinaryOp.BitwiseOR'                                     new JST.BinaryExpression                                         (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral(28)))));                      var fieldRef = new CST.FieldRef(TypeCompEnv.TypeRef' fieldDef.FieldSignature);                      var field = Env.JSTHelpers.ResolveInstanceField(TypeCompEnv' obj' fieldRef);                      innerBody.Add                          (JST.Statement.Assignment                               (hash'                                new JST.BinaryExpression                                    (hash'                                     JST.BinaryOp.BitwiseXOR'                                     JST.Expression.DotCall                                         (TypeCompEnv.ResolveType(fieldDef.FieldType' TypePhase.Slots)'                                          Constants.TypeHash'                                          field))));                  }                  innerBody.Add(new JST.ReturnStatement(hash));              }              else if (s is CST.ObjectTypeStyle)              {                  // NOTE: CLR Bizzarism: IEquatable<T> does not provide a GetHashCode' thus a                  //       default EqualityComparer<T> when T has IEquatable<T> will use the IEquatable                  //       Equals but the Object GetHashCode. Go figure.                  innerBody.Add                      (new JST.IfStatement                           (JST.Expression.IsNull(obj)' new JST.Statements(new JST.ReturnStatement(new JST.NumericLiteral(0)))));                  var getHashCodeRef = new CST.MethodRef                      (Env.Global.ObjectRef'                       "GetHashCode"'                       false'                       null'                       new Seq<CST.TypeRef> { Env.Global.ObjectRef }'                       Env.Global.Int32Ref);                  var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression                      (TypeCompEnv' innerNameSupply' innerBody' getHashCodeRef' new Seq<JST.Expression> { obj });                  innerBody.Add(new JST.ReturnStatement(call));              }              else                  // Default is ok                  return;
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: if (s is CST.VoidTypeStyle || s is CST.ManagedPointerTypeStyle)                  innerBody.Add                      (new JST.ThrowStatement                           (JST.Expression.DotCall(RootId.ToE()' Constants.RootInvalidOperationException)));              else if (s is CST.NumberTypeStyle || s is CST.EnumTypeStyle || TypeCompEnv.TypeRef.Equals(Env.Global.DecimalRef))                  innerBody.Add(new JST.ReturnStatement(obj));              else if (s is CST.HandleTypeStyle)              {                  innerBody.Add                      (new JST.IfStatement                           (JST.Expression.IsNull(obj)' new JST.Statements(new JST.ReturnStatement(new JST.NumericLiteral(0)))));                  var objid = JST.Expression.Dot(obj' Constants.ObjectId);                  innerBody.Add                      (new JST.IfStatement                           (JST.Expression.IsNull(objid)'                            new JST.Statements(JST.Statement.Assignment                                (objid'                                 new JST.UnaryExpression                                     (JST.Expression.Dot(RootId.ToE()' Constants.RootNextObjectId)'                                      JST.UnaryOp.PostIncrement)))));                  innerBody.Add(new JST.ReturnStatement(objid));              }              else if (s is CST.NullableTypeStyle)              {                  innerBody.Add                      (new JST.IfStatement                           (JST.Expression.IsNull(obj)' new JST.Statements(new JST.ReturnStatement(new JST.NumericLiteral(0)))));                  innerBody.Add                      (new JST.ReturnStatement                           (JST.Expression.DotCall                                (TypeCompEnv.ResolveType(TypeCompEnv.TypeBoundArguments[0]' TypePhase.Slots)'                                 Constants.TypeHash'                                 obj)));              }              else if (s is CST.StructTypeStyle)              {                  var hashId = innerNameSupply.GenSym();                  innerBody.Add(JST.Statement.Var(hashId' new JST.NumericLiteral(0)));                  var hash = hashId.ToE();                  foreach (var fieldDef in Parent.Fields.Where(f => !f.IsStatic))                  {                      innerBody.Add                          (JST.Statement.Assignment                               (hash'                                new JST.BinaryExpression                                    (new JST.BinaryExpression(hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral(3))'                                     JST.BinaryOp.BitwiseOR'                                     new JST.BinaryExpression                                         (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral(28)))));                      var fieldRef = new CST.FieldRef(TypeCompEnv.TypeRef' fieldDef.FieldSignature);                      var field = Env.JSTHelpers.ResolveInstanceField(TypeCompEnv' obj' fieldRef);                      innerBody.Add                          (JST.Statement.Assignment                               (hash'                                new JST.BinaryExpression                                    (hash'                                     JST.BinaryOp.BitwiseXOR'                                     JST.Expression.DotCall                                         (TypeCompEnv.ResolveType(fieldDef.FieldType' TypePhase.Slots)'                                          Constants.TypeHash'                                          field))));                  }                  innerBody.Add(new JST.ReturnStatement(hash));              }              else if (s is CST.ObjectTypeStyle)              {                  // NOTE: CLR Bizzarism: IEquatable<T> does not provide a GetHashCode' thus a                  //       default EqualityComparer<T> when T has IEquatable<T> will use the IEquatable                  //       Equals but the Object GetHashCode. Go figure.                  innerBody.Add                      (new JST.IfStatement                           (JST.Expression.IsNull(obj)' new JST.Statements(new JST.ReturnStatement(new JST.NumericLiteral(0)))));                  var getHashCodeRef = new CST.MethodRef                      (Env.Global.ObjectRef'                       "GetHashCode"'                       false'                       null'                       new Seq<CST.TypeRef> { Env.Global.ObjectRef }'                       Env.Global.Int32Ref);                  var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression                      (TypeCompEnv' innerNameSupply' innerBody' getHashCodeRef' new Seq<JST.Expression> { obj });                  innerBody.Add(new JST.ReturnStatement(call));              }              else                  // Default is ok                  return;
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The following statement contains a magic number: foreach (var kv in attr.NamedProperties)              {                  var stmnt = default(JST.Statement);                  foreach (var memberDef in                      attrTypeEnv.Type.Members.Where                          (m => !m.IsStatic && m.Name.Equals(kv.Key' StringComparison.Ordinal)))                  {                      switch (memberDef.Flavor)                      {                          case CST.MemberDefFlavor.Field:                              {                                  var fieldDef = (CST.FieldDef)memberDef;                                  if (fieldDef.Invalid == null && fieldDef.IsUsed)                                  {                                      var t = attrTypeEnv.SubstituteType(fieldDef.FieldType);                                      var o = kv.Value;                                      var e = Env.JSTHelpers.InitializerExpression(innerTypeCompEnv' ctxt' o' t);                                      var slot = Env.GlobalMapping.ResolveFieldDefToSlot                                          (attrTypeEnv.Assembly' attrTypeEnv.Type' fieldDef);                                      stmnt = JST.Statement.DotAssignment                                          (id.ToE()' new JST.Identifier(Constants.ObjectInstanceFieldSlot(slot))' e);                                  }                                  break;                              }                          case CST.MemberDefFlavor.Property:                              {                                  var propDef = (CST.PropertyDef)memberDef;                                  if (propDef.Invalid == null)                                  {                                      var t = attrTypeEnv.SubstituteType(propDef.FieldType);                                      var o = kv.Value;                                      var e = Env.JSTHelpers.InitializerExpression(innerTypeCompEnv' ctxt' o' t);                                      if (propDef.Set != null)                                      {                                          var setMethodDef = attrTypeEnv.Type.ResolveMethod(propDef.Set);                                          if (setMethodDef != null && setMethodDef.Invalid == null && setMethodDef.IsUsed &&                                              setMethodDef.Arity == 2 && !Env.InlinedMethods.IsInlinable(innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' setMethodDef))                                          {                                              var setMethodRef = new CST.MethodRef                                                  (attr.Type' setMethodDef.MethodSignature' null);                                              stmnt = new JST.ExpressionStatement                                                  (innerTypeCompEnv.MethodCallExpression                                                       (setMethodRef'                                                        innerTypeCompEnv.NameSupply'                                                        false'                                                        new Seq<JST.Expression>(id.ToE()' e)));                                          }                                      }                                  }                                  break;                              }                          case CST.MemberDefFlavor.Method:                          case CST.MemberDefFlavor.Event:                              break;                          default:                              throw new ArgumentOutOfRangeException();                      }                  }                  if (stmnt == null)                  {                      Env.Log                          (new UnimplementableFeatureMessage                               (ctxt'                                "custom attribute"'                                String.Format                                    ("Type '{0}' does not have a field or set-able property for named parameter '{1}'"'                                     kv.Key)));                  }                  else                      body.Add(stmnt);              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,EmitMethods,The following statement contains a magic number: switch (Env.CompilationMode)              {                  case CompilationMode.Plain:                  {                      // Method definitions are bound directly into target                      foreach (var methodDef in Methods.Where(m => m.Invalid == null))                      {                          if (Env.InteropManager.IsStatic(TyconEnv.Assembly' TyconEnv.Type' methodDef) == isStatic)                          {                              var compiler = new MethodCompiler(this' outerNameSupply' methodDef' MethodCompilationMode.DirectBind);                              compiler.Emit(body' target);                          }                      }                      break;                  }              case CompilationMode.Collecting:                  {                      // Method definitions are bound into MethodCache' redirectors are bound into target                      foreach (var methodDef in Methods.Where(m => m.Invalid == null))                      {                          if (Env.InteropManager.IsStatic(TyconEnv.Assembly' TyconEnv.Type' methodDef) == isStatic)                          {                              var slot = Env.GlobalMapping.ResolveMethodDefToSlot(TyconEnv.Assembly' TyconEnv.Type' methodDef);                              var methodName = CST.CSTWriter.WithAppend                                  (Env.Global' CST.WriterStyle.Uniform' methodDef.MethodSignature.Append);                              body.Add                                  (JST.Statement.DotCall                                       (RootId.ToE()'                                        Constants.RootCollectingBindMethodBuilder'                                        lhs'                                        new JST.BooleanLiteral(isStatic)'                                        new JST.StringLiteral(slot)'                                        new JST.StringLiteral(methodName)));                              var compiler = new MethodCompiler(this' outerNameSupply' methodDef' MethodCompilationMode.DirectBind);                              compiler.Emit(body' JST.Expression.Dot(target' Constants.TypeMethodCache));                          }                      }                      break;                  }              case CompilationMode.Traced:                  {                      // Methods in the initial trace or this trace will be bound directly.                      // Methods in a trace other than above are bound via builder which is given trace name.                      // Remaining methods are built via builder with null trace name.                      var traceToArgs = new Map<string' Seq<JST.Expression>>();                      var remainingArgs = new Seq<JST.Expression>();                      remainingArgs.Add(TypeDefinitionId.ToE());                      remainingArgs.Add(new JST.BooleanLiteral(isStatic));                      remainingArgs.Add(new JST.NullExpression());                      foreach (var methodDef in Methods.Where(m => m.Invalid == null))                      {                          if (Env.InteropManager.IsStatic(TyconEnv.Assembly' TyconEnv.Type' methodDef) == isStatic)                          {                              var slot = Env.GlobalMapping.ResolveMethodDefToSlot(TyconEnv.Assembly' TyconEnv.Type' methodDef);                              var defTrace = Env.Traces.MethodToTrace[methodDef.QualifiedMemberName(Env.Global' TyconEnv.Assembly' TyconEnv.Type)];                              if (defTrace.Flavor == TraceFlavor.OnDemand && defTrace != TypeTrace.Parent.Parent)                              {                                  // Method definition in in another trace' bind redirector for it.                                  var args = default(Seq<JST.Expression>);                                  if (!traceToArgs.TryGetValue(defTrace.Name' out args))                                  {                                      args = new Seq<JST.Expression>();                                      args.Add(lhs);                                      args.Add(new JST.BooleanLiteral(isStatic));                                      args.Add(new JST.StringLiteral(defTrace.Name));                                      traceToArgs.Add(defTrace.Name' args);                                  }                                  args.Add(new JST.StringLiteral(slot));                              }                              else if (defTrace.Flavor == TraceFlavor.Remainder)                                  // Method definition is in a stand-alone loader' bind redirector for it.                                  remainingArgs.Add(new JST.StringLiteral(slot));                              else                              {                                  // Method definition is bound directly                                  var compiler = new MethodCompiler(this' outerNameSupply' methodDef' MethodCompilationMode.DirectBind);                                  compiler.Emit(body' target);                              }                          }                      }                      foreach (var kv in traceToArgs)                          body.Add(JST.Statement.DotCall(RootId.ToE()' Constants.RootBindMethodBuilders' kv.Value));                      if (remainingArgs.Count > 3)                          body.Add(JST.Statement.DotCall(RootId.ToE()' Constants.RootBindMethodBuilders' remainingArgs));                      break;                  }              default:                  throw new ArgumentOutOfRangeException();              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerEnvironment.cs,CompilerEnvironment,The following statement contains a magic number: ImportInlineThreshold = 15;
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerEnvironment.cs,CompilerEnvironment,The following statement contains a magic number: InlineThreshold = 15;
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,FriendlyTypeName,The following statement contains a magic number: JST.Lexemes.AppendStringToFriendlyIdentifier(sb' types[types.Count - 1].ToLowerInvariant()' 15);
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,FriendlyAssemblyName,The following statement contains a magic number: JST.Lexemes.AppendStringToFriendlyIdentifier(sb' name.Name' 15);
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,FriendlyMemberName,The following statement contains a magic number: JST.Lexemes.AppendStringToFriendlyIdentifier(sb' types[types.Count - 1]' 15);
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,FriendlyMemberName,The following statement contains a magic number: JST.Lexemes.AppendStringToFriendlyIdentifier(sb' nm' 15);
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,FriendlyStringName,The following statement contains a magic number: JST.Lexemes.AppendStringToFriendlyIdentifier(sb' str' 15);
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,StringStats,C:\repos\Reactive-Extensions_IL2JS\Compiler\StringStats.cs,GetEnumerator,The following statement contains a magic number: foreach (var kv in counts)              {                  //                       Definition          Reference                  //                       ------------------  ------------------                  // In-place string    |  <nothing>           "..."                  // Type level string  |  a.sxy="...";        a.sxy                  var inplaceSize = kv.Value*(kv.Key.Length + 2);                  var typeSize = 9 + kv.Key.Length + kv.Value*5;                  yield return                      new KeyValuePair<string' StringBindScope>                          (kv.Key' typeSize < inplaceSize ? StringBindScope.Type : StringBindScope.InPlace);              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,StringStats,C:\repos\Reactive-Extensions_IL2JS\Compiler\StringStats.cs,GetEnumerator,The following statement contains a magic number: foreach (var kv in counts)              {                  //                       Definition          Reference                  //                       ------------------  ------------------                  // In-place string    |  <nothing>           "..."                  // Type level string  |  a.sxy="...";        a.sxy                  var inplaceSize = kv.Value*(kv.Key.Length + 2);                  var typeSize = 9 + kv.Key.Length + kv.Value*5;                  yield return                      new KeyValuePair<string' StringBindScope>                          (kv.Key' typeSize < inplaceSize ? StringBindScope.Type : StringBindScope.InPlace);              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,StringStats,C:\repos\Reactive-Extensions_IL2JS\Compiler\StringStats.cs,GetEnumerator,The following statement contains a magic number: foreach (var kv in counts)              {                  //                       Definition          Reference                  //                       ------------------  ------------------                  // In-place string    |  <nothing>           "..."                  // Type level string  |  a.sxy="...";        a.sxy                  var inplaceSize = kv.Value*(kv.Key.Length + 2);                  var typeSize = 9 + kv.Key.Length + kv.Value*5;                  yield return                      new KeyValuePair<string' StringBindScope>                          (kv.Key' typeSize < inplaceSize ? StringBindScope.Type : StringBindScope.InPlace);              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DefaultImportingConstructor,The following statement contains a magic number: foreach (var currCtor in                  typeEnv.Type.Members.OfType<CST.MethodDef>().Where                      (m =>                       m.Invalid == null && !m.IsStatic && m.IsConstructor &&                       !IsImported(typeEnv.Assembly' typeEnv.Type' m)))              {                  var currArity = currCtor.ValueParameters.Count;                  var thisRank = 0;                  switch (state)                  {                  case InstanceState.ManagedOnly:                      if (currArity == 1)                          // .ctor(C this)                          thisRank = 1;                      break;                  case InstanceState.ManagedAndJavaScript:                  case InstanceState.JavaScriptOnly:                      if (currArity == 2 && currCtor.ValueParameters[1].Type.Equals(env.JSContextRef))                          // .ctor(C this' JSContext ctxt)                          thisRank = 2;                      break;                  case InstanceState.Merged:                      throw new InvalidOperationException                          ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");                  default:                      throw new ArgumentOutOfRangeException();                  }                    if (thisRank > 0 &&                      currCtor.Annotations.OfType<CST.AccessibilityAnnotation>().Where                          (a => a.Accessibility != CST.Accessibility.Public).Any())                  {                      env.Log                          (new InvalidInteropMessage                               (CST.MessageContextBuilders.Member(env.Global' typeEnv.Assembly' typeEnv.Type' currCtor)'                                "importing constructors must be public"));                      throw new DefinitionException();                  }                    if (thisRank > bestRank)                  {                      bestRank = thisRank;                      bestCtor = currCtor;                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DefaultImportingConstructor,The following statement contains a magic number: foreach (var currCtor in                  typeEnv.Type.Members.OfType<CST.MethodDef>().Where                      (m =>                       m.Invalid == null && !m.IsStatic && m.IsConstructor &&                       !IsImported(typeEnv.Assembly' typeEnv.Type' m)))              {                  var currArity = currCtor.ValueParameters.Count;                  var thisRank = 0;                  switch (state)                  {                  case InstanceState.ManagedOnly:                      if (currArity == 1)                          // .ctor(C this)                          thisRank = 1;                      break;                  case InstanceState.ManagedAndJavaScript:                  case InstanceState.JavaScriptOnly:                      if (currArity == 2 && currCtor.ValueParameters[1].Type.Equals(env.JSContextRef))                          // .ctor(C this' JSContext ctxt)                          thisRank = 2;                      break;                  case InstanceState.Merged:                      throw new InvalidOperationException                          ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");                  default:                      throw new ArgumentOutOfRangeException();                  }                    if (thisRank > 0 &&                      currCtor.Annotations.OfType<CST.AccessibilityAnnotation>().Where                          (a => a.Accessibility != CST.Accessibility.Public).Any())                  {                      env.Log                          (new InvalidInteropMessage                               (CST.MessageContextBuilders.Member(env.Global' typeEnv.Assembly' typeEnv.Type' currCtor)'                                "importing constructors must be public"));                      throw new DefinitionException();                  }                    if (thisRank > bestRank)                  {                      bestRank = thisRank;                      bestCtor = currCtor;                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: foreach (var currCtor in                  polyMethEnv.Type.Members.OfType<CST.MethodDef>().Where                      (m =>                       m.Invalid == null && !m.IsStatic && m.IsConstructor &&                       !IsImported(polyMethEnv.Assembly' polyMethEnv.Type' m)))              {                  var currRank = 0;                  var currArity = currCtor.ValueParameters.Count;                  switch (state)                  {                  case InstanceState.ManagedOnly:                      if (currArity == 1)                          // .ctor(C this)                          currRank = 1;                      break;                  case InstanceState.ManagedAndJavaScript:                  case InstanceState.JavaScriptOnly:                      if (currArity == 2 && currCtor.ValueParameters[1].Type.Equals(env.JSContextRef))                          // .ctor(C this' JSContext ctxt)                          currRank = 1;                      else if (currArity == polyMethEnv.Method.Arity + 1 &&                               currCtor.ValueParameters[1].Type.Equals(env.JSContextRef))                      {                          // .ctor(C this' JSContext ctxt' T t' U u)                          currRank = 2;                          for (var i = 2; i < currArity; i++)                          {                              if (                                  !currCtor.ValueParameters[i].Type.IsEquivalentTo                                       (polyMethEnv' polyMethEnv.Method.ValueParameters[i - 1].Type))                              {                                  currRank = 0;                                  break;                              }                          }                      }                      break;                  case InstanceState.Merged:                      throw new InvalidOperationException                          ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");                  default:                      throw new ArgumentOutOfRangeException();                  }                    if (currRank > 0 &&                      currCtor.Annotations.OfType<CST.AccessibilityAnnotation>().Where                          (a => a.Accessibility != CST.Accessibility.Public).Any())                  {                      env.Log                          (new InvalidInteropMessage                               (CST.MessageContextBuilders.Member(env.Global' polyMethEnv.Assembly' polyMethEnv.Type' currCtor)'                                "importing constructors must be public"));                      throw new DefinitionException();                  }                    if (currRank > bestRank)                  {                      bestRank = currRank;                      bestCtor = new CST.MethodRef(polyMethEnv.TypeRef' currCtor.MethodSignature' null);                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: foreach (var currCtor in                  polyMethEnv.Type.Members.OfType<CST.MethodDef>().Where                      (m =>                       m.Invalid == null && !m.IsStatic && m.IsConstructor &&                       !IsImported(polyMethEnv.Assembly' polyMethEnv.Type' m)))              {                  var currRank = 0;                  var currArity = currCtor.ValueParameters.Count;                  switch (state)                  {                  case InstanceState.ManagedOnly:                      if (currArity == 1)                          // .ctor(C this)                          currRank = 1;                      break;                  case InstanceState.ManagedAndJavaScript:                  case InstanceState.JavaScriptOnly:                      if (currArity == 2 && currCtor.ValueParameters[1].Type.Equals(env.JSContextRef))                          // .ctor(C this' JSContext ctxt)                          currRank = 1;                      else if (currArity == polyMethEnv.Method.Arity + 1 &&                               currCtor.ValueParameters[1].Type.Equals(env.JSContextRef))                      {                          // .ctor(C this' JSContext ctxt' T t' U u)                          currRank = 2;                          for (var i = 2; i < currArity; i++)                          {                              if (                                  !currCtor.ValueParameters[i].Type.IsEquivalentTo                                       (polyMethEnv' polyMethEnv.Method.ValueParameters[i - 1].Type))                              {                                  currRank = 0;                                  break;                              }                          }                      }                      break;                  case InstanceState.Merged:                      throw new InvalidOperationException                          ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");                  default:                      throw new ArgumentOutOfRangeException();                  }                    if (currRank > 0 &&                      currCtor.Annotations.OfType<CST.AccessibilityAnnotation>().Where                          (a => a.Accessibility != CST.Accessibility.Public).Any())                  {                      env.Log                          (new InvalidInteropMessage                               (CST.MessageContextBuilders.Member(env.Global' polyMethEnv.Assembly' polyMethEnv.Type' currCtor)'                                "importing constructors must be public"));                      throw new DefinitionException();                  }                    if (currRank > bestRank)                  {                      bestRank = currRank;                      bestCtor = new CST.MethodRef(polyMethEnv.TypeRef' currCtor.MethodSignature' null);                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: foreach (var currCtor in                  polyMethEnv.Type.Members.OfType<CST.MethodDef>().Where                      (m =>                       m.Invalid == null && !m.IsStatic && m.IsConstructor &&                       !IsImported(polyMethEnv.Assembly' polyMethEnv.Type' m)))              {                  var currRank = 0;                  var currArity = currCtor.ValueParameters.Count;                  switch (state)                  {                  case InstanceState.ManagedOnly:                      if (currArity == 1)                          // .ctor(C this)                          currRank = 1;                      break;                  case InstanceState.ManagedAndJavaScript:                  case InstanceState.JavaScriptOnly:                      if (currArity == 2 && currCtor.ValueParameters[1].Type.Equals(env.JSContextRef))                          // .ctor(C this' JSContext ctxt)                          currRank = 1;                      else if (currArity == polyMethEnv.Method.Arity + 1 &&                               currCtor.ValueParameters[1].Type.Equals(env.JSContextRef))                      {                          // .ctor(C this' JSContext ctxt' T t' U u)                          currRank = 2;                          for (var i = 2; i < currArity; i++)                          {                              if (                                  !currCtor.ValueParameters[i].Type.IsEquivalentTo                                       (polyMethEnv' polyMethEnv.Method.ValueParameters[i - 1].Type))                              {                                  currRank = 0;                                  break;                              }                          }                      }                      break;                  case InstanceState.Merged:                      throw new InvalidOperationException                          ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");                  default:                      throw new ArgumentOutOfRangeException();                  }                    if (currRank > 0 &&                      currCtor.Annotations.OfType<CST.AccessibilityAnnotation>().Where                          (a => a.Accessibility != CST.Accessibility.Public).Any())                  {                      env.Log                          (new InvalidInteropMessage                               (CST.MessageContextBuilders.Member(env.Global' polyMethEnv.Assembly' polyMethEnv.Type' currCtor)'                                "importing constructors must be public"));                      throw new DefinitionException();                  }                    if (currRank > bestRank)                  {                      bestRank = currRank;                      bestCtor = new CST.MethodRef(polyMethEnv.TypeRef' currCtor.MethodSignature' null);                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && methodDef.IsConstructor)              {                  // Constructor                  if (script == null)                  {                      var creation = default(Creation);                      attributeHelper.GetValueFromMethod                          (assemblyDef'                           typeDef'                           methodDef'                           attributeHelper.ImportAttributeRef'                           attributeHelper.TheCreationProperty'                           true'                           false'                           ref creation);                      switch (creation)                      {                      case Creation.Constructor:                          script = PrefixName(assemblyDef' typeDef' methodDef' null' false);                          break;                      case Creation.Object:                          if (arguments.Count > 0)                          {                              env.Log                                  (new InvalidInteropMessage                                       (ctxt' "imported constructors for object literals cannot have arguments"));                              throw new DefinitionException();                          }                          script = Constants.Object.ToE();                          break;                      case Creation.Array:                          script = Constants.Array.ToE();                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var call = AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                      return new JST.NewExpression(call);                  }                  else if (script is JST.FunctionExpression)                      return AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                  else                  {                      script = PrefixName(assemblyDef' typeDef' methodDef' script' false);                      var call = AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                      return new JST.NewExpression(call);                  }              }              else              {                  var outer = typeDef.OuterPropertyOrEvent(methodDef.MethodSignature);                  if (outer != null)                  {                      var isOnMethod = attributeHelper.MethodHasAttribute                          (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);                      var localScript = default(JST.Expression);                      if (isOnMethod)                          attributeHelper.GetValueFromMethod                              (assemblyDef'                               typeDef'                               methodDef'                               attributeHelper.ImportAttributeRef'                               attributeHelper.TheScriptProperty'                               false'                               false'                               ref localScript);                        switch (outer.Flavor)                      {                      case CST.MemberDefFlavor.Property:                          {                              var propDef = (CST.PropertyDef)outer;                              if (propDef.Get != null && methodDef.Signature.Equals(propDef.Get))                              {                                  // Getter                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "get"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage                                               (ctxt' "property import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      if (script == null && arguments.Count == 2 && !methodDef.IsStatic)                                          return new JST.IndexExpression(arguments[0]' arguments[1]);                                      else                                      {                                          script = PrefixName                                              (assemblyDef'                                               typeDef'                                               methodDef'                                               RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                               false);                                          if (methodDef.IsStatic && arguments.Count == 0)                                              return script;                                          else if (!methodDef.IsStatic && arguments.Count == 1)                                              return JST.Expression.Dot                                                  (arguments[0]' JST.Expression.ExplodePath(script));                                          else                                          {                                              env.Log                                                  (new InvalidInteropMessage                                                       (ctxt'                                                        "additional getter parameters not supported for default getters"));                                              throw new DefinitionException();                                          }                                      }                                  }                              }                              else if (propDef.Set != null && methodDef.Signature.Equals(propDef.Set))                              {                                  // Setter                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "set"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage                                               (ctxt' "property import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      if (script == null && arguments.Count == 3 && !methodDef.IsStatic)                                          return new JST.BinaryExpression                                              (new JST.IndexExpression(arguments[0]' arguments[1])'                                               JST.BinaryOp.Assignment'                                               arguments[2]);                                      else                                      {                                          script = PrefixName                                              (assemblyDef'                                               typeDef'                                               methodDef'                                               RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                               false);                                          if (methodDef.IsStatic && arguments.Count == 1)                                              return new JST.BinaryExpression                                                  (script' JST.BinaryOp.Assignment' arguments[0]);                                          else if (!methodDef.IsStatic && arguments.Count == 2)                                              return new JST.BinaryExpression                                                  (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                                   JST.BinaryOp.Assignment'                                                   arguments[1]);                                          else                                          {                                              env.Log                                                  (new InvalidInteropMessage                                                       (ctxt'                                                        "additional setter parameters not supported for default setters"));                                              throw new DefinitionException();                                          }                                      }                                  }                              }                              else                                  throw new InvalidOperationException();                          }                      case CST.MemberDefFlavor.Event:                          {                              var eventDef = (CST.EventDef)outer;                              // XREF1201                              if (eventDef.Add != null && methodDef.Signature.Equals(eventDef.Add))                              {                                  // Adder                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "add"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage(ctxt' "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      // The delegate argument has already taken account of the combine' so                                       // just a field assignment                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                           false);                                      if (methodDef.IsStatic && arguments.Count == 1)                                          return new JST.BinaryExpression(script' JST.BinaryOp.Assignment' arguments[0]);                                      else if (!methodDef.IsStatic && arguments.Count == 2)                                          return new JST.BinaryExpression                                              (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                               JST.BinaryOp.Assignment'                                               arguments[1]);                                      else                                          throw new InvalidOperationException("mismatched event adder arity");                                  }                              }                              else if (eventDef.Remove != null && methodDef.Signature.Equals(eventDef.Remove))                              {                                  // Remover                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "remove"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage(ctxt' "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      // The delegate argument has already taken account of the delete' so                                       // just a field assignment                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                           false);                                      if (methodDef.IsStatic && arguments.Count == 1)                                          return new JST.BinaryExpression(script' JST.BinaryOp.Assignment' arguments[0]);                                      else if (!methodDef.IsStatic && arguments.Count == 2)                                          return new JST.BinaryExpression                                              (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                               JST.BinaryOp.Assignment'                                               arguments[1]);                                      else                                          throw new InvalidOperationException("mismatched event remover arity");                                  }                              }                              else                                  throw new InvalidOperationException();                          }                      case CST.MemberDefFlavor.Field:                      case CST.MemberDefFlavor.Method:                          throw new InvalidOperationException("outer is not property or event");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }                  else                  {                      // Normal method                      script = PrefixName                          (assemblyDef' typeDef' methodDef' RecaseMethod(assemblyDef' typeDef' methodDef' script)' false);                      return AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && methodDef.IsConstructor)              {                  // Constructor                  if (script == null)                  {                      var creation = default(Creation);                      attributeHelper.GetValueFromMethod                          (assemblyDef'                           typeDef'                           methodDef'                           attributeHelper.ImportAttributeRef'                           attributeHelper.TheCreationProperty'                           true'                           false'                           ref creation);                      switch (creation)                      {                      case Creation.Constructor:                          script = PrefixName(assemblyDef' typeDef' methodDef' null' false);                          break;                      case Creation.Object:                          if (arguments.Count > 0)                          {                              env.Log                                  (new InvalidInteropMessage                                       (ctxt' "imported constructors for object literals cannot have arguments"));                              throw new DefinitionException();                          }                          script = Constants.Object.ToE();                          break;                      case Creation.Array:                          script = Constants.Array.ToE();                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var call = AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                      return new JST.NewExpression(call);                  }                  else if (script is JST.FunctionExpression)                      return AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                  else                  {                      script = PrefixName(assemblyDef' typeDef' methodDef' script' false);                      var call = AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                      return new JST.NewExpression(call);                  }              }              else              {                  var outer = typeDef.OuterPropertyOrEvent(methodDef.MethodSignature);                  if (outer != null)                  {                      var isOnMethod = attributeHelper.MethodHasAttribute                          (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);                      var localScript = default(JST.Expression);                      if (isOnMethod)                          attributeHelper.GetValueFromMethod                              (assemblyDef'                               typeDef'                               methodDef'                               attributeHelper.ImportAttributeRef'                               attributeHelper.TheScriptProperty'                               false'                               false'                               ref localScript);                        switch (outer.Flavor)                      {                      case CST.MemberDefFlavor.Property:                          {                              var propDef = (CST.PropertyDef)outer;                              if (propDef.Get != null && methodDef.Signature.Equals(propDef.Get))                              {                                  // Getter                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "get"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage                                               (ctxt' "property import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      if (script == null && arguments.Count == 2 && !methodDef.IsStatic)                                          return new JST.IndexExpression(arguments[0]' arguments[1]);                                      else                                      {                                          script = PrefixName                                              (assemblyDef'                                               typeDef'                                               methodDef'                                               RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                               false);                                          if (methodDef.IsStatic && arguments.Count == 0)                                              return script;                                          else if (!methodDef.IsStatic && arguments.Count == 1)                                              return JST.Expression.Dot                                                  (arguments[0]' JST.Expression.ExplodePath(script));                                          else                                          {                                              env.Log                                                  (new InvalidInteropMessage                                                       (ctxt'                                                        "additional getter parameters not supported for default getters"));                                              throw new DefinitionException();                                          }                                      }                                  }                              }                              else if (propDef.Set != null && methodDef.Signature.Equals(propDef.Set))                              {                                  // Setter                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "set"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage                                               (ctxt' "property import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      if (script == null && arguments.Count == 3 && !methodDef.IsStatic)                                          return new JST.BinaryExpression                                              (new JST.IndexExpression(arguments[0]' arguments[1])'                                               JST.BinaryOp.Assignment'                                               arguments[2]);                                      else                                      {                                          script = PrefixName                                              (assemblyDef'                                               typeDef'                                               methodDef'                                               RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                               false);                                          if (methodDef.IsStatic && arguments.Count == 1)                                              return new JST.BinaryExpression                                                  (script' JST.BinaryOp.Assignment' arguments[0]);                                          else if (!methodDef.IsStatic && arguments.Count == 2)                                              return new JST.BinaryExpression                                                  (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                                   JST.BinaryOp.Assignment'                                                   arguments[1]);                                          else                                          {                                              env.Log                                                  (new InvalidInteropMessage                                                       (ctxt'                                                        "additional setter parameters not supported for default setters"));                                              throw new DefinitionException();                                          }                                      }                                  }                              }                              else                                  throw new InvalidOperationException();                          }                      case CST.MemberDefFlavor.Event:                          {                              var eventDef = (CST.EventDef)outer;                              // XREF1201                              if (eventDef.Add != null && methodDef.Signature.Equals(eventDef.Add))                              {                                  // Adder                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "add"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage(ctxt' "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      // The delegate argument has already taken account of the combine' so                                       // just a field assignment                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                           false);                                      if (methodDef.IsStatic && arguments.Count == 1)                                          return new JST.BinaryExpression(script' JST.BinaryOp.Assignment' arguments[0]);                                      else if (!methodDef.IsStatic && arguments.Count == 2)                                          return new JST.BinaryExpression                                              (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                               JST.BinaryOp.Assignment'                                               arguments[1]);                                      else                                          throw new InvalidOperationException("mismatched event adder arity");                                  }                              }                              else if (eventDef.Remove != null && methodDef.Signature.Equals(eventDef.Remove))                              {                                  // Remover                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "remove"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage(ctxt' "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      // The delegate argument has already taken account of the delete' so                                       // just a field assignment                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                           false);                                      if (methodDef.IsStatic && arguments.Count == 1)                                          return new JST.BinaryExpression(script' JST.BinaryOp.Assignment' arguments[0]);                                      else if (!methodDef.IsStatic && arguments.Count == 2)                                          return new JST.BinaryExpression                                              (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                               JST.BinaryOp.Assignment'                                               arguments[1]);                                      else                                          throw new InvalidOperationException("mismatched event remover arity");                                  }                              }                              else                                  throw new InvalidOperationException();                          }                      case CST.MemberDefFlavor.Field:                      case CST.MemberDefFlavor.Method:                          throw new InvalidOperationException("outer is not property or event");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }                  else                  {                      // Normal method                      script = PrefixName                          (assemblyDef' typeDef' methodDef' RecaseMethod(assemblyDef' typeDef' methodDef' script)' false);                      return AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && methodDef.IsConstructor)              {                  // Constructor                  if (script == null)                  {                      var creation = default(Creation);                      attributeHelper.GetValueFromMethod                          (assemblyDef'                           typeDef'                           methodDef'                           attributeHelper.ImportAttributeRef'                           attributeHelper.TheCreationProperty'                           true'                           false'                           ref creation);                      switch (creation)                      {                      case Creation.Constructor:                          script = PrefixName(assemblyDef' typeDef' methodDef' null' false);                          break;                      case Creation.Object:                          if (arguments.Count > 0)                          {                              env.Log                                  (new InvalidInteropMessage                                       (ctxt' "imported constructors for object literals cannot have arguments"));                              throw new DefinitionException();                          }                          script = Constants.Object.ToE();                          break;                      case Creation.Array:                          script = Constants.Array.ToE();                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var call = AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                      return new JST.NewExpression(call);                  }                  else if (script is JST.FunctionExpression)                      return AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                  else                  {                      script = PrefixName(assemblyDef' typeDef' methodDef' script' false);                      var call = AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                      return new JST.NewExpression(call);                  }              }              else              {                  var outer = typeDef.OuterPropertyOrEvent(methodDef.MethodSignature);                  if (outer != null)                  {                      var isOnMethod = attributeHelper.MethodHasAttribute                          (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);                      var localScript = default(JST.Expression);                      if (isOnMethod)                          attributeHelper.GetValueFromMethod                              (assemblyDef'                               typeDef'                               methodDef'                               attributeHelper.ImportAttributeRef'                               attributeHelper.TheScriptProperty'                               false'                               false'                               ref localScript);                        switch (outer.Flavor)                      {                      case CST.MemberDefFlavor.Property:                          {                              var propDef = (CST.PropertyDef)outer;                              if (propDef.Get != null && methodDef.Signature.Equals(propDef.Get))                              {                                  // Getter                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "get"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage                                               (ctxt' "property import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      if (script == null && arguments.Count == 2 && !methodDef.IsStatic)                                          return new JST.IndexExpression(arguments[0]' arguments[1]);                                      else                                      {                                          script = PrefixName                                              (assemblyDef'                                               typeDef'                                               methodDef'                                               RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                               false);                                          if (methodDef.IsStatic && arguments.Count == 0)                                              return script;                                          else if (!methodDef.IsStatic && arguments.Count == 1)                                              return JST.Expression.Dot                                                  (arguments[0]' JST.Expression.ExplodePath(script));                                          else                                          {                                              env.Log                                                  (new InvalidInteropMessage                                                       (ctxt'                                                        "additional getter parameters not supported for default getters"));                                              throw new DefinitionException();                                          }                                      }                                  }                              }                              else if (propDef.Set != null && methodDef.Signature.Equals(propDef.Set))                              {                                  // Setter                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "set"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage                                               (ctxt' "property import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      if (script == null && arguments.Count == 3 && !methodDef.IsStatic)                                          return new JST.BinaryExpression                                              (new JST.IndexExpression(arguments[0]' arguments[1])'                                               JST.BinaryOp.Assignment'                                               arguments[2]);                                      else                                      {                                          script = PrefixName                                              (assemblyDef'                                               typeDef'                                               methodDef'                                               RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                               false);                                          if (methodDef.IsStatic && arguments.Count == 1)                                              return new JST.BinaryExpression                                                  (script' JST.BinaryOp.Assignment' arguments[0]);                                          else if (!methodDef.IsStatic && arguments.Count == 2)                                              return new JST.BinaryExpression                                                  (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                                   JST.BinaryOp.Assignment'                                                   arguments[1]);                                          else                                          {                                              env.Log                                                  (new InvalidInteropMessage                                                       (ctxt'                                                        "additional setter parameters not supported for default setters"));                                              throw new DefinitionException();                                          }                                      }                                  }                              }                              else                                  throw new InvalidOperationException();                          }                      case CST.MemberDefFlavor.Event:                          {                              var eventDef = (CST.EventDef)outer;                              // XREF1201                              if (eventDef.Add != null && methodDef.Signature.Equals(eventDef.Add))                              {                                  // Adder                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "add"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage(ctxt' "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      // The delegate argument has already taken account of the combine' so                                       // just a field assignment                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                           false);                                      if (methodDef.IsStatic && arguments.Count == 1)                                          return new JST.BinaryExpression(script' JST.BinaryOp.Assignment' arguments[0]);                                      else if (!methodDef.IsStatic && arguments.Count == 2)                                          return new JST.BinaryExpression                                              (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                               JST.BinaryOp.Assignment'                                               arguments[1]);                                      else                                          throw new InvalidOperationException("mismatched event adder arity");                                  }                              }                              else if (eventDef.Remove != null && methodDef.Signature.Equals(eventDef.Remove))                              {                                  // Remover                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "remove"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage(ctxt' "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      // The delegate argument has already taken account of the delete' so                                       // just a field assignment                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                           false);                                      if (methodDef.IsStatic && arguments.Count == 1)                                          return new JST.BinaryExpression(script' JST.BinaryOp.Assignment' arguments[0]);                                      else if (!methodDef.IsStatic && arguments.Count == 2)                                          return new JST.BinaryExpression                                              (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                               JST.BinaryOp.Assignment'                                               arguments[1]);                                      else                                          throw new InvalidOperationException("mismatched event remover arity");                                  }                              }                              else                                  throw new InvalidOperationException();                          }                      case CST.MemberDefFlavor.Field:                      case CST.MemberDefFlavor.Method:                          throw new InvalidOperationException("outer is not property or event");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }                  else                  {                      // Normal method                      script = PrefixName                          (assemblyDef' typeDef' methodDef' RecaseMethod(assemblyDef' typeDef' methodDef' script)' false);                      return AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && methodDef.IsConstructor)              {                  // Constructor                  if (script == null)                  {                      var creation = default(Creation);                      attributeHelper.GetValueFromMethod                          (assemblyDef'                           typeDef'                           methodDef'                           attributeHelper.ImportAttributeRef'                           attributeHelper.TheCreationProperty'                           true'                           false'                           ref creation);                      switch (creation)                      {                      case Creation.Constructor:                          script = PrefixName(assemblyDef' typeDef' methodDef' null' false);                          break;                      case Creation.Object:                          if (arguments.Count > 0)                          {                              env.Log                                  (new InvalidInteropMessage                                       (ctxt' "imported constructors for object literals cannot have arguments"));                              throw new DefinitionException();                          }                          script = Constants.Object.ToE();                          break;                      case Creation.Array:                          script = Constants.Array.ToE();                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var call = AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                      return new JST.NewExpression(call);                  }                  else if (script is JST.FunctionExpression)                      return AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                  else                  {                      script = PrefixName(assemblyDef' typeDef' methodDef' script' false);                      var call = AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                      return new JST.NewExpression(call);                  }              }              else              {                  var outer = typeDef.OuterPropertyOrEvent(methodDef.MethodSignature);                  if (outer != null)                  {                      var isOnMethod = attributeHelper.MethodHasAttribute                          (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);                      var localScript = default(JST.Expression);                      if (isOnMethod)                          attributeHelper.GetValueFromMethod                              (assemblyDef'                               typeDef'                               methodDef'                               attributeHelper.ImportAttributeRef'                               attributeHelper.TheScriptProperty'                               false'                               false'                               ref localScript);                        switch (outer.Flavor)                      {                      case CST.MemberDefFlavor.Property:                          {                              var propDef = (CST.PropertyDef)outer;                              if (propDef.Get != null && methodDef.Signature.Equals(propDef.Get))                              {                                  // Getter                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "get"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage                                               (ctxt' "property import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      if (script == null && arguments.Count == 2 && !methodDef.IsStatic)                                          return new JST.IndexExpression(arguments[0]' arguments[1]);                                      else                                      {                                          script = PrefixName                                              (assemblyDef'                                               typeDef'                                               methodDef'                                               RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                               false);                                          if (methodDef.IsStatic && arguments.Count == 0)                                              return script;                                          else if (!methodDef.IsStatic && arguments.Count == 1)                                              return JST.Expression.Dot                                                  (arguments[0]' JST.Expression.ExplodePath(script));                                          else                                          {                                              env.Log                                                  (new InvalidInteropMessage                                                       (ctxt'                                                        "additional getter parameters not supported for default getters"));                                              throw new DefinitionException();                                          }                                      }                                  }                              }                              else if (propDef.Set != null && methodDef.Signature.Equals(propDef.Set))                              {                                  // Setter                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "set"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage                                               (ctxt' "property import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      if (script == null && arguments.Count == 3 && !methodDef.IsStatic)                                          return new JST.BinaryExpression                                              (new JST.IndexExpression(arguments[0]' arguments[1])'                                               JST.BinaryOp.Assignment'                                               arguments[2]);                                      else                                      {                                          script = PrefixName                                              (assemblyDef'                                               typeDef'                                               methodDef'                                               RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                               false);                                          if (methodDef.IsStatic && arguments.Count == 1)                                              return new JST.BinaryExpression                                                  (script' JST.BinaryOp.Assignment' arguments[0]);                                          else if (!methodDef.IsStatic && arguments.Count == 2)                                              return new JST.BinaryExpression                                                  (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                                   JST.BinaryOp.Assignment'                                                   arguments[1]);                                          else                                          {                                              env.Log                                                  (new InvalidInteropMessage                                                       (ctxt'                                                        "additional setter parameters not supported for default setters"));                                              throw new DefinitionException();                                          }                                      }                                  }                              }                              else                                  throw new InvalidOperationException();                          }                      case CST.MemberDefFlavor.Event:                          {                              var eventDef = (CST.EventDef)outer;                              // XREF1201                              if (eventDef.Add != null && methodDef.Signature.Equals(eventDef.Add))                              {                                  // Adder                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "add"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage(ctxt' "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      // The delegate argument has already taken account of the combine' so                                       // just a field assignment                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                           false);                                      if (methodDef.IsStatic && arguments.Count == 1)                                          return new JST.BinaryExpression(script' JST.BinaryOp.Assignment' arguments[0]);                                      else if (!methodDef.IsStatic && arguments.Count == 2)                                          return new JST.BinaryExpression                                              (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                               JST.BinaryOp.Assignment'                                               arguments[1]);                                      else                                          throw new InvalidOperationException("mismatched event adder arity");                                  }                              }                              else if (eventDef.Remove != null && methodDef.Signature.Equals(eventDef.Remove))                              {                                  // Remover                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "remove"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage(ctxt' "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      // The delegate argument has already taken account of the delete' so                                       // just a field assignment                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                           false);                                      if (methodDef.IsStatic && arguments.Count == 1)                                          return new JST.BinaryExpression(script' JST.BinaryOp.Assignment' arguments[0]);                                      else if (!methodDef.IsStatic && arguments.Count == 2)                                          return new JST.BinaryExpression                                              (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                               JST.BinaryOp.Assignment'                                               arguments[1]);                                      else                                          throw new InvalidOperationException("mismatched event remover arity");                                  }                              }                              else                                  throw new InvalidOperationException();                          }                      case CST.MemberDefFlavor.Field:                      case CST.MemberDefFlavor.Method:                          throw new InvalidOperationException("outer is not property or event");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }                  else                  {                      // Normal method                      script = PrefixName                          (assemblyDef' typeDef' methodDef' RecaseMethod(assemblyDef' typeDef' methodDef' script)' false);                      return AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && methodDef.IsConstructor)              {                  // Constructor                  if (script == null)                  {                      var creation = default(Creation);                      attributeHelper.GetValueFromMethod                          (assemblyDef'                           typeDef'                           methodDef'                           attributeHelper.ImportAttributeRef'                           attributeHelper.TheCreationProperty'                           true'                           false'                           ref creation);                      switch (creation)                      {                      case Creation.Constructor:                          script = PrefixName(assemblyDef' typeDef' methodDef' null' false);                          break;                      case Creation.Object:                          if (arguments.Count > 0)                          {                              env.Log                                  (new InvalidInteropMessage                                       (ctxt' "imported constructors for object literals cannot have arguments"));                              throw new DefinitionException();                          }                          script = Constants.Object.ToE();                          break;                      case Creation.Array:                          script = Constants.Array.ToE();                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var call = AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                      return new JST.NewExpression(call);                  }                  else if (script is JST.FunctionExpression)                      return AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                  else                  {                      script = PrefixName(assemblyDef' typeDef' methodDef' script' false);                      var call = AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                      return new JST.NewExpression(call);                  }              }              else              {                  var outer = typeDef.OuterPropertyOrEvent(methodDef.MethodSignature);                  if (outer != null)                  {                      var isOnMethod = attributeHelper.MethodHasAttribute                          (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);                      var localScript = default(JST.Expression);                      if (isOnMethod)                          attributeHelper.GetValueFromMethod                              (assemblyDef'                               typeDef'                               methodDef'                               attributeHelper.ImportAttributeRef'                               attributeHelper.TheScriptProperty'                               false'                               false'                               ref localScript);                        switch (outer.Flavor)                      {                      case CST.MemberDefFlavor.Property:                          {                              var propDef = (CST.PropertyDef)outer;                              if (propDef.Get != null && methodDef.Signature.Equals(propDef.Get))                              {                                  // Getter                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "get"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage                                               (ctxt' "property import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      if (script == null && arguments.Count == 2 && !methodDef.IsStatic)                                          return new JST.IndexExpression(arguments[0]' arguments[1]);                                      else                                      {                                          script = PrefixName                                              (assemblyDef'                                               typeDef'                                               methodDef'                                               RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                               false);                                          if (methodDef.IsStatic && arguments.Count == 0)                                              return script;                                          else if (!methodDef.IsStatic && arguments.Count == 1)                                              return JST.Expression.Dot                                                  (arguments[0]' JST.Expression.ExplodePath(script));                                          else                                          {                                              env.Log                                                  (new InvalidInteropMessage                                                       (ctxt'                                                        "additional getter parameters not supported for default getters"));                                              throw new DefinitionException();                                          }                                      }                                  }                              }                              else if (propDef.Set != null && methodDef.Signature.Equals(propDef.Set))                              {                                  // Setter                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "set"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage                                               (ctxt' "property import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      if (script == null && arguments.Count == 3 && !methodDef.IsStatic)                                          return new JST.BinaryExpression                                              (new JST.IndexExpression(arguments[0]' arguments[1])'                                               JST.BinaryOp.Assignment'                                               arguments[2]);                                      else                                      {                                          script = PrefixName                                              (assemblyDef'                                               typeDef'                                               methodDef'                                               RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                               false);                                          if (methodDef.IsStatic && arguments.Count == 1)                                              return new JST.BinaryExpression                                                  (script' JST.BinaryOp.Assignment' arguments[0]);                                          else if (!methodDef.IsStatic && arguments.Count == 2)                                              return new JST.BinaryExpression                                                  (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                                   JST.BinaryOp.Assignment'                                                   arguments[1]);                                          else                                          {                                              env.Log                                                  (new InvalidInteropMessage                                                       (ctxt'                                                        "additional setter parameters not supported for default setters"));                                              throw new DefinitionException();                                          }                                      }                                  }                              }                              else                                  throw new InvalidOperationException();                          }                      case CST.MemberDefFlavor.Event:                          {                              var eventDef = (CST.EventDef)outer;                              // XREF1201                              if (eventDef.Add != null && methodDef.Signature.Equals(eventDef.Add))                              {                                  // Adder                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "add"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage(ctxt' "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      // The delegate argument has already taken account of the combine' so                                       // just a field assignment                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                           false);                                      if (methodDef.IsStatic && arguments.Count == 1)                                          return new JST.BinaryExpression(script' JST.BinaryOp.Assignment' arguments[0]);                                      else if (!methodDef.IsStatic && arguments.Count == 2)                                          return new JST.BinaryExpression                                              (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                               JST.BinaryOp.Assignment'                                               arguments[1]);                                      else                                          throw new InvalidOperationException("mismatched event adder arity");                                  }                              }                              else if (eventDef.Remove != null && methodDef.Signature.Equals(eventDef.Remove))                              {                                  // Remover                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "remove"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage(ctxt' "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      // The delegate argument has already taken account of the delete' so                                       // just a field assignment                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                           false);                                      if (methodDef.IsStatic && arguments.Count == 1)                                          return new JST.BinaryExpression(script' JST.BinaryOp.Assignment' arguments[0]);                                      else if (!methodDef.IsStatic && arguments.Count == 2)                                          return new JST.BinaryExpression                                              (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                               JST.BinaryOp.Assignment'                                               arguments[1]);                                      else                                          throw new InvalidOperationException("mismatched event remover arity");                                  }                              }                              else                                  throw new InvalidOperationException();                          }                      case CST.MemberDefFlavor.Field:                      case CST.MemberDefFlavor.Method:                          throw new InvalidOperationException("outer is not property or event");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }                  else                  {                      // Normal method                      script = PrefixName                          (assemblyDef' typeDef' methodDef' RecaseMethod(assemblyDef' typeDef' methodDef' script)' false);                      return AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                  }              }
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && methodDef.IsConstructor)              {                  // Constructor                  if (script == null)                  {                      var creation = default(Creation);                      attributeHelper.GetValueFromMethod                          (assemblyDef'                           typeDef'                           methodDef'                           attributeHelper.ImportAttributeRef'                           attributeHelper.TheCreationProperty'                           true'                           false'                           ref creation);                      switch (creation)                      {                      case Creation.Constructor:                          script = PrefixName(assemblyDef' typeDef' methodDef' null' false);                          break;                      case Creation.Object:                          if (arguments.Count > 0)                          {                              env.Log                                  (new InvalidInteropMessage                                       (ctxt' "imported constructors for object literals cannot have arguments"));                              throw new DefinitionException();                          }                          script = Constants.Object.ToE();                          break;                      case Creation.Array:                          script = Constants.Array.ToE();                          break;                      default:                          throw new ArgumentOutOfRangeException();                      }                      var call = AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                      return new JST.NewExpression(call);                  }                  else if (script is JST.FunctionExpression)                      return AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                  else                  {                      script = PrefixName(assemblyDef' typeDef' methodDef' script' false);                      var call = AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                      return new JST.NewExpression(call);                  }              }              else              {                  var outer = typeDef.OuterPropertyOrEvent(methodDef.MethodSignature);                  if (outer != null)                  {                      var isOnMethod = attributeHelper.MethodHasAttribute                          (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);                      var localScript = default(JST.Expression);                      if (isOnMethod)                          attributeHelper.GetValueFromMethod                              (assemblyDef'                               typeDef'                               methodDef'                               attributeHelper.ImportAttributeRef'                               attributeHelper.TheScriptProperty'                               false'                               false'                               ref localScript);                        switch (outer.Flavor)                      {                      case CST.MemberDefFlavor.Property:                          {                              var propDef = (CST.PropertyDef)outer;                              if (propDef.Get != null && methodDef.Signature.Equals(propDef.Get))                              {                                  // Getter                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "get"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage                                               (ctxt' "property import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      if (script == null && arguments.Count == 2 && !methodDef.IsStatic)                                          return new JST.IndexExpression(arguments[0]' arguments[1]);                                      else                                      {                                          script = PrefixName                                              (assemblyDef'                                               typeDef'                                               methodDef'                                               RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                               false);                                          if (methodDef.IsStatic && arguments.Count == 0)                                              return script;                                          else if (!methodDef.IsStatic && arguments.Count == 1)                                              return JST.Expression.Dot                                                  (arguments[0]' JST.Expression.ExplodePath(script));                                          else                                          {                                              env.Log                                                  (new InvalidInteropMessage                                                       (ctxt'                                                        "additional getter parameters not supported for default getters"));                                              throw new DefinitionException();                                          }                                      }                                  }                              }                              else if (propDef.Set != null && methodDef.Signature.Equals(propDef.Set))                              {                                  // Setter                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "set"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage                                               (ctxt' "property import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      if (script == null && arguments.Count == 3 && !methodDef.IsStatic)                                          return new JST.BinaryExpression                                              (new JST.IndexExpression(arguments[0]' arguments[1])'                                               JST.BinaryOp.Assignment'                                               arguments[2]);                                      else                                      {                                          script = PrefixName                                              (assemblyDef'                                               typeDef'                                               methodDef'                                               RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                               false);                                          if (methodDef.IsStatic && arguments.Count == 1)                                              return new JST.BinaryExpression                                                  (script' JST.BinaryOp.Assignment' arguments[0]);                                          else if (!methodDef.IsStatic && arguments.Count == 2)                                              return new JST.BinaryExpression                                                  (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                                   JST.BinaryOp.Assignment'                                                   arguments[1]);                                          else                                          {                                              env.Log                                                  (new InvalidInteropMessage                                                       (ctxt'                                                        "additional setter parameters not supported for default setters"));                                              throw new DefinitionException();                                          }                                      }                                  }                              }                              else                                  throw new InvalidOperationException();                          }                      case CST.MemberDefFlavor.Event:                          {                              var eventDef = (CST.EventDef)outer;                              // XREF1201                              if (eventDef.Add != null && methodDef.Signature.Equals(eventDef.Add))                              {                                  // Adder                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "add"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage(ctxt' "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      // The delegate argument has already taken account of the combine' so                                       // just a field assignment                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                           false);                                      if (methodDef.IsStatic && arguments.Count == 1)                                          return new JST.BinaryExpression(script' JST.BinaryOp.Assignment' arguments[0]);                                      else if (!methodDef.IsStatic && arguments.Count == 2)                                          return new JST.BinaryExpression                                              (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                               JST.BinaryOp.Assignment'                                               arguments[1]);                                      else                                          throw new InvalidOperationException("mismatched event adder arity");                                  }                              }                              else if (eventDef.Remove != null && methodDef.Signature.Equals(eventDef.Remove))                              {                                  // Remover                                  if (isOnMethod)                                  {                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           GetterSetterAdderRemoverNameFromMethod                                               (assemblyDef' typeDef' methodDef' "remove"' localScript)'                                           false);                                      return AppendFinalImport                                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                                  }                                  else if (script != null && script is JST.FunctionExpression)                                  {                                      env.Log                                          (new InvalidInteropMessage(ctxt' "event import script cannot be a function"));                                      throw new DefinitionException();                                  }                                  else                                  {                                      // The delegate argument has already taken account of the delete' so                                       // just a field assignment                                      script = PrefixName                                          (assemblyDef'                                           typeDef'                                           methodDef'                                           RecasePropertyEvent(assemblyDef' typeDef' methodDef' script)'                                           false);                                      if (methodDef.IsStatic && arguments.Count == 1)                                          return new JST.BinaryExpression(script' JST.BinaryOp.Assignment' arguments[0]);                                      else if (!methodDef.IsStatic && arguments.Count == 2)                                          return new JST.BinaryExpression                                              (JST.Expression.Dot(arguments[0]' JST.Expression.ExplodePath(script))'                                               JST.BinaryOp.Assignment'                                               arguments[1]);                                      else                                          throw new InvalidOperationException("mismatched event remover arity");                                  }                              }                              else                                  throw new InvalidOperationException();                          }                      case CST.MemberDefFlavor.Field:                      case CST.MemberDefFlavor.Method:                          throw new InvalidOperationException("outer is not property or event");                      default:                          throw new ArgumentOutOfRangeException();                      }                  }                  else                  {                      // Normal method                      script = PrefixName                          (assemblyDef' typeDef' methodDef' RecaseMethod(assemblyDef' typeDef' methodDef' script)' false);                      return AppendFinalImport                          (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);                  }              }
