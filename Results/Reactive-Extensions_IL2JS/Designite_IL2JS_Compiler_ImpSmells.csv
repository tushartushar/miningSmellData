Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The method has 146 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The method has 118 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,The method has 184 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The method has 329 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateStatement,The method has 214 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS,Program,C:\repos\Reactive-Extensions_IL2JS\Compiler\Program.cs,Main,The method has 139 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalImport,The method has 102 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The method has 167 lines of code.
Long Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The method has 246 lines of code.
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,LastCompilationTime,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitTypeBindings,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitEntryPoint,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitAssemblyBindings,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,CompileTypes,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,SetupTypes,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,Emit,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitStart,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitManifest,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,Cyclomatic complexity of the method is 51
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,RuntimeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\RuntimeCompiler.cs,Emit,Cyclomatic complexity of the method is 26
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,DefaultResolveType,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,InitializerExpression,Cyclomatic complexity of the method is 23
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendInvokeImportingConstructor,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendCallExportedMethod,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,MethodCompiler,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,Cyclomatic complexity of the method is 49
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateCellReadWrite,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateCellAsPointer,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,Cyclomatic complexity of the method is 105
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,HandlerLiteral,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateStatement,Cyclomatic complexity of the method is 73
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,NormalMethod,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,Emit,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,MethodHasAttribute,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromMethod,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,EnterMethod,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,Program,C:\repos\Reactive-Extensions_IL2JS\Compiler\Program.cs,Main,Cyclomatic complexity of the method is 41
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitVirtualAndInterfaceMethodRedirectors,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitSetupType,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitDefaultValue,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,ConstructObjectFunction,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitConstructObjectAndInstanceMethods,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitEquals,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitInterop,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,MemberInfoExpression,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompilerEnvironment.cs,BindUsage,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,Cyclomatic complexity of the method is 24
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,EmitMethods,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CompileMethods,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerEnvironment.cs,Log,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,TypeMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,AddNames,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,SlotAllocation,C:\repos\Reactive-Extensions_IL2JS\Compiler\SlotAllocation.cs,SlotName,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,ImplementableMemberDef,Cyclomatic complexity of the method is 24
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DefaultImportingConstructor,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsImported,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsFactory,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalImport,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,Cyclomatic complexity of the method is 37
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalExport,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendExport,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,Cyclomatic complexity of the method is 91
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitInitializeFunction,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,DefaultMethodCallExpression,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructGenericEnumeratorAtDynamicType,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructGenericEnumeratorAtStaticType,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,DefaultVirtualMethodCallExpression,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendInvokeImportingConstructor,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendCallExportedMethod,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateCellReadWrite,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateCall,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The method has 13 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateStatement,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,WithLineCounts,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,MethodImpl,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,TypeHasAttribute,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,FieldHasAttribute,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,PropertyHasAttribute,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,EventHasAttribute,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,MethodHasAttribute,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParameterHasAttribute,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ResultHasAttribute,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValue,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValue,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromAssembly,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromType,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromField,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromProperty,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromEvent,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromMethod,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromParameter,The method has 9 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromResult,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,MethodCompilerEnvironment,The method has 19 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,EnterUntranslatedMethod,The method has 9 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,EnterMethod,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,BindMap,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,BindUsage,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,MethodCallExpression,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitBindInstanceExports,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompilerEnvironment.cs,TypeCompilerEnvironment,The method has 12 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompilerEnvironment.cs,EnterType,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,EmitMethods,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,TypeMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,AddNames,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,ImplementableInstruction,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,TypeRepresentation,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,TypeRepresentation,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,GetterSetterAdderRemoverNameFromMethod,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,GetterSetterAdderRemoverNameFromPropertyEvent,The method has 5 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The method has 6 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalImport,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The method has 7 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalExport,The method has 9 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendExport,The method has 8 parameters.
Long Parameter List,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The method has 5 parameters.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the parameter numInstanceFieldsAllSupertypes is 30.
Long Identifier,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the parameter numExportsBoundToInstanceNonRuntime is 35.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,CollectTypes,The length of the statement  "			var methodDef = typeDef.Members.OfType<CST.MethodDef> ().Where (m => m.Invalid == null && m.IsStatic && m.IsConstructor).FirstOrDefault (); " is 139.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitTypeBindings,The length of the statement  "			var typeName = CST.CSTWriter.WithAppend (Env.Global' CST.WriterStyle.Uniform' typeDef.EffectiveName (Env.Global).Append); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitTypeBindings,The length of the statement  "			var typeName = CST.CSTWriter.WithAppend (Env.Global' CST.WriterStyle.Uniform' typeDef.EffectiveName (Env.Global).Append); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitEntryPoint,The length of the statement  "		var func = new JST.FunctionExpression (null' new JST.Statements (new JST.ExpressionStatement (MethodCallExpression (entryPoint' innerNameSupply' false' new Seq<JST.Expression> ())))); " is 183.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,SetupTypes,The length of the statement  "	foreach (var name in Env.Validity.TypeInitializationOrder.Where (name => name.Assembly.Equals (AssmEnv.Assembly.Name) && need.Contains (name.Type))) { " is 150.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,SetupTypes,The length of the statement  "		body.Add (JST.Statement.DotCall (assemblyId.ToE ()' new JST.Identifier (Constants.AssemblyTypeBuilderSlot (slotName)))); " is 120.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitInitializeFunction,The length of the statement  "			if (Env.InteropManager.IsExported (assmEnv.Assembly' typeDef' methodDef) && !Env.InteropManager.IsBindToInstance (assmEnv.Assembly' typeDef' methodDef)) { " is 154.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitInitializeFunction,The length of the statement  "				Env.InteropManager.AppendExport (innerNameSupply' rootId' assmEnv.Assembly' typeDef' methodDef' null' innerBody' (ns' asm' typ' meth' b' a) => Env.JSTHelpers.AppendCallExportedMethod (this' ns' asm' typ' meth' b' a)); " is 217.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitInitializeFunction,The length of the statement  "		innerBody.Add (new JST.ExpressionStatement (MethodCallExpression (moduleInitializer' innerNameSupply' false' new Seq<JST.Expression> ()))); " is 139.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,Emit,The length of the statement  "	if (Env.BreakOnBreak && Env.AttributeHelper.AssemblyHasAttribute (assmEnv.Assembly' Env.AttributeHelper.BreakAttributeRef' false' false)) " is 137.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,Emit,The length of the statement  "		assmLoader.Add (JST.Statement.DotCall (new JST.Identifier (Env.Root).ToE ()' Constants.RootBindAssembly' new JST.StringLiteral (assmName)' assmFunc)); " is 150.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,Emit,The length of the statement  "		body.Add (JST.Statement.Var (assemblyId' new JST.IndexExpression (JST.Expression.Dot (rootId.ToE ()' Constants.RootAssemblyCache)' new JST.StringLiteral (assmName)))); " is 167.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,Emit,The length of the statement  "		body.Add (JST.Statement.Var (assemblyId' JST.Expression.DotCall (rootId.ToE ()' Constants.RootCreateAssembly' new JST.StringLiteral (assmName)))); " is 146.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitStart,The length of the statement  "		startStmnt = new JST.TryStatement (new JST.Statements (startStmnt)' new JST.CatchClause (exId' new JST.Statements (JST.Statement.DotCall (new JST.Identifier (Env.Root).ToE ()' Constants.RootWriteLine' new JST.BinaryExpression (new JST.StringLiteral ("UNCAUGHT EXCEPTION: ")' JST.BinaryOp.Plus' JST.Expression.DotCall (globalRootId.ToE ()' Constants.RootExceptionDescription' exId.ToE ())))))); " is 393.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitStart,The length of the statement  "		scriptBody.Add (new JST.IfStatement (JST.Expression.Dot (windowId.ToE ()' addEventListenerId)' new JST.Statements (JST.Statement.DotCall (windowId.ToE ()' addEventListenerId' new JST.StringLiteral ("load")' startId.ToE ()' new JST.BooleanLiteral (false)))' new JST.Statements (new JST.IfStatement (JST.Expression.Dot (windowId.ToE ()' attachEventId)' new JST.Statements (JST.Statement.DotCall (windowId.ToE ()' attachEventId' new JST.StringLiteral ("onload")' startId.ToE ()))' new JST.Statements (JST.Statement.DotAssignment (windowId.ToE ()' onloadId' startId.ToE ())))))); " is 575.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitManifest,The length of the statement  "		var initialName = Env.Traces.TraceMap.Where (kv => kv.Value.Flavor == TraceFlavor.Initial).Select (kv => kv.Value.Name).FirstOrDefault (); " is 138.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,InlinedMethodCache,C:\repos\Reactive-Extensions_IL2JS\Compiler\InlinedMethodCache.cs,CouldBeInlinableBasedOnHeaderAlone,The length of the statement  "	env.AttributeHelper.GetValueFromType (assemblyDef' typeDef' env.AttributeHelper.ReflectionAttributeRef' env.AttributeHelper.TheReflectionLevelProperty' true' true' ref level); " is 175.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,InlinedMethodCache,C:\repos\Reactive-Extensions_IL2JS\Compiler\InlinedMethodCache.cs,CouldBeInlinableBasedOnHeaderAlone,The length of the statement  "	if (assemblyDef.EntryPoint != null && assemblyDef.EntryPoint.QualifiedMemberName.Equals (methodDef.QualifiedMemberName (env.Global' assemblyDef' typeDef))) " is 155.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,InlinedMethodCache,C:\repos\Reactive-Extensions_IL2JS\Compiler\InlinedMethodCache.cs,PrimIsInlinable,The length of the statement  "	if (env.InteropManager.IsImported (assemblyDef' typeDef' methodDef) || env.InteropManager.IsExported (assemblyDef' typeDef' methodDef)) " is 135.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,InlinedMethodCache,C:\repos\Reactive-Extensions_IL2JS\Compiler\InlinedMethodCache.cs,PrimIsInlinable,The length of the statement  "	var overrideInline = env.AttributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' env.AttributeHelper.InlineAttributeRef' env.AttributeHelper.TheIsInlinedProperty' true' false' ref isInline); " is 203.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,InlinedMethodCache,C:\repos\Reactive-Extensions_IL2JS\Compiler\InlinedMethodCache.cs,PrimIsInlinable,The length of the statement  "	var methEnv = env.Global.Environment ().AddAssembly (assemblyDef).AddType (typeDef).AddSelfTypeBoundArguments ().AddMethod (methodDef).AddSelfMethodBoundArguments (); " is 166.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,RuntimeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\RuntimeCompiler.cs,Emit,The length of the statement  "		var simpCtxt = new JST.SimplifierContext (true' env.DebugMode' new JST.NameSupply (Constants.Globals)' null).InFreshStatements (); " is 130.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,RuntimeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\RuntimeCompiler.cs,Emit,The length of the statement  "	var mscorlibName = new JST.StringLiteral (CST.CSTWriter.WithAppend (env.Global' CST.WriterStyle.Uniform' env.Global.MsCorLibName.Append)); " is 138.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,MethodSlotName,The length of the statement  "		return new JST.BinaryExpression (new JST.StringLiteral (Constants.TypeVirtualMethodSlot (slotName) + "_")' JST.BinaryOp.Plus' JST.Expression.Dot (resolver.ResolveType (methodRef.DefiningType)' Constants.ObjectId)); " is 214.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,DefaultResolveAssembly,The length of the statement  "		var slotName = Constants.AssemblyReferenceBuilderSlot (env.GlobalMapping.ResolveAssemblyReferenceToSlot (resolver.AssmEnv.Assembly' assemblyName)); " is 147.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The length of the statement  "	if (s is CST.ObjectTypeStyle && !calleeMethEnv.Method.IsStatic && calleeMethEnv.Method.Name.Equals (".ctor"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1) { " is 172.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The length of the statement  "	else if (s is CST.NullableTypeStyle && !calleeMethEnv.Method.IsStatic && calleeMethEnv.Method.Name.Equals (".ctor"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 2) { " is 179.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The length of the statement  "		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootAssertNonNullInvalidOperation' JST.Expression.DotCall (arguments [0]' Constants.PointerRead)); " is 163.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The length of the statement  "	else if (calleeMethEnv.TypeRef.Equals (env.Global.DebuggerRef) && calleeMethEnv.Method.Name.Equals ("Break"' StringComparison.Ordinal)) { " is 137.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The length of the statement  "		return new JST.CallExpression (new JST.IndexExpression (type' MethodSlotName (resolver' calleeMethEnv.MethodRef' false))' args); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The length of the statement  "		return new JST.CallExpression (new JST.IndexExpression (target' MethodSlotName (resolver' calleeMethEnv.MethodRef' false))' args); " is 130.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructGenericEnumeratorAtDynamicType,The length of the statement  "	var genericEnumeratorType = JST.Expression.DotCall (mscorlib' new JST.Identifier (Constants.AssemblyTypeBuilderSlot (genericEnumeratorSlot))' elemTypeId.ToE ()); " is 161.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructGenericEnumeratorAtDynamicType,The length of the statement  "	var ctorRef = new CST.PolymorphicMethodRef (env.GenericEnumeratorTypeConstructorRef' ".ctor"' false' 0' new Seq<CST.TypeRef> { " is 126.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructGenericEnumeratorAtDynamicType,The length of the statement  "	var init = new JST.NewExpression (JST.Expression.DotCall (genericEnumeratorTypeId.ToE ()' Constants.TypeConstructObject)); " is 122.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructGenericEnumeratorAtStaticType,The length of the statement  "	var genericEnumeratorCall = ConstructorExpression (resolver' nameSupply' null' null' genericEnumeratorCtor' new Seq<JST.Expression> { " is 133.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructGenericEnumeratorAtStaticType,The length of the statement  "	var call = new JST.ConditionalExpression (JST.Expression.IsNull (JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootGetArrayElementType' obj))' fallback' genericEnumeratorCall); " is 188.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The length of the statement  "		if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 1 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("Invoke"' StringComparison.Ordinal)) { " is 185.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The length of the statement  "		else if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 3 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("BeginInvoke"' StringComparison.Ordinal)) { " is 195.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The length of the statement  "		else if (calleeMethEnv.Method.Arity == 2 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("EndInvoke"' StringComparison.Ordinal)) { " is 158.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The length of the statement  "	else if (calleeMethEnv.TypeRef.Equals (env.Global.ArrayRef) && calleeMethEnv.Method.Name.Equals ("GetEnumerator"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0) { " is 216.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The length of the statement  "		var fallback = new JST.ThrowStatement (JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootInvalidOperationException)); " is 129.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The length of the statement  "	else if (calleeMethEnv.TypeRef.Equals (env.Global.IEnumerableRef) && calleeMethEnv.Method.Name.Equals ("GetEnumerator"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0) { " is 222.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The length of the statement  "	else if (calleeMethEnv.TypeConstructorRef.Equals (env.Global.IEnumerableTypeConstructorRef) && calleeMethEnv.Method.Name.Equals ("GetEnumerator"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0) { " is 248.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The length of the statement  "		return ConstructGenericEnumeratorAtStaticType (resolver' nameSupply' optBody' fallback' calleeMethEnv.TypeBoundArguments [0]' target); " is 134.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ResolveStaticField,The length of the statement  "	return JST.Expression.Dot (resolver.ResolveType (fieldRef.DefiningType)' ResolveFieldToIdentifier (resolver' fieldRef' true)); " is 126.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,BoxExpressionForType,The length of the statement  "		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewPointerToValue' obj' resolver.ResolveType (typeRef' TypePhase.Id)); " is 139.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PointerToArrayElementExpression,The length of the statement  "	return JST.Expression.DotCall (resolver.RootId.ToE ()' env.CLRArraySemantics ? Constants.RootNewStrictPointerToArrayElem : Constants.RootNewFastPointerToArrayElem' array' index' resolver.ResolveType (elemTypeRef' TypePhase.Id)); " is 228.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ResolveFieldToPointerInternal,The length of the statement  "	return JST.Expression.DotCall (resolver.RootId.ToE ()' isStatic ? Constants.RootNewPointerToStaticField : Constants.RootNewPointerToObjectField' targetObject' new JST.StringLiteral (isStatic ? Constants.TypeStaticFieldSlot (slot) : Constants.ObjectInstanceFieldSlot (slot))' fieldType); " is 286.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The length of the statement  "			return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' new JST.NullExpression ()' new JST.NullExpression ()' delegateType); " is 150.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The length of the statement  "			return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' arguments [0]' arguments [1]' delegateType); " is 126.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The length of the statement  "		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewMultiDimArray' elemType' new JST.ArrayLiteral (lowers)' new JST.ArrayLiteral (sizes)); " is 158.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The length of the statement  "				body.Add (JST.Statement.DotAssignment (lvalue' Constants.ObjectPrepareForExport' JST.Expression.Dot (defType' Constants.TypeBindInstanceExports))); " is 147.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,EnsureHasId,The length of the statement  "	statements.Add (new JST.IfStatement (JST.Expression.IsNull (JST.Expression.Dot (objId.ToE ()' Constants.ObjectId))' new JST.Statements (JST.Statement.Assignment (JST.Expression.Dot (objId.ToE ()' Constants.ObjectId)' new JST.UnaryExpression (JST.Expression.Dot (resolver.RootId.ToE ()' Constants.RootNextObjectId)' JST.UnaryOp.PostIncrement))))); " is 346.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ImportExpressionForType,The length of the statement  "					return new JST.ConditionalExpression (JST.Expression.IsNull (obj)' obj' CloneExpressionForType (resolver' typeRef.Arguments [0]' obj)); " is 135.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ImportExpressionForType,The length of the statement  "					return new JST.ConditionalExpression (JST.Expression.IsNull (obj)' DefaultExpressionForType (resolver' typeRef)' CloneExpressionForType (resolver' typeRef' obj)); " is 162.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ExportExpressionForType,The length of the statement  "					return new JST.ConditionalExpression (JST.Expression.IsNull (obj)' obj' CloneExpressionForType (resolver' typeRef.Arguments [0]' obj)); " is 135.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendInvokeImportingConstructor,The length of the statement  "			env.Log (new InvalidInteropMessage (CST.MessageContextBuilders.Env (polyMethEnv)' "no importing constructor could be found to pair with this imported constructor")); " is 165.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendInvokeImportingConstructor,The length of the statement  "			env.Log (new InvalidInteropMessage (CST.MessageContextBuilders.Env (typeEnv)' "no default importing constructor could be found for this type")); " is 144.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendCallExportedMethod,The length of the statement  "		body.Add (new JST.TryStatement (new JST.Statements (tryBody)' new JST.CatchClause (exId' new JST.Statements (new JST.ThrowStatement (JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootExportException' exId.ToE ())))))); " is 230.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,IsInlinableImported,The length of the statement  "		return env.InteropManager.IsInlinable (assemblyDef' typeDef' (CST.MethodDef)memberDef' env.InteropManager.GetTypeRepresentation (assemblyDef' typeDef).State); " is 158.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,The length of the statement  "	var methCompEnv = MethodCompilerEnvironment.EnterUntranslatedMethod (env' outerNameSupply' nameSupply' rootId' assemblyId' typeDefinitionId' methEnv' parent.TypeTrace); " is 168.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,The length of the statement  "				callArgs.Add (env.JSTHelpers.ExportExpressionForType (methCompEnv' methCompEnv.Method.ValueParameters [i].Type' valueParameters [i - delta].ToE ())); " is 149.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,The length of the statement  "		var call = env.InteropManager.AppendImport (nameSupply' rootId' methEnv.Assembly' methEnv.Type' methEnv.Method' body' callArgs); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,The length of the statement  "				body.Add (JST.Statement.DotCall (rootId.ToE ()' state == InstanceState.ManagedAndJavaScript ? Constants.RootSetupManagedAndJavaScript : Constants.RootSetupJavaScriptOnly' managedObjId.ToE ())); " is 193.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,The length of the statement  "			var slotName = new JST.StringLiteral (Constants.ObjectEventSlot (env.GlobalMapping.ResolveEventDefToSlot (methCompEnv.Assembly' methCompEnv.Type' eventDef))); " is 158.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,The length of the statement  "				body.Add (new JST.ExpressionStatement (env.InteropManager.AppendImport (nameSupply' rootId' methEnv.Assembly' methEnv.Type' methEnv.Method' body' callArgs))); " is 158.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,The length of the statement  "				body.Add (new JST.ExpressionStatement (env.InteropManager.AppendImport (nameSupply' rootId' methEnv.Assembly' methEnv.Type' methEnv.Method' body' callArgs))); " is 158.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,The length of the statement  "					callArgs.Add (env.JSTHelpers.ExportExpressionForType (methCompEnv' methEnv.Method.ValueParameters [i].Type' valueParameters [i].ToE ())); " is 137.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,The length of the statement  "			var call = env.InteropManager.AppendImport (nameSupply' rootId' methEnv.Assembly' methEnv.Type' methEnv.Method' body' callArgs); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,The length of the statement  "				body.Add (new JST.ReturnStatement (env.JSTHelpers.ImportExpressionForType (methCompEnv' methCompEnv.Method.Result.Type' call))); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,ImportedMethod,The length of the statement  "		funcBody.Add (new JST.TryStatement (new JST.Statements (body)' new JST.CatchClause (exId' new JST.Statements (new JST.ThrowStatement (JST.Expression.DotCall (rootId.ToE ()' Constants.RootImportException' exId.ToE ())))))); " is 222.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,StringIsTrue,The length of the statement  "	return new JST.BinaryExpression (e' JST.BinaryOp.LogicalOR' new JST.BinaryExpression (e' JST.BinaryOp.StrictEquals' new JST.StringLiteral (""))); " is 145.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateCall,The length of the statement  "	if (s is CST.NullableTypeStyle && methodRef.Name.Equals ("get_HasValue"' StringComparison.Ordinal) && arguments [0].Flavor == CST.ExpressionFlavor.AddressOf) { " is 159.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateCall,The length of the statement  "	else if (s is CST.NullableTypeStyle && methodRef.Name.Equals ("get_Value"' StringComparison.Ordinal) && arguments [0].Flavor == CST.ExpressionFlavor.AddressOf) { " is 161.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateCall,The length of the statement  "		return JST.Expression.DotCall (rootId.ToE ()' Constants.RootAssertNonNullInvalidOperation' TranslateCellReadWrite (methCompEnv' optBody' false' ao.Cell' null)); " is 160.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The length of the statement  "		return JST.Expression.DotCall (rootId.ToE ()' Constants.RootReflectionFieldInfo' new JST.StringLiteral (slot)' fieldDefType' new JST.BooleanLiteral (fieldEnv.Field.IsStatic)' new JST.BooleanLiteral (!fieldEnv.Field.IsStatic)' new JST.StringLiteral (fieldEnv.Field.Name)' new JST.NullExpression ()' fieldType' init); " is 315.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The length of the statement  "		var slot = env.GlobalMapping.ResolveMethodDefToSlot (runtimeMethEnv.Assembly' runtimeMethEnv.Type' runtimeMethEnv.Method); " is 122.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The length of the statement  "		var paramTypes = methodDef.ValueParameters.Where ((t' i) => i > 0 || methodDef.IsStatic).Select (t => methCompEnv.ResolveType (runtimeMethEnv.SubstituteType (t.Type))).ToSeq (); " is 177.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The length of the statement  "		var result = methodDef.Result == null ? null : methCompEnv.ResolveType (runtimeMethEnv.SubstituteType (methodDef.Result.Type)); " is 127.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The length of the statement  "		return JST.Expression.DotCall (rootId.ToE ()' Constants.RootReflectionMethodInfo' new JST.StringLiteral (slot)' methodDefType' new JST.BooleanLiteral (isStatic)' new JST.BooleanLiteral (!isStatic)' new JST.StringLiteral (methodDef.Name)' new JST.NullExpression ()' new JST.BooleanLiteral (runtimeMethEnv.Method.IsVirtualOrAbstract)' new JST.ArrayLiteral (paramTypes)' new JST.BooleanLiteral (true)' result); " is 407.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The length of the statement  "		bindings.Add (Constants.CodePtrType' isVirtual ? new JST.NullExpression () : methCompEnv.ResolveType (cpe.Method.DefiningType)); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The length of the statement  "		bindings.Add (Constants.CodePtrArity' new JST.NumericLiteral (cpe.Method.ValueParameters.Count - (cpe.Method.IsStatic ? 0 : 1))); " is 129.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The length of the statement  "			env.Log (new LossOfPrecisionMessage (CST.MessageContextBuilders.Expression (messageCtxt' expr)' "unsigned arithmetic")); " is 120.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The length of the statement  "			env.Log (new LossOfPrecisionMessage (CST.MessageContextBuilders.Expression (messageCtxt' expr)' "unsigned arithmetic")); " is 120.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The length of the statement  "			return TranslateCellReadWrite (methCompEnv' optBody' ignoreResult' aoe.Cell' lvalue => TranslateExpression (methCompEnv' optBody' lvalue' false' we.Value)); " is 156.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateExpression,The length of the statement  "		var call = env.InteropManager.AppendImport (nameSupply' rootId' calleeMemEnv.Assembly' calleeMemEnv.Type' calleeMemEnv.Method' localBody' args); " is 144.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,HandlerLiteral,The length of the statement  "		}' new JST.Statements (new JST.IfStatement (match' new JST.Statements (JST.Statement.Assignment (catchh.ExceptionId.ToE ()' exid.ToE ())' new JST.ReturnStatement (new JST.BooleanLiteral (true)))' new JST.Statements (new JST.ReturnStatement (new JST.BooleanLiteral (false)))))); " is 277.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateStatement,The length of the statement  "		var els = ites.Else == null ? default(JST.Statements) : new JST.Statements (TranslateStatements (methCompEnv' ites.Else)); " is 122.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateStatement,The length of the statement  "				cases.Add (new JST.CaseClause (new JST.NumericLiteral (ssc.Values [ssc.Values.Count - 1])' new JST.Statements (caseBody))); " is 123.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateStatement,The length of the statement  "			var exp = TranslateCellReadWrite (methCompEnv' body' true' aoe.Cell' lvalue => env.JSTHelpers.DefaultExpressionForType (methCompEnv' ptrType.Arguments [0])); " is 157.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateStatement,The length of the statement  "				var thisTest = JST.Expression.IsNotNull (JST.Expression.DotCall (rootId.ToE ()' Constants.RootIsInst' exceptionId.ToE ()' type)); " is 129.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateStatement,The length of the statement  "					catchIf = new JST.IfStatement (catchTests [i]' new JST.Statements (catchBodies [i])' new JST.Statements (new JST.ThrowStatement (exceptionId.ToE ()))); " is 151.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateStatement,The length of the statement  "		body.Add (JST.Statement.Call (JST.Expression.Dot (pts.StateId.ToE ()' Constants.StateTryStack' Constants.push)' new JST.ObjectLiteral (new OrdMap<JST.Identifier' JST.Expression> { " is 179.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateStatement,The length of the statement  "		body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootLeaveTryCatch' ls.StateId.ToE ()' new JST.NumericLiteral (ls.PopCount)' new JST.NumericLiteral (ls.TargetId))); " is 173.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,NormalMethod,The length of the statement  "	var methCompEnv = MethodCompilerEnvironment.EnterMethod (env' outerNameSupply' nameSupply' rootId' assemblyId' typeDefinitionId' cstmethod.CompEnv' parent.TypeTrace); " is 166.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,WithLineCounts,The length of the statement  "				finallyClause = new JST.FinallyClause (trys.Finally.Loc' WithLineCounts (trys.Finally.Body' nextLine' currDepth + 1' lineCountIds)); " is 132.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,WithLineCounts,The length of the statement  "	return statement.CloneWithSubStatementss (statement.SubStatementss.Select (ss => WithLineCounts (ss' nextLine' currDepth' lineCountIds)).ToSeq ()); " is 147.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,MethodImpl,The length of the statement  "		funcBody.Add (new JST.TryStatement (new JST.Statements (debugBody)' new JST.CatchClause (exId' new JST.Statements (JST.Statement.DotCall (rootId.ToE ()' Constants.RootDebugger' exId.ToE ())' new JST.ThrowStatement (exId.ToE ()))))); " is 232.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,Emit,The length of the statement  "	if (env.BreakOnBreak && env.AttributeHelper.MethodHasAttribute (methEnv.Assembly' methEnv.Type' methEnv.Method' env.AttributeHelper.BreakAttributeRef' false' false)) " is 165.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,Emit,The length of the statement  "		methodLoader.Add (JST.Statement.DotCall (new JST.Identifier (env.Root).ToE ()' Constants.RootBindMethod' new JST.StringLiteral (assmName)' new JST.StringLiteral (typeSlot)' new JST.BooleanLiteral (env.InteropManager.IsStatic (methEnv.Assembly' methEnv.Type' methEnv.Method))' new JST.StringLiteral (methodSlot)' func)); " is 319.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,Emit,The length of the statement  "		var methodFileName = Path.Combine (env.OutputDirectory' Path.Combine (JST.Lexemes.StringToFileName (assmName)' Path.Combine (typeSlot' Path.Combine (methodSlot' Constants.MethodFileName)))); " is 190.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,MkRef,The length of the statement  "	return new CST.NamedTypeRef (new CST.QualifiedTypeName (env.Global.MsCorLibName' CST.TypeName.FromReflectionName (name))); " is 122.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParseScript,The length of the statement  "					env.Log (new InvalidInteropMessage (new MessageContext (ctxt' currIndex.Right.Loc' null)' "Expecting identifier' string or number")); " is 133.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParseScript,The length of the statement  "					env.Log (new InvalidInteropMessage (new MessageContext (ctxt' curr.Loc' null)' "Expecting identifier' string or number")); " is 122.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParseScript,The length of the statement  "		env.Log (new InvalidInteropMessage (new MessageContext (ctxt' e.Loc' null)' "syntax error in " + e.Context + ": " + e.Details)); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValue,The length of the statement  "						env.Log (new InvalidInteropMessage (CST.MessageContextBuilders.AttributeProperty (ctxt' env.Global' attribute' property.Name)' "duplicate inconsistent bindings")); " is 163.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromAssembly,The length of the statement  "	if (GetValue (CST.MessageContextBuilders.Assembly (env.Global' assemblyDef)' assemblyDef.CustomAttributes' attrType' property' ref value)) " is 138.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromType,The length of the statement  "	if (GetValue (CST.MessageContextBuilders.Type (env.Global' assemblyDef' typeDef)' typeDef.CustomAttributes' attrType' property' ref value)) " is 139.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromField,The length of the statement  "	if (GetValue (CST.MessageContextBuilders.Member (env.Global' assemblyDef' typeDef' fieldDef)' fieldDef.CustomAttributes' attrType' property' ref value)) " is 152.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromProperty,The length of the statement  "	if (GetValue (CST.MessageContextBuilders.Member (env.Global' assemblyDef' typeDef' propDef)' propDef.CustomAttributes' attrType' property' ref value)) " is 150.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromEvent,The length of the statement  "	if (GetValue (CST.MessageContextBuilders.Member (env.Global' assemblyDef' typeDef' eventDef)' eventDef.CustomAttributes' attrType' property' ref value)) " is 152.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromMethod,The length of the statement  "	if (GetValue (CST.MessageContextBuilders.Member (env.Global' assemblyDef' typeDef' methodDef)' methodDef.CustomAttributes' attrType' property' ref value)) " is 154.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromMethod,The length of the statement  "				return GetValueFromEvent<T> (assemblyDef' typeDef' (CST.EventDef)outerDef' attrType' property' true' inheritSupertypes' ref value); " is 131.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromMethod,The length of the statement  "				return GetValueFromProperty<T> (assemblyDef' typeDef' (CST.PropertyDef)outerDef' attrType' property' true' inheritSupertypes' ref value); " is 137.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromParameter,The length of the statement  "		if (GetValue (CST.MessageContextBuilders.ArgOrLocal (CST.MessageContextBuilders.Member (env.Global' assemblyDef' typeDef' methodDef)' CST.ArgLocal.Arg' idx)' methodDef.ValueParameters [idx].CustomAttributes' attrType' property' ref value)) " is 239.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,GetValueFromResult,The length of the statement  "		if (GetValue (CST.MessageContextBuilders.Result (CST.MessageContextBuilders.Member (env.Global' assemblyDef' typeDef' methodDef))' methodDef.Result.CustomAttributes' attrType' property' ref value)) " is 197.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,EnterUntranslatedMethod,The length of the statement  "	return EnterMethod (env' outerNameSupply' nameSupply' rootId' assemblyId' typeDefinitonId' methEnv.AddVariables (nameSupply' i => false)' typeTrace); " is 149.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,EnterMethod,The length of the statement  "	var res = new MethodCompilerEnvironment (compEnv.Global' compEnv.SkolemDefs' compEnv.Assembly' compEnv.Type' compEnv.TypeBoundArguments' compEnv.Method' compEnv.MethodBoundArguments' compEnv.Variables' compEnv.ValueParameterIds' compEnv.LocalIds' env' nameSupply' rootId' assemblyId' typeDefinitonId' methodId' typeBoundTypeParameterIds' methodBoundTypeParameterIds' typeTrace); " is 378.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,EnterBlock,The length of the statement  "	var res = new MethodCompilerEnvironment (Global' SkolemDefs' Assembly' Type' TypeBoundArguments' Method' MethodBoundArguments' Variables' ValueParameterIds' LocalIds' Env' NameSupply' rootId' assemblyId' typeDefinitionId' MethodId' TypeBoundTypeParameterIds' MethodBoundTypeParameterIds' typeTrace); " is 299.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,BindUsage,The length of the statement  "	BindMap (statements' usage.Assemblies' boundAssemblies' n => n.ToString ()' n => env.JSTHelpers.DefaultResolveAssembly (this' n)); " is 130.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,BindUsage,The length of the statement  "	BindMap (statements' usage.Types' boundTypes' t => t.ToString ()' t => env.JSTHelpers.DefaultResolveType (this' t' TypePhase.Constructed)); " is 139.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,BindUsage,The length of the statement  "	BindMap (statements' usage.VariablePointers' boundVariablePointers' id => String.Format ("Pointer to {0}"' id.Value)' VariablePointerExpression); " is 145.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompilerEnvironment.cs,MethodCallExpression,The length of the statement  "		var args = TypeBoundTypeParameterIds.Select (id => id.ToE ()).Concat (MethodBoundTypeParameterIds.Select (id => id.ToE ())).Concat (arguments).ToSeq (); " is 152.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,Program,C:\repos\Reactive-Extensions_IL2JS\Compiler\Program.cs,Main,The length of the statement  "		if (env.CompilationMode == CompilationMode.Traced && env.TraceFileNames.Count == 0 && string.IsNullOrEmpty (env.FinalTraceName)) { " is 130.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,Program,C:\repos\Reactive-Extensions_IL2JS\Compiler\Program.cs,Main,The length of the statement  "			env.Log (new UsageMessage ("'-mode traced' must be accompanied by at least on of '-trace' or '-finalTraceName' options.")); " is 123.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TraceCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TraceCompiler.cs,Emit,The length of the statement  "		var program = new JST.Program (new JST.Statements (new JST.ExpressionStatement (new JST.StatementsPseudoExpression (new JST.Statements (body)' null)))); " is 152.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitVirtualAndInterfaceMethodRedirectors,The length of the statement  "			var virtSlotName = Env.GlobalMapping.ResolveMethodDefToSlot (virtPolyMethEnv.Assembly' virtPolyMethEnv.Type' virtPolyMethEnv.Method); " is 133.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitVirtualAndInterfaceMethodRedirectors,The length of the statement  "			var implSlotName = Env.GlobalMapping.ResolveMethodDefToSlot (implPolyMethEnv.Assembly' implPolyMethEnv.Type' implPolyMethEnv.Method); " is 133.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitVirtualAndInterfaceMethodRedirectors,The length of the statement  "					body.Add (JST.Statement.DotCall (RootId.ToE ()' Constants.RootBindInterfaceMethodToVirtual' lhs' ifaceType' new JST.StringLiteral (virtSlotName)' new JST.StringLiteral (implSlotName)' new JST.NumericLiteral (methTypeAndArgArity))); " is 231.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitVirtualAndInterfaceMethodRedirectors,The length of the statement  "					body.Add (JST.Statement.DotCall (RootId.ToE ()' Constants.RootBindInterfaceMethodToNonVirtual' lhs' ifaceType' new JST.StringLiteral (virtSlotName)' TypeCompEnv.ResolveType (implMethodRef.DefiningType' TypePhase.Slots)' new JST.StringLiteral (implSlotName)' new JST.NumericLiteral (methTypeAndArgArity))); " is 305.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitVirtualAndInterfaceMethodRedirectors,The length of the statement  "					body.Add (JST.Statement.DotCall (RootId.ToE ()' Constants.RootBindVirtualMethod' lhs' TypeCompEnv.ResolveType (implMethodRef.DefiningType' TypePhase.Slots)' new JST.StringLiteral (virtSlotName)' new JST.StringLiteral (implSlotName)' new JST.NumericLiteral (methTypeAndArgArity))); " is 280.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitBaseAndSupertypes,The length of the statement  "		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeBaseType' Env.JSTHelpers.DefaultResolveType (TypeCompEnv' TypeCompEnv.Type.Extends' TypePhase.Slots))); " is 161.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitBaseAndSupertypes,The length of the statement  "	body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeSupertypes' JST.Expression.DotCall (RootId.ToE ()' Constants.RootBuildSupertypesMap' buildSupertypesArgs))); " is 166.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitSetupType,The length of the statement  "		if (TypeCompEnv.Type.Style is CST.EnumTypeStyle || fieldDef.Init == null || fieldDef.Init.Flavor != CST.FieldInitFlavor.Const) { " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitSetupType,The length of the statement  "			innerBody.Add (JST.Statement.DotAssignment (TypeId.ToE ()' Env.JSTHelpers.ResolveFieldToIdentifier (innerTypeCompEnv' fieldRef' true)' Env.JSTHelpers.DefaultFieldValue (innerTypeCompEnv' fieldRef))); " is 199.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitSetupType,The length of the statement  "		innerBody.Add (new JST.ExpressionStatement (innerTypeCompEnv.MethodCallExpression (Parent.StaticInitializer' innerTypeCompEnv.NameSupply' false' JST.Constants.EmptyExpressions))); " is 179.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitSetupType,The length of the statement  "	body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeSetupType' new JST.FunctionExpression (null' new JST.Statements (innerBody)))); " is 137.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitDefaultConstructor,The length of the statement  "		var ctor = Env.JSTHelpers.ConstructorExpression (TypeCompEnv' innerNameSupply' innerBody' null' Parent.DefaultConstructor' JST.Constants.EmptyExpressions); " is 155.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitDefaultConstructor,The length of the statement  "		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeDefaultConstructor' new JST.FunctionExpression (null' new JST.Statements (innerBody)))); " is 146.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,AccumInstanceFields,The length of the statement  "	foreach (var fieldDef in thisTypeEnv.Type.Members.OfType<CST.FieldDef> ().Where (f => f.Invalid == null && f.IsUsed && !f.IsStatic)) " is 132.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,The length of the statement  "				innerBody.Add (JST.Statement.DotAssignment (newObj' fieldId' Env.JSTHelpers.CloneExpressionForType (innerTypeCompEnv' fieldRef.ExternalFieldType' JST.Expression.Dot (oldObj' fieldId)))); " is 186.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,The length of the statement  "			body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeMemberwiseClone' new JST.FunctionExpression (parameters' new JST.Statements (innerBody)))); " is 149.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,The length of the statement  "			innerBody.Add (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidOperationException))); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,The length of the statement  "			innerBody.Add (JST.Statement.Var (newObjId' new JST.NewExpression (new JST.CallExpression (Constants.Array.ToE ()' JST.Expression.Dot (oldObj' Constants.length))))); " is 165.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,The length of the statement  "			var loopClause = new JST.ForVarLoopClause (iId' new JST.BinaryExpression (iId.ToE ()' JST.BinaryOp.LessThan' JST.Expression.Dot (oldObj' Constants.length))' new JST.UnaryExpression (iId.ToE ()' JST.UnaryOp.PostIncrement)); " is 222.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,The length of the statement  "			var loopBody = JST.Statement.IndexAssignment (newObjId.ToE ()' iId.ToE ()' Env.JSTHelpers.CloneExpressionForType (TypeCompEnv' TypeCompEnv.TypeBoundArguments [0]' new JST.IndexExpression (oldObj' iId.ToE ()))); " is 210.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,The length of the statement  "			innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (oldObj)' new JST.Statements (new JST.ReturnStatement (new JST.NullExpression ()))' new JST.Statements (new JST.ReturnStatement (Env.JSTHelpers.CloneExpressionForType (TypeCompEnv' TypeCompEnv.TypeBoundArguments [0]' oldObj))))); " is 287.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,The length of the statement  "		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeMemberwiseClone' new JST.FunctionExpression (parameters' new JST.Statements (innerBody)))); " is 149.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitClone,The length of the statement  "		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeClone' JST.Expression.Dot (lhs' Constants.TypeMemberwiseClone))); " is 123.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitDefaultValue,The length of the statement  "		innerBody.Add (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidOperationException))); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitDefaultValue,The length of the statement  "			bindings.Add (Env.JSTHelpers.ResolveFieldToIdentifier (innerTypeCompEnv' fieldRef' false)' Env.JSTHelpers.DefaultFieldValue (innerTypeCompEnv' fieldRef)); " is 154.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitDefaultValue,The length of the statement  "		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeDefaultValue' new JST.FunctionExpression (null' new JST.Statements (innerBody)))); " is 140.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,ConstructObjectFunction,The length of the statement  "				ifBody.Add (JST.Statement.DotAssignment (inst' Env.JSTHelpers.ResolveFieldToIdentifier (innerTypeCompEnv' fieldRef' false)' Env.JSTHelpers.DefaultFieldValue (innerTypeCompEnv' fieldRef))); " is 188.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitConstructObjectAndInstanceMethods,The length of the statement  "	else if (s is CST.InterfaceTypeStyle || s is CST.VoidTypeStyle || (TypeCompEnv.Type.IsAbstract && TypeCompEnv.Type.IsSealed)) { " is 127.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitConstructObjectAndInstanceMethods,The length of the statement  "		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeConstructObject' new JST.FunctionExpression (null' new JST.Statements (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidOperationException)))))); " is 238.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitConstructObjectAndInstanceMethods,The length of the statement  "			body.Add (JST.Statement.DotCall (RootId.ToE ()' Constants.RootInheritPrototypeProperties' JST.Expression.Dot (ctor' Constants.prototype)' JST.Expression.Dot (baseCtor' Constants.prototype))); " is 191.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitConstructObjectAndInstanceMethods,The length of the statement  "			var newProto = new JST.NewExpression (new JST.CallExpression (JST.Expression.Dot (lhs' Constants.TypeBaseType' Constants.TypeConstructObject)' new JST.BooleanLiteral (true))); " is 175.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitUnbox,The length of the statement  "			innerBody.Add (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidOperationException))); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitUnbox,The length of the statement  "			innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootNewPointerToValue' new JST.NullExpression ()' lhs))))); " is 218.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitUnbox,The length of the statement  "			innerBody.Add (new JST.IfStatement (new JST.BinaryExpression (JST.Expression.Dot (obj' Constants.ObjectType)' JST.BinaryOp.StrictNotEquals' TypeCompEnv.ResolveType (TypeCompEnv.TypeBoundArguments [0]' TypePhase.Id))' new JST.Statements (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidCastException))))); " is 340.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitUnbox,The length of the statement  "			innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootNullReferenceException))))); " is 190.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitUnbox,The length of the statement  "			innerBody.Add (new JST.IfStatement (new JST.BinaryExpression (JST.Expression.Dot (obj' Constants.ObjectType)' JST.BinaryOp.StrictNotEquals' lhs)' new JST.Statements (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidCastException))))); " is 269.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitUnbox,The length of the statement  "		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeUnbox' new JST.FunctionExpression (parameters' new JST.Statements (innerBody)))); " is 139.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitBox,The length of the statement  "			innerBody.Add (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidOperationException))); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitBox,The length of the statement  "			innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NullExpression ())))); " is 140.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitBox,The length of the statement  "			innerBody.Add (new JST.ReturnStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootNewPointerToValue' obj' TypeCompEnv.ResolveType (TypeCompEnv.TypeBoundArguments [0]' TypePhase.Id)))); " is 195.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitBox,The length of the statement  "			innerBody.Add (new JST.ReturnStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootNewPointerToValue' obj' lhs))); " is 124.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitBox,The length of the statement  "		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeBox' new JST.FunctionExpression (parameters' new JST.Statements (innerBody)))); " is 137.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitUnboxAny,The length of the statement  "			innerBody.Add (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidOperationException))); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitUnboxAny,The length of the statement  "			innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NullExpression ())))); " is 140.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitUnboxAny,The length of the statement  "			innerBody.Add (new JST.IfStatement (new JST.BinaryExpression (JST.Expression.Dot (obj' Constants.ObjectType)' JST.BinaryOp.StrictNotEquals' TypeCompEnv.ResolveType (TypeCompEnv.TypeBoundArguments [0]' TypePhase.Id))' new JST.Statements (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidCastException))))); " is 340.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitUnboxAny,The length of the statement  "			innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootNullReferenceException))))); " is 190.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitUnboxAny,The length of the statement  "			innerBody.Add (new JST.IfStatement (new JST.BinaryExpression (JST.Expression.Dot (obj' Constants.ObjectType)' JST.BinaryOp.StrictNotEquals' lhs)' new JST.Statements (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidCastException))))); " is 269.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitUnboxAny,The length of the statement  "		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeUnboxAny' new JST.FunctionExpression (parameters' new JST.Statements (innerBody)))); " is 142.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitConditionalDeref,The length of the statement  "			innerBody.Add (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidOperationException))); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitConditionalDeref,The length of the statement  "		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeConditionalDeref' new JST.FunctionExpression (parameters' new JST.Statements (innerBody)))); " is 150.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitEquals,The length of the statement  "		innerBody.Add (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidOperationException))); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitEquals,The length of the statement  "		innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (left)' new JST.Statements (new JST.ReturnStatement (JST.Expression.IsNull (right))))); " is 145.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitEquals,The length of the statement  "		innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (right)' new JST.Statements (new JST.ReturnStatement (new JST.BooleanLiteral (false))))); " is 147.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitEquals,The length of the statement  "		innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (left)' new JST.Statements (new JST.ReturnStatement (JST.Expression.IsNull (right))))); " is 145.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitEquals,The length of the statement  "		innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (right)' new JST.Statements (new JST.ReturnStatement (new JST.BooleanLiteral (false))))); " is 147.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitEquals,The length of the statement  "		innerBody.Add (new JST.ReturnStatement (JST.Expression.DotCall (TypeCompEnv.ResolveType (TypeCompEnv.TypeBoundArguments [0]' TypePhase.Slots)' Constants.TypeEquals' left' right))); " is 180.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitEquals,The length of the statement  "			var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression (TypeCompEnv' innerNameSupply' innerBody' equalsRef' new Seq<JST.Expression> { " is 139.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitEquals,The length of the statement  "				innerBody.Add (new JST.IfStatement (JST.Expression.Not (JST.Expression.DotCall (TypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Slots)' Constants.TypeEquals' leftField' rightField))' new JST.Statements (new JST.ReturnStatement (new JST.BooleanLiteral (false))))); " is 270.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitEquals,The length of the statement  "		innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (left)' new JST.Statements (new JST.ReturnStatement (JST.Expression.IsNull (right))))); " is 145.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitEquals,The length of the statement  "		innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (right)' new JST.Statements (new JST.ReturnStatement (new JST.BooleanLiteral (false))))); " is 147.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitEquals,The length of the statement  "		var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression (TypeCompEnv' innerNameSupply' innerBody' equalsRef' new Seq<JST.Expression> { " is 139.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitEquals,The length of the statement  "	body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeEquals' new JST.FunctionExpression (parameters' new JST.Statements (innerBody)))); " is 140.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The length of the statement  "		innerBody.Add (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidOperationException))); " is 121.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The length of the statement  "		innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0))))); " is 141.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The length of the statement  "		innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (objid)' new JST.Statements (JST.Statement.Assignment (objid' new JST.UnaryExpression (JST.Expression.Dot (RootId.ToE ()' Constants.RootNextObjectId)' JST.UnaryOp.PostIncrement))))); " is 240.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The length of the statement  "		innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0))))); " is 141.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The length of the statement  "		innerBody.Add (new JST.ReturnStatement (JST.Expression.DotCall (TypeCompEnv.ResolveType (TypeCompEnv.TypeBoundArguments [0]' TypePhase.Slots)' Constants.TypeHash' obj))); " is 170.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The length of the statement  "			innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28))))); " is 279.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The length of the statement  "			innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (hash' JST.BinaryOp.BitwiseXOR' JST.Expression.DotCall (TypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Slots)' Constants.TypeHash' field)))); " is 221.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The length of the statement  "		innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0))))); " is 141.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The length of the statement  "		var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression (TypeCompEnv' innerNameSupply' innerBody' getHashCodeRef' new Seq<JST.Expression> { " is 144.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The length of the statement  "	body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeHash' new JST.FunctionExpression (parameters' new JST.Statements (innerBody)))); " is 138.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitDefaultImportingConstructor,The length of the statement  "	Env.JSTHelpers.AppendInvokeImportingConstructor (innerTypeCompEnv' innerTypeCompEnv.NameSupply' ctorParameters' innerBody' parameters [1]); " is 139.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitDefaultImportingConstructor,The length of the statement  "	body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeImportingConstructor' new JST.FunctionExpression (parameters' new JST.Statements (innerBody)))); " is 154.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitBindInstanceExports,The length of the statement  "			innerBody.Add (JST.Statement.DotCall (innerTypeCompEnv.ResolveType (TypeCompEnv.Type.Extends' TypePhase.Slots)' Constants.TypeBindInstanceExports' parameters [0].ToE ())); " is 171.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitBindInstanceExports,The length of the statement  "			Env.InteropManager.AppendExport (innerTypeCompEnv.NameSupply' RootId' TypeCompEnv.Assembly' TypeCompEnv.Type' methodDef' parameters [0].ToE ()' innerBody' (ns' asm' typ' mem' b' a) => Env.JSTHelpers.AppendCallExportedMethod (innerTypeCompEnv' ns' asm' typ' mem' b' a)); " is 269.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitIsValidJavaScriptType,The length of the statement  "	if (s is CST.StringTypeStyle || s is CST.NumberTypeStyle || s is CST.EnumTypeStyle || TypeCompEnv.TypeRef.Equals (Env.Global.DecimalRef)) { " is 139.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitIsValidJavaScriptType,The length of the statement  "			innerBody.Add (new JST.ReturnStatement (new JST.BinaryExpression (obj' JST.BinaryOp.Equals' new JST.StringLiteral ("string")))); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitIsValidJavaScriptType,The length of the statement  "			innerBody.Add (new JST.ReturnStatement (JST.Expression.Or (new JST.BinaryExpression (obj' JST.BinaryOp.Equals' new JST.StringLiteral ("number"))' new JST.BinaryExpression (obj' JST.BinaryOp.Equals' new JST.StringLiteral ("boolean"))))); " is 236.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitIsValidJavaScriptType,The length of the statement  "			innerBody.Add (new JST.ReturnStatement (new JST.BinaryExpression (obj' JST.BinaryOp.Equals' new JST.StringLiteral ("number")))); " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitIsValidJavaScriptType,The length of the statement  "		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeIsValidJavaScriptType' new JST.FunctionExpression (parameters' new JST.Statements (innerBody)))); " is 155.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,DelegateImporterExporter,The length of the statement  "	body.Add (new JST.ReturnStatement (JST.Expression.DotCall (RootId.ToE ()' func' TypeId.ToE ()' new JST.ArrayLiteral (delTypeDef.ValueParameters.Select (p => innerTypeCompEnv.ResolveType (p.Type' TypePhase.Constructed)).ToSeq ())' delTypeDef.Result == null ? new JST.NullExpression () : innerTypeCompEnv.ResolveType (delTypeDef.Result.Type' TypePhase.Constructed)' new JST.BooleanLiteral (delInfo.IsCaptureThis)' new JST.BooleanLiteral (delInfo.IsInlineParamsArray)' parameters [0].ToE ()))); " is 491.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The length of the statement  "		Env.Log (new UnimplementableFeatureMessage (ctxt' "custom attribute"' String.Format ("Type '{0}' is not marked as [Used] or is invalid"' attr.Type))); " is 150.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The length of the statement  "	var ctorDef = attrTypeEnv.Type.Members.OfType<CST.MethodDef> ().Where (m => m.Invalid == null && m.IsUsed && m.IsConstructor && !m.IsStatic && m.Arity == attr.PositionalProperties.Count + 1).FirstOrDefault (); " is 209.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The length of the statement  "		Env.Log (new UnimplementableFeatureMessage (ctxt' "custom attribute"' String.Format ("Type '{0}' does not have a constructor for {1} positional parameters"' attr.Type' attr.PositionalProperties.Count))); " is 203.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The length of the statement  "		foreach (var memberDef in attrTypeEnv.Type.Members.Where (m => !m.IsStatic && m.Name.Equals (kv.Key' StringComparison.Ordinal))) { " is 130.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The length of the statement  "						if (setMethodDef != null && setMethodDef.Invalid == null && setMethodDef.IsUsed && setMethodDef.Arity == 2 && !Env.InlinedMethods.IsInlinable (innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' setMethodDef)) { " is 209.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The length of the statement  "							stmnt = new JST.ExpressionStatement (innerTypeCompEnv.MethodCallExpression (setMethodRef' innerTypeCompEnv.NameSupply' false' new Seq<JST.Expression> (id.ToE ()' e))); " is 167.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The length of the statement  "			Env.Log (new UnimplementableFeatureMessage (ctxt' "custom attribute"' String.Format ("Type '{0}' does not have a field or set-able property for named parameter '{1}'"' kv.Key))); " is 178.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,MethodInfoFromMethod,The length of the statement  "	if (methodDef.Invalid != null || !methodDef.IsUsed || Env.InlinedMethods.IsInlinable (innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' methodDef)) " is 147.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,MethodInfoFromMethod,The length of the statement  "	var attrs = CustomAttributesExpression (body' innerTypeCompEnv' CST.MessageContextBuilders.Member (Env.Global' innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' methodDef)' methodDef.CustomAttributes); " is 201.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,MethodInfoFromMethod,The length of the statement  "	var paramTypes = new JST.ArrayLiteral (methodDef.ValueParameters.Skip (methodDef.IsStatic ? 0 : 1).Select (p => innerTypeCompEnv.ResolveType (p.Type' TypePhase.Constructed)).ToSeq ()); " is 184.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,MethodInfoFromMethod,The length of the statement  "		return JST.Expression.DotCall (RootId.ToE ()' Constants.RootReflectionConstructorInfo' new JST.StringLiteral (slot)' TypeId.ToE ()' new JST.BooleanLiteral (!methodDef.IsStatic)' attrs' paramTypes); " is 197.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,MethodInfoFromMethod,The length of the statement  "		return JST.Expression.DotCall (RootId.ToE ()' Constants.RootReflectionMethodInfo' new JST.StringLiteral (slot)' TypeId.ToE ()' new JST.BooleanLiteral (methodDef.IsStatic)' new JST.BooleanLiteral (!methodDef.IsStatic)' new JST.StringLiteral (methodDef.Name)' attrs' new JST.BooleanLiteral (methodDef.IsVirtualOrAbstract)' paramTypes' new JST.BooleanLiteral (true)' methodDef.Result == null ? (JST.Expression)new JST.NullExpression () : innerTypeCompEnv.ResolveType (methodDef.Result.Type' TypePhase.Constructed)); " is 512.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,FieldInfoFromField,The length of the statement  "	if (Env.AttributeHelper.FieldHasAttribute (innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' fieldDef' Env.Global.CompilerGeneratedAttributeRef' false' false)) " is 159.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,FieldInfoFromField,The length of the statement  "	return JST.Expression.DotCall (RootId.ToE ()' Constants.RootReflectionFieldInfo' new JST.StringLiteral (slot)' TypeId.ToE ()' new JST.BooleanLiteral (fieldDef.IsStatic)' new JST.BooleanLiteral (!fieldDef.IsStatic)' new JST.StringLiteral (fieldDef.Name)' CustomAttributesExpression (body' innerTypeCompEnv' CST.MessageContextBuilders.Member (Env.Global' innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' fieldDef)' fieldDef.CustomAttributes)' innerTypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Constructed)' new JST.NullExpression ()); " is 543.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,PropertyInfoFromProperty,The length of the statement  "	return JST.Expression.DotCall (RootId.ToE ()' Constants.RootReflectionPropertyInfo' slotExp' TypeId.ToE ()' new JST.BooleanLiteral (propDef.IsStatic)' new JST.BooleanLiteral (!propDef.IsStatic)' new JST.StringLiteral (propDef.Name)' CustomAttributesExpression (body' innerTypeCompEnv' CST.MessageContextBuilders.Member (Env.Global' innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' propDef)' propDef.CustomAttributes)' innerTypeCompEnv.ResolveType (propDef.FieldType' TypePhase.Constructed)' propDef.Get == null || !sharedMethodInfos.ContainsKey (propDef.Get) ? (JST.Expression)new JST.NullExpression () : sharedMethodInfos [propDef.Get].ToE ()' propDef.Set == null || !sharedMethodInfos.ContainsKey (propDef.Set) ? (JST.Expression)new JST.NullExpression () : sharedMethodInfos [propDef.Set].ToE ()); " is 800.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EventInfoFromEvent,The length of the statement  "	return JST.Expression.DotCall (RootId.ToE ()' Constants.RootReflectionEventInfo' slotExp' TypeId.ToE ()' new JST.BooleanLiteral (eventDef.IsStatic)' new JST.BooleanLiteral (!eventDef.IsStatic)' new JST.StringLiteral (eventDef.Name)' CustomAttributesExpression (body' innerTypeCompEnv' CST.MessageContextBuilders.Member (Env.Global' innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' eventDef)' eventDef.CustomAttributes)' innerTypeCompEnv.ResolveType (eventDef.HandlerType' TypePhase.Constructed)' eventDef.Add == null || !sharedMethodInfos.ContainsKey (eventDef.Add) ? (JST.Expression)new JST.NullExpression () : sharedMethodInfos [eventDef.Add].ToE ()' eventDef.Remove == null || !sharedMethodInfos.ContainsKey (eventDef.Remove) ? (JST.Expression)new JST.NullExpression () : sharedMethodInfos [eventDef.Remove].ToE ()); " is 820.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,ReflectionNameExpression,The length of the statement  "	var nm = CST.CSTWriter.WithAppend (Env.Global' isFullName ? CST.WriterStyle.ReflectionFullName : CST.WriterStyle.ReflectionName' innerTypeCompEnv.Type.EffectiveName (Env.Global).Append); " is 186.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,ReflectionNameExpression,The length of the statement  "		return JST.Expression.DotCall (RootId.ToE ()' Constants.RootReflectionName' lit' new JST.ArrayLiteral (innerTypeCompEnv.TypeBoundArguments.Select (t => innerTypeCompEnv.ResolveType (t' TypePhase.Id)).ToSeq ())' new JST.BooleanLiteral (isFullName)); " is 248.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,ReflectionNamespaceExpression,The length of the statement  "	var lit = nm.Namespace.Length == 0 ? (JST.Expression)new JST.NullExpression () : (JST.Expression)new JST.StringLiteral (nm.Namespace); " is 134.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,ReflectionNamespaceExpression,The length of the statement  "		return JST.Expression.DotCall (RootId.ToE ()' Constants.RootReflectionNamespace' lit' new JST.ArrayLiteral (innerTypeCompEnv.TypeBoundArguments.Select (t => innerTypeCompEnv.ResolveType (t' TypePhase.Id)).ToSeq ())); " is 216.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitReflection,The length of the statement  "	Env.AttributeHelper.GetValueFromType (innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' Env.AttributeHelper.ReflectionAttributeRef' Env.AttributeHelper.TheReflectionLevelProperty' true' true' ref level); " is 203.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitReflection,The length of the statement  "		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeReflectionName' ReflectionNameExpression (body' innerTypeCompEnv' false))); " is 133.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitReflection,The length of the statement  "		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeReflectionFullName' ReflectionNameExpression (body' innerTypeCompEnv' true))); " is 136.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitReflection,The length of the statement  "		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeReflectionNamespace' ReflectionNamespaceExpression (body' innerTypeCompEnv))); " is 136.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitReflection,The length of the statement  "			body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeReflectionMemberInfos' MemberInfoExpression (body' innerTypeCompEnv))); " is 129.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitReflection,The length of the statement  "			body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeReflectionCustomAttributes' CustomAttributesExpression (body' innerTypeCompEnv' CST.MessageContextBuilders.Env (TypeCompEnv)' TypeCompEnv.Type.CustomAttributes))); " is 221.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,Emit,The length of the statement  "			localBody.Add (JST.Statement.Var (TypeCompEnv.TypeBoundTypeParameterIds [i]' new JST.IndexExpression (JST.Expression.Dot (TypeId.ToE ()' Constants.TypeArguments)' i))); " is 168.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,Emit,The length of the statement  "		body.Add (JST.Statement.DotAssignment (TypeDefinitionId.ToE ()' Constants.TypeSetupInstance' new JST.FunctionExpression (parameters' new JST.Statements (localBody)))); " is 167.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompilerEnvironment.cs,EnterType,The length of the statement  "	var res = new TypeCompilerEnvironment (typeEnv.Global' typeEnv.SkolemDefs' typeEnv.Assembly' typeEnv.Type' typeEnv.TypeBoundArguments' env' nameSupply' rootId' assemblyId' typeId' typeBoundTypeParameterIds' typeTrace); " is 218.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompilerEnvironment.cs,EnterFunction,The length of the statement  "	var res = new TypeCompilerEnvironment (Global' SkolemDefs' Assembly' Type' TypeBoundArguments' env' NameSupply.Fork ()' rootId' assemblyId' typeId' TypeBoundTypeParameterIds' typeTrace); " is 186.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompilerEnvironment.cs,BindBaseTypes,The length of the statement  "				boundTypes.Add (baseTypeEnv.TypeConstructorRef' new ExpressionAndPhase (JST.Expression.Dot (baseType' Constants.TypeApplicand)' TypePhase.Slots)); " is 146.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompilerEnvironment.cs,BindSpecial,The length of the statement  "		boundTypes.Add (TypeConstructorRef' new ExpressionAndPhase (JST.Expression.Dot (typeId.ToE ()' Constants.TypeApplicand)' TypePhase.Constructed)); " is 145.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompilerEnvironment.cs,BindSpecial,The length of the statement  "		boundTypes.Add (TypeBoundArguments [i]' new ExpressionAndPhase (TypeBoundTypeParameterIds [i].ToE ()' TypePhase.Constructed)); " is 126.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The length of the statement  "			Env.Log (new UnusedDefinitionMessage (CST.MessageContextBuilders.Member (Env.Global' TyconEnv.Assembly' TyconEnv.Type' fieldDef))); " is 131.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The length of the statement  "			Env.Log (new UnusedDefinitionMessage (CST.MessageContextBuilders.Member (Env.Global' TyconEnv.Assembly' TyconEnv.Type' eventDef))); " is 131.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The length of the statement  "			Env.Log (new UnusedDefinitionMessage (CST.MessageContextBuilders.Member (Env.Global' TyconEnv.Assembly' TyconEnv.Type' propDef))); " is 130.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The length of the statement  "		foreach (var methodDef in TyconEnv.Type.Members.OfType<CST.MethodDef> ().Where (d => d.Invalid == null && !d.IsAbstract)) { " is 123.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The length of the statement  "					Env.Log (new UnusedDefinitionMessage (CST.MessageContextBuilders.Member (Env.Global' TyconEnv.Assembly' TyconEnv.Type' methodDef))); " is 132.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The length of the statement  "			else if (!Env.Validity.IsMustHaveADefinition (methodDef.QualifiedMemberName (Env.Global' TyconEnv.Assembly' TyconEnv.Type)) && (Env.InteropManager.IsInlinable (TyconEnv.Assembly' TyconEnv.Type' methodDef' state) || Env.InlinedMethods.IsInlinable (TyconEnv.Assembly' TyconEnv.Type' methodDef))) { " is 295.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The length of the statement  "					Env.Log (new InlinedDefinitionMessage (CST.MessageContextBuilders.Member (Env.Global' TyconEnv.Assembly' TyconEnv.Type' methodDef))); " is 133.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The length of the statement  "			else if (state != InstanceState.JavaScriptOnly && state != InstanceState.ManagedAndJavaScript && !methodDef.IsStatic && methodDef.IsConstructor && methodDef.Arity > 1 && methodDef.ValueParameters [1].Equals (Env.JSContextRef)) { " is 228.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The length of the statement  "				else if (!methodDef.IsStatic && methodDef.IsConstructor && methodDef.Arity == 1 && !Env.InteropManager.IsFactory (TyconEnv.Assembly' TyconEnv.Type' methodDef)) { " is 161.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The length of the statement  "					DefaultConstructor = new CST.MethodRef (TyconEnv.AddSelfTypeBoundArguments ().TypeRef' methodDef.MethodSignature' null); " is 120.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,BuildTypeStructure,The length of the statement  "		body.Add (JST.Statement.DotAssignment (TypeDefinitionId.ToE ()' new JST.Identifier (Constants.TypeStringSlot (kv.Value))' new JST.StringLiteral (kv.Key))); " is 155.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,EmitMethods,The length of the statement  "				body.Add (JST.Statement.DotCall (RootId.ToE ()' Constants.RootCollectingBindMethodBuilder' lhs' new JST.BooleanLiteral (isStatic)' new JST.StringLiteral (slot)' new JST.StringLiteral (methodName))); " is 198.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,Emit,The length of the statement  "	if (Env.BreakOnBreak && Env.AttributeHelper.TypeHasAttribute (TyconEnv.Assembly' TyconEnv.Type' Env.AttributeHelper.BreakAttributeRef' false' false)) " is 149.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,Emit,The length of the statement  "	var typeName = CST.CSTWriter.WithAppend (Env.Global' CST.WriterStyle.Uniform' TyconEnv.Type.EffectiveName (Env.Global).Append); " is 127.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,Emit,The length of the statement  "		loaderBody.Add (JST.Statement.DotCall (new JST.Identifier (Env.Root).ToE ()' Constants.RootBindType' new JST.StringLiteral (assmName)' new JST.StringLiteral (slotName)' new JST.StringLiteral (typeName)' func)); " is 210.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,Emit,The length of the statement  "		body.Add (JST.Statement.Var (TypeDefinitionId' JST.Expression.DotCall (AssemblyId.ToE ()' new JST.Identifier (Constants.AssemblyTypeBuilderSlot (slotName))' Env.JSTHelpers.PhaseExpression (TypePhase.Slots)))); " is 209.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,Emit,The length of the statement  "		body.Add (JST.Statement.Var (TypeDefinitionId' JST.Expression.DotCall (AssemblyId.ToE ()' new JST.Identifier (Constants.AssemblyTypeBuilderSlot (slotName))' Env.JSTHelpers.PhaseExpression (TypePhase.Id)))); " is 206.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,GlobalMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,ResolveFieldDefToSlot,The length of the statement  "	return TypeMappingFor (assemblyDef' typeDef).ResolveFieldToSlot (fieldDef.QualifiedMemberName (env.Global' assemblyDef' typeDef)); " is 130.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,GlobalMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,ResolveEventDefToSlot,The length of the statement  "	return TypeMappingFor (assemblyDef' typeDef).ResolveEventToSlot (eventDef.QualifiedMemberName (env.Global' assemblyDef' typeDef)); " is 130.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,GlobalMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,ResolveMethodDefToSlot,The length of the statement  "	return TypeMappingFor (assemblyDef' typeDef).ResolveMethodToSlot (methodDef.QualifiedMemberName (env.Global' assemblyDef' typeDef)); " is 132.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,GlobalMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,ResolvePropertyDefToSlot,The length of the statement  "	return TypeMappingFor (assemblyDef' typeDef).ResolvePropertyToSlot (propDef.QualifiedMemberName (env.Global' assemblyDef' typeDef)); " is 132.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,StringStats,C:\repos\Reactive-Extensions_IL2JS\Compiler\StringStats.cs,GetEnumerator,The length of the statement  "		yield return new KeyValuePair<string' StringBindScope> (kv.Key' typeSize < inplaceSize ? StringBindScope.Type : StringBindScope.InPlace); " is 137.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,IsAlternateEntryPoint,The length of the statement  "	return env.AttributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' env.AttributeHelper.EntryPointAttributeRef' false' false); " is 138.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,HasFullReflection,The length of the statement  "	env.AttributeHelper.GetValueFromType (assemblyDef' typeDef' env.AttributeHelper.ReflectionAttributeRef' env.AttributeHelper.TheReflectionLevelProperty' true' true' ref level); " is 175.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,TypeAlwaysUsed,The length of the statement  "	env.AttributeHelper.GetValueFromType (assemblyDef' typeDef' env.AttributeHelper.UsedTypeAttributeRef' env.AttributeHelper.TheIsUsedProperty' true' false' ref isUsed); " is 166.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,TypeAlwaysUsed,The length of the statement  "	env.AttributeHelper.GetValueFromType (assemblyDef' typeDef' env.AttributeHelper.UsedAttributeRef' env.AttributeHelper.TheIsUsedProperty' true' false' ref isUsedType); " is 166.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,FieldAlwaysUsed,The length of the statement  "	            if (env.AttributeHelper.FieldHasAttribute(assemblyDef' typeDef' fieldDef' env.Global.CompilerGeneratedAttributeRef' false))" is 123.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,FieldAlwaysUsed,The length of the statement  "	if (env.AttributeHelper.FieldHasAttribute (assemblyDef' typeDef' fieldDef' env.AttributeHelper.IgnoreAttributeRef' true' true)) " is 127.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,FieldAlwaysUsed,The length of the statement  "	env.AttributeHelper.GetValueFromField (assemblyDef' typeDef' fieldDef' env.AttributeHelper.UsedAttributeRef' env.AttributeHelper.TheIsUsedProperty' true' false' ref isUsed); " is 173.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,MethodAlwaysUsed,The length of the statement  "	            if (env.AttributeHelper.MethodHasAttribute(assemblyDef' typeDef' methodDef' env.Global.CompilerGeneratedAttributeRef' false))" is 125.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,MethodAlwaysUsed,The length of the statement  "	if (env.AttributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' env.AttributeHelper.IgnoreAttributeRef' true' true)) " is 129.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,MethodAlwaysUsed,The length of the statement  "	env.AttributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' env.AttributeHelper.UsedAttributeRef' env.AttributeHelper.TheIsUsedProperty' true' false' ref isUsed); " is 175.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,PropertyAlwaysUsed,The length of the statement  "	if (env.AttributeHelper.PropertyHasAttribute (assemblyDef' typeDef' propDef' env.AttributeHelper.IgnoreAttributeRef' true' true)) " is 129.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,PropertyAlwaysUsed,The length of the statement  "	env.AttributeHelper.GetValueFromProperty (assemblyDef' typeDef' propDef' env.AttributeHelper.UsedAttributeRef' env.AttributeHelper.TheIsUsedProperty' true' false' ref isUsed); " is 175.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,EventAlwaysUsed,The length of the statement  "	if (env.AttributeHelper.EventHasAttribute (assemblyDef' typeDef' eventDef' env.AttributeHelper.IgnoreAttributeRef' true' true)) " is 127.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,EventAlwaysUsed,The length of the statement  "	env.AttributeHelper.GetValueFromEvent (assemblyDef' typeDef' eventDef' env.AttributeHelper.UsedAttributeRef' env.AttributeHelper.TheIsUsedProperty' true' false' ref isUsed); " is 173.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,PropogateExtraUsedFromMember,The length of the statement  "		if (!methodDef.IsStatic && methodDef.IsConstructor && env.InteropManager.IsImported (assemblyDef' typeDef' methodDef) && !env.InteropManager.IsFactory (assemblyDef' typeDef' methodDef)) { " is 187.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,PropogateExtraUsedFromMember,The length of the statement  "			var polyMethEnv = Global.Environment ().AddAssembly (assemblyDef).AddType (typeDef).AddSelfTypeBoundArguments ().AddMethod (methodDef); " is 135.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,IgnoreMethodDefBody,The length of the statement  "	return env.AttributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' env.AttributeHelper.InteropGeneratedAttributeRef' false' false); " is 144.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,ImplementableMemberDef,The length of the statement  "	if (env.AttributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' env.AttributeHelper.IgnoreAttributeRef' true' true)) { " is 131.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,ImplementableMemberDef,The length of the statement  "		if (!(s is CST.InterfaceTypeStyle) && methodDef.MethodStyle != CST.MethodStyle.Abstract && !env.InteropManager.IsImported (assemblyDef' typeDef' methodDef)) { " is 158.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,ImplementableMemberRef,The length of the statement  "	if (memberRef.DefiningType.Style (rootEnv) is CST.DelegateTypeStyle && memberRef.Name.Equals (".ctor"' StringComparison.Ordinal)) " is 129.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,RecaseMethod,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.NamingAttributeRef' attributeHelper.TheMemberNameCasingProperty' true' false' ref casing); " is 175.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,RecaseProperty,The length of the statement  "	attributeHelper.GetValueFromProperty (assemblyDef' typeDef' propDef' attributeHelper.NamingAttributeRef' attributeHelper.TheMemberNameCasingProperty' true' false' ref casing); " is 175.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,RecasePropertyEvent,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.NamingAttributeRef' attributeHelper.TheMemberNameCasingProperty' true' false' ref casing); " is 175.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,GetterSetterAdderRemoverNameFromMethod,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.NamingAttributeRef' attributeHelper.TheRemoveAccessorPrefixProperty' true' false' ref removeAccessor); " is 187.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,GetterSetterAdderRemoverNameFromMethod,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.NamingAttributeRef' attributeHelper.ThePrefixNameCasingProperty' true' false' ref prefixCasing); " is 181.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,GetterSetterAdderRemoverNameFromMethod,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.NamingAttributeRef' attributeHelper.TheRemoveAccessorUnderscoreProperty' true' false' ref removeUnderscore); " is 193.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,GetterSetterAdderRemoverNameFromMethod,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.NamingAttributeRef' attributeHelper.TheMemberNameCasingProperty' true' false' ref memberCasing); " is 181.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,GetterSetterAdderRemoverNameFromPropertyEvent,The length of the statement  "	JST.Expression.ExplodePath (RecasePropertyEvent (assemblyDef' typeDef' methodDef' null)) : // Take the user supplied property/event name as a starting point " is 156.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,GetterSetterAdderRemoverNameFromPropertyEvent,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.NamingAttributeRef' attributeHelper.TheRemoveAccessorPrefixProperty' true' false' ref removeAccessor); " is 187.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,GetterSetterAdderRemoverNameFromPropertyEvent,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.NamingAttributeRef' attributeHelper.ThePrefixNameCasingProperty' true' false' ref prefixCasing); " is 181.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,GetterSetterAdderRemoverNameFromPropertyEvent,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.NamingAttributeRef' attributeHelper.TheRemoveAccessorUnderscoreProperty' true' false' ref removeUnderscore); " is 193.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.NamingAttributeRef' attributeHelper.TheQualificationProperty' true' false' ref qual); " is 170.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ExportAttributeRef' attributeHelper.TheBindToPrototypeProperty' true' false' ref bindToProto); " is 179.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The length of the statement  "		attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.NamingAttributeRef' attributeHelper.TheGlobalObjectProperty' true' false' ref global); " is 171.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The length of the statement  "			attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.NamingAttributeRef' attributeHelper.TheNamespaceCasingProperty' true' false' ref nsCasing); " is 176.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The length of the statement  "		attributeHelper.GetValueFromType (assemblyDef' typeDef' attributeHelper.NamingAttributeRef' attributeHelper.TheTypeNameCasingProperty' true' false' ref tnCasing); " is 162.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The length of the statement  "		foreach (var n in typeDef.EffectiveName (env.Global).Types.Select (name => new JST.PropertyName (Recase (name' tnCasing)))) " is 123.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DefaultImportingConstructor,The length of the statement  "	foreach (var currCtor in typeEnv.Type.Members.OfType<CST.MethodDef> ().Where (m => m.Invalid == null && !m.IsStatic && m.IsConstructor && !IsImported (typeEnv.Assembly' typeEnv.Type' m))) { " is 189.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DefaultImportingConstructor,The length of the statement  "		if (thisRank > 0 && currCtor.Annotations.OfType<CST.AccessibilityAnnotation> ().Where (a => a.Accessibility != CST.Accessibility.Public).Any ()) { " is 146.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DefaultImportingConstructor,The length of the statement  "			env.Log (new InvalidInteropMessage (CST.MessageContextBuilders.Member (env.Global' typeEnv.Assembly' typeEnv.Type' currCtor)' "importing constructors must be public")); " is 168.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The length of the statement  "	foreach (var currCtor in polyMethEnv.Type.Members.OfType<CST.MethodDef> ().Where (m => m.Invalid == null && !m.IsStatic && m.IsConstructor && !IsImported (polyMethEnv.Assembly' polyMethEnv.Type' m))) { " is 201.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The length of the statement  "		if (currRank > 0 && currCtor.Annotations.OfType<CST.AccessibilityAnnotation> ().Where (a => a.Accessibility != CST.Accessibility.Public).Any ()) { " is 146.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The length of the statement  "			env.Log (new InvalidInteropMessage (CST.MessageContextBuilders.Member (env.Global' polyMethEnv.Assembly' polyMethEnv.Type' currCtor)' "importing constructors must be public")); " is 176.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsExtern,The length of the statement  "	return methodDef.IsExtern || attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.InteropGeneratedAttributeRef' false' false); " is 158.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsImported,The length of the statement  "				if (attributeHelper.MethodHasAttribute (assemblyDef' typeDef' typeDef.ResolveMethod (eventDef.Add)' attributeHelper.ImportAttributeRef' false' false)) " is 150.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsImported,The length of the statement  "				if (attributeHelper.MethodHasAttribute (assemblyDef' typeDef' typeDef.ResolveMethod (eventDef.Remove)' attributeHelper.ImportAttributeRef' false' false)) " is 153.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsImported,The length of the statement  "				if (attributeHelper.MethodHasAttribute (assemblyDef' typeDef' typeDef.ResolveMethod (propDef.Get)' attributeHelper.ImportAttributeRef' false' false)) " is 149.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsImported,The length of the statement  "				if (attributeHelper.MethodHasAttribute (assemblyDef' typeDef' typeDef.ResolveMethod (propDef.Set)' attributeHelper.ImportAttributeRef' false' false)) " is 149.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsImported,The length of the statement  "		if (attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' true' false)) { " is 124.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsImported,The length of the statement  "			if (attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' env.Global.DllImportAttributeRef' false' false)) { " is 123.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsImported,The length of the statement  "		if (attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false)) { " is 125.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsInlinable,The length of the statement  "	if (env.AttributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' env.AttributeHelper.InlineAttributeRef' env.AttributeHelper.TheIsInlinedProperty' true' false' ref isInline)) " is 186.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsInlinable,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' true' false' ref script); " is 165.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsFactory,The length of the statement  "				attributeHelper.GetValueFromType (assemblyDef' typeDef' attributeHelper.RuntimeAttributeRef' attributeHelper.TheIsRuntimeProperty' true' false' ref isRuntime); " is 159.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsNoInteropParameter,The length of the statement  "		attributeHelper.GetValueFromType (assemblyDef' typeDef' attributeHelper.RuntimeAttributeRef' attributeHelper.TheIsRuntimeProperty' true' false' ref isRuntime); " is 159.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsNoInteropParameter,The length of the statement  "		attributeHelper.GetValueFromParameter (assemblyDef' typeDef' methodDef' idx' attributeHelper.NoInteropAttributeRef' attributeHelper.TheIsNoInteropProperty' true' false' ref isNoInterop); " is 186.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsNoInteropResult,The length of the statement  "	attributeHelper.GetValueFromResult (assemblyDef' typeDef' methodDef' attributeHelper.NoInteropAttributeRef' attributeHelper.TheIsNoInteropProperty' true' false' ref isNoInterop); " is 178.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalImport,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.ThePassRootAsArgumentProperty' true' false' ref scriptExpectsRoot); " is 188.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalImport,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.ThePassInstanceAsArgumentProperty' true' false' ref passInstAsArg); " is 188.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalImport,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheInlineParamsArrayProperty' true' false' ref inlineParams); " is 182.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalImport,The length of the statement  "		body.Add (new JST.IfStatement (JST.Expression.IsNotNull (arrArg)' new JST.Statements (new JST.ForStatement (new JST.ForVarLoopClause (iId' new JST.NumericLiteral (0)' new JST.BinaryExpression (iId.ToE ()' JST.BinaryOp.LessThan' JST.Expression.Dot (arrArg' Constants.length))' new JST.UnaryExpression (iId.ToE ()' JST.UnaryOp.PostIncrement))' new JST.Statements (JST.Statement.DotCall (argsId.ToE ()' Constants.push' new JST.IndexExpression (arrArg' iId.ToE ()))))))); " is 467.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalImport,The length of the statement  "				call = JST.Expression.DotCall (JST.Expression.Dot (instArg' JST.Expression.ExplodePath (script))' Constants.apply' instArg' argsId.ToE ()); " is 139.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,CheckParameterAndReturnTypesAreImportableExportable,The length of the statement  "	var methEnv = rootEnv.AddAssembly (assemblyDef).AddType (typeDef).AddSelfTypeBoundArguments ().AddMethod (methodDef).AddSelfMethodBoundArguments (); " is 148.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,CheckParameterAndReturnTypesAreImportableExportable,The length of the statement  "		CheckTypeIsImportableExportable (CST.MessageContextBuilders.ArgOrLocal (ctxt' CST.ArgLocal.Arg' i)' methEnv' methodDef.ValueParameters [i].Type); " is 145.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' true' false' ref script); " is 165.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "			attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheCreationProperty' true' false' ref creation); " is 169.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "			var isOnMethod = attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false); " is 136.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "				attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' false' false' ref localScript); " is 171.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "						script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false); " is 155.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "							script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false); " is 124.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "						script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false); " is 155.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "							return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]); " is 129.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "							script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false); " is 124.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "								return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]); " is 146.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "						script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false); " is 155.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "						script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false); " is 124.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "							return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]); " is 146.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "						script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false); " is 158.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "						script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false); " is 124.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The length of the statement  "							return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]); " is 146.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsExported,The length of the statement  "	if (!methodDef.IsStatic && methodDef.IsConstructor && methodDef.Arity > 1 && methodDef.ValueParameters [1].Type.Equals (env.JSContextRef)) " is 138.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsExported,The length of the statement  "	if (attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ExportAttributeRef' !IsExtern (assemblyDef' typeDef' methodDef)' false) && !attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.NotExportedAttributeRef' false' false)) " is 289.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsBindToInstance,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ExportAttributeRef' attributeHelper.TheBindToPrototypeProperty' true' false' ref isProto); " is 175.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,EnsurePathExists,The length of the statement  "			statements.Add (new JST.TryStatement (new JST.Statements (new JST.ExpressionStatement (prefix))' new JST.CatchClause (exId' new JST.Statements (JST.Statement.Assignment (prefix' new JST.ObjectLiteral ()))))); " is 208.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,EnsurePathExists,The length of the statement  "			statements.Add (new JST.IfStatement (JST.Expression.IsNull (prefix)' new JST.Statements (JST.Statement.Assignment (prefix' new JST.ObjectLiteral ())))); " is 152.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalExport,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ExportAttributeRef' attributeHelper.TheInlineParamsArrayProperty' true' false' ref inlineParams); " is 182.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalExport,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ExportAttributeRef' attributeHelper.ThePassRootAsArgumentProperty' true' false' ref isPassRoot); " is 181.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalExport,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ExportAttributeRef' attributeHelper.TheBindToPrototypeProperty' true' false' ref isProto); " is 175.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalExport,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ExportAttributeRef' attributeHelper.ThePassInstanceAsArgumentProperty' true' false' ref isPassInstance); " is 189.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendFinalExport,The length of the statement  "		funcBody.Add (new JST.ForStatement (new JST.ForVarLoopClause (iId' new JST.NumericLiteral (funcArity)' new JST.BinaryExpression (iId.ToE ()' JST.BinaryOp.LessThan' JST.Expression.Dot (Constants.arguments.ToE ()' Constants.length))' new JST.UnaryExpression (iId.ToE ()' JST.UnaryOp.PostIncrement))' new JST.Statements (JST.Statement.DotCall (arrId.ToE ()' Constants.push' new JST.IndexExpression (Constants.arguments.ToE ()' iId.ToE ()))))); " is 440.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendExport,The length of the statement  "		env.Log (new InvalidInteropMessage (ctxt' "higher-kinded types cannot export static methods or instance constructors")); " is 120.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendExport,The length of the statement  "	attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ExportAttributeRef' attributeHelper.TheScriptProperty' true' false' ref script); " is 165.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendExport,The length of the statement  "		var hasLocalScript = attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ExportAttributeRef' attributeHelper.TheScriptProperty' false' false' ref localScript); " is 192.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendExport,The length of the statement  "				script = hasLocalScript ? GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript) : GetterSetterAdderRemoverNameFromPropertyEvent (assemblyDef' typeDef' methodDef' "add"' script); " is 216.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendExport,The length of the statement  "				script = hasLocalScript ? GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript) : GetterSetterAdderRemoverNameFromPropertyEvent (assemblyDef' typeDef' methodDef' "remove"' script); " is 222.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendExport,The length of the statement  "				script = hasLocalScript ? GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript) : GetterSetterAdderRemoverNameFromPropertyEvent (assemblyDef' typeDef' methodDef' "get"' script); " is 216.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendExport,The length of the statement  "				script = hasLocalScript ? GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript) : GetterSetterAdderRemoverNameFromPropertyEvent (assemblyDef' typeDef' methodDef' "set"' script); " is 216.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "	if (s is CST.PointerTypeStyle || s is CST.CodePointerTypeStyle || s is CST.NullableTypeStyle || s is CST.ArrayTypeStyle || s is CST.ValueTypeStyle || s is CST.DelegateTypeStyle || s is CST.InterfaceTypeStyle) " is 208.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "	if (attributeHelper.GetValueFromType (assemblyDef' typeDef' attributeHelper.InteropAttributeRef' attributeHelper.TheStateProperty' false' false' ref state)) " is 156.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "	attributeHelper.GetValueFromType (assemblyDef' typeDef' attributeHelper.RuntimeAttributeRef' attributeHelper.TheIsRuntimeProperty' true' false' ref isRuntime); " is 159.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "							env.Log (new InvalidInteropMessage (CST.MessageContextBuilders.Member (env.Global' assemblyDef' typeDef' methodDef)' "all constructors for a 'Merged' type must be imported")); " is 175.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "				env.Log (new InvalidInteropMessage (CST.MessageContextBuilders.Member (env.Global' assemblyDef' typeDef' methodDef)' "'Merged' cannot contain non-inlinable instance methods")); " is 176.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "			if (attributeHelper.PropertyHasAttribute (assemblyDef' typeDef' propDef' attributeHelper.ImportKeyAttributeRef' false' false)) { " is 128.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "			attributeHelper.GetValueFromType (extAssemblyDef' extTypeDef' attributeHelper.RuntimeAttributeRef' attributeHelper.TheIsRuntimeProperty' true' false' ref isRuntime); " is 165.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "			numInstanceFieldsAllSupertypes += extTypeDef.Members.OfType<CST.FieldDef> ().Where (f => f.Invalid == null && !f.IsStatic).Count (); " is 132.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "			var n = extTypeDef.Members.OfType<CST.MethodDef> ().Where (m => m.Invalid == null && IsExported (extAssemblyDef' extTypeDef' m) && IsBindToInstance (extAssemblyDef' extTypeDef' m)).Count (); " is 190.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "	if (baseRepresentation != null && baseRepresentation.State != InstanceState.ManagedOnly && baseRepresentation.State != state) { " is 127.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "		env.Log (new InvalidInteropMessage (ctxt' "type is not the same state as base type' and base type is not 'ManagedOnly'")); " is 122.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "			env.Log (new InvalidInteropMessage (ctxt' "'Merged' cannot contain managed instance fields' either directly or inherited from supertypes")); " is 140.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "			env.Log (new InvalidInteropMessage (ctxt' "a type with state 'JavaScriptOnly' type cannot contain managed instance fields' either directly or inherited from supertypes")); " is 171.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "			env.Log (new InvalidInteropMessage (ctxt' "a type with state 'JavaScriptOnly' cannot contain exported instance methods")); " is 122.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "				attributeHelper.GetValueFromType (assemblyDef' typeDef' attributeHelper.InteropAttributeRef' attributeHelper.TheDefaultKeyProperty' true' false' ref keyField); " is 159.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "					env.Log (new InvalidInteropMessage (ctxt' "default key must be specified for type with state 'ManagedAndJavaScript' without an 'ImportKey' attribute")); " is 152.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "				attributeHelper.GetValueFromProperty (assemblyDef' typeDef' keyPropDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' true' false' ref keyField); " is 170.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "					env.Log (new InvalidInteropMessage (ctxt' "key for type with state 'ManagedAndJavaScript' must be imported as an identifier' not a function")); " is 143.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "			attributeHelper.GetValueFromType (assemblyDef' typeDef' attributeHelper.InteropAttributeRef' attributeHelper.TheScriptProperty' true' false' ref typeClassifier); " is 161.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "		attributeHelper.GetValueFromType (assemblyDef' typeDef' attributeHelper.InteropAttributeRef' attributeHelper.TheUndefinedIsNotNullProperty' true' false' ref undefinedIsNotNull); " is 177.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The length of the statement  "	return new TypeRepresentation (state' numExportsBoundToInstance' numStepsToRootType' keyField' typeClassifier' undefinedIsNotNull); " is 131.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DelegateInfo,The length of the statement  "	attributeHelper.GetValueFromType (assemblyDef' typeDef' attributeHelper.ExportAttributeRef' attributeHelper.ThePassInstanceAsArgumentProperty' true' false' ref isCaptureThis); " is 175.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DelegateInfo,The length of the statement  "	attributeHelper.GetValueFromType (assemblyDef' typeDef' attributeHelper.ExportAttributeRef' attributeHelper.TheInlineParamsArrayProperty' true' false' ref isInlineParamsArray); " is 176.
Long Statement,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsSimulateMulticastEvents,The length of the statement  "	return attributeHelper.GetValueFromEvent (assemblyDef' typeDef' eventDef' attributeHelper.ImportAttributeRef' attributeHelper.TheSimulateMulticastEventsProperty' true' false' ref simMulticast); " is 193.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The conditional expression  "s is CST.ObjectTypeStyle && !calleeMethEnv.Method.IsStatic && calleeMethEnv.Method.Name.Equals (".ctor"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The conditional expression  "s is CST.NullableTypeStyle && !calleeMethEnv.Method.IsStatic && calleeMethEnv.Method.Name.Equals (".ctor"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 2"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The conditional expression  "calleeMethEnv.TypeRef.Equals (env.Global.ArrayRef) && calleeMethEnv.Method.Name.Equals ("GetEnumerator"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The conditional expression  "calleeMethEnv.TypeRef.Equals (env.Global.IEnumerableRef) && calleeMethEnv.Method.Name.Equals ("GetEnumerator"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The conditional expression  "calleeMethEnv.TypeConstructorRef.Equals (env.Global.IEnumerableTypeConstructorRef) && calleeMethEnv.Method.Name.Equals ("GetEnumerator"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,TranslateConditionalExpression,The conditional expression  "s is CST.ObjectTypeStyle || s is CST.StringTypeStyle || s is CST.ParameterTypeStyle || s is CST.NullTypeStyle"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitConstructObjectAndInstanceMethods,The conditional expression  "s is CST.InterfaceTypeStyle || s is CST.VoidTypeStyle || (TypeCompEnv.Type.IsAbstract && TypeCompEnv.Type.IsSealed)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitIsValidJavaScriptType,The conditional expression  "s is CST.StringTypeStyle || s is CST.NumberTypeStyle || s is CST.EnumTypeStyle || TypeCompEnv.TypeRef.Equals (Env.Global.DecimalRef)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The conditional expression  "setMethodDef != null && setMethodDef.Invalid == null && setMethodDef.IsUsed && setMethodDef.Arity == 2 && !Env.InlinedMethods.IsInlinable (innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' setMethodDef)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The conditional expression  "state != InstanceState.JavaScriptOnly && state != InstanceState.ManagedAndJavaScript && !methodDef.IsStatic && methodDef.IsConstructor && methodDef.Arity > 1 && methodDef.ValueParameters [1].Equals (Env.JSContextRef)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,CollectMembers,The conditional expression  "!methodDef.IsStatic && methodDef.IsConstructor && methodDef.Arity == 1 && !Env.InteropManager.IsFactory (TyconEnv.Assembly' TyconEnv.Type' methodDef)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS,ValidityContext,C:\repos\Reactive-Extensions_IL2JS\Compiler\Validity.cs,PropogateExtraUsedFromMember,The conditional expression  "!methodDef.IsStatic && methodDef.IsConstructor && env.InteropManager.IsImported (assemblyDef' typeDef' methodDef) && !env.InteropManager.IsFactory (assemblyDef' typeDef' methodDef)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The conditional expression  "script == null && !methodDef.IsStatic && methodDef.IsConstructor && qual == Qualification.None"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The conditional expression  "isExport && !isNonInstance && !isProto && qual != Qualification.None"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,PrefixName,The conditional expression  "isExport && !isNonInstance && isProto && qual == Qualification.None"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,IsExported,The conditional expression  "!methodDef.IsStatic && methodDef.IsConstructor && methodDef.Arity > 1 && methodDef.ValueParameters [1].Type.Equals (env.JSContextRef)"  is complex.
Complex Conditional,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MakeTypeRepresentation,The conditional expression  "s is CST.PointerTypeStyle || s is CST.CodePointerTypeStyle || s is CST.NullableTypeStyle || s is CST.ArrayTypeStyle || s is CST.ValueTypeStyle || s is CST.DelegateTypeStyle || s is CST.InterfaceTypeStyle"  is complex.
Empty Catch Block,Microsoft.LiveLabs.JavaScript.IL2JS,Program,C:\repos\Reactive-Extensions_IL2JS\Compiler\Program.cs,Main,The method has an empty catch block.
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitTypeBindings,The following statement contains a magic number: switch (Env.CompilationMode) {  case CompilationMode.Plain:  case CompilationMode.Collecting: {  	if (Env.DebugMode)  		body.Add (new JST.CommentStatement ("Type builders"));  	var args = new Seq<JST.Expression> ();  	args.Add (assemblyId.ToE ());  	args.Add (new JST.NullExpression ());  	foreach (var typeDef in typeDefs) {  		var slotName = Env.GlobalMapping.ResolveTypeDefToSlot (assmEnv.Assembly' typeDef);  		var typeName = CST.CSTWriter.WithAppend (Env.Global' CST.WriterStyle.Uniform' typeDef.EffectiveName (Env.Global).Append);  		args.Add (new JST.StringLiteral (slotName));  		args.Add (new JST.StringLiteral (typeName));  	}  	if (args.Count > 2)  		body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindTypeBuilders' args));  	break;  }  case CompilationMode.Traced: {  	// Types in the initial trace' this trace' or remainder trace are bound via builder with  	// null trace name. All other types are bound via builder with their containing trace name.  	var traceToArgs = new Map<string' Seq<JST.Expression>> ();  	var remainingArgs = new Seq<JST.Expression> ();  	remainingArgs.Add (assemblyId.ToE ());  	remainingArgs.Add (new JST.NullExpression ());  	foreach (var typeDef in typeDefs) {  		var typeName = CST.CSTWriter.WithAppend (Env.Global' CST.WriterStyle.Uniform' typeDef.EffectiveName (Env.Global).Append);  		var slotName = Env.GlobalMapping.ResolveTypeDefToSlot (assmEnv.Assembly' typeDef);  		var defTrace = Env.Traces.TypeToTrace [typeDef.QualifiedTypeName (Env.Global' assmEnv.Assembly)];  		if (defTrace.Flavor == TraceFlavor.OnDemand && defTrace != assemblyTrace.Parent) {  			var args = default(Seq<JST.Expression>);  			if (!traceToArgs.TryGetValue (defTrace.Name' out args)) {  				args = new Seq<JST.Expression> ();  				args.Add (assemblyId.ToE ());  				args.Add (new JST.StringLiteral (defTrace.Name));  				traceToArgs.Add (defTrace.Name' args);  			}  			args.Add (new JST.StringLiteral (slotName));  			args.Add (new JST.StringLiteral (typeName));  		}  		else {  			remainingArgs.Add (new JST.StringLiteral (slotName));  			remainingArgs.Add (new JST.StringLiteral (typeName));  		}  	}  	foreach (var kv in traceToArgs)  		body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindTypeBuilders' kv.Value));  	if (remainingArgs.Count > 2)  		body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindTypeBuilders' remainingArgs));  	break;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitTypeBindings,The following statement contains a magic number: switch (Env.CompilationMode) {  case CompilationMode.Plain:  case CompilationMode.Collecting: {  	if (Env.DebugMode)  		body.Add (new JST.CommentStatement ("Type builders"));  	var args = new Seq<JST.Expression> ();  	args.Add (assemblyId.ToE ());  	args.Add (new JST.NullExpression ());  	foreach (var typeDef in typeDefs) {  		var slotName = Env.GlobalMapping.ResolveTypeDefToSlot (assmEnv.Assembly' typeDef);  		var typeName = CST.CSTWriter.WithAppend (Env.Global' CST.WriterStyle.Uniform' typeDef.EffectiveName (Env.Global).Append);  		args.Add (new JST.StringLiteral (slotName));  		args.Add (new JST.StringLiteral (typeName));  	}  	if (args.Count > 2)  		body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindTypeBuilders' args));  	break;  }  case CompilationMode.Traced: {  	// Types in the initial trace' this trace' or remainder trace are bound via builder with  	// null trace name. All other types are bound via builder with their containing trace name.  	var traceToArgs = new Map<string' Seq<JST.Expression>> ();  	var remainingArgs = new Seq<JST.Expression> ();  	remainingArgs.Add (assemblyId.ToE ());  	remainingArgs.Add (new JST.NullExpression ());  	foreach (var typeDef in typeDefs) {  		var typeName = CST.CSTWriter.WithAppend (Env.Global' CST.WriterStyle.Uniform' typeDef.EffectiveName (Env.Global).Append);  		var slotName = Env.GlobalMapping.ResolveTypeDefToSlot (assmEnv.Assembly' typeDef);  		var defTrace = Env.Traces.TypeToTrace [typeDef.QualifiedTypeName (Env.Global' assmEnv.Assembly)];  		if (defTrace.Flavor == TraceFlavor.OnDemand && defTrace != assemblyTrace.Parent) {  			var args = default(Seq<JST.Expression>);  			if (!traceToArgs.TryGetValue (defTrace.Name' out args)) {  				args = new Seq<JST.Expression> ();  				args.Add (assemblyId.ToE ());  				args.Add (new JST.StringLiteral (defTrace.Name));  				traceToArgs.Add (defTrace.Name' args);  			}  			args.Add (new JST.StringLiteral (slotName));  			args.Add (new JST.StringLiteral (typeName));  		}  		else {  			remainingArgs.Add (new JST.StringLiteral (slotName));  			remainingArgs.Add (new JST.StringLiteral (typeName));  		}  	}  	foreach (var kv in traceToArgs)  		body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindTypeBuilders' kv.Value));  	if (remainingArgs.Count > 2)  		body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindTypeBuilders' remainingArgs));  	break;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitTypeBindings,The following statement contains a magic number: if (args.Count > 2)  	body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindTypeBuilders' args));  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitTypeBindings,The following statement contains a magic number: if (remainingArgs.Count > 2)  	body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindTypeBuilders' remainingArgs));  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitAssemblyBindings,The following statement contains a magic number: switch (Env.CompilationMode) {  case CompilationMode.Plain:  case CompilationMode.Collecting: {  	if (Env.DebugMode)  		body.Add (new JST.CommentStatement ("Referenced assemblies"));  	var args = new Seq<JST.Expression> ();  	args.Add (assemblyId.ToE ());  	args.Add (new JST.NullExpression ());  	foreach (var nm in assmEnv.AllAssembliesInLoadOrder ()) {  		if (!nm.Equals (Env.Global.MsCorLibName) && !nm.Equals (assmEnv.Assembly.Name)) {  			var assmName = CST.CSTWriter.WithAppend (Env.Global' CST.WriterStyle.Uniform' nm.Append);  			var slotName = Env.GlobalMapping.ResolveAssemblyReferenceToSlot (assmEnv.Assembly' nm);  			args.Add (new JST.StringLiteral (slotName));  			args.Add (new JST.StringLiteral (assmName));  		}  		// else: don't need ref to mscorlib or self  	}  	if (args.Count > 2)  		body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindAssemblyBuilders' args));  	break;  }  case CompilationMode.Traced: {  	// Assemblies in the initial trace' this trace' or the remainder trace are bound via a builder  	// which is given the null trace name. All other assemblies are bound by a builder given their  	// containing trace name.  	var traceToArgs = new Map<string' Seq<JST.Expression>> ();  	var remainingArgs = new Seq<JST.Expression> ();  	remainingArgs.Add (assemblyId.ToE ());  	remainingArgs.Add (new JST.NullExpression ());  	foreach (var nm in assmEnv.AllAssembliesInLoadOrder ()) {  		if (!nm.Equals (Env.Global.MsCorLibName) && !nm.Equals (assmEnv.Assembly.Name)) {  			var assmName = CST.CSTWriter.WithAppend (Env.Global' CST.WriterStyle.Uniform' nm.Append);  			var slotName = Env.GlobalMapping.ResolveAssemblyReferenceToSlot (assmEnv.Assembly' nm);  			var defTrace = Env.Traces.AssemblyToTrace [nm];  			if (defTrace.Flavor == TraceFlavor.OnDemand && defTrace != assemblyTrace.Parent) {  				var args = default(Seq<JST.Expression>);  				if (!traceToArgs.TryGetValue (defTrace.Name' out args)) {  					args = new Seq<JST.Expression> ();  					args.Add (assemblyId.ToE ());  					args.Add (new JST.StringLiteral (defTrace.Name));  					traceToArgs.Add (defTrace.Name' args);  				}  				args.Add (new JST.StringLiteral (slotName));  				args.Add (new JST.StringLiteral (assmName));  			}  			else {  				remainingArgs.Add (new JST.StringLiteral (slotName));  				remainingArgs.Add (new JST.StringLiteral (assmName));  			}  		}  		// else: don't need ref to mscorlib or self  	}  	foreach (var kv in traceToArgs)  		body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindAssemblyBuilders' kv.Value));  	if (remainingArgs.Count > 2)  		body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindAssemblyBuilders' remainingArgs));  	break;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitAssemblyBindings,The following statement contains a magic number: switch (Env.CompilationMode) {  case CompilationMode.Plain:  case CompilationMode.Collecting: {  	if (Env.DebugMode)  		body.Add (new JST.CommentStatement ("Referenced assemblies"));  	var args = new Seq<JST.Expression> ();  	args.Add (assemblyId.ToE ());  	args.Add (new JST.NullExpression ());  	foreach (var nm in assmEnv.AllAssembliesInLoadOrder ()) {  		if (!nm.Equals (Env.Global.MsCorLibName) && !nm.Equals (assmEnv.Assembly.Name)) {  			var assmName = CST.CSTWriter.WithAppend (Env.Global' CST.WriterStyle.Uniform' nm.Append);  			var slotName = Env.GlobalMapping.ResolveAssemblyReferenceToSlot (assmEnv.Assembly' nm);  			args.Add (new JST.StringLiteral (slotName));  			args.Add (new JST.StringLiteral (assmName));  		}  		// else: don't need ref to mscorlib or self  	}  	if (args.Count > 2)  		body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindAssemblyBuilders' args));  	break;  }  case CompilationMode.Traced: {  	// Assemblies in the initial trace' this trace' or the remainder trace are bound via a builder  	// which is given the null trace name. All other assemblies are bound by a builder given their  	// containing trace name.  	var traceToArgs = new Map<string' Seq<JST.Expression>> ();  	var remainingArgs = new Seq<JST.Expression> ();  	remainingArgs.Add (assemblyId.ToE ());  	remainingArgs.Add (new JST.NullExpression ());  	foreach (var nm in assmEnv.AllAssembliesInLoadOrder ()) {  		if (!nm.Equals (Env.Global.MsCorLibName) && !nm.Equals (assmEnv.Assembly.Name)) {  			var assmName = CST.CSTWriter.WithAppend (Env.Global' CST.WriterStyle.Uniform' nm.Append);  			var slotName = Env.GlobalMapping.ResolveAssemblyReferenceToSlot (assmEnv.Assembly' nm);  			var defTrace = Env.Traces.AssemblyToTrace [nm];  			if (defTrace.Flavor == TraceFlavor.OnDemand && defTrace != assemblyTrace.Parent) {  				var args = default(Seq<JST.Expression>);  				if (!traceToArgs.TryGetValue (defTrace.Name' out args)) {  					args = new Seq<JST.Expression> ();  					args.Add (assemblyId.ToE ());  					args.Add (new JST.StringLiteral (defTrace.Name));  					traceToArgs.Add (defTrace.Name' args);  				}  				args.Add (new JST.StringLiteral (slotName));  				args.Add (new JST.StringLiteral (assmName));  			}  			else {  				remainingArgs.Add (new JST.StringLiteral (slotName));  				remainingArgs.Add (new JST.StringLiteral (assmName));  			}  		}  		// else: don't need ref to mscorlib or self  	}  	foreach (var kv in traceToArgs)  		body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindAssemblyBuilders' kv.Value));  	if (remainingArgs.Count > 2)  		body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindAssemblyBuilders' remainingArgs));  	break;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitAssemblyBindings,The following statement contains a magic number: if (args.Count > 2)  	body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindAssemblyBuilders' args));  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\AssemblyCompiler.cs,EmitAssemblyBindings,The following statement contains a magic number: if (remainingArgs.Count > 2)  	body.Add (JST.Statement.DotCall (rootId.ToE ()' Constants.RootBindAssemblyBuilders' remainingArgs));  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-allWarns"))  	env.NoWarns = new Set<string> ();  else if (c.Equals (opt' "-assemblyNameResolution")) {  	var f = getArgs (1) [0];  	if (c.Equals (f' "full"))  		env.AssemblyNameResolution = CST.AssemblyNameResolution.Full;  	else if (c.Equals (f' "nameVersion"))  		env.AssemblyNameResolution = CST.AssemblyNameResolution.NameVersion;  	else if (c.Equals (f' "name"))  		env.AssemblyNameResolution = CST.AssemblyNameResolution.Name;  	else {  		log (new UsageMessage ("Unrecognised -assemblyNameResolution value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-augment"))  	env.AugmentationFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-breakOnBreak"))  	env.BreakOnBreak = false;  else if (c.Equals (opt' "+breakOnBreak"))  	env.BreakOnBreak = true;  else if (c.Equals (opt' "-clrArraySemantics"))  	env.CLRArraySemantics = false;  else if (c.Equals (opt' "+clrArraySemantics"))  	env.CLRArraySemantics = true;  else if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-allWarns"))  	env.NoWarns = new Set<string> ();  else if (c.Equals (opt' "-assemblyNameResolution")) {  	var f = getArgs (1) [0];  	if (c.Equals (f' "full"))  		env.AssemblyNameResolution = CST.AssemblyNameResolution.Full;  	else if (c.Equals (f' "nameVersion"))  		env.AssemblyNameResolution = CST.AssemblyNameResolution.NameVersion;  	else if (c.Equals (f' "name"))  		env.AssemblyNameResolution = CST.AssemblyNameResolution.Name;  	else {  		log (new UsageMessage ("Unrecognised -assemblyNameResolution value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-augment"))  	env.AugmentationFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-breakOnBreak"))  	env.BreakOnBreak = false;  else if (c.Equals (opt' "+breakOnBreak"))  	env.BreakOnBreak = true;  else if (c.Equals (opt' "-clrArraySemantics"))  	env.CLRArraySemantics = false;  else if (c.Equals (opt' "+clrArraySemantics"))  	env.CLRArraySemantics = true;  else if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-assemblyNameResolution")) {  	var f = getArgs (1) [0];  	if (c.Equals (f' "full"))  		env.AssemblyNameResolution = CST.AssemblyNameResolution.Full;  	else if (c.Equals (f' "nameVersion"))  		env.AssemblyNameResolution = CST.AssemblyNameResolution.NameVersion;  	else if (c.Equals (f' "name"))  		env.AssemblyNameResolution = CST.AssemblyNameResolution.Name;  	else {  		log (new UsageMessage ("Unrecognised -assemblyNameResolution value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-augment"))  	env.AugmentationFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-breakOnBreak"))  	env.BreakOnBreak = false;  else if (c.Equals (opt' "+breakOnBreak"))  	env.BreakOnBreak = true;  else if (c.Equals (opt' "-clrArraySemantics"))  	env.CLRArraySemantics = false;  else if (c.Equals (opt' "+clrArraySemantics"))  	env.CLRArraySemantics = true;  else if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-assemblyNameResolution")) {  	var f = getArgs (1) [0];  	if (c.Equals (f' "full"))  		env.AssemblyNameResolution = CST.AssemblyNameResolution.Full;  	else if (c.Equals (f' "nameVersion"))  		env.AssemblyNameResolution = CST.AssemblyNameResolution.NameVersion;  	else if (c.Equals (f' "name"))  		env.AssemblyNameResolution = CST.AssemblyNameResolution.Name;  	else {  		log (new UsageMessage ("Unrecognised -assemblyNameResolution value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-augment"))  	env.AugmentationFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-breakOnBreak"))  	env.BreakOnBreak = false;  else if (c.Equals (opt' "+breakOnBreak"))  	env.BreakOnBreak = true;  else if (c.Equals (opt' "-clrArraySemantics"))  	env.CLRArraySemantics = false;  else if (c.Equals (opt' "+clrArraySemantics"))  	env.CLRArraySemantics = true;  else if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-augment"))  	env.AugmentationFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-breakOnBreak"))  	env.BreakOnBreak = false;  else if (c.Equals (opt' "+breakOnBreak"))  	env.BreakOnBreak = true;  else if (c.Equals (opt' "-clrArraySemantics"))  	env.CLRArraySemantics = false;  else if (c.Equals (opt' "+clrArraySemantics"))  	env.CLRArraySemantics = true;  else if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-augment"))  	env.AugmentationFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-breakOnBreak"))  	env.BreakOnBreak = false;  else if (c.Equals (opt' "+breakOnBreak"))  	env.BreakOnBreak = true;  else if (c.Equals (opt' "-clrArraySemantics"))  	env.CLRArraySemantics = false;  else if (c.Equals (opt' "+clrArraySemantics"))  	env.CLRArraySemantics = true;  else if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-breakOnBreak"))  	env.BreakOnBreak = false;  else if (c.Equals (opt' "+breakOnBreak"))  	env.BreakOnBreak = true;  else if (c.Equals (opt' "-clrArraySemantics"))  	env.CLRArraySemantics = false;  else if (c.Equals (opt' "+clrArraySemantics"))  	env.CLRArraySemantics = true;  else if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-breakOnBreak"))  	env.BreakOnBreak = false;  else if (c.Equals (opt' "+breakOnBreak"))  	env.BreakOnBreak = true;  else if (c.Equals (opt' "-clrArraySemantics"))  	env.CLRArraySemantics = false;  else if (c.Equals (opt' "+clrArraySemantics"))  	env.CLRArraySemantics = true;  else if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "+breakOnBreak"))  	env.BreakOnBreak = true;  else if (c.Equals (opt' "-clrArraySemantics"))  	env.CLRArraySemantics = false;  else if (c.Equals (opt' "+clrArraySemantics"))  	env.CLRArraySemantics = true;  else if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "+breakOnBreak"))  	env.BreakOnBreak = true;  else if (c.Equals (opt' "-clrArraySemantics"))  	env.CLRArraySemantics = false;  else if (c.Equals (opt' "+clrArraySemantics"))  	env.CLRArraySemantics = true;  else if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-clrArraySemantics"))  	env.CLRArraySemantics = false;  else if (c.Equals (opt' "+clrArraySemantics"))  	env.CLRArraySemantics = true;  else if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-clrArraySemantics"))  	env.CLRArraySemantics = false;  else if (c.Equals (opt' "+clrArraySemantics"))  	env.CLRArraySemantics = true;  else if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "+clrArraySemantics"))  	env.CLRArraySemantics = true;  else if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "+clrArraySemantics"))  	env.CLRArraySemantics = true;  else if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-clrInteropExceptions"))  	env.CLRInteropExceptions = false;  else if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "+clrInteropExceptions"))  	env.CLRInteropExceptions = true;  else if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = false;  else if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "+clrNullVirtcallSemantics"))  	env.CLRNullVirtcallSemantics = true;  else if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-compile"))  	env.CompileFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-debug")) {  	env.DebugMode = false;  	env.PrettyPrint = false;  	env.DebugLevel = 0;  }  else if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "+debug")) {  	env.DebugMode = true;  	env.PrettyPrint = true;  	env.DebugLevel = 1;  }  else if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-debugLevel")) {  	var n = default(int);  	if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  		log (new UsageMessage ("Invalid -debugLevel value"));  		throw new ExitException ();  	}  	env.DebugLevel = n;  }  else if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (!int.TryParse (getArgs (1) [0]' out n) || n < 0 || n > 2) {  	log (new UsageMessage ("Invalid -debugLevel value"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-debugTrace"))  	env.DebugTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-finalTraceName"))  	env.FinalTraceName = getArgs (1) [0];  else if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-help"))  	Usage (null);  else if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-inDir"))  	env.InputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-initialTrace"))  	env.InitialTraceFileName = getArgs (1) [0];  else if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-importInlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -importInlineThreshold value"));  		throw new ExitException ();  	}  	env.ImportInlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-inlineThreshold")) {  	var i = default(int);  	if (!int.TryParse (getArgs (1) [0]' out i)) {  		log (new UsageMessage ("Invalid -inlineThreshold value"));  		throw new ExitException ();  	}  	env.InlineThreshold = Math.Max (-1' i);  }  else if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-loadPath"))  	env.LoadPaths.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-mode")) {  	var m = getArgs (1) [0];  	if (c.Equals (m' "plain"))  		env.CompilationMode = CompilationMode.Plain;  	else if (c.Equals (m' "collecting"))  		env.CompilationMode = CompilationMode.Collecting;  	else if (c.Equals (m' "traced"))  		env.CompilationMode = CompilationMode.Traced;  	else {  		log (new UsageMessage ("Invalid -mode value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-noWarn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns.Add (id);  }  else if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-original"))  	env.OriginalStrongNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-outDir"))  	env.OutputDirectory = ExpandVars (getArgs (1) [0]);  else if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "+prettyPrint"))  	env.PrettyPrint = true;  else if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-prettyPrint"))  	env.PrettyPrint = false;  else if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-reference"))  	env.ReferenceFileNames.Add (ExpandVars (getArgs (1) [0]));  else if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerCommandLine,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerCommandLine.cs,Process,The following statement contains a magic number: if (c.Equals (opt' "-rename")) {  	var args = getArgs (2);  	env.RenameRules.Add (new CST.RenameRule (args [0]' args [1]));  }  else if (c.Equals (opt' "-root"))  	env.Root = getArgs (1) [0];  else if (c.Equals (opt' "-safeInterop"))  	env.SafeInterop = false;  else if (c.Equals (opt' "+safeInterop"))  	env.SafeInterop = true;  else if (c.Equals (opt' "-skipUpToDate"))  	env.SkipUpToDate = false;  else if (c.Equals (opt' "+skipUpToDate"))  	env.SkipUpToDate = true;  else if (c.Equals (opt' "-target")) {  	var str = getArgs (1) [0];  	if (c.Equals (str' "browser"))  		env.Target = Target.Browser;  	else if (c.Equals (str' "cscript"))  		env.Target = Target.CScript;  	else {  		log (new UsageMessage ("Invalid -target value"));  		throw new ExitException ();  	}  }  else if (c.Equals (opt' "-trace"))  	env.TraceFileNames.Add (getArgs (1) [0]);  else if (c.Equals (opt' "+warn")) {  	var id = getArgs (1) [0].Trim ().ToLowerInvariant ();  	env.NoWarns = env.NoWarns.Where (id2 => !id2.Equals (id' StringComparison.Ordinal)).ToSet ();  }  else {  	log (new UsageMessage ("Unrecognised option '" + opt + "'"));  	throw new ExitException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PhaseExpression,The following statement contains a magic number: switch (phase) {  case TypePhase.Id:  	return new JST.NumericLiteral (1);  case TypePhase.Slots:  	return new JST.NumericLiteral (2);  case TypePhase.Constructed:  	return new JST.NumericLiteral (3);  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PhaseExpression,The following statement contains a magic number: switch (phase) {  case TypePhase.Id:  	return new JST.NumericLiteral (1);  case TypePhase.Slots:  	return new JST.NumericLiteral (2);  case TypePhase.Constructed:  	return new JST.NumericLiteral (3);  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PhaseExpression,The following statement contains a magic number: return new JST.NumericLiteral (2);  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PhaseExpression,The following statement contains a magic number: return new JST.NumericLiteral (3);  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The following statement contains a magic number: if (s is CST.ObjectTypeStyle && !calleeMethEnv.Method.IsStatic && calleeMethEnv.Method.Name.Equals (".ctor"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1) {  	// SPECIAL CASE: Object constructor is the identity  	return null;  }  else if (s is CST.NullableTypeStyle && !calleeMethEnv.Method.IsStatic && calleeMethEnv.Method.Name.Equals (".ctor"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 2) {  	// SPECIAL CASE: Nullable`1::.ctor(ptr' x) is just ptr.W(x)  	return JST.Expression.DotCall (arguments [0]' Constants.PointerWrite' arguments [1]);  }  else if (s is CST.NullableTypeStyle && calleeMethEnv.Method.Name.Equals ("get_HasValue"' StringComparison.Ordinal)) {  	// SPECIAL CASE: Nullable`1::get_HasValue(ptr) becomes ptr.R() != null  	return JST.Expression.IsNotNull (JST.Expression.DotCall (arguments [0]' Constants.PointerRead));  }  else if (s is CST.NullableTypeStyle && calleeMethEnv.Method.Name.Equals ("get_Value"' StringComparison.Ordinal)) {  	// SPECIAL CASE: Nullable`1::get_Value(ptr) becomes AssertNonNullInvalidOperation(ptr.R())  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootAssertNonNullInvalidOperation' JST.Expression.DotCall (arguments [0]' Constants.PointerRead));  }  else if (s is CST.MultiDimArrayTypeStyle && calleeMethEnv.Method.Name.Equals ("Get"' StringComparison.Ordinal)) {  	// SPECIAL CASE: Multi-dimensional array get  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootGetMultiDimArrayValue' arguments);  }  else if (s is CST.MultiDimArrayTypeStyle && calleeMethEnv.Method.Name.Equals ("Set"' StringComparison.Ordinal)) {  	// SPECIAL CASE: Multi-dimensional array set  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootSetMultiDimArrayValue' arguments);  }  else if (s is CST.MultiDimArrayTypeStyle && calleeMethEnv.Method.Name.Equals ("Address"' StringComparison.Ordinal)) {  	// SPECIAL CASE: Multi-dimensional array element address  	var elemType = resolver.ResolveType (calleeMethEnv.TypeBoundArguments [0]);  	var allArgs = new Seq<JST.Expression> {  		elemType  	};  	foreach (var a in arguments)  		allArgs.Add (a);  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewPointerToMultiDimArrayElem' allArgs);  }  else if (calleeMethEnv.TypeRef.Equals (env.Global.DebuggerRef) && calleeMethEnv.Method.Name.Equals ("Break"' StringComparison.Ordinal)) {  	// SPECIAL CASE: Break into debugger directly  	return new JST.DebuggerExpression ();  }  else if (calleeMethEnv.Method.IsStatic || isFactory) {  	var type = resolver.ResolveType (calleeMethEnv.TypeRef);  	var args = calleeMethEnv.MethodBoundArguments.Select (resolver.ResolveType).Concat (arguments).ToSeq ();  	return new JST.CallExpression (new JST.IndexExpression (type' MethodSlotName (resolver' calleeMethEnv.MethodRef' false))' args);  }  else {  	if (arguments.Count == 0)  		throw new InvalidOperationException ("mismatched method arity");  	var target = arguments [0];  	var args = calleeMethEnv.MethodBoundArguments.Select (resolver.ResolveType).Concat (arguments.Skip (1)).ToSeq ();  	return new JST.CallExpression (new JST.IndexExpression (target' MethodSlotName (resolver' calleeMethEnv.MethodRef' false))' args);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimMethodCallExpression,The following statement contains a magic number: if (s is CST.NullableTypeStyle && !calleeMethEnv.Method.IsStatic && calleeMethEnv.Method.Name.Equals (".ctor"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 2) {  	// SPECIAL CASE: Nullable`1::.ctor(ptr' x) is just ptr.W(x)  	return JST.Expression.DotCall (arguments [0]' Constants.PointerWrite' arguments [1]);  }  else if (s is CST.NullableTypeStyle && calleeMethEnv.Method.Name.Equals ("get_HasValue"' StringComparison.Ordinal)) {  	// SPECIAL CASE: Nullable`1::get_HasValue(ptr) becomes ptr.R() != null  	return JST.Expression.IsNotNull (JST.Expression.DotCall (arguments [0]' Constants.PointerRead));  }  else if (s is CST.NullableTypeStyle && calleeMethEnv.Method.Name.Equals ("get_Value"' StringComparison.Ordinal)) {  	// SPECIAL CASE: Nullable`1::get_Value(ptr) becomes AssertNonNullInvalidOperation(ptr.R())  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootAssertNonNullInvalidOperation' JST.Expression.DotCall (arguments [0]' Constants.PointerRead));  }  else if (s is CST.MultiDimArrayTypeStyle && calleeMethEnv.Method.Name.Equals ("Get"' StringComparison.Ordinal)) {  	// SPECIAL CASE: Multi-dimensional array get  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootGetMultiDimArrayValue' arguments);  }  else if (s is CST.MultiDimArrayTypeStyle && calleeMethEnv.Method.Name.Equals ("Set"' StringComparison.Ordinal)) {  	// SPECIAL CASE: Multi-dimensional array set  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootSetMultiDimArrayValue' arguments);  }  else if (s is CST.MultiDimArrayTypeStyle && calleeMethEnv.Method.Name.Equals ("Address"' StringComparison.Ordinal)) {  	// SPECIAL CASE: Multi-dimensional array element address  	var elemType = resolver.ResolveType (calleeMethEnv.TypeBoundArguments [0]);  	var allArgs = new Seq<JST.Expression> {  		elemType  	};  	foreach (var a in arguments)  		allArgs.Add (a);  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewPointerToMultiDimArrayElem' allArgs);  }  else if (calleeMethEnv.TypeRef.Equals (env.Global.DebuggerRef) && calleeMethEnv.Method.Name.Equals ("Break"' StringComparison.Ordinal)) {  	// SPECIAL CASE: Break into debugger directly  	return new JST.DebuggerExpression ();  }  else if (calleeMethEnv.Method.IsStatic || isFactory) {  	var type = resolver.ResolveType (calleeMethEnv.TypeRef);  	var args = calleeMethEnv.MethodBoundArguments.Select (resolver.ResolveType).Concat (arguments).ToSeq ();  	return new JST.CallExpression (new JST.IndexExpression (type' MethodSlotName (resolver' calleeMethEnv.MethodRef' false))' args);  }  else {  	if (arguments.Count == 0)  		throw new InvalidOperationException ("mismatched method arity");  	var target = arguments [0];  	var args = calleeMethEnv.MethodBoundArguments.Select (resolver.ResolveType).Concat (arguments.Skip (1)).ToSeq ();  	return new JST.CallExpression (new JST.IndexExpression (target' MethodSlotName (resolver' calleeMethEnv.MethodRef' false))' args);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The following statement contains a magic number: if (s is CST.DelegateTypeStyle) {  	var delTypeDef = (CST.DelegateTypeDef)calleeMethEnv.Type;  	if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 1 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("Invoke"' StringComparison.Ordinal)) {  		// SPECIAL CASE: Invoke rewritten to direct function application  		return new JST.CallExpression (target' arguments.Skip (1).ToSeq ());  	}  	else if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 3 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("BeginInvoke"' StringComparison.Ordinal)) {  		// SPECIAL CASE: BeginInvoke rewritten to runtime call  		var resType = calleeMethEnv.SubstituteType (delTypeDef.Result.Type);  		var resTypeExpr = resType == null ? null : resolver.ResolveType (resType' TypePhase.Constructed);  		var args = new Seq<JST.Expression> ();  		args.Add (new JST.NumericLiteral (delTypeDef.ValueParameters.Count));  		args.Add (resTypeExpr);  		args.Add (target);  		foreach (var a in arguments.Skip (1))  			args.Add (a);  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootDelegateBeginInvoke' args);  	}  	else if (calleeMethEnv.Method.Arity == 2 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("EndInvoke"' StringComparison.Ordinal)) {  		// SPECIAL CASE: EndInvoke rewritten to runtime call  		var resType = calleeMethEnv.SubstituteType (delTypeDef.Result.Type);  		var resTypeExpr = resType == null ? null : resolver.ResolveType (resType' TypePhase.Constructed);  		var args = new Seq<JST.Expression> ();  		args.Add (resTypeExpr);  		args.Add (target);  		foreach (var a in arguments.Skip (1))  			args.Add (a);  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootDelegateEndInvoke' args);  	}  	else  		throw new InvalidOperationException ("unrecognised virtual method of delegate");  }  else if (calleeMethEnv.TypeRef.Equals (env.Global.ArrayRef) && calleeMethEnv.Method.Name.Equals ("GetEnumerator"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0) {  	// SPECIAL CASE: Construct a GenericEnumerator at array's run-time element type  	var fallback = new JST.ThrowStatement (JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootInvalidOperationException));  	return ConstructGenericEnumeratorAtDynamicType (resolver' nameSupply' optBody' fallback' target);  }  else if (calleeMethEnv.TypeRef.Equals (env.Global.IEnumerableRef) && calleeMethEnv.Method.Name.Equals ("GetEnumerator"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0) {  	// SPECIAL CASE: If target is a built-in array' constructor a GenericEnumerator at array's  	//               run-time element type. Otherwise invoke original interface method.  	var fallback = new JST.ReturnStatement (new JST.CallExpression (func' arguments.Skip (1).ToSeq ()));  	return ConstructGenericEnumeratorAtDynamicType (resolver' nameSupply' optBody' fallback' target);  }  else if (calleeMethEnv.TypeConstructorRef.Equals (env.Global.IEnumerableTypeConstructorRef) && calleeMethEnv.Method.Name.Equals ("GetEnumerator"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0) {  	// SPECIAL CASE: If target is a built-in array' construct a GenericEnumerator at requested interface  	//               type. Otherwise invoke original interface method.  	// NOTE: We don't use array's runtime element type  	var fallback = new JST.CallExpression (func' arguments.Skip (1).ToSeq ());  	return ConstructGenericEnumeratorAtStaticType (resolver' nameSupply' optBody' fallback' calleeMethEnv.TypeBoundArguments [0]' target);  }  else {  	var args = calleeMethEnv.MethodBoundArguments.Select (resolver.ResolveType).Concat (arguments.Skip (1)).ToSeq ();  	return new JST.CallExpression (func' args);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The following statement contains a magic number: if (s is CST.DelegateTypeStyle) {  	var delTypeDef = (CST.DelegateTypeDef)calleeMethEnv.Type;  	if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 1 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("Invoke"' StringComparison.Ordinal)) {  		// SPECIAL CASE: Invoke rewritten to direct function application  		return new JST.CallExpression (target' arguments.Skip (1).ToSeq ());  	}  	else if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 3 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("BeginInvoke"' StringComparison.Ordinal)) {  		// SPECIAL CASE: BeginInvoke rewritten to runtime call  		var resType = calleeMethEnv.SubstituteType (delTypeDef.Result.Type);  		var resTypeExpr = resType == null ? null : resolver.ResolveType (resType' TypePhase.Constructed);  		var args = new Seq<JST.Expression> ();  		args.Add (new JST.NumericLiteral (delTypeDef.ValueParameters.Count));  		args.Add (resTypeExpr);  		args.Add (target);  		foreach (var a in arguments.Skip (1))  			args.Add (a);  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootDelegateBeginInvoke' args);  	}  	else if (calleeMethEnv.Method.Arity == 2 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("EndInvoke"' StringComparison.Ordinal)) {  		// SPECIAL CASE: EndInvoke rewritten to runtime call  		var resType = calleeMethEnv.SubstituteType (delTypeDef.Result.Type);  		var resTypeExpr = resType == null ? null : resolver.ResolveType (resType' TypePhase.Constructed);  		var args = new Seq<JST.Expression> ();  		args.Add (resTypeExpr);  		args.Add (target);  		foreach (var a in arguments.Skip (1))  			args.Add (a);  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootDelegateEndInvoke' args);  	}  	else  		throw new InvalidOperationException ("unrecognised virtual method of delegate");  }  else if (calleeMethEnv.TypeRef.Equals (env.Global.ArrayRef) && calleeMethEnv.Method.Name.Equals ("GetEnumerator"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0) {  	// SPECIAL CASE: Construct a GenericEnumerator at array's run-time element type  	var fallback = new JST.ThrowStatement (JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootInvalidOperationException));  	return ConstructGenericEnumeratorAtDynamicType (resolver' nameSupply' optBody' fallback' target);  }  else if (calleeMethEnv.TypeRef.Equals (env.Global.IEnumerableRef) && calleeMethEnv.Method.Name.Equals ("GetEnumerator"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0) {  	// SPECIAL CASE: If target is a built-in array' constructor a GenericEnumerator at array's  	//               run-time element type. Otherwise invoke original interface method.  	var fallback = new JST.ReturnStatement (new JST.CallExpression (func' arguments.Skip (1).ToSeq ()));  	return ConstructGenericEnumeratorAtDynamicType (resolver' nameSupply' optBody' fallback' target);  }  else if (calleeMethEnv.TypeConstructorRef.Equals (env.Global.IEnumerableTypeConstructorRef) && calleeMethEnv.Method.Name.Equals ("GetEnumerator"' StringComparison.Ordinal) && calleeMethEnv.Method.Arity == 1 && calleeMethEnv.Method.TypeArity == 0) {  	// SPECIAL CASE: If target is a built-in array' construct a GenericEnumerator at requested interface  	//               type. Otherwise invoke original interface method.  	// NOTE: We don't use array's runtime element type  	var fallback = new JST.CallExpression (func' arguments.Skip (1).ToSeq ());  	return ConstructGenericEnumeratorAtStaticType (resolver' nameSupply' optBody' fallback' calleeMethEnv.TypeBoundArguments [0]' target);  }  else {  	var args = calleeMethEnv.MethodBoundArguments.Select (resolver.ResolveType).Concat (arguments.Skip (1)).ToSeq ();  	return new JST.CallExpression (func' args);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The following statement contains a magic number: if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 1 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("Invoke"' StringComparison.Ordinal)) {  	// SPECIAL CASE: Invoke rewritten to direct function application  	return new JST.CallExpression (target' arguments.Skip (1).ToSeq ());  }  else if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 3 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("BeginInvoke"' StringComparison.Ordinal)) {  	// SPECIAL CASE: BeginInvoke rewritten to runtime call  	var resType = calleeMethEnv.SubstituteType (delTypeDef.Result.Type);  	var resTypeExpr = resType == null ? null : resolver.ResolveType (resType' TypePhase.Constructed);  	var args = new Seq<JST.Expression> ();  	args.Add (new JST.NumericLiteral (delTypeDef.ValueParameters.Count));  	args.Add (resTypeExpr);  	args.Add (target);  	foreach (var a in arguments.Skip (1))  		args.Add (a);  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootDelegateBeginInvoke' args);  }  else if (calleeMethEnv.Method.Arity == 2 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("EndInvoke"' StringComparison.Ordinal)) {  	// SPECIAL CASE: EndInvoke rewritten to runtime call  	var resType = calleeMethEnv.SubstituteType (delTypeDef.Result.Type);  	var resTypeExpr = resType == null ? null : resolver.ResolveType (resType' TypePhase.Constructed);  	var args = new Seq<JST.Expression> ();  	args.Add (resTypeExpr);  	args.Add (target);  	foreach (var a in arguments.Skip (1))  		args.Add (a);  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootDelegateEndInvoke' args);  }  else  	throw new InvalidOperationException ("unrecognised virtual method of delegate");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The following statement contains a magic number: if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 1 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("Invoke"' StringComparison.Ordinal)) {  	// SPECIAL CASE: Invoke rewritten to direct function application  	return new JST.CallExpression (target' arguments.Skip (1).ToSeq ());  }  else if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 3 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("BeginInvoke"' StringComparison.Ordinal)) {  	// SPECIAL CASE: BeginInvoke rewritten to runtime call  	var resType = calleeMethEnv.SubstituteType (delTypeDef.Result.Type);  	var resTypeExpr = resType == null ? null : resolver.ResolveType (resType' TypePhase.Constructed);  	var args = new Seq<JST.Expression> ();  	args.Add (new JST.NumericLiteral (delTypeDef.ValueParameters.Count));  	args.Add (resTypeExpr);  	args.Add (target);  	foreach (var a in arguments.Skip (1))  		args.Add (a);  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootDelegateBeginInvoke' args);  }  else if (calleeMethEnv.Method.Arity == 2 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("EndInvoke"' StringComparison.Ordinal)) {  	// SPECIAL CASE: EndInvoke rewritten to runtime call  	var resType = calleeMethEnv.SubstituteType (delTypeDef.Result.Type);  	var resTypeExpr = resType == null ? null : resolver.ResolveType (resType' TypePhase.Constructed);  	var args = new Seq<JST.Expression> ();  	args.Add (resTypeExpr);  	args.Add (target);  	foreach (var a in arguments.Skip (1))  		args.Add (a);  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootDelegateEndInvoke' args);  }  else  	throw new InvalidOperationException ("unrecognised virtual method of delegate");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The following statement contains a magic number: if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 3 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("BeginInvoke"' StringComparison.Ordinal)) {  	// SPECIAL CASE: BeginInvoke rewritten to runtime call  	var resType = calleeMethEnv.SubstituteType (delTypeDef.Result.Type);  	var resTypeExpr = resType == null ? null : resolver.ResolveType (resType' TypePhase.Constructed);  	var args = new Seq<JST.Expression> ();  	args.Add (new JST.NumericLiteral (delTypeDef.ValueParameters.Count));  	args.Add (resTypeExpr);  	args.Add (target);  	foreach (var a in arguments.Skip (1))  		args.Add (a);  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootDelegateBeginInvoke' args);  }  else if (calleeMethEnv.Method.Arity == 2 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("EndInvoke"' StringComparison.Ordinal)) {  	// SPECIAL CASE: EndInvoke rewritten to runtime call  	var resType = calleeMethEnv.SubstituteType (delTypeDef.Result.Type);  	var resTypeExpr = resType == null ? null : resolver.ResolveType (resType' TypePhase.Constructed);  	var args = new Seq<JST.Expression> ();  	args.Add (resTypeExpr);  	args.Add (target);  	foreach (var a in arguments.Skip (1))  		args.Add (a);  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootDelegateEndInvoke' args);  }  else  	throw new InvalidOperationException ("unrecognised virtual method of delegate");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The following statement contains a magic number: if (calleeMethEnv.Method.Arity == delTypeDef.ValueParameters.Count + 3 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("BeginInvoke"' StringComparison.Ordinal)) {  	// SPECIAL CASE: BeginInvoke rewritten to runtime call  	var resType = calleeMethEnv.SubstituteType (delTypeDef.Result.Type);  	var resTypeExpr = resType == null ? null : resolver.ResolveType (resType' TypePhase.Constructed);  	var args = new Seq<JST.Expression> ();  	args.Add (new JST.NumericLiteral (delTypeDef.ValueParameters.Count));  	args.Add (resTypeExpr);  	args.Add (target);  	foreach (var a in arguments.Skip (1))  		args.Add (a);  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootDelegateBeginInvoke' args);  }  else if (calleeMethEnv.Method.Arity == 2 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("EndInvoke"' StringComparison.Ordinal)) {  	// SPECIAL CASE: EndInvoke rewritten to runtime call  	var resType = calleeMethEnv.SubstituteType (delTypeDef.Result.Type);  	var resTypeExpr = resType == null ? null : resolver.ResolveType (resType' TypePhase.Constructed);  	var args = new Seq<JST.Expression> ();  	args.Add (resTypeExpr);  	args.Add (target);  	foreach (var a in arguments.Skip (1))  		args.Add (a);  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootDelegateEndInvoke' args);  }  else  	throw new InvalidOperationException ("unrecognised virtual method of delegate");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,PrimVirtualMethodCallExpression,The following statement contains a magic number: if (calleeMethEnv.Method.Arity == 2 && calleeMethEnv.Method.TypeArity == 0 && calleeMethEnv.Method.Name.Equals ("EndInvoke"' StringComparison.Ordinal)) {  	// SPECIAL CASE: EndInvoke rewritten to runtime call  	var resType = calleeMethEnv.SubstituteType (delTypeDef.Result.Type);  	var resTypeExpr = resType == null ? null : resolver.ResolveType (resType' TypePhase.Constructed);  	var args = new Seq<JST.Expression> ();  	args.Add (resTypeExpr);  	args.Add (target);  	foreach (var a in arguments.Skip (1))  		args.Add (a);  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootDelegateEndInvoke' args);  }  else  	throw new InvalidOperationException ("unrecognised virtual method of delegate");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.NullableTypeStyle) {  	// SPECIAL CASE: new Nullable<T>(x) is represented by x  	return arguments [0];  }  else if (s is CST.DelegateTypeStyle) {  	var delegateType = resolver.ResolveType (methodRef.DefiningType);  	if (arguments == null || arguments.Count == 0)  		// SPECIAL CASE: Construct empty delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' new JST.NullExpression ()' new JST.NullExpression ()' delegateType);  	else if (arguments.Count == 2)  		// SPECIAL CASE: Construct normal delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' arguments [0]' arguments [1]' delegateType);  	else  		throw new InvalidOperationException ("mismatched delegate constructor arity");  }  else if (s is CST.MultiDimArrayTypeStyle) {  	// SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime  	var methEnv = methodRef.Enter (resolver.RootEnv);  	var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;  	var elemType = resolver.ResolveType (methodRef.DefiningType.Arguments [0]);  	var lowers = new Seq<JST.Expression> ();  	var sizes = new Seq<JST.Expression> ();  	if (arguments.Count == multiDef.Rank) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (new JST.NumericLiteral (0));  			sizes.Add (arguments [i]);  		}  	}  	else if (arguments.Count == multiDef.Rank * 2) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (arguments [i * 2]);  			sizes.Add (arguments [i * 2 + 1]);  		}  	}  	else  		throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewMultiDimArray' elemType' new JST.ArrayLiteral (lowers)' new JST.ArrayLiteral (sizes));  }  else {  	if (optBody == null)  		optLvalue = null;  	var body = optBody ?? new Seq<JST.Statement> ();  	var rep = env.InteropManager.GetTypeRepresentation (null' resolver.RootEnv' methodRef.DefiningType);  	// Share type if necessary  	var defType = resolver.ResolveType (methodRef.DefiningType);  	if (!defType.IsDuplicatable) {  		var id = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (id' defType));  		defType = id.ToE ();  	}  	// Initialize an object of the right type  	var init = default(JST.Expression);  	if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)  		init = new JST.NumericLiteral (0);  	else if (s is CST.ValueTypeStyle)  		// Defer to type  		init = JST.Expression.DotCall (defType' Constants.TypeDefaultValue);  	else  		// Reference types: invoke ConstructObject function  		init = new JST.NewExpression (JST.Expression.DotCall (defType' Constants.TypeConstructObject));  	var lvalue = default(JST.Expression);  	if (optLvalue == null) {  		var objId = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (objId' init));  		lvalue = objId.ToE ();  	}  	else {  		lvalue = optLvalue;  		body.Add (JST.Statement.Assignment (lvalue' init));  	}  	var tyconEnv = methodRef.DefiningType.EnterConstructor (resolver.RootEnv);  	if (rep.NumExportsBoundToInstance > 0) {  		if (rep.State == InstanceState.ManagedOnly) {  			// This must be a 'Runtime' type' bind it's instance exports before invoking ctor  			body.Add (JST.Statement.DotCall (defType' Constants.TypeBindInstanceExports' lvalue));  		}  		else {  			// Any instance exports will be bound into instance when object is first exported  			body.Add (JST.Statement.DotAssignment (lvalue' Constants.ObjectPrepareForExport' JST.Expression.Dot (defType' Constants.TypeBindInstanceExports)));  		}  	}  	var args = new Seq<JST.Expression> ();  	if (s is CST.ValueTypeStyle) {  		// Pass pointer to constructor as 'this'  		args.Add (PointerToLvalueExpression (resolver' nameSupply' lvalue' defType));  	}  	else if (s is CST.ReferenceTypeStyle) {  		// Pass object to constructor as 'this'  		args.Add (lvalue);  	}  	else if (s is CST.ParameterTypeStyle) {  		// Make pointer' ask runtime type to conditionally dereference it' and pass  		// result as 'this'. Works regardless of whether runtime type is value or ref.  		var ptrExp = PointerToLvalueExpression (resolver' nameSupply' lvalue' defType);  		var conPtrExp = JST.Expression.DotCall (defType' Constants.TypeConditionalDeref' ptrExp);  		args.Add (conPtrExp);  	}  	else  		throw new InvalidOperationException ("cannot construct instances of this type");  	// Pass constructor arguments' if any  	if (arguments != null) {  		foreach (var arg in arguments)  			args.Add (arg);  	}  	// Call constructor' if any  	var call = resolver.MethodCallExpression (methodRef' nameSupply' false' args);  	if (call != null)  		body.Add (new JST.ExpressionStatement (call));  	if (optBody == null)  		return new JST.StatementsPseudoExpression (new JST.Statements (body)' lvalue);  	else if (optLvalue == null)  		return lvalue;  	else  		return null;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.NullableTypeStyle) {  	// SPECIAL CASE: new Nullable<T>(x) is represented by x  	return arguments [0];  }  else if (s is CST.DelegateTypeStyle) {  	var delegateType = resolver.ResolveType (methodRef.DefiningType);  	if (arguments == null || arguments.Count == 0)  		// SPECIAL CASE: Construct empty delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' new JST.NullExpression ()' new JST.NullExpression ()' delegateType);  	else if (arguments.Count == 2)  		// SPECIAL CASE: Construct normal delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' arguments [0]' arguments [1]' delegateType);  	else  		throw new InvalidOperationException ("mismatched delegate constructor arity");  }  else if (s is CST.MultiDimArrayTypeStyle) {  	// SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime  	var methEnv = methodRef.Enter (resolver.RootEnv);  	var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;  	var elemType = resolver.ResolveType (methodRef.DefiningType.Arguments [0]);  	var lowers = new Seq<JST.Expression> ();  	var sizes = new Seq<JST.Expression> ();  	if (arguments.Count == multiDef.Rank) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (new JST.NumericLiteral (0));  			sizes.Add (arguments [i]);  		}  	}  	else if (arguments.Count == multiDef.Rank * 2) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (arguments [i * 2]);  			sizes.Add (arguments [i * 2 + 1]);  		}  	}  	else  		throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewMultiDimArray' elemType' new JST.ArrayLiteral (lowers)' new JST.ArrayLiteral (sizes));  }  else {  	if (optBody == null)  		optLvalue = null;  	var body = optBody ?? new Seq<JST.Statement> ();  	var rep = env.InteropManager.GetTypeRepresentation (null' resolver.RootEnv' methodRef.DefiningType);  	// Share type if necessary  	var defType = resolver.ResolveType (methodRef.DefiningType);  	if (!defType.IsDuplicatable) {  		var id = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (id' defType));  		defType = id.ToE ();  	}  	// Initialize an object of the right type  	var init = default(JST.Expression);  	if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)  		init = new JST.NumericLiteral (0);  	else if (s is CST.ValueTypeStyle)  		// Defer to type  		init = JST.Expression.DotCall (defType' Constants.TypeDefaultValue);  	else  		// Reference types: invoke ConstructObject function  		init = new JST.NewExpression (JST.Expression.DotCall (defType' Constants.TypeConstructObject));  	var lvalue = default(JST.Expression);  	if (optLvalue == null) {  		var objId = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (objId' init));  		lvalue = objId.ToE ();  	}  	else {  		lvalue = optLvalue;  		body.Add (JST.Statement.Assignment (lvalue' init));  	}  	var tyconEnv = methodRef.DefiningType.EnterConstructor (resolver.RootEnv);  	if (rep.NumExportsBoundToInstance > 0) {  		if (rep.State == InstanceState.ManagedOnly) {  			// This must be a 'Runtime' type' bind it's instance exports before invoking ctor  			body.Add (JST.Statement.DotCall (defType' Constants.TypeBindInstanceExports' lvalue));  		}  		else {  			// Any instance exports will be bound into instance when object is first exported  			body.Add (JST.Statement.DotAssignment (lvalue' Constants.ObjectPrepareForExport' JST.Expression.Dot (defType' Constants.TypeBindInstanceExports)));  		}  	}  	var args = new Seq<JST.Expression> ();  	if (s is CST.ValueTypeStyle) {  		// Pass pointer to constructor as 'this'  		args.Add (PointerToLvalueExpression (resolver' nameSupply' lvalue' defType));  	}  	else if (s is CST.ReferenceTypeStyle) {  		// Pass object to constructor as 'this'  		args.Add (lvalue);  	}  	else if (s is CST.ParameterTypeStyle) {  		// Make pointer' ask runtime type to conditionally dereference it' and pass  		// result as 'this'. Works regardless of whether runtime type is value or ref.  		var ptrExp = PointerToLvalueExpression (resolver' nameSupply' lvalue' defType);  		var conPtrExp = JST.Expression.DotCall (defType' Constants.TypeConditionalDeref' ptrExp);  		args.Add (conPtrExp);  	}  	else  		throw new InvalidOperationException ("cannot construct instances of this type");  	// Pass constructor arguments' if any  	if (arguments != null) {  		foreach (var arg in arguments)  			args.Add (arg);  	}  	// Call constructor' if any  	var call = resolver.MethodCallExpression (methodRef' nameSupply' false' args);  	if (call != null)  		body.Add (new JST.ExpressionStatement (call));  	if (optBody == null)  		return new JST.StatementsPseudoExpression (new JST.Statements (body)' lvalue);  	else if (optLvalue == null)  		return lvalue;  	else  		return null;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.NullableTypeStyle) {  	// SPECIAL CASE: new Nullable<T>(x) is represented by x  	return arguments [0];  }  else if (s is CST.DelegateTypeStyle) {  	var delegateType = resolver.ResolveType (methodRef.DefiningType);  	if (arguments == null || arguments.Count == 0)  		// SPECIAL CASE: Construct empty delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' new JST.NullExpression ()' new JST.NullExpression ()' delegateType);  	else if (arguments.Count == 2)  		// SPECIAL CASE: Construct normal delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' arguments [0]' arguments [1]' delegateType);  	else  		throw new InvalidOperationException ("mismatched delegate constructor arity");  }  else if (s is CST.MultiDimArrayTypeStyle) {  	// SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime  	var methEnv = methodRef.Enter (resolver.RootEnv);  	var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;  	var elemType = resolver.ResolveType (methodRef.DefiningType.Arguments [0]);  	var lowers = new Seq<JST.Expression> ();  	var sizes = new Seq<JST.Expression> ();  	if (arguments.Count == multiDef.Rank) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (new JST.NumericLiteral (0));  			sizes.Add (arguments [i]);  		}  	}  	else if (arguments.Count == multiDef.Rank * 2) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (arguments [i * 2]);  			sizes.Add (arguments [i * 2 + 1]);  		}  	}  	else  		throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewMultiDimArray' elemType' new JST.ArrayLiteral (lowers)' new JST.ArrayLiteral (sizes));  }  else {  	if (optBody == null)  		optLvalue = null;  	var body = optBody ?? new Seq<JST.Statement> ();  	var rep = env.InteropManager.GetTypeRepresentation (null' resolver.RootEnv' methodRef.DefiningType);  	// Share type if necessary  	var defType = resolver.ResolveType (methodRef.DefiningType);  	if (!defType.IsDuplicatable) {  		var id = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (id' defType));  		defType = id.ToE ();  	}  	// Initialize an object of the right type  	var init = default(JST.Expression);  	if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)  		init = new JST.NumericLiteral (0);  	else if (s is CST.ValueTypeStyle)  		// Defer to type  		init = JST.Expression.DotCall (defType' Constants.TypeDefaultValue);  	else  		// Reference types: invoke ConstructObject function  		init = new JST.NewExpression (JST.Expression.DotCall (defType' Constants.TypeConstructObject));  	var lvalue = default(JST.Expression);  	if (optLvalue == null) {  		var objId = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (objId' init));  		lvalue = objId.ToE ();  	}  	else {  		lvalue = optLvalue;  		body.Add (JST.Statement.Assignment (lvalue' init));  	}  	var tyconEnv = methodRef.DefiningType.EnterConstructor (resolver.RootEnv);  	if (rep.NumExportsBoundToInstance > 0) {  		if (rep.State == InstanceState.ManagedOnly) {  			// This must be a 'Runtime' type' bind it's instance exports before invoking ctor  			body.Add (JST.Statement.DotCall (defType' Constants.TypeBindInstanceExports' lvalue));  		}  		else {  			// Any instance exports will be bound into instance when object is first exported  			body.Add (JST.Statement.DotAssignment (lvalue' Constants.ObjectPrepareForExport' JST.Expression.Dot (defType' Constants.TypeBindInstanceExports)));  		}  	}  	var args = new Seq<JST.Expression> ();  	if (s is CST.ValueTypeStyle) {  		// Pass pointer to constructor as 'this'  		args.Add (PointerToLvalueExpression (resolver' nameSupply' lvalue' defType));  	}  	else if (s is CST.ReferenceTypeStyle) {  		// Pass object to constructor as 'this'  		args.Add (lvalue);  	}  	else if (s is CST.ParameterTypeStyle) {  		// Make pointer' ask runtime type to conditionally dereference it' and pass  		// result as 'this'. Works regardless of whether runtime type is value or ref.  		var ptrExp = PointerToLvalueExpression (resolver' nameSupply' lvalue' defType);  		var conPtrExp = JST.Expression.DotCall (defType' Constants.TypeConditionalDeref' ptrExp);  		args.Add (conPtrExp);  	}  	else  		throw new InvalidOperationException ("cannot construct instances of this type");  	// Pass constructor arguments' if any  	if (arguments != null) {  		foreach (var arg in arguments)  			args.Add (arg);  	}  	// Call constructor' if any  	var call = resolver.MethodCallExpression (methodRef' nameSupply' false' args);  	if (call != null)  		body.Add (new JST.ExpressionStatement (call));  	if (optBody == null)  		return new JST.StatementsPseudoExpression (new JST.Statements (body)' lvalue);  	else if (optLvalue == null)  		return lvalue;  	else  		return null;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.NullableTypeStyle) {  	// SPECIAL CASE: new Nullable<T>(x) is represented by x  	return arguments [0];  }  else if (s is CST.DelegateTypeStyle) {  	var delegateType = resolver.ResolveType (methodRef.DefiningType);  	if (arguments == null || arguments.Count == 0)  		// SPECIAL CASE: Construct empty delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' new JST.NullExpression ()' new JST.NullExpression ()' delegateType);  	else if (arguments.Count == 2)  		// SPECIAL CASE: Construct normal delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' arguments [0]' arguments [1]' delegateType);  	else  		throw new InvalidOperationException ("mismatched delegate constructor arity");  }  else if (s is CST.MultiDimArrayTypeStyle) {  	// SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime  	var methEnv = methodRef.Enter (resolver.RootEnv);  	var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;  	var elemType = resolver.ResolveType (methodRef.DefiningType.Arguments [0]);  	var lowers = new Seq<JST.Expression> ();  	var sizes = new Seq<JST.Expression> ();  	if (arguments.Count == multiDef.Rank) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (new JST.NumericLiteral (0));  			sizes.Add (arguments [i]);  		}  	}  	else if (arguments.Count == multiDef.Rank * 2) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (arguments [i * 2]);  			sizes.Add (arguments [i * 2 + 1]);  		}  	}  	else  		throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewMultiDimArray' elemType' new JST.ArrayLiteral (lowers)' new JST.ArrayLiteral (sizes));  }  else {  	if (optBody == null)  		optLvalue = null;  	var body = optBody ?? new Seq<JST.Statement> ();  	var rep = env.InteropManager.GetTypeRepresentation (null' resolver.RootEnv' methodRef.DefiningType);  	// Share type if necessary  	var defType = resolver.ResolveType (methodRef.DefiningType);  	if (!defType.IsDuplicatable) {  		var id = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (id' defType));  		defType = id.ToE ();  	}  	// Initialize an object of the right type  	var init = default(JST.Expression);  	if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)  		init = new JST.NumericLiteral (0);  	else if (s is CST.ValueTypeStyle)  		// Defer to type  		init = JST.Expression.DotCall (defType' Constants.TypeDefaultValue);  	else  		// Reference types: invoke ConstructObject function  		init = new JST.NewExpression (JST.Expression.DotCall (defType' Constants.TypeConstructObject));  	var lvalue = default(JST.Expression);  	if (optLvalue == null) {  		var objId = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (objId' init));  		lvalue = objId.ToE ();  	}  	else {  		lvalue = optLvalue;  		body.Add (JST.Statement.Assignment (lvalue' init));  	}  	var tyconEnv = methodRef.DefiningType.EnterConstructor (resolver.RootEnv);  	if (rep.NumExportsBoundToInstance > 0) {  		if (rep.State == InstanceState.ManagedOnly) {  			// This must be a 'Runtime' type' bind it's instance exports before invoking ctor  			body.Add (JST.Statement.DotCall (defType' Constants.TypeBindInstanceExports' lvalue));  		}  		else {  			// Any instance exports will be bound into instance when object is first exported  			body.Add (JST.Statement.DotAssignment (lvalue' Constants.ObjectPrepareForExport' JST.Expression.Dot (defType' Constants.TypeBindInstanceExports)));  		}  	}  	var args = new Seq<JST.Expression> ();  	if (s is CST.ValueTypeStyle) {  		// Pass pointer to constructor as 'this'  		args.Add (PointerToLvalueExpression (resolver' nameSupply' lvalue' defType));  	}  	else if (s is CST.ReferenceTypeStyle) {  		// Pass object to constructor as 'this'  		args.Add (lvalue);  	}  	else if (s is CST.ParameterTypeStyle) {  		// Make pointer' ask runtime type to conditionally dereference it' and pass  		// result as 'this'. Works regardless of whether runtime type is value or ref.  		var ptrExp = PointerToLvalueExpression (resolver' nameSupply' lvalue' defType);  		var conPtrExp = JST.Expression.DotCall (defType' Constants.TypeConditionalDeref' ptrExp);  		args.Add (conPtrExp);  	}  	else  		throw new InvalidOperationException ("cannot construct instances of this type");  	// Pass constructor arguments' if any  	if (arguments != null) {  		foreach (var arg in arguments)  			args.Add (arg);  	}  	// Call constructor' if any  	var call = resolver.MethodCallExpression (methodRef' nameSupply' false' args);  	if (call != null)  		body.Add (new JST.ExpressionStatement (call));  	if (optBody == null)  		return new JST.StatementsPseudoExpression (new JST.Statements (body)' lvalue);  	else if (optLvalue == null)  		return lvalue;  	else  		return null;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.DelegateTypeStyle) {  	var delegateType = resolver.ResolveType (methodRef.DefiningType);  	if (arguments == null || arguments.Count == 0)  		// SPECIAL CASE: Construct empty delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' new JST.NullExpression ()' new JST.NullExpression ()' delegateType);  	else if (arguments.Count == 2)  		// SPECIAL CASE: Construct normal delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' arguments [0]' arguments [1]' delegateType);  	else  		throw new InvalidOperationException ("mismatched delegate constructor arity");  }  else if (s is CST.MultiDimArrayTypeStyle) {  	// SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime  	var methEnv = methodRef.Enter (resolver.RootEnv);  	var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;  	var elemType = resolver.ResolveType (methodRef.DefiningType.Arguments [0]);  	var lowers = new Seq<JST.Expression> ();  	var sizes = new Seq<JST.Expression> ();  	if (arguments.Count == multiDef.Rank) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (new JST.NumericLiteral (0));  			sizes.Add (arguments [i]);  		}  	}  	else if (arguments.Count == multiDef.Rank * 2) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (arguments [i * 2]);  			sizes.Add (arguments [i * 2 + 1]);  		}  	}  	else  		throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewMultiDimArray' elemType' new JST.ArrayLiteral (lowers)' new JST.ArrayLiteral (sizes));  }  else {  	if (optBody == null)  		optLvalue = null;  	var body = optBody ?? new Seq<JST.Statement> ();  	var rep = env.InteropManager.GetTypeRepresentation (null' resolver.RootEnv' methodRef.DefiningType);  	// Share type if necessary  	var defType = resolver.ResolveType (methodRef.DefiningType);  	if (!defType.IsDuplicatable) {  		var id = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (id' defType));  		defType = id.ToE ();  	}  	// Initialize an object of the right type  	var init = default(JST.Expression);  	if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)  		init = new JST.NumericLiteral (0);  	else if (s is CST.ValueTypeStyle)  		// Defer to type  		init = JST.Expression.DotCall (defType' Constants.TypeDefaultValue);  	else  		// Reference types: invoke ConstructObject function  		init = new JST.NewExpression (JST.Expression.DotCall (defType' Constants.TypeConstructObject));  	var lvalue = default(JST.Expression);  	if (optLvalue == null) {  		var objId = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (objId' init));  		lvalue = objId.ToE ();  	}  	else {  		lvalue = optLvalue;  		body.Add (JST.Statement.Assignment (lvalue' init));  	}  	var tyconEnv = methodRef.DefiningType.EnterConstructor (resolver.RootEnv);  	if (rep.NumExportsBoundToInstance > 0) {  		if (rep.State == InstanceState.ManagedOnly) {  			// This must be a 'Runtime' type' bind it's instance exports before invoking ctor  			body.Add (JST.Statement.DotCall (defType' Constants.TypeBindInstanceExports' lvalue));  		}  		else {  			// Any instance exports will be bound into instance when object is first exported  			body.Add (JST.Statement.DotAssignment (lvalue' Constants.ObjectPrepareForExport' JST.Expression.Dot (defType' Constants.TypeBindInstanceExports)));  		}  	}  	var args = new Seq<JST.Expression> ();  	if (s is CST.ValueTypeStyle) {  		// Pass pointer to constructor as 'this'  		args.Add (PointerToLvalueExpression (resolver' nameSupply' lvalue' defType));  	}  	else if (s is CST.ReferenceTypeStyle) {  		// Pass object to constructor as 'this'  		args.Add (lvalue);  	}  	else if (s is CST.ParameterTypeStyle) {  		// Make pointer' ask runtime type to conditionally dereference it' and pass  		// result as 'this'. Works regardless of whether runtime type is value or ref.  		var ptrExp = PointerToLvalueExpression (resolver' nameSupply' lvalue' defType);  		var conPtrExp = JST.Expression.DotCall (defType' Constants.TypeConditionalDeref' ptrExp);  		args.Add (conPtrExp);  	}  	else  		throw new InvalidOperationException ("cannot construct instances of this type");  	// Pass constructor arguments' if any  	if (arguments != null) {  		foreach (var arg in arguments)  			args.Add (arg);  	}  	// Call constructor' if any  	var call = resolver.MethodCallExpression (methodRef' nameSupply' false' args);  	if (call != null)  		body.Add (new JST.ExpressionStatement (call));  	if (optBody == null)  		return new JST.StatementsPseudoExpression (new JST.Statements (body)' lvalue);  	else if (optLvalue == null)  		return lvalue;  	else  		return null;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.DelegateTypeStyle) {  	var delegateType = resolver.ResolveType (methodRef.DefiningType);  	if (arguments == null || arguments.Count == 0)  		// SPECIAL CASE: Construct empty delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' new JST.NullExpression ()' new JST.NullExpression ()' delegateType);  	else if (arguments.Count == 2)  		// SPECIAL CASE: Construct normal delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' arguments [0]' arguments [1]' delegateType);  	else  		throw new InvalidOperationException ("mismatched delegate constructor arity");  }  else if (s is CST.MultiDimArrayTypeStyle) {  	// SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime  	var methEnv = methodRef.Enter (resolver.RootEnv);  	var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;  	var elemType = resolver.ResolveType (methodRef.DefiningType.Arguments [0]);  	var lowers = new Seq<JST.Expression> ();  	var sizes = new Seq<JST.Expression> ();  	if (arguments.Count == multiDef.Rank) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (new JST.NumericLiteral (0));  			sizes.Add (arguments [i]);  		}  	}  	else if (arguments.Count == multiDef.Rank * 2) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (arguments [i * 2]);  			sizes.Add (arguments [i * 2 + 1]);  		}  	}  	else  		throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewMultiDimArray' elemType' new JST.ArrayLiteral (lowers)' new JST.ArrayLiteral (sizes));  }  else {  	if (optBody == null)  		optLvalue = null;  	var body = optBody ?? new Seq<JST.Statement> ();  	var rep = env.InteropManager.GetTypeRepresentation (null' resolver.RootEnv' methodRef.DefiningType);  	// Share type if necessary  	var defType = resolver.ResolveType (methodRef.DefiningType);  	if (!defType.IsDuplicatable) {  		var id = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (id' defType));  		defType = id.ToE ();  	}  	// Initialize an object of the right type  	var init = default(JST.Expression);  	if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)  		init = new JST.NumericLiteral (0);  	else if (s is CST.ValueTypeStyle)  		// Defer to type  		init = JST.Expression.DotCall (defType' Constants.TypeDefaultValue);  	else  		// Reference types: invoke ConstructObject function  		init = new JST.NewExpression (JST.Expression.DotCall (defType' Constants.TypeConstructObject));  	var lvalue = default(JST.Expression);  	if (optLvalue == null) {  		var objId = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (objId' init));  		lvalue = objId.ToE ();  	}  	else {  		lvalue = optLvalue;  		body.Add (JST.Statement.Assignment (lvalue' init));  	}  	var tyconEnv = methodRef.DefiningType.EnterConstructor (resolver.RootEnv);  	if (rep.NumExportsBoundToInstance > 0) {  		if (rep.State == InstanceState.ManagedOnly) {  			// This must be a 'Runtime' type' bind it's instance exports before invoking ctor  			body.Add (JST.Statement.DotCall (defType' Constants.TypeBindInstanceExports' lvalue));  		}  		else {  			// Any instance exports will be bound into instance when object is first exported  			body.Add (JST.Statement.DotAssignment (lvalue' Constants.ObjectPrepareForExport' JST.Expression.Dot (defType' Constants.TypeBindInstanceExports)));  		}  	}  	var args = new Seq<JST.Expression> ();  	if (s is CST.ValueTypeStyle) {  		// Pass pointer to constructor as 'this'  		args.Add (PointerToLvalueExpression (resolver' nameSupply' lvalue' defType));  	}  	else if (s is CST.ReferenceTypeStyle) {  		// Pass object to constructor as 'this'  		args.Add (lvalue);  	}  	else if (s is CST.ParameterTypeStyle) {  		// Make pointer' ask runtime type to conditionally dereference it' and pass  		// result as 'this'. Works regardless of whether runtime type is value or ref.  		var ptrExp = PointerToLvalueExpression (resolver' nameSupply' lvalue' defType);  		var conPtrExp = JST.Expression.DotCall (defType' Constants.TypeConditionalDeref' ptrExp);  		args.Add (conPtrExp);  	}  	else  		throw new InvalidOperationException ("cannot construct instances of this type");  	// Pass constructor arguments' if any  	if (arguments != null) {  		foreach (var arg in arguments)  			args.Add (arg);  	}  	// Call constructor' if any  	var call = resolver.MethodCallExpression (methodRef' nameSupply' false' args);  	if (call != null)  		body.Add (new JST.ExpressionStatement (call));  	if (optBody == null)  		return new JST.StatementsPseudoExpression (new JST.Statements (body)' lvalue);  	else if (optLvalue == null)  		return lvalue;  	else  		return null;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.DelegateTypeStyle) {  	var delegateType = resolver.ResolveType (methodRef.DefiningType);  	if (arguments == null || arguments.Count == 0)  		// SPECIAL CASE: Construct empty delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' new JST.NullExpression ()' new JST.NullExpression ()' delegateType);  	else if (arguments.Count == 2)  		// SPECIAL CASE: Construct normal delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' arguments [0]' arguments [1]' delegateType);  	else  		throw new InvalidOperationException ("mismatched delegate constructor arity");  }  else if (s is CST.MultiDimArrayTypeStyle) {  	// SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime  	var methEnv = methodRef.Enter (resolver.RootEnv);  	var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;  	var elemType = resolver.ResolveType (methodRef.DefiningType.Arguments [0]);  	var lowers = new Seq<JST.Expression> ();  	var sizes = new Seq<JST.Expression> ();  	if (arguments.Count == multiDef.Rank) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (new JST.NumericLiteral (0));  			sizes.Add (arguments [i]);  		}  	}  	else if (arguments.Count == multiDef.Rank * 2) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (arguments [i * 2]);  			sizes.Add (arguments [i * 2 + 1]);  		}  	}  	else  		throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewMultiDimArray' elemType' new JST.ArrayLiteral (lowers)' new JST.ArrayLiteral (sizes));  }  else {  	if (optBody == null)  		optLvalue = null;  	var body = optBody ?? new Seq<JST.Statement> ();  	var rep = env.InteropManager.GetTypeRepresentation (null' resolver.RootEnv' methodRef.DefiningType);  	// Share type if necessary  	var defType = resolver.ResolveType (methodRef.DefiningType);  	if (!defType.IsDuplicatable) {  		var id = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (id' defType));  		defType = id.ToE ();  	}  	// Initialize an object of the right type  	var init = default(JST.Expression);  	if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)  		init = new JST.NumericLiteral (0);  	else if (s is CST.ValueTypeStyle)  		// Defer to type  		init = JST.Expression.DotCall (defType' Constants.TypeDefaultValue);  	else  		// Reference types: invoke ConstructObject function  		init = new JST.NewExpression (JST.Expression.DotCall (defType' Constants.TypeConstructObject));  	var lvalue = default(JST.Expression);  	if (optLvalue == null) {  		var objId = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (objId' init));  		lvalue = objId.ToE ();  	}  	else {  		lvalue = optLvalue;  		body.Add (JST.Statement.Assignment (lvalue' init));  	}  	var tyconEnv = methodRef.DefiningType.EnterConstructor (resolver.RootEnv);  	if (rep.NumExportsBoundToInstance > 0) {  		if (rep.State == InstanceState.ManagedOnly) {  			// This must be a 'Runtime' type' bind it's instance exports before invoking ctor  			body.Add (JST.Statement.DotCall (defType' Constants.TypeBindInstanceExports' lvalue));  		}  		else {  			// Any instance exports will be bound into instance when object is first exported  			body.Add (JST.Statement.DotAssignment (lvalue' Constants.ObjectPrepareForExport' JST.Expression.Dot (defType' Constants.TypeBindInstanceExports)));  		}  	}  	var args = new Seq<JST.Expression> ();  	if (s is CST.ValueTypeStyle) {  		// Pass pointer to constructor as 'this'  		args.Add (PointerToLvalueExpression (resolver' nameSupply' lvalue' defType));  	}  	else if (s is CST.ReferenceTypeStyle) {  		// Pass object to constructor as 'this'  		args.Add (lvalue);  	}  	else if (s is CST.ParameterTypeStyle) {  		// Make pointer' ask runtime type to conditionally dereference it' and pass  		// result as 'this'. Works regardless of whether runtime type is value or ref.  		var ptrExp = PointerToLvalueExpression (resolver' nameSupply' lvalue' defType);  		var conPtrExp = JST.Expression.DotCall (defType' Constants.TypeConditionalDeref' ptrExp);  		args.Add (conPtrExp);  	}  	else  		throw new InvalidOperationException ("cannot construct instances of this type");  	// Pass constructor arguments' if any  	if (arguments != null) {  		foreach (var arg in arguments)  			args.Add (arg);  	}  	// Call constructor' if any  	var call = resolver.MethodCallExpression (methodRef' nameSupply' false' args);  	if (call != null)  		body.Add (new JST.ExpressionStatement (call));  	if (optBody == null)  		return new JST.StatementsPseudoExpression (new JST.Statements (body)' lvalue);  	else if (optLvalue == null)  		return lvalue;  	else  		return null;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.DelegateTypeStyle) {  	var delegateType = resolver.ResolveType (methodRef.DefiningType);  	if (arguments == null || arguments.Count == 0)  		// SPECIAL CASE: Construct empty delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' new JST.NullExpression ()' new JST.NullExpression ()' delegateType);  	else if (arguments.Count == 2)  		// SPECIAL CASE: Construct normal delegates directly  		return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' arguments [0]' arguments [1]' delegateType);  	else  		throw new InvalidOperationException ("mismatched delegate constructor arity");  }  else if (s is CST.MultiDimArrayTypeStyle) {  	// SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime  	var methEnv = methodRef.Enter (resolver.RootEnv);  	var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;  	var elemType = resolver.ResolveType (methodRef.DefiningType.Arguments [0]);  	var lowers = new Seq<JST.Expression> ();  	var sizes = new Seq<JST.Expression> ();  	if (arguments.Count == multiDef.Rank) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (new JST.NumericLiteral (0));  			sizes.Add (arguments [i]);  		}  	}  	else if (arguments.Count == multiDef.Rank * 2) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (arguments [i * 2]);  			sizes.Add (arguments [i * 2 + 1]);  		}  	}  	else  		throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewMultiDimArray' elemType' new JST.ArrayLiteral (lowers)' new JST.ArrayLiteral (sizes));  }  else {  	if (optBody == null)  		optLvalue = null;  	var body = optBody ?? new Seq<JST.Statement> ();  	var rep = env.InteropManager.GetTypeRepresentation (null' resolver.RootEnv' methodRef.DefiningType);  	// Share type if necessary  	var defType = resolver.ResolveType (methodRef.DefiningType);  	if (!defType.IsDuplicatable) {  		var id = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (id' defType));  		defType = id.ToE ();  	}  	// Initialize an object of the right type  	var init = default(JST.Expression);  	if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)  		init = new JST.NumericLiteral (0);  	else if (s is CST.ValueTypeStyle)  		// Defer to type  		init = JST.Expression.DotCall (defType' Constants.TypeDefaultValue);  	else  		// Reference types: invoke ConstructObject function  		init = new JST.NewExpression (JST.Expression.DotCall (defType' Constants.TypeConstructObject));  	var lvalue = default(JST.Expression);  	if (optLvalue == null) {  		var objId = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (objId' init));  		lvalue = objId.ToE ();  	}  	else {  		lvalue = optLvalue;  		body.Add (JST.Statement.Assignment (lvalue' init));  	}  	var tyconEnv = methodRef.DefiningType.EnterConstructor (resolver.RootEnv);  	if (rep.NumExportsBoundToInstance > 0) {  		if (rep.State == InstanceState.ManagedOnly) {  			// This must be a 'Runtime' type' bind it's instance exports before invoking ctor  			body.Add (JST.Statement.DotCall (defType' Constants.TypeBindInstanceExports' lvalue));  		}  		else {  			// Any instance exports will be bound into instance when object is first exported  			body.Add (JST.Statement.DotAssignment (lvalue' Constants.ObjectPrepareForExport' JST.Expression.Dot (defType' Constants.TypeBindInstanceExports)));  		}  	}  	var args = new Seq<JST.Expression> ();  	if (s is CST.ValueTypeStyle) {  		// Pass pointer to constructor as 'this'  		args.Add (PointerToLvalueExpression (resolver' nameSupply' lvalue' defType));  	}  	else if (s is CST.ReferenceTypeStyle) {  		// Pass object to constructor as 'this'  		args.Add (lvalue);  	}  	else if (s is CST.ParameterTypeStyle) {  		// Make pointer' ask runtime type to conditionally dereference it' and pass  		// result as 'this'. Works regardless of whether runtime type is value or ref.  		var ptrExp = PointerToLvalueExpression (resolver' nameSupply' lvalue' defType);  		var conPtrExp = JST.Expression.DotCall (defType' Constants.TypeConditionalDeref' ptrExp);  		args.Add (conPtrExp);  	}  	else  		throw new InvalidOperationException ("cannot construct instances of this type");  	// Pass constructor arguments' if any  	if (arguments != null) {  		foreach (var arg in arguments)  			args.Add (arg);  	}  	// Call constructor' if any  	var call = resolver.MethodCallExpression (methodRef' nameSupply' false' args);  	if (call != null)  		body.Add (new JST.ExpressionStatement (call));  	if (optBody == null)  		return new JST.StatementsPseudoExpression (new JST.Statements (body)' lvalue);  	else if (optLvalue == null)  		return lvalue;  	else  		return null;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (arguments == null || arguments.Count == 0)  	// SPECIAL CASE: Construct empty delegates directly  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' new JST.NullExpression ()' new JST.NullExpression ()' delegateType);  else if (arguments.Count == 2)  	// SPECIAL CASE: Construct normal delegates directly  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' arguments [0]' arguments [1]' delegateType);  else  	throw new InvalidOperationException ("mismatched delegate constructor arity");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (arguments.Count == 2)  	// SPECIAL CASE: Construct normal delegates directly  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewDelegate' arguments [0]' arguments [1]' delegateType);  else  	throw new InvalidOperationException ("mismatched delegate constructor arity");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.MultiDimArrayTypeStyle) {  	// SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime  	var methEnv = methodRef.Enter (resolver.RootEnv);  	var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;  	var elemType = resolver.ResolveType (methodRef.DefiningType.Arguments [0]);  	var lowers = new Seq<JST.Expression> ();  	var sizes = new Seq<JST.Expression> ();  	if (arguments.Count == multiDef.Rank) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (new JST.NumericLiteral (0));  			sizes.Add (arguments [i]);  		}  	}  	else if (arguments.Count == multiDef.Rank * 2) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (arguments [i * 2]);  			sizes.Add (arguments [i * 2 + 1]);  		}  	}  	else  		throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewMultiDimArray' elemType' new JST.ArrayLiteral (lowers)' new JST.ArrayLiteral (sizes));  }  else {  	if (optBody == null)  		optLvalue = null;  	var body = optBody ?? new Seq<JST.Statement> ();  	var rep = env.InteropManager.GetTypeRepresentation (null' resolver.RootEnv' methodRef.DefiningType);  	// Share type if necessary  	var defType = resolver.ResolveType (methodRef.DefiningType);  	if (!defType.IsDuplicatable) {  		var id = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (id' defType));  		defType = id.ToE ();  	}  	// Initialize an object of the right type  	var init = default(JST.Expression);  	if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)  		init = new JST.NumericLiteral (0);  	else if (s is CST.ValueTypeStyle)  		// Defer to type  		init = JST.Expression.DotCall (defType' Constants.TypeDefaultValue);  	else  		// Reference types: invoke ConstructObject function  		init = new JST.NewExpression (JST.Expression.DotCall (defType' Constants.TypeConstructObject));  	var lvalue = default(JST.Expression);  	if (optLvalue == null) {  		var objId = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (objId' init));  		lvalue = objId.ToE ();  	}  	else {  		lvalue = optLvalue;  		body.Add (JST.Statement.Assignment (lvalue' init));  	}  	var tyconEnv = methodRef.DefiningType.EnterConstructor (resolver.RootEnv);  	if (rep.NumExportsBoundToInstance > 0) {  		if (rep.State == InstanceState.ManagedOnly) {  			// This must be a 'Runtime' type' bind it's instance exports before invoking ctor  			body.Add (JST.Statement.DotCall (defType' Constants.TypeBindInstanceExports' lvalue));  		}  		else {  			// Any instance exports will be bound into instance when object is first exported  			body.Add (JST.Statement.DotAssignment (lvalue' Constants.ObjectPrepareForExport' JST.Expression.Dot (defType' Constants.TypeBindInstanceExports)));  		}  	}  	var args = new Seq<JST.Expression> ();  	if (s is CST.ValueTypeStyle) {  		// Pass pointer to constructor as 'this'  		args.Add (PointerToLvalueExpression (resolver' nameSupply' lvalue' defType));  	}  	else if (s is CST.ReferenceTypeStyle) {  		// Pass object to constructor as 'this'  		args.Add (lvalue);  	}  	else if (s is CST.ParameterTypeStyle) {  		// Make pointer' ask runtime type to conditionally dereference it' and pass  		// result as 'this'. Works regardless of whether runtime type is value or ref.  		var ptrExp = PointerToLvalueExpression (resolver' nameSupply' lvalue' defType);  		var conPtrExp = JST.Expression.DotCall (defType' Constants.TypeConditionalDeref' ptrExp);  		args.Add (conPtrExp);  	}  	else  		throw new InvalidOperationException ("cannot construct instances of this type");  	// Pass constructor arguments' if any  	if (arguments != null) {  		foreach (var arg in arguments)  			args.Add (arg);  	}  	// Call constructor' if any  	var call = resolver.MethodCallExpression (methodRef' nameSupply' false' args);  	if (call != null)  		body.Add (new JST.ExpressionStatement (call));  	if (optBody == null)  		return new JST.StatementsPseudoExpression (new JST.Statements (body)' lvalue);  	else if (optLvalue == null)  		return lvalue;  	else  		return null;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.MultiDimArrayTypeStyle) {  	// SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime  	var methEnv = methodRef.Enter (resolver.RootEnv);  	var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;  	var elemType = resolver.ResolveType (methodRef.DefiningType.Arguments [0]);  	var lowers = new Seq<JST.Expression> ();  	var sizes = new Seq<JST.Expression> ();  	if (arguments.Count == multiDef.Rank) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (new JST.NumericLiteral (0));  			sizes.Add (arguments [i]);  		}  	}  	else if (arguments.Count == multiDef.Rank * 2) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (arguments [i * 2]);  			sizes.Add (arguments [i * 2 + 1]);  		}  	}  	else  		throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewMultiDimArray' elemType' new JST.ArrayLiteral (lowers)' new JST.ArrayLiteral (sizes));  }  else {  	if (optBody == null)  		optLvalue = null;  	var body = optBody ?? new Seq<JST.Statement> ();  	var rep = env.InteropManager.GetTypeRepresentation (null' resolver.RootEnv' methodRef.DefiningType);  	// Share type if necessary  	var defType = resolver.ResolveType (methodRef.DefiningType);  	if (!defType.IsDuplicatable) {  		var id = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (id' defType));  		defType = id.ToE ();  	}  	// Initialize an object of the right type  	var init = default(JST.Expression);  	if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)  		init = new JST.NumericLiteral (0);  	else if (s is CST.ValueTypeStyle)  		// Defer to type  		init = JST.Expression.DotCall (defType' Constants.TypeDefaultValue);  	else  		// Reference types: invoke ConstructObject function  		init = new JST.NewExpression (JST.Expression.DotCall (defType' Constants.TypeConstructObject));  	var lvalue = default(JST.Expression);  	if (optLvalue == null) {  		var objId = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (objId' init));  		lvalue = objId.ToE ();  	}  	else {  		lvalue = optLvalue;  		body.Add (JST.Statement.Assignment (lvalue' init));  	}  	var tyconEnv = methodRef.DefiningType.EnterConstructor (resolver.RootEnv);  	if (rep.NumExportsBoundToInstance > 0) {  		if (rep.State == InstanceState.ManagedOnly) {  			// This must be a 'Runtime' type' bind it's instance exports before invoking ctor  			body.Add (JST.Statement.DotCall (defType' Constants.TypeBindInstanceExports' lvalue));  		}  		else {  			// Any instance exports will be bound into instance when object is first exported  			body.Add (JST.Statement.DotAssignment (lvalue' Constants.ObjectPrepareForExport' JST.Expression.Dot (defType' Constants.TypeBindInstanceExports)));  		}  	}  	var args = new Seq<JST.Expression> ();  	if (s is CST.ValueTypeStyle) {  		// Pass pointer to constructor as 'this'  		args.Add (PointerToLvalueExpression (resolver' nameSupply' lvalue' defType));  	}  	else if (s is CST.ReferenceTypeStyle) {  		// Pass object to constructor as 'this'  		args.Add (lvalue);  	}  	else if (s is CST.ParameterTypeStyle) {  		// Make pointer' ask runtime type to conditionally dereference it' and pass  		// result as 'this'. Works regardless of whether runtime type is value or ref.  		var ptrExp = PointerToLvalueExpression (resolver' nameSupply' lvalue' defType);  		var conPtrExp = JST.Expression.DotCall (defType' Constants.TypeConditionalDeref' ptrExp);  		args.Add (conPtrExp);  	}  	else  		throw new InvalidOperationException ("cannot construct instances of this type");  	// Pass constructor arguments' if any  	if (arguments != null) {  		foreach (var arg in arguments)  			args.Add (arg);  	}  	// Call constructor' if any  	var call = resolver.MethodCallExpression (methodRef' nameSupply' false' args);  	if (call != null)  		body.Add (new JST.ExpressionStatement (call));  	if (optBody == null)  		return new JST.StatementsPseudoExpression (new JST.Statements (body)' lvalue);  	else if (optLvalue == null)  		return lvalue;  	else  		return null;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (s is CST.MultiDimArrayTypeStyle) {  	// SPECIAL CASE: Multi-dimensional arrays are constructed by the runtime  	var methEnv = methodRef.Enter (resolver.RootEnv);  	var multiDef = (CST.MultiDimArrayTypeDef)methEnv.Type;  	var elemType = resolver.ResolveType (methodRef.DefiningType.Arguments [0]);  	var lowers = new Seq<JST.Expression> ();  	var sizes = new Seq<JST.Expression> ();  	if (arguments.Count == multiDef.Rank) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (new JST.NumericLiteral (0));  			sizes.Add (arguments [i]);  		}  	}  	else if (arguments.Count == multiDef.Rank * 2) {  		for (var i = 0; i < multiDef.Rank; i++) {  			lowers.Add (arguments [i * 2]);  			sizes.Add (arguments [i * 2 + 1]);  		}  	}  	else  		throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  	return JST.Expression.DotCall (resolver.RootId.ToE ()' Constants.RootNewMultiDimArray' elemType' new JST.ArrayLiteral (lowers)' new JST.ArrayLiteral (sizes));  }  else {  	if (optBody == null)  		optLvalue = null;  	var body = optBody ?? new Seq<JST.Statement> ();  	var rep = env.InteropManager.GetTypeRepresentation (null' resolver.RootEnv' methodRef.DefiningType);  	// Share type if necessary  	var defType = resolver.ResolveType (methodRef.DefiningType);  	if (!defType.IsDuplicatable) {  		var id = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (id' defType));  		defType = id.ToE ();  	}  	// Initialize an object of the right type  	var init = default(JST.Expression);  	if (s is CST.EnumTypeStyle || s is CST.NumberTypeStyle)  		init = new JST.NumericLiteral (0);  	else if (s is CST.ValueTypeStyle)  		// Defer to type  		init = JST.Expression.DotCall (defType' Constants.TypeDefaultValue);  	else  		// Reference types: invoke ConstructObject function  		init = new JST.NewExpression (JST.Expression.DotCall (defType' Constants.TypeConstructObject));  	var lvalue = default(JST.Expression);  	if (optLvalue == null) {  		var objId = nameSupply.GenSym ();  		body.Add (JST.Statement.Var (objId' init));  		lvalue = objId.ToE ();  	}  	else {  		lvalue = optLvalue;  		body.Add (JST.Statement.Assignment (lvalue' init));  	}  	var tyconEnv = methodRef.DefiningType.EnterConstructor (resolver.RootEnv);  	if (rep.NumExportsBoundToInstance > 0) {  		if (rep.State == InstanceState.ManagedOnly) {  			// This must be a 'Runtime' type' bind it's instance exports before invoking ctor  			body.Add (JST.Statement.DotCall (defType' Constants.TypeBindInstanceExports' lvalue));  		}  		else {  			// Any instance exports will be bound into instance when object is first exported  			body.Add (JST.Statement.DotAssignment (lvalue' Constants.ObjectPrepareForExport' JST.Expression.Dot (defType' Constants.TypeBindInstanceExports)));  		}  	}  	var args = new Seq<JST.Expression> ();  	if (s is CST.ValueTypeStyle) {  		// Pass pointer to constructor as 'this'  		args.Add (PointerToLvalueExpression (resolver' nameSupply' lvalue' defType));  	}  	else if (s is CST.ReferenceTypeStyle) {  		// Pass object to constructor as 'this'  		args.Add (lvalue);  	}  	else if (s is CST.ParameterTypeStyle) {  		// Make pointer' ask runtime type to conditionally dereference it' and pass  		// result as 'this'. Works regardless of whether runtime type is value or ref.  		var ptrExp = PointerToLvalueExpression (resolver' nameSupply' lvalue' defType);  		var conPtrExp = JST.Expression.DotCall (defType' Constants.TypeConditionalDeref' ptrExp);  		args.Add (conPtrExp);  	}  	else  		throw new InvalidOperationException ("cannot construct instances of this type");  	// Pass constructor arguments' if any  	if (arguments != null) {  		foreach (var arg in arguments)  			args.Add (arg);  	}  	// Call constructor' if any  	var call = resolver.MethodCallExpression (methodRef' nameSupply' false' args);  	if (call != null)  		body.Add (new JST.ExpressionStatement (call));  	if (optBody == null)  		return new JST.StatementsPseudoExpression (new JST.Statements (body)' lvalue);  	else if (optLvalue == null)  		return lvalue;  	else  		return null;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (arguments.Count == multiDef.Rank) {  	for (var i = 0; i < multiDef.Rank; i++) {  		lowers.Add (new JST.NumericLiteral (0));  		sizes.Add (arguments [i]);  	}  }  else if (arguments.Count == multiDef.Rank * 2) {  	for (var i = 0; i < multiDef.Rank; i++) {  		lowers.Add (arguments [i * 2]);  		sizes.Add (arguments [i * 2 + 1]);  	}  }  else  	throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (arguments.Count == multiDef.Rank) {  	for (var i = 0; i < multiDef.Rank; i++) {  		lowers.Add (new JST.NumericLiteral (0));  		sizes.Add (arguments [i]);  	}  }  else if (arguments.Count == multiDef.Rank * 2) {  	for (var i = 0; i < multiDef.Rank; i++) {  		lowers.Add (arguments [i * 2]);  		sizes.Add (arguments [i * 2 + 1]);  	}  }  else  	throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (arguments.Count == multiDef.Rank) {  	for (var i = 0; i < multiDef.Rank; i++) {  		lowers.Add (new JST.NumericLiteral (0));  		sizes.Add (arguments [i]);  	}  }  else if (arguments.Count == multiDef.Rank * 2) {  	for (var i = 0; i < multiDef.Rank; i++) {  		lowers.Add (arguments [i * 2]);  		sizes.Add (arguments [i * 2 + 1]);  	}  }  else  	throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (arguments.Count == multiDef.Rank * 2) {  	for (var i = 0; i < multiDef.Rank; i++) {  		lowers.Add (arguments [i * 2]);  		sizes.Add (arguments [i * 2 + 1]);  	}  }  else  	throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (arguments.Count == multiDef.Rank * 2) {  	for (var i = 0; i < multiDef.Rank; i++) {  		lowers.Add (arguments [i * 2]);  		sizes.Add (arguments [i * 2 + 1]);  	}  }  else  	throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: if (arguments.Count == multiDef.Rank * 2) {  	for (var i = 0; i < multiDef.Rank; i++) {  		lowers.Add (arguments [i * 2]);  		sizes.Add (arguments [i * 2 + 1]);  	}  }  else  	throw new InvalidOperationException ("invalid multi-dimensional array constructor call");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: for (var i = 0; i < multiDef.Rank; i++) {  	lowers.Add (arguments [i * 2]);  	sizes.Add (arguments [i * 2 + 1]);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: for (var i = 0; i < multiDef.Rank; i++) {  	lowers.Add (arguments [i * 2]);  	sizes.Add (arguments [i * 2 + 1]);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: lowers.Add (arguments [i * 2]);  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,ConstructorExpression,The following statement contains a magic number: sizes.Add (arguments [i * 2 + 1]);  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendInvokeImportingConstructor,The following statement contains a magic number: if (bestCtor.ValueParameters.Count == 1 && bestCtor.DefiningType.Style (typeEnv) is CST.ObjectTypeStyle) {  	// Ignore' since Object::.ctor is no-op  }  else {  	var callArgs = new Seq<JST.Expression> ();  	// this  	callArgs.Add (parameters [0].ToE ());  	if (bestCtor.ValueParameters.Count >= 2) {  		// JSContext  		callArgs.Add (unmanagedObjId.ToE ());  		if (bestCtor.ValueParameters.Count > 2) {  			// Constructor args  			for (var i = 1; i < parameters.Count; i++)  				callArgs.Add (parameters [i].ToE ());  		}  	}  	body.Add (new JST.ExpressionStatement (resolver.MethodCallExpression (bestCtor' nameSupply' false' callArgs)));  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendInvokeImportingConstructor,The following statement contains a magic number: if (bestCtor.ValueParameters.Count == 1 && bestCtor.DefiningType.Style (typeEnv) is CST.ObjectTypeStyle) {  	// Ignore' since Object::.ctor is no-op  }  else {  	var callArgs = new Seq<JST.Expression> ();  	// this  	callArgs.Add (parameters [0].ToE ());  	if (bestCtor.ValueParameters.Count >= 2) {  		// JSContext  		callArgs.Add (unmanagedObjId.ToE ());  		if (bestCtor.ValueParameters.Count > 2) {  			// Constructor args  			for (var i = 1; i < parameters.Count; i++)  				callArgs.Add (parameters [i].ToE ());  		}  	}  	body.Add (new JST.ExpressionStatement (resolver.MethodCallExpression (bestCtor' nameSupply' false' callArgs)));  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendInvokeImportingConstructor,The following statement contains a magic number: if (bestCtor.ValueParameters.Count >= 2) {  	// JSContext  	callArgs.Add (unmanagedObjId.ToE ());  	if (bestCtor.ValueParameters.Count > 2) {  		// Constructor args  		for (var i = 1; i < parameters.Count; i++)  			callArgs.Add (parameters [i].ToE ());  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendInvokeImportingConstructor,The following statement contains a magic number: if (bestCtor.ValueParameters.Count >= 2) {  	// JSContext  	callArgs.Add (unmanagedObjId.ToE ());  	if (bestCtor.ValueParameters.Count > 2) {  		// Constructor args  		for (var i = 1; i < parameters.Count; i++)  			callArgs.Add (parameters [i].ToE ());  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,JSTHelpers,C:\repos\Reactive-Extensions_IL2JS\Compiler\JSTHelpers.cs,AppendInvokeImportingConstructor,The following statement contains a magic number: if (bestCtor.ValueParameters.Count > 2) {  	// Constructor args  	for (var i = 1; i < parameters.Count; i++)  		callArgs.Add (parameters [i].ToE ());  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,HandlerLiteral,The following statement contains a magic number: switch (handler.Flavor) {  case CST.HandlerFlavor.Catch: {  	var catchh = (CST.CatchTryPseudoStatementHandler)handler;  	var exid = nameSupply.GenSym ();  	var type = methCompEnv.ResolveType (catchh.ExceptionType);  	var match = JST.Expression.IsNotNull (JST.Expression.DotCall (rootId.ToE ()' Constants.RootIsInst' exid.ToE ()' type));  	var pred = new JST.FunctionExpression (new Seq<JST.Identifier> {  		exid  	}' new JST.Statements (new JST.IfStatement (match' new JST.Statements (JST.Statement.Assignment (catchh.ExceptionId.ToE ()' exid.ToE ())' new JST.ReturnStatement (new JST.BooleanLiteral (true)))' new JST.Statements (new JST.ReturnStatement (new JST.BooleanLiteral (false))))));  	return new JST.ObjectLiteral (new OrdMap<JST.Identifier' JST.Expression> {  		{  			Constants.HandlerStyle'  			new JST.NumericLiteral (0)  		}'  		{  			Constants.HandlerTarget'  			new JST.NumericLiteral (catchh.HandlerId)  		}'  		{  			Constants.HandlerPred'  			pred  		}  	});  }  case CST.HandlerFlavor.Fault:  	return new JST.ObjectLiteral (new OrdMap<JST.Identifier' JST.Expression> {  		{  			Constants.HandlerStyle'  			new JST.NumericLiteral (1)  		}'  		{  			Constants.HandlerTarget'  			new JST.NumericLiteral (handler.HandlerId)  		}  	});  case CST.HandlerFlavor.Finally:  	return new JST.ObjectLiteral (new OrdMap<JST.Identifier' JST.Expression> {  		{  			Constants.HandlerStyle'  			new JST.NumericLiteral (2)  		}'  		{  			Constants.HandlerTarget'  			new JST.NumericLiteral (handler.HandlerId)  		}  	});  case CST.HandlerFlavor.Filter:  	throw new InvalidOperationException ("filter blocks not supported");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,MethodCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\MethodCompiler.cs,HandlerLiteral,The following statement contains a magic number: return new JST.ObjectLiteral (new OrdMap<JST.Identifier' JST.Expression> {  	{  		Constants.HandlerStyle'  		new JST.NumericLiteral (2)  	}'  	{  		Constants.HandlerTarget'  		new JST.NumericLiteral (handler.HandlerId)  	}  });  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParseCreation,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 2) {  	env.Log (new InvalidInteropMessage (ctxt' "expecting creation flag"));  	throw new DefinitionException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParseQualification,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 4) {  	env.Log (new InvalidInteropMessage (ctxt' "expecting qualification flag"));  	throw new DefinitionException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParseCasing,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 2) {  	env.Log (new InvalidInteropMessage (ctxt' "expecting casing flag"));  	throw new DefinitionException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParseInstanceState,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 3) {  	env.Log (new InvalidInteropMessage (ctxt' "expecting instance state flag"));  	throw new DefinitionException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AttributeHelper,C:\repos\Reactive-Extensions_IL2JS\Compiler\AttributeHelper.cs,ParseReflectionLevel,The following statement contains a magic number: if (oi == null || oi.Value < 0 || oi.Value > 2) {  	env.Log (new InvalidInteropMessage (ctxt' "expecting reflection level flag"));  	throw new DefinitionException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: foreach (var s in prog.Body.Body) {  	var ctxt = CompMsgContext.TraceFile (s.Loc);  	var ok = false;  	if (s.Flavor == JST.StatementFlavor.Comment)  		ok = true;  	else if (s.Flavor == JST.StatementFlavor.Expression) {  		var e = ((JST.ExpressionStatement)s).Expression;  		if (e.Flavor == JST.ExpressionFlavor.Call) {  			var call = (JST.CallExpression)e;  			if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  				var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  				var callargs = new Seq<string> ();  				ok = true;  				foreach (var a in call.Arguments) {  					if (a.Flavor == JST.ExpressionFlavor.String)  						callargs.Add (((JST.StringLiteral)a).Value);  					else  						ok = false;  				}  				if (ok) {  					var n = callargs.Count;  					if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  						AddAssembly (ctxt' callargs [0]);  					else if (callid.Equals (Constants.TraceFileType) && n == 2)  						AddType (ctxt' callargs [0]' callargs [1]);  					else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  						AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  					else  						ok = false;  				}  			}  		}  	}  	if (!ok) {  		traces.Env.Log (new InvalidTraceMessage (ctxt' "syntax error"));  		throw new ExitException ();  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: foreach (var s in prog.Body.Body) {  	var ctxt = CompMsgContext.TraceFile (s.Loc);  	var ok = false;  	if (s.Flavor == JST.StatementFlavor.Comment)  		ok = true;  	else if (s.Flavor == JST.StatementFlavor.Expression) {  		var e = ((JST.ExpressionStatement)s).Expression;  		if (e.Flavor == JST.ExpressionFlavor.Call) {  			var call = (JST.CallExpression)e;  			if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  				var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  				var callargs = new Seq<string> ();  				ok = true;  				foreach (var a in call.Arguments) {  					if (a.Flavor == JST.ExpressionFlavor.String)  						callargs.Add (((JST.StringLiteral)a).Value);  					else  						ok = false;  				}  				if (ok) {  					var n = callargs.Count;  					if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  						AddAssembly (ctxt' callargs [0]);  					else if (callid.Equals (Constants.TraceFileType) && n == 2)  						AddType (ctxt' callargs [0]' callargs [1]);  					else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  						AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  					else  						ok = false;  				}  			}  		}  	}  	if (!ok) {  		traces.Env.Log (new InvalidTraceMessage (ctxt' "syntax error"));  		throw new ExitException ();  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: foreach (var s in prog.Body.Body) {  	var ctxt = CompMsgContext.TraceFile (s.Loc);  	var ok = false;  	if (s.Flavor == JST.StatementFlavor.Comment)  		ok = true;  	else if (s.Flavor == JST.StatementFlavor.Expression) {  		var e = ((JST.ExpressionStatement)s).Expression;  		if (e.Flavor == JST.ExpressionFlavor.Call) {  			var call = (JST.CallExpression)e;  			if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  				var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  				var callargs = new Seq<string> ();  				ok = true;  				foreach (var a in call.Arguments) {  					if (a.Flavor == JST.ExpressionFlavor.String)  						callargs.Add (((JST.StringLiteral)a).Value);  					else  						ok = false;  				}  				if (ok) {  					var n = callargs.Count;  					if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  						AddAssembly (ctxt' callargs [0]);  					else if (callid.Equals (Constants.TraceFileType) && n == 2)  						AddType (ctxt' callargs [0]' callargs [1]);  					else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  						AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  					else  						ok = false;  				}  			}  		}  	}  	if (!ok) {  		traces.Env.Log (new InvalidTraceMessage (ctxt' "syntax error"));  		throw new ExitException ();  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (s.Flavor == JST.StatementFlavor.Comment)  	ok = true;  else if (s.Flavor == JST.StatementFlavor.Expression) {  	var e = ((JST.ExpressionStatement)s).Expression;  	if (e.Flavor == JST.ExpressionFlavor.Call) {  		var call = (JST.CallExpression)e;  		if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  			var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  			var callargs = new Seq<string> ();  			ok = true;  			foreach (var a in call.Arguments) {  				if (a.Flavor == JST.ExpressionFlavor.String)  					callargs.Add (((JST.StringLiteral)a).Value);  				else  					ok = false;  			}  			if (ok) {  				var n = callargs.Count;  				if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  					AddAssembly (ctxt' callargs [0]);  				else if (callid.Equals (Constants.TraceFileType) && n == 2)  					AddType (ctxt' callargs [0]' callargs [1]);  				else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  					AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  				else  					ok = false;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (s.Flavor == JST.StatementFlavor.Comment)  	ok = true;  else if (s.Flavor == JST.StatementFlavor.Expression) {  	var e = ((JST.ExpressionStatement)s).Expression;  	if (e.Flavor == JST.ExpressionFlavor.Call) {  		var call = (JST.CallExpression)e;  		if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  			var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  			var callargs = new Seq<string> ();  			ok = true;  			foreach (var a in call.Arguments) {  				if (a.Flavor == JST.ExpressionFlavor.String)  					callargs.Add (((JST.StringLiteral)a).Value);  				else  					ok = false;  			}  			if (ok) {  				var n = callargs.Count;  				if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  					AddAssembly (ctxt' callargs [0]);  				else if (callid.Equals (Constants.TraceFileType) && n == 2)  					AddType (ctxt' callargs [0]' callargs [1]);  				else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  					AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  				else  					ok = false;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (s.Flavor == JST.StatementFlavor.Comment)  	ok = true;  else if (s.Flavor == JST.StatementFlavor.Expression) {  	var e = ((JST.ExpressionStatement)s).Expression;  	if (e.Flavor == JST.ExpressionFlavor.Call) {  		var call = (JST.CallExpression)e;  		if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  			var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  			var callargs = new Seq<string> ();  			ok = true;  			foreach (var a in call.Arguments) {  				if (a.Flavor == JST.ExpressionFlavor.String)  					callargs.Add (((JST.StringLiteral)a).Value);  				else  					ok = false;  			}  			if (ok) {  				var n = callargs.Count;  				if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  					AddAssembly (ctxt' callargs [0]);  				else if (callid.Equals (Constants.TraceFileType) && n == 2)  					AddType (ctxt' callargs [0]' callargs [1]);  				else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  					AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  				else  					ok = false;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (s.Flavor == JST.StatementFlavor.Expression) {  	var e = ((JST.ExpressionStatement)s).Expression;  	if (e.Flavor == JST.ExpressionFlavor.Call) {  		var call = (JST.CallExpression)e;  		if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  			var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  			var callargs = new Seq<string> ();  			ok = true;  			foreach (var a in call.Arguments) {  				if (a.Flavor == JST.ExpressionFlavor.String)  					callargs.Add (((JST.StringLiteral)a).Value);  				else  					ok = false;  			}  			if (ok) {  				var n = callargs.Count;  				if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  					AddAssembly (ctxt' callargs [0]);  				else if (callid.Equals (Constants.TraceFileType) && n == 2)  					AddType (ctxt' callargs [0]' callargs [1]);  				else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  					AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  				else  					ok = false;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (s.Flavor == JST.StatementFlavor.Expression) {  	var e = ((JST.ExpressionStatement)s).Expression;  	if (e.Flavor == JST.ExpressionFlavor.Call) {  		var call = (JST.CallExpression)e;  		if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  			var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  			var callargs = new Seq<string> ();  			ok = true;  			foreach (var a in call.Arguments) {  				if (a.Flavor == JST.ExpressionFlavor.String)  					callargs.Add (((JST.StringLiteral)a).Value);  				else  					ok = false;  			}  			if (ok) {  				var n = callargs.Count;  				if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  					AddAssembly (ctxt' callargs [0]);  				else if (callid.Equals (Constants.TraceFileType) && n == 2)  					AddType (ctxt' callargs [0]' callargs [1]);  				else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  					AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  				else  					ok = false;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (s.Flavor == JST.StatementFlavor.Expression) {  	var e = ((JST.ExpressionStatement)s).Expression;  	if (e.Flavor == JST.ExpressionFlavor.Call) {  		var call = (JST.CallExpression)e;  		if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  			var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  			var callargs = new Seq<string> ();  			ok = true;  			foreach (var a in call.Arguments) {  				if (a.Flavor == JST.ExpressionFlavor.String)  					callargs.Add (((JST.StringLiteral)a).Value);  				else  					ok = false;  			}  			if (ok) {  				var n = callargs.Count;  				if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  					AddAssembly (ctxt' callargs [0]);  				else if (callid.Equals (Constants.TraceFileType) && n == 2)  					AddType (ctxt' callargs [0]' callargs [1]);  				else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  					AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  				else  					ok = false;  			}  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (e.Flavor == JST.ExpressionFlavor.Call) {  	var call = (JST.CallExpression)e;  	if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  		var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  		var callargs = new Seq<string> ();  		ok = true;  		foreach (var a in call.Arguments) {  			if (a.Flavor == JST.ExpressionFlavor.String)  				callargs.Add (((JST.StringLiteral)a).Value);  			else  				ok = false;  		}  		if (ok) {  			var n = callargs.Count;  			if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  				AddAssembly (ctxt' callargs [0]);  			else if (callid.Equals (Constants.TraceFileType) && n == 2)  				AddType (ctxt' callargs [0]' callargs [1]);  			else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  				AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  			else  				ok = false;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (e.Flavor == JST.ExpressionFlavor.Call) {  	var call = (JST.CallExpression)e;  	if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  		var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  		var callargs = new Seq<string> ();  		ok = true;  		foreach (var a in call.Arguments) {  			if (a.Flavor == JST.ExpressionFlavor.String)  				callargs.Add (((JST.StringLiteral)a).Value);  			else  				ok = false;  		}  		if (ok) {  			var n = callargs.Count;  			if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  				AddAssembly (ctxt' callargs [0]);  			else if (callid.Equals (Constants.TraceFileType) && n == 2)  				AddType (ctxt' callargs [0]' callargs [1]);  			else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  				AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  			else  				ok = false;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (e.Flavor == JST.ExpressionFlavor.Call) {  	var call = (JST.CallExpression)e;  	if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  		var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  		var callargs = new Seq<string> ();  		ok = true;  		foreach (var a in call.Arguments) {  			if (a.Flavor == JST.ExpressionFlavor.String)  				callargs.Add (((JST.StringLiteral)a).Value);  			else  				ok = false;  		}  		if (ok) {  			var n = callargs.Count;  			if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  				AddAssembly (ctxt' callargs [0]);  			else if (callid.Equals (Constants.TraceFileType) && n == 2)  				AddType (ctxt' callargs [0]' callargs [1]);  			else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  				AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  			else  				ok = false;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  	var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  	var callargs = new Seq<string> ();  	ok = true;  	foreach (var a in call.Arguments) {  		if (a.Flavor == JST.ExpressionFlavor.String)  			callargs.Add (((JST.StringLiteral)a).Value);  		else  			ok = false;  	}  	if (ok) {  		var n = callargs.Count;  		if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  			AddAssembly (ctxt' callargs [0]);  		else if (callid.Equals (Constants.TraceFileType) && n == 2)  			AddType (ctxt' callargs [0]' callargs [1]);  		else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  			AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  		else  			ok = false;  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  	var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  	var callargs = new Seq<string> ();  	ok = true;  	foreach (var a in call.Arguments) {  		if (a.Flavor == JST.ExpressionFlavor.String)  			callargs.Add (((JST.StringLiteral)a).Value);  		else  			ok = false;  	}  	if (ok) {  		var n = callargs.Count;  		if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  			AddAssembly (ctxt' callargs [0]);  		else if (callid.Equals (Constants.TraceFileType) && n == 2)  			AddType (ctxt' callargs [0]' callargs [1]);  		else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  			AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  		else  			ok = false;  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (call.Applicand.Flavor == JST.ExpressionFlavor.Identifier) {  	var callid = ((JST.IdentifierExpression)call.Applicand).Identifier;  	var callargs = new Seq<string> ();  	ok = true;  	foreach (var a in call.Arguments) {  		if (a.Flavor == JST.ExpressionFlavor.String)  			callargs.Add (((JST.StringLiteral)a).Value);  		else  			ok = false;  	}  	if (ok) {  		var n = callargs.Count;  		if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  			AddAssembly (ctxt' callargs [0]);  		else if (callid.Equals (Constants.TraceFileType) && n == 2)  			AddType (ctxt' callargs [0]' callargs [1]);  		else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  			AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  		else  			ok = false;  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (ok) {  	var n = callargs.Count;  	if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  		AddAssembly (ctxt' callargs [0]);  	else if (callid.Equals (Constants.TraceFileType) && n == 2)  		AddType (ctxt' callargs [0]' callargs [1]);  	else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  		AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  	else  		ok = false;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (ok) {  	var n = callargs.Count;  	if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  		AddAssembly (ctxt' callargs [0]);  	else if (callid.Equals (Constants.TraceFileType) && n == 2)  		AddType (ctxt' callargs [0]' callargs [1]);  	else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  		AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  	else  		ok = false;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (ok) {  	var n = callargs.Count;  	if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  		AddAssembly (ctxt' callargs [0]);  	else if (callid.Equals (Constants.TraceFileType) && n == 2)  		AddType (ctxt' callargs [0]' callargs [1]);  	else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  		AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  	else  		ok = false;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  	AddAssembly (ctxt' callargs [0]);  else if (callid.Equals (Constants.TraceFileType) && n == 2)  	AddType (ctxt' callargs [0]' callargs [1]);  else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  	AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  else  	ok = false;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  	AddAssembly (ctxt' callargs [0]);  else if (callid.Equals (Constants.TraceFileType) && n == 2)  	AddType (ctxt' callargs [0]' callargs [1]);  else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  	AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  else  	ok = false;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (callid.Equals (Constants.TraceFileAssembly) && n == 1)  	AddAssembly (ctxt' callargs [0]);  else if (callid.Equals (Constants.TraceFileType) && n == 2)  	AddType (ctxt' callargs [0]' callargs [1]);  else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  	AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  else  	ok = false;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (callid.Equals (Constants.TraceFileType) && n == 2)  	AddType (ctxt' callargs [0]' callargs [1]);  else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  	AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  else  	ok = false;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (callid.Equals (Constants.TraceFileType) && n == 2)  	AddType (ctxt' callargs [0]' callargs [1]);  else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  	AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  else  	ok = false;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (callid.Equals (Constants.TraceFileType) && n == 2)  	AddType (ctxt' callargs [0]' callargs [1]);  else if (callid.Equals (Constants.TraceFileMethod) && n == 3)  	AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  else  	ok = false;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (callid.Equals (Constants.TraceFileMethod) && n == 3)  	AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  else  	ok = false;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: if (callid.Equals (Constants.TraceFileMethod) && n == 3)  	AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  else  	ok = false;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,Trace,C:\repos\Reactive-Extensions_IL2JS\Compiler\Traces.cs,Load,The following statement contains a magic number: AddMethod (ctxt' callargs [0]' callargs [1]' callargs [2]);  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitVirtualAndInterfaceMethodRedirectors,The following statement contains a magic number: if (defaultArgs.Count > 2)  	body.Add (JST.Statement.DotCall (RootId.ToE ()' Constants.RootBindVirtualMethods' defaultArgs));  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitFKToHKMethodRedirectors,The following statement contains a magic number: if (args.Count > 2)  	body.Add (JST.Statement.DotCall (RootId.ToE ()' Constants.RootBindFKToHKMethodRedirectors' args));  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,The following statement contains a magic number: if (s is CST.ClassTypeStyle || s is CST.StructTypeStyle) {  	var fields = new Seq<CST.FieldRef> ();  	AccumInstanceFields (TypeCompEnv' fields);  	var trivFields = new Seq<CST.FieldRef> ();  	var nonTrivFields = new Seq<CST.FieldRef> ();  	foreach (var fieldRef in fields) {  		var fieldType = ((CST.FieldSignature)fieldRef.ExternalSignature).FieldType;  		if (Env.JSTHelpers.CloneIsNonTrivial (TypeCompEnv' fieldType))  			nonTrivFields.Add (fieldRef);  		else  			trivFields.Add (fieldRef);  	}  	if (nonTrivFields.Count > 0) {  		var innerTypeCompEnv = TypeCompEnv.EnterFunction ();  		var parameters = new Seq<JST.Identifier> ();  		parameters.Add (innerTypeCompEnv.NameSupply.GenSym ());  		var oldObj = parameters [0].ToE ();  		var innerBody = new Seq<JST.Statement> ();  		var usage = new CST.Usage ();  		foreach (var fieldRef in nonTrivFields)  			fieldRef.ExternalFieldType.AccumUsage (usage' true);  		innerTypeCompEnv.BindUsage (innerBody' usage' TypePhase.Constructed);  		var newObjId = innerTypeCompEnv.NameSupply.GenSym ();  		if (s is CST.ClassTypeStyle)  			// Reference type' object Id is allocated lazily  			innerBody.Add (JST.Statement.Var (newObjId' JST.Expression.DotCall (TypeId.ToE ()' Constants.TypeConstructObject)));  		else  			// Value type  			innerBody.Add (JST.Statement.Var (newObjId' new JST.ObjectLiteral ()));  		var newObj = newObjId.ToE ();  		// Explicity clone non-trivial fields  		foreach (var fieldRef in nonTrivFields) {  			var fieldId = Env.JSTHelpers.ResolveFieldToIdentifier (innerTypeCompEnv' fieldRef' false);  			innerBody.Add (JST.Statement.DotAssignment (newObj' fieldId' Env.JSTHelpers.CloneExpressionForType (innerTypeCompEnv' fieldRef.ExternalFieldType' JST.Expression.Dot (oldObj' fieldId))));  		}  		if (trivFields.Count < 3) {  			// Explicity copy the remaining trivial fields  			foreach (var fieldRef in trivFields) {  				var fieldId = Env.JSTHelpers.ResolveFieldToIdentifier (innerTypeCompEnv' fieldRef' false);  				innerBody.Add (JST.Statement.DotAssignment (newObj' fieldId' JST.Expression.Dot (oldObj' fieldId)));  			}  		}  		else {  			// Generically copy the remaining trivial fields  			innerBody.Add (JST.Statement.DotCall (RootId.ToE ()' Constants.RootInheritProperties' newObj' oldObj));  		}  		innerBody.Add (new JST.ReturnStatement (newObj));  		body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeMemberwiseClone' new JST.FunctionExpression (parameters' new JST.Statements (innerBody))));  	}  	else {  		// default generic clone with no inner cloning is ok  		return;  	}  }  else {  	var innerNameSupply = NameSupply.Fork ();  	var parameters = new Seq<JST.Identifier> ();  	parameters.Add (innerNameSupply.GenSym ());  	var oldObj = parameters [0].ToE ();  	var innerBody = new Seq<JST.Statement> ();  	if (s is CST.VoidTypeStyle) {  		innerBody.Add (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidOperationException)));  	}  	else if (s is CST.ArrayTypeStyle) {  		var newObjId = innerNameSupply.GenSym ();  		innerBody.Add (JST.Statement.Var (newObjId' new JST.NewExpression (new JST.CallExpression (Constants.Array.ToE ()' JST.Expression.Dot (oldObj' Constants.length)))));  		innerBody.Add (JST.Statement.DotAssignment (newObjId.ToE ()' Constants.ObjectType' TypeId.ToE ()));  		// Object Id is allocated lazily  		var iId = innerNameSupply.GenSym ();  		var loopClause = new JST.ForVarLoopClause (iId' new JST.BinaryExpression (iId.ToE ()' JST.BinaryOp.LessThan' JST.Expression.Dot (oldObj' Constants.length))' new JST.UnaryExpression (iId.ToE ()' JST.UnaryOp.PostIncrement));  		var loopBody = JST.Statement.IndexAssignment (newObjId.ToE ()' iId.ToE ()' Env.JSTHelpers.CloneExpressionForType (TypeCompEnv' TypeCompEnv.TypeBoundArguments [0]' new JST.IndexExpression (oldObj' iId.ToE ())));  		innerBody.Add (new JST.ForStatement (loopClause' new JST.Statements (loopBody)));  		innerBody.Add (new JST.ReturnStatement (newObjId.ToE ()));  	}  	else if (s is CST.NullableTypeStyle) {  		innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (oldObj)' new JST.Statements (new JST.ReturnStatement (new JST.NullExpression ()))' new JST.Statements (new JST.ReturnStatement (Env.JSTHelpers.CloneExpressionForType (TypeCompEnv' TypeCompEnv.TypeBoundArguments [0]' oldObj)))));  	}  	else {  		innerBody.Add (new JST.ReturnStatement (oldObj));  	}  	body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeMemberwiseClone' new JST.FunctionExpression (parameters' new JST.Statements (innerBody))));  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,The following statement contains a magic number: if (nonTrivFields.Count > 0) {  	var innerTypeCompEnv = TypeCompEnv.EnterFunction ();  	var parameters = new Seq<JST.Identifier> ();  	parameters.Add (innerTypeCompEnv.NameSupply.GenSym ());  	var oldObj = parameters [0].ToE ();  	var innerBody = new Seq<JST.Statement> ();  	var usage = new CST.Usage ();  	foreach (var fieldRef in nonTrivFields)  		fieldRef.ExternalFieldType.AccumUsage (usage' true);  	innerTypeCompEnv.BindUsage (innerBody' usage' TypePhase.Constructed);  	var newObjId = innerTypeCompEnv.NameSupply.GenSym ();  	if (s is CST.ClassTypeStyle)  		// Reference type' object Id is allocated lazily  		innerBody.Add (JST.Statement.Var (newObjId' JST.Expression.DotCall (TypeId.ToE ()' Constants.TypeConstructObject)));  	else  		// Value type  		innerBody.Add (JST.Statement.Var (newObjId' new JST.ObjectLiteral ()));  	var newObj = newObjId.ToE ();  	// Explicity clone non-trivial fields  	foreach (var fieldRef in nonTrivFields) {  		var fieldId = Env.JSTHelpers.ResolveFieldToIdentifier (innerTypeCompEnv' fieldRef' false);  		innerBody.Add (JST.Statement.DotAssignment (newObj' fieldId' Env.JSTHelpers.CloneExpressionForType (innerTypeCompEnv' fieldRef.ExternalFieldType' JST.Expression.Dot (oldObj' fieldId))));  	}  	if (trivFields.Count < 3) {  		// Explicity copy the remaining trivial fields  		foreach (var fieldRef in trivFields) {  			var fieldId = Env.JSTHelpers.ResolveFieldToIdentifier (innerTypeCompEnv' fieldRef' false);  			innerBody.Add (JST.Statement.DotAssignment (newObj' fieldId' JST.Expression.Dot (oldObj' fieldId)));  		}  	}  	else {  		// Generically copy the remaining trivial fields  		innerBody.Add (JST.Statement.DotCall (RootId.ToE ()' Constants.RootInheritProperties' newObj' oldObj));  	}  	innerBody.Add (new JST.ReturnStatement (newObj));  	body.Add (JST.Statement.DotAssignment (lhs' Constants.TypeMemberwiseClone' new JST.FunctionExpression (parameters' new JST.Statements (innerBody))));  }  else {  	// default generic clone with no inner cloning is ok  	return;  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitMemberwiseClone,The following statement contains a magic number: if (trivFields.Count < 3) {  	// Explicity copy the remaining trivial fields  	foreach (var fieldRef in trivFields) {  		var fieldId = Env.JSTHelpers.ResolveFieldToIdentifier (innerTypeCompEnv' fieldRef' false);  		innerBody.Add (JST.Statement.DotAssignment (newObj' fieldId' JST.Expression.Dot (oldObj' fieldId)));  	}  }  else {  	// Generically copy the remaining trivial fields  	innerBody.Add (JST.Statement.DotCall (RootId.ToE ()' Constants.RootInheritProperties' newObj' oldObj));  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: if (s is CST.VoidTypeStyle || s is CST.ManagedPointerTypeStyle)  	innerBody.Add (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidOperationException)));  else if (s is CST.NumberTypeStyle || s is CST.EnumTypeStyle || TypeCompEnv.TypeRef.Equals (Env.Global.DecimalRef))  	innerBody.Add (new JST.ReturnStatement (obj));  else if (s is CST.HandleTypeStyle) {  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var objid = JST.Expression.Dot (obj' Constants.ObjectId);  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (objid)' new JST.Statements (JST.Statement.Assignment (objid' new JST.UnaryExpression (JST.Expression.Dot (RootId.ToE ()' Constants.RootNextObjectId)' JST.UnaryOp.PostIncrement)))));  	innerBody.Add (new JST.ReturnStatement (objid));  }  else if (s is CST.NullableTypeStyle) {  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	innerBody.Add (new JST.ReturnStatement (JST.Expression.DotCall (TypeCompEnv.ResolveType (TypeCompEnv.TypeBoundArguments [0]' TypePhase.Slots)' Constants.TypeHash' obj)));  }  else if (s is CST.StructTypeStyle) {  	var hashId = innerNameSupply.GenSym ();  	innerBody.Add (JST.Statement.Var (hashId' new JST.NumericLiteral (0)));  	var hash = hashId.ToE ();  	foreach (var fieldDef in Parent.Fields.Where (f => !f.IsStatic)) {  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28)))));  		var fieldRef = new CST.FieldRef (TypeCompEnv.TypeRef' fieldDef.FieldSignature);  		var field = Env.JSTHelpers.ResolveInstanceField (TypeCompEnv' obj' fieldRef);  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (hash' JST.BinaryOp.BitwiseXOR' JST.Expression.DotCall (TypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Slots)' Constants.TypeHash' field))));  	}  	innerBody.Add (new JST.ReturnStatement (hash));  }  else if (s is CST.ObjectTypeStyle) {  	// NOTE: CLR Bizzarism: IEquatable<T> does not provide a GetHashCode' thus a  	//       default EqualityComparer<T> when T has IEquatable<T> will use the IEquatable  	//       Equals but the Object GetHashCode. Go figure.  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var getHashCodeRef = new CST.MethodRef (Env.Global.ObjectRef' "GetHashCode"' false' null' new Seq<CST.TypeRef> {  		Env.Global.ObjectRef  	}' Env.Global.Int32Ref);  	var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression (TypeCompEnv' innerNameSupply' innerBody' getHashCodeRef' new Seq<JST.Expression> {  		obj  	});  	innerBody.Add (new JST.ReturnStatement (call));  }  else  	// Default is ok  	return;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: if (s is CST.VoidTypeStyle || s is CST.ManagedPointerTypeStyle)  	innerBody.Add (new JST.ThrowStatement (JST.Expression.DotCall (RootId.ToE ()' Constants.RootInvalidOperationException)));  else if (s is CST.NumberTypeStyle || s is CST.EnumTypeStyle || TypeCompEnv.TypeRef.Equals (Env.Global.DecimalRef))  	innerBody.Add (new JST.ReturnStatement (obj));  else if (s is CST.HandleTypeStyle) {  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var objid = JST.Expression.Dot (obj' Constants.ObjectId);  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (objid)' new JST.Statements (JST.Statement.Assignment (objid' new JST.UnaryExpression (JST.Expression.Dot (RootId.ToE ()' Constants.RootNextObjectId)' JST.UnaryOp.PostIncrement)))));  	innerBody.Add (new JST.ReturnStatement (objid));  }  else if (s is CST.NullableTypeStyle) {  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	innerBody.Add (new JST.ReturnStatement (JST.Expression.DotCall (TypeCompEnv.ResolveType (TypeCompEnv.TypeBoundArguments [0]' TypePhase.Slots)' Constants.TypeHash' obj)));  }  else if (s is CST.StructTypeStyle) {  	var hashId = innerNameSupply.GenSym ();  	innerBody.Add (JST.Statement.Var (hashId' new JST.NumericLiteral (0)));  	var hash = hashId.ToE ();  	foreach (var fieldDef in Parent.Fields.Where (f => !f.IsStatic)) {  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28)))));  		var fieldRef = new CST.FieldRef (TypeCompEnv.TypeRef' fieldDef.FieldSignature);  		var field = Env.JSTHelpers.ResolveInstanceField (TypeCompEnv' obj' fieldRef);  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (hash' JST.BinaryOp.BitwiseXOR' JST.Expression.DotCall (TypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Slots)' Constants.TypeHash' field))));  	}  	innerBody.Add (new JST.ReturnStatement (hash));  }  else if (s is CST.ObjectTypeStyle) {  	// NOTE: CLR Bizzarism: IEquatable<T> does not provide a GetHashCode' thus a  	//       default EqualityComparer<T> when T has IEquatable<T> will use the IEquatable  	//       Equals but the Object GetHashCode. Go figure.  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var getHashCodeRef = new CST.MethodRef (Env.Global.ObjectRef' "GetHashCode"' false' null' new Seq<CST.TypeRef> {  		Env.Global.ObjectRef  	}' Env.Global.Int32Ref);  	var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression (TypeCompEnv' innerNameSupply' innerBody' getHashCodeRef' new Seq<JST.Expression> {  		obj  	});  	innerBody.Add (new JST.ReturnStatement (call));  }  else  	// Default is ok  	return;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: if (s is CST.NumberTypeStyle || s is CST.EnumTypeStyle || TypeCompEnv.TypeRef.Equals (Env.Global.DecimalRef))  	innerBody.Add (new JST.ReturnStatement (obj));  else if (s is CST.HandleTypeStyle) {  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var objid = JST.Expression.Dot (obj' Constants.ObjectId);  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (objid)' new JST.Statements (JST.Statement.Assignment (objid' new JST.UnaryExpression (JST.Expression.Dot (RootId.ToE ()' Constants.RootNextObjectId)' JST.UnaryOp.PostIncrement)))));  	innerBody.Add (new JST.ReturnStatement (objid));  }  else if (s is CST.NullableTypeStyle) {  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	innerBody.Add (new JST.ReturnStatement (JST.Expression.DotCall (TypeCompEnv.ResolveType (TypeCompEnv.TypeBoundArguments [0]' TypePhase.Slots)' Constants.TypeHash' obj)));  }  else if (s is CST.StructTypeStyle) {  	var hashId = innerNameSupply.GenSym ();  	innerBody.Add (JST.Statement.Var (hashId' new JST.NumericLiteral (0)));  	var hash = hashId.ToE ();  	foreach (var fieldDef in Parent.Fields.Where (f => !f.IsStatic)) {  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28)))));  		var fieldRef = new CST.FieldRef (TypeCompEnv.TypeRef' fieldDef.FieldSignature);  		var field = Env.JSTHelpers.ResolveInstanceField (TypeCompEnv' obj' fieldRef);  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (hash' JST.BinaryOp.BitwiseXOR' JST.Expression.DotCall (TypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Slots)' Constants.TypeHash' field))));  	}  	innerBody.Add (new JST.ReturnStatement (hash));  }  else if (s is CST.ObjectTypeStyle) {  	// NOTE: CLR Bizzarism: IEquatable<T> does not provide a GetHashCode' thus a  	//       default EqualityComparer<T> when T has IEquatable<T> will use the IEquatable  	//       Equals but the Object GetHashCode. Go figure.  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var getHashCodeRef = new CST.MethodRef (Env.Global.ObjectRef' "GetHashCode"' false' null' new Seq<CST.TypeRef> {  		Env.Global.ObjectRef  	}' Env.Global.Int32Ref);  	var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression (TypeCompEnv' innerNameSupply' innerBody' getHashCodeRef' new Seq<JST.Expression> {  		obj  	});  	innerBody.Add (new JST.ReturnStatement (call));  }  else  	// Default is ok  	return;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: if (s is CST.NumberTypeStyle || s is CST.EnumTypeStyle || TypeCompEnv.TypeRef.Equals (Env.Global.DecimalRef))  	innerBody.Add (new JST.ReturnStatement (obj));  else if (s is CST.HandleTypeStyle) {  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var objid = JST.Expression.Dot (obj' Constants.ObjectId);  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (objid)' new JST.Statements (JST.Statement.Assignment (objid' new JST.UnaryExpression (JST.Expression.Dot (RootId.ToE ()' Constants.RootNextObjectId)' JST.UnaryOp.PostIncrement)))));  	innerBody.Add (new JST.ReturnStatement (objid));  }  else if (s is CST.NullableTypeStyle) {  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	innerBody.Add (new JST.ReturnStatement (JST.Expression.DotCall (TypeCompEnv.ResolveType (TypeCompEnv.TypeBoundArguments [0]' TypePhase.Slots)' Constants.TypeHash' obj)));  }  else if (s is CST.StructTypeStyle) {  	var hashId = innerNameSupply.GenSym ();  	innerBody.Add (JST.Statement.Var (hashId' new JST.NumericLiteral (0)));  	var hash = hashId.ToE ();  	foreach (var fieldDef in Parent.Fields.Where (f => !f.IsStatic)) {  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28)))));  		var fieldRef = new CST.FieldRef (TypeCompEnv.TypeRef' fieldDef.FieldSignature);  		var field = Env.JSTHelpers.ResolveInstanceField (TypeCompEnv' obj' fieldRef);  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (hash' JST.BinaryOp.BitwiseXOR' JST.Expression.DotCall (TypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Slots)' Constants.TypeHash' field))));  	}  	innerBody.Add (new JST.ReturnStatement (hash));  }  else if (s is CST.ObjectTypeStyle) {  	// NOTE: CLR Bizzarism: IEquatable<T> does not provide a GetHashCode' thus a  	//       default EqualityComparer<T> when T has IEquatable<T> will use the IEquatable  	//       Equals but the Object GetHashCode. Go figure.  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var getHashCodeRef = new CST.MethodRef (Env.Global.ObjectRef' "GetHashCode"' false' null' new Seq<CST.TypeRef> {  		Env.Global.ObjectRef  	}' Env.Global.Int32Ref);  	var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression (TypeCompEnv' innerNameSupply' innerBody' getHashCodeRef' new Seq<JST.Expression> {  		obj  	});  	innerBody.Add (new JST.ReturnStatement (call));  }  else  	// Default is ok  	return;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: if (s is CST.HandleTypeStyle) {  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var objid = JST.Expression.Dot (obj' Constants.ObjectId);  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (objid)' new JST.Statements (JST.Statement.Assignment (objid' new JST.UnaryExpression (JST.Expression.Dot (RootId.ToE ()' Constants.RootNextObjectId)' JST.UnaryOp.PostIncrement)))));  	innerBody.Add (new JST.ReturnStatement (objid));  }  else if (s is CST.NullableTypeStyle) {  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	innerBody.Add (new JST.ReturnStatement (JST.Expression.DotCall (TypeCompEnv.ResolveType (TypeCompEnv.TypeBoundArguments [0]' TypePhase.Slots)' Constants.TypeHash' obj)));  }  else if (s is CST.StructTypeStyle) {  	var hashId = innerNameSupply.GenSym ();  	innerBody.Add (JST.Statement.Var (hashId' new JST.NumericLiteral (0)));  	var hash = hashId.ToE ();  	foreach (var fieldDef in Parent.Fields.Where (f => !f.IsStatic)) {  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28)))));  		var fieldRef = new CST.FieldRef (TypeCompEnv.TypeRef' fieldDef.FieldSignature);  		var field = Env.JSTHelpers.ResolveInstanceField (TypeCompEnv' obj' fieldRef);  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (hash' JST.BinaryOp.BitwiseXOR' JST.Expression.DotCall (TypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Slots)' Constants.TypeHash' field))));  	}  	innerBody.Add (new JST.ReturnStatement (hash));  }  else if (s is CST.ObjectTypeStyle) {  	// NOTE: CLR Bizzarism: IEquatable<T> does not provide a GetHashCode' thus a  	//       default EqualityComparer<T> when T has IEquatable<T> will use the IEquatable  	//       Equals but the Object GetHashCode. Go figure.  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var getHashCodeRef = new CST.MethodRef (Env.Global.ObjectRef' "GetHashCode"' false' null' new Seq<CST.TypeRef> {  		Env.Global.ObjectRef  	}' Env.Global.Int32Ref);  	var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression (TypeCompEnv' innerNameSupply' innerBody' getHashCodeRef' new Seq<JST.Expression> {  		obj  	});  	innerBody.Add (new JST.ReturnStatement (call));  }  else  	// Default is ok  	return;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: if (s is CST.HandleTypeStyle) {  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var objid = JST.Expression.Dot (obj' Constants.ObjectId);  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (objid)' new JST.Statements (JST.Statement.Assignment (objid' new JST.UnaryExpression (JST.Expression.Dot (RootId.ToE ()' Constants.RootNextObjectId)' JST.UnaryOp.PostIncrement)))));  	innerBody.Add (new JST.ReturnStatement (objid));  }  else if (s is CST.NullableTypeStyle) {  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	innerBody.Add (new JST.ReturnStatement (JST.Expression.DotCall (TypeCompEnv.ResolveType (TypeCompEnv.TypeBoundArguments [0]' TypePhase.Slots)' Constants.TypeHash' obj)));  }  else if (s is CST.StructTypeStyle) {  	var hashId = innerNameSupply.GenSym ();  	innerBody.Add (JST.Statement.Var (hashId' new JST.NumericLiteral (0)));  	var hash = hashId.ToE ();  	foreach (var fieldDef in Parent.Fields.Where (f => !f.IsStatic)) {  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28)))));  		var fieldRef = new CST.FieldRef (TypeCompEnv.TypeRef' fieldDef.FieldSignature);  		var field = Env.JSTHelpers.ResolveInstanceField (TypeCompEnv' obj' fieldRef);  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (hash' JST.BinaryOp.BitwiseXOR' JST.Expression.DotCall (TypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Slots)' Constants.TypeHash' field))));  	}  	innerBody.Add (new JST.ReturnStatement (hash));  }  else if (s is CST.ObjectTypeStyle) {  	// NOTE: CLR Bizzarism: IEquatable<T> does not provide a GetHashCode' thus a  	//       default EqualityComparer<T> when T has IEquatable<T> will use the IEquatable  	//       Equals but the Object GetHashCode. Go figure.  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var getHashCodeRef = new CST.MethodRef (Env.Global.ObjectRef' "GetHashCode"' false' null' new Seq<CST.TypeRef> {  		Env.Global.ObjectRef  	}' Env.Global.Int32Ref);  	var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression (TypeCompEnv' innerNameSupply' innerBody' getHashCodeRef' new Seq<JST.Expression> {  		obj  	});  	innerBody.Add (new JST.ReturnStatement (call));  }  else  	// Default is ok  	return;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: if (s is CST.NullableTypeStyle) {  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	innerBody.Add (new JST.ReturnStatement (JST.Expression.DotCall (TypeCompEnv.ResolveType (TypeCompEnv.TypeBoundArguments [0]' TypePhase.Slots)' Constants.TypeHash' obj)));  }  else if (s is CST.StructTypeStyle) {  	var hashId = innerNameSupply.GenSym ();  	innerBody.Add (JST.Statement.Var (hashId' new JST.NumericLiteral (0)));  	var hash = hashId.ToE ();  	foreach (var fieldDef in Parent.Fields.Where (f => !f.IsStatic)) {  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28)))));  		var fieldRef = new CST.FieldRef (TypeCompEnv.TypeRef' fieldDef.FieldSignature);  		var field = Env.JSTHelpers.ResolveInstanceField (TypeCompEnv' obj' fieldRef);  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (hash' JST.BinaryOp.BitwiseXOR' JST.Expression.DotCall (TypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Slots)' Constants.TypeHash' field))));  	}  	innerBody.Add (new JST.ReturnStatement (hash));  }  else if (s is CST.ObjectTypeStyle) {  	// NOTE: CLR Bizzarism: IEquatable<T> does not provide a GetHashCode' thus a  	//       default EqualityComparer<T> when T has IEquatable<T> will use the IEquatable  	//       Equals but the Object GetHashCode. Go figure.  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var getHashCodeRef = new CST.MethodRef (Env.Global.ObjectRef' "GetHashCode"' false' null' new Seq<CST.TypeRef> {  		Env.Global.ObjectRef  	}' Env.Global.Int32Ref);  	var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression (TypeCompEnv' innerNameSupply' innerBody' getHashCodeRef' new Seq<JST.Expression> {  		obj  	});  	innerBody.Add (new JST.ReturnStatement (call));  }  else  	// Default is ok  	return;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: if (s is CST.NullableTypeStyle) {  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	innerBody.Add (new JST.ReturnStatement (JST.Expression.DotCall (TypeCompEnv.ResolveType (TypeCompEnv.TypeBoundArguments [0]' TypePhase.Slots)' Constants.TypeHash' obj)));  }  else if (s is CST.StructTypeStyle) {  	var hashId = innerNameSupply.GenSym ();  	innerBody.Add (JST.Statement.Var (hashId' new JST.NumericLiteral (0)));  	var hash = hashId.ToE ();  	foreach (var fieldDef in Parent.Fields.Where (f => !f.IsStatic)) {  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28)))));  		var fieldRef = new CST.FieldRef (TypeCompEnv.TypeRef' fieldDef.FieldSignature);  		var field = Env.JSTHelpers.ResolveInstanceField (TypeCompEnv' obj' fieldRef);  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (hash' JST.BinaryOp.BitwiseXOR' JST.Expression.DotCall (TypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Slots)' Constants.TypeHash' field))));  	}  	innerBody.Add (new JST.ReturnStatement (hash));  }  else if (s is CST.ObjectTypeStyle) {  	// NOTE: CLR Bizzarism: IEquatable<T> does not provide a GetHashCode' thus a  	//       default EqualityComparer<T> when T has IEquatable<T> will use the IEquatable  	//       Equals but the Object GetHashCode. Go figure.  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var getHashCodeRef = new CST.MethodRef (Env.Global.ObjectRef' "GetHashCode"' false' null' new Seq<CST.TypeRef> {  		Env.Global.ObjectRef  	}' Env.Global.Int32Ref);  	var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression (TypeCompEnv' innerNameSupply' innerBody' getHashCodeRef' new Seq<JST.Expression> {  		obj  	});  	innerBody.Add (new JST.ReturnStatement (call));  }  else  	// Default is ok  	return;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: if (s is CST.StructTypeStyle) {  	var hashId = innerNameSupply.GenSym ();  	innerBody.Add (JST.Statement.Var (hashId' new JST.NumericLiteral (0)));  	var hash = hashId.ToE ();  	foreach (var fieldDef in Parent.Fields.Where (f => !f.IsStatic)) {  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28)))));  		var fieldRef = new CST.FieldRef (TypeCompEnv.TypeRef' fieldDef.FieldSignature);  		var field = Env.JSTHelpers.ResolveInstanceField (TypeCompEnv' obj' fieldRef);  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (hash' JST.BinaryOp.BitwiseXOR' JST.Expression.DotCall (TypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Slots)' Constants.TypeHash' field))));  	}  	innerBody.Add (new JST.ReturnStatement (hash));  }  else if (s is CST.ObjectTypeStyle) {  	// NOTE: CLR Bizzarism: IEquatable<T> does not provide a GetHashCode' thus a  	//       default EqualityComparer<T> when T has IEquatable<T> will use the IEquatable  	//       Equals but the Object GetHashCode. Go figure.  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var getHashCodeRef = new CST.MethodRef (Env.Global.ObjectRef' "GetHashCode"' false' null' new Seq<CST.TypeRef> {  		Env.Global.ObjectRef  	}' Env.Global.Int32Ref);  	var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression (TypeCompEnv' innerNameSupply' innerBody' getHashCodeRef' new Seq<JST.Expression> {  		obj  	});  	innerBody.Add (new JST.ReturnStatement (call));  }  else  	// Default is ok  	return;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: if (s is CST.StructTypeStyle) {  	var hashId = innerNameSupply.GenSym ();  	innerBody.Add (JST.Statement.Var (hashId' new JST.NumericLiteral (0)));  	var hash = hashId.ToE ();  	foreach (var fieldDef in Parent.Fields.Where (f => !f.IsStatic)) {  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28)))));  		var fieldRef = new CST.FieldRef (TypeCompEnv.TypeRef' fieldDef.FieldSignature);  		var field = Env.JSTHelpers.ResolveInstanceField (TypeCompEnv' obj' fieldRef);  		innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (hash' JST.BinaryOp.BitwiseXOR' JST.Expression.DotCall (TypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Slots)' Constants.TypeHash' field))));  	}  	innerBody.Add (new JST.ReturnStatement (hash));  }  else if (s is CST.ObjectTypeStyle) {  	// NOTE: CLR Bizzarism: IEquatable<T> does not provide a GetHashCode' thus a  	//       default EqualityComparer<T> when T has IEquatable<T> will use the IEquatable  	//       Equals but the Object GetHashCode. Go figure.  	innerBody.Add (new JST.IfStatement (JST.Expression.IsNull (obj)' new JST.Statements (new JST.ReturnStatement (new JST.NumericLiteral (0)))));  	var getHashCodeRef = new CST.MethodRef (Env.Global.ObjectRef' "GetHashCode"' false' null' new Seq<CST.TypeRef> {  		Env.Global.ObjectRef  	}' Env.Global.Int32Ref);  	var call = Env.JSTHelpers.DefaultVirtualMethodCallExpression (TypeCompEnv' innerNameSupply' innerBody' getHashCodeRef' new Seq<JST.Expression> {  		obj  	});  	innerBody.Add (new JST.ReturnStatement (call));  }  else  	// Default is ok  	return;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: foreach (var fieldDef in Parent.Fields.Where (f => !f.IsStatic)) {  	innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28)))));  	var fieldRef = new CST.FieldRef (TypeCompEnv.TypeRef' fieldDef.FieldSignature);  	var field = Env.JSTHelpers.ResolveInstanceField (TypeCompEnv' obj' fieldRef);  	innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (hash' JST.BinaryOp.BitwiseXOR' JST.Expression.DotCall (TypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Slots)' Constants.TypeHash' field))));  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: foreach (var fieldDef in Parent.Fields.Where (f => !f.IsStatic)) {  	innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28)))));  	var fieldRef = new CST.FieldRef (TypeCompEnv.TypeRef' fieldDef.FieldSignature);  	var field = Env.JSTHelpers.ResolveInstanceField (TypeCompEnv' obj' fieldRef);  	innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (hash' JST.BinaryOp.BitwiseXOR' JST.Expression.DotCall (TypeCompEnv.ResolveType (fieldDef.FieldType' TypePhase.Slots)' Constants.TypeHash' field))));  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28)))));  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,EmitHash,The following statement contains a magic number: innerBody.Add (JST.Statement.Assignment (hash' new JST.BinaryExpression (new JST.BinaryExpression (hash' JST.BinaryOp.LeftShift' new JST.NumericLiteral (3))' JST.BinaryOp.BitwiseOR' new JST.BinaryExpression (hash' JST.BinaryOp.UnsignedRightShift' new JST.NumericLiteral (28)))));  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The following statement contains a magic number: foreach (var kv in attr.NamedProperties) {  	var stmnt = default(JST.Statement);  	foreach (var memberDef in attrTypeEnv.Type.Members.Where (m => !m.IsStatic && m.Name.Equals (kv.Key' StringComparison.Ordinal))) {  		switch (memberDef.Flavor) {  		case CST.MemberDefFlavor.Field: {  			var fieldDef = (CST.FieldDef)memberDef;  			if (fieldDef.Invalid == null && fieldDef.IsUsed) {  				var t = attrTypeEnv.SubstituteType (fieldDef.FieldType);  				var o = kv.Value;  				var e = Env.JSTHelpers.InitializerExpression (innerTypeCompEnv' ctxt' o' t);  				var slot = Env.GlobalMapping.ResolveFieldDefToSlot (attrTypeEnv.Assembly' attrTypeEnv.Type' fieldDef);  				stmnt = JST.Statement.DotAssignment (id.ToE ()' new JST.Identifier (Constants.ObjectInstanceFieldSlot (slot))' e);  			}  			break;  		}  		case CST.MemberDefFlavor.Property: {  			var propDef = (CST.PropertyDef)memberDef;  			if (propDef.Invalid == null) {  				var t = attrTypeEnv.SubstituteType (propDef.FieldType);  				var o = kv.Value;  				var e = Env.JSTHelpers.InitializerExpression (innerTypeCompEnv' ctxt' o' t);  				if (propDef.Set != null) {  					var setMethodDef = attrTypeEnv.Type.ResolveMethod (propDef.Set);  					if (setMethodDef != null && setMethodDef.Invalid == null && setMethodDef.IsUsed && setMethodDef.Arity == 2 && !Env.InlinedMethods.IsInlinable (innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' setMethodDef)) {  						var setMethodRef = new CST.MethodRef (attr.Type' setMethodDef.MethodSignature' null);  						stmnt = new JST.ExpressionStatement (innerTypeCompEnv.MethodCallExpression (setMethodRef' innerTypeCompEnv.NameSupply' false' new Seq<JST.Expression> (id.ToE ()' e)));  					}  				}  			}  			break;  		}  		case CST.MemberDefFlavor.Method:  		case CST.MemberDefFlavor.Event:  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	if (stmnt == null) {  		Env.Log (new UnimplementableFeatureMessage (ctxt' "custom attribute"' String.Format ("Type '{0}' does not have a field or set-able property for named parameter '{1}'"' kv.Key)));  	}  	else  		body.Add (stmnt);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The following statement contains a magic number: foreach (var memberDef in attrTypeEnv.Type.Members.Where (m => !m.IsStatic && m.Name.Equals (kv.Key' StringComparison.Ordinal))) {  	switch (memberDef.Flavor) {  	case CST.MemberDefFlavor.Field: {  		var fieldDef = (CST.FieldDef)memberDef;  		if (fieldDef.Invalid == null && fieldDef.IsUsed) {  			var t = attrTypeEnv.SubstituteType (fieldDef.FieldType);  			var o = kv.Value;  			var e = Env.JSTHelpers.InitializerExpression (innerTypeCompEnv' ctxt' o' t);  			var slot = Env.GlobalMapping.ResolveFieldDefToSlot (attrTypeEnv.Assembly' attrTypeEnv.Type' fieldDef);  			stmnt = JST.Statement.DotAssignment (id.ToE ()' new JST.Identifier (Constants.ObjectInstanceFieldSlot (slot))' e);  		}  		break;  	}  	case CST.MemberDefFlavor.Property: {  		var propDef = (CST.PropertyDef)memberDef;  		if (propDef.Invalid == null) {  			var t = attrTypeEnv.SubstituteType (propDef.FieldType);  			var o = kv.Value;  			var e = Env.JSTHelpers.InitializerExpression (innerTypeCompEnv' ctxt' o' t);  			if (propDef.Set != null) {  				var setMethodDef = attrTypeEnv.Type.ResolveMethod (propDef.Set);  				if (setMethodDef != null && setMethodDef.Invalid == null && setMethodDef.IsUsed && setMethodDef.Arity == 2 && !Env.InlinedMethods.IsInlinable (innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' setMethodDef)) {  					var setMethodRef = new CST.MethodRef (attr.Type' setMethodDef.MethodSignature' null);  					stmnt = new JST.ExpressionStatement (innerTypeCompEnv.MethodCallExpression (setMethodRef' innerTypeCompEnv.NameSupply' false' new Seq<JST.Expression> (id.ToE ()' e)));  				}  			}  		}  		break;  	}  	case CST.MemberDefFlavor.Method:  	case CST.MemberDefFlavor.Event:  		break;  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The following statement contains a magic number: switch (memberDef.Flavor) {  case CST.MemberDefFlavor.Field: {  	var fieldDef = (CST.FieldDef)memberDef;  	if (fieldDef.Invalid == null && fieldDef.IsUsed) {  		var t = attrTypeEnv.SubstituteType (fieldDef.FieldType);  		var o = kv.Value;  		var e = Env.JSTHelpers.InitializerExpression (innerTypeCompEnv' ctxt' o' t);  		var slot = Env.GlobalMapping.ResolveFieldDefToSlot (attrTypeEnv.Assembly' attrTypeEnv.Type' fieldDef);  		stmnt = JST.Statement.DotAssignment (id.ToE ()' new JST.Identifier (Constants.ObjectInstanceFieldSlot (slot))' e);  	}  	break;  }  case CST.MemberDefFlavor.Property: {  	var propDef = (CST.PropertyDef)memberDef;  	if (propDef.Invalid == null) {  		var t = attrTypeEnv.SubstituteType (propDef.FieldType);  		var o = kv.Value;  		var e = Env.JSTHelpers.InitializerExpression (innerTypeCompEnv' ctxt' o' t);  		if (propDef.Set != null) {  			var setMethodDef = attrTypeEnv.Type.ResolveMethod (propDef.Set);  			if (setMethodDef != null && setMethodDef.Invalid == null && setMethodDef.IsUsed && setMethodDef.Arity == 2 && !Env.InlinedMethods.IsInlinable (innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' setMethodDef)) {  				var setMethodRef = new CST.MethodRef (attr.Type' setMethodDef.MethodSignature' null);  				stmnt = new JST.ExpressionStatement (innerTypeCompEnv.MethodCallExpression (setMethodRef' innerTypeCompEnv.NameSupply' false' new Seq<JST.Expression> (id.ToE ()' e)));  			}  		}  	}  	break;  }  case CST.MemberDefFlavor.Method:  case CST.MemberDefFlavor.Event:  	break;  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The following statement contains a magic number: if (propDef.Invalid == null) {  	var t = attrTypeEnv.SubstituteType (propDef.FieldType);  	var o = kv.Value;  	var e = Env.JSTHelpers.InitializerExpression (innerTypeCompEnv' ctxt' o' t);  	if (propDef.Set != null) {  		var setMethodDef = attrTypeEnv.Type.ResolveMethod (propDef.Set);  		if (setMethodDef != null && setMethodDef.Invalid == null && setMethodDef.IsUsed && setMethodDef.Arity == 2 && !Env.InlinedMethods.IsInlinable (innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' setMethodDef)) {  			var setMethodRef = new CST.MethodRef (attr.Type' setMethodDef.MethodSignature' null);  			stmnt = new JST.ExpressionStatement (innerTypeCompEnv.MethodCallExpression (setMethodRef' innerTypeCompEnv.NameSupply' false' new Seq<JST.Expression> (id.ToE ()' e)));  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The following statement contains a magic number: if (propDef.Set != null) {  	var setMethodDef = attrTypeEnv.Type.ResolveMethod (propDef.Set);  	if (setMethodDef != null && setMethodDef.Invalid == null && setMethodDef.IsUsed && setMethodDef.Arity == 2 && !Env.InlinedMethods.IsInlinable (innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' setMethodDef)) {  		var setMethodRef = new CST.MethodRef (attr.Type' setMethodDef.MethodSignature' null);  		stmnt = new JST.ExpressionStatement (innerTypeCompEnv.MethodCallExpression (setMethodRef' innerTypeCompEnv.NameSupply' false' new Seq<JST.Expression> (id.ToE ()' e)));  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeCompiler.cs,CustomAttributeExpression,The following statement contains a magic number: if (setMethodDef != null && setMethodDef.Invalid == null && setMethodDef.IsUsed && setMethodDef.Arity == 2 && !Env.InlinedMethods.IsInlinable (innerTypeCompEnv.Assembly' innerTypeCompEnv.Type' setMethodDef)) {  	var setMethodRef = new CST.MethodRef (attr.Type' setMethodDef.MethodSignature' null);  	stmnt = new JST.ExpressionStatement (innerTypeCompEnv.MethodCallExpression (setMethodRef' innerTypeCompEnv.NameSupply' false' new Seq<JST.Expression> (id.ToE ()' e)));  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,EmitMethods,The following statement contains a magic number: switch (Env.CompilationMode) {  case CompilationMode.Plain: {  	// Method definitions are bound directly into target  	foreach (var methodDef in Methods.Where (m => m.Invalid == null)) {  		if (Env.InteropManager.IsStatic (TyconEnv.Assembly' TyconEnv.Type' methodDef) == isStatic) {  			var compiler = new MethodCompiler (this' outerNameSupply' methodDef' MethodCompilationMode.DirectBind);  			compiler.Emit (body' target);  		}  	}  	break;  }  case CompilationMode.Collecting: {  	// Method definitions are bound into MethodCache' redirectors are bound into target  	foreach (var methodDef in Methods.Where (m => m.Invalid == null)) {  		if (Env.InteropManager.IsStatic (TyconEnv.Assembly' TyconEnv.Type' methodDef) == isStatic) {  			var slot = Env.GlobalMapping.ResolveMethodDefToSlot (TyconEnv.Assembly' TyconEnv.Type' methodDef);  			var methodName = CST.CSTWriter.WithAppend (Env.Global' CST.WriterStyle.Uniform' methodDef.MethodSignature.Append);  			body.Add (JST.Statement.DotCall (RootId.ToE ()' Constants.RootCollectingBindMethodBuilder' lhs' new JST.BooleanLiteral (isStatic)' new JST.StringLiteral (slot)' new JST.StringLiteral (methodName)));  			var compiler = new MethodCompiler (this' outerNameSupply' methodDef' MethodCompilationMode.DirectBind);  			compiler.Emit (body' JST.Expression.Dot (target' Constants.TypeMethodCache));  		}  	}  	break;  }  case CompilationMode.Traced: {  	// Methods in the initial trace or this trace will be bound directly.  	// Methods in a trace other than above are bound via builder which is given trace name.  	// Remaining methods are built via builder with null trace name.  	var traceToArgs = new Map<string' Seq<JST.Expression>> ();  	var remainingArgs = new Seq<JST.Expression> ();  	remainingArgs.Add (TypeDefinitionId.ToE ());  	remainingArgs.Add (new JST.BooleanLiteral (isStatic));  	remainingArgs.Add (new JST.NullExpression ());  	foreach (var methodDef in Methods.Where (m => m.Invalid == null)) {  		if (Env.InteropManager.IsStatic (TyconEnv.Assembly' TyconEnv.Type' methodDef) == isStatic) {  			var slot = Env.GlobalMapping.ResolveMethodDefToSlot (TyconEnv.Assembly' TyconEnv.Type' methodDef);  			var defTrace = Env.Traces.MethodToTrace [methodDef.QualifiedMemberName (Env.Global' TyconEnv.Assembly' TyconEnv.Type)];  			if (defTrace.Flavor == TraceFlavor.OnDemand && defTrace != TypeTrace.Parent.Parent) {  				// Method definition in in another trace' bind redirector for it.  				var args = default(Seq<JST.Expression>);  				if (!traceToArgs.TryGetValue (defTrace.Name' out args)) {  					args = new Seq<JST.Expression> ();  					args.Add (lhs);  					args.Add (new JST.BooleanLiteral (isStatic));  					args.Add (new JST.StringLiteral (defTrace.Name));  					traceToArgs.Add (defTrace.Name' args);  				}  				args.Add (new JST.StringLiteral (slot));  			}  			else if (defTrace.Flavor == TraceFlavor.Remainder)  				// Method definition is in a stand-alone loader' bind redirector for it.  				remainingArgs.Add (new JST.StringLiteral (slot));  			else {  				// Method definition is bound directly  				var compiler = new MethodCompiler (this' outerNameSupply' methodDef' MethodCompilationMode.DirectBind);  				compiler.Emit (body' target);  			}  		}  	}  	foreach (var kv in traceToArgs)  		body.Add (JST.Statement.DotCall (RootId.ToE ()' Constants.RootBindMethodBuilders' kv.Value));  	if (remainingArgs.Count > 3)  		body.Add (JST.Statement.DotCall (RootId.ToE ()' Constants.RootBindMethodBuilders' remainingArgs));  	break;  }  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeDefinitionCompiler,C:\repos\Reactive-Extensions_IL2JS\Compiler\TypeDefinitionCompiler.cs,EmitMethods,The following statement contains a magic number: if (remainingArgs.Count > 3)  	body.Add (JST.Statement.DotCall (RootId.ToE ()' Constants.RootBindMethodBuilders' remainingArgs));  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerEnvironment.cs,CompilerEnvironment,The following statement contains a magic number: ImportInlineThreshold = 15;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,CompilerEnvironment,C:\repos\Reactive-Extensions_IL2JS\Compiler\CompilerEnvironment.cs,CompilerEnvironment,The following statement contains a magic number: InlineThreshold = 15;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,FriendlyTypeName,The following statement contains a magic number: JST.Lexemes.AppendStringToFriendlyIdentifier (sb' types [types.Count - 1].ToLowerInvariant ()' 15);  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,AssemblyMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,FriendlyAssemblyName,The following statement contains a magic number: JST.Lexemes.AppendStringToFriendlyIdentifier (sb' name.Name' 15);  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,FriendlyMemberName,The following statement contains a magic number: JST.Lexemes.AppendStringToFriendlyIdentifier (sb' types [types.Count - 1]' 15);  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,FriendlyMemberName,The following statement contains a magic number: JST.Lexemes.AppendStringToFriendlyIdentifier (sb' nm' 15);  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,TypeMapping,C:\repos\Reactive-Extensions_IL2JS\Compiler\GlobalMapping.cs,FriendlyStringName,The following statement contains a magic number: JST.Lexemes.AppendStringToFriendlyIdentifier (sb' str' 15);  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,StringStats,C:\repos\Reactive-Extensions_IL2JS\Compiler\StringStats.cs,GetEnumerator,The following statement contains a magic number: foreach (var kv in counts) {  	//                       Definition          Reference  	//                       ------------------  ------------------  	// In-place string    |  <nothing>           "..."  	// Type level string  |  a.sxy="...";        a.sxy  	var inplaceSize = kv.Value * (kv.Key.Length + 2);  	var typeSize = 9 + kv.Key.Length + kv.Value * 5;  	yield return new KeyValuePair<string' StringBindScope> (kv.Key' typeSize < inplaceSize ? StringBindScope.Type : StringBindScope.InPlace);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,StringStats,C:\repos\Reactive-Extensions_IL2JS\Compiler\StringStats.cs,GetEnumerator,The following statement contains a magic number: foreach (var kv in counts) {  	//                       Definition          Reference  	//                       ------------------  ------------------  	// In-place string    |  <nothing>           "..."  	// Type level string  |  a.sxy="...";        a.sxy  	var inplaceSize = kv.Value * (kv.Key.Length + 2);  	var typeSize = 9 + kv.Key.Length + kv.Value * 5;  	yield return new KeyValuePair<string' StringBindScope> (kv.Key' typeSize < inplaceSize ? StringBindScope.Type : StringBindScope.InPlace);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS,StringStats,C:\repos\Reactive-Extensions_IL2JS\Compiler\StringStats.cs,GetEnumerator,The following statement contains a magic number: foreach (var kv in counts) {  	//                       Definition          Reference  	//                       ------------------  ------------------  	// In-place string    |  <nothing>           "..."  	// Type level string  |  a.sxy="...";        a.sxy  	var inplaceSize = kv.Value * (kv.Key.Length + 2);  	var typeSize = 9 + kv.Key.Length + kv.Value * 5;  	yield return new KeyValuePair<string' StringBindScope> (kv.Key' typeSize < inplaceSize ? StringBindScope.Type : StringBindScope.InPlace);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DefaultImportingConstructor,The following statement contains a magic number: foreach (var currCtor in typeEnv.Type.Members.OfType<CST.MethodDef> ().Where (m => m.Invalid == null && !m.IsStatic && m.IsConstructor && !IsImported (typeEnv.Assembly' typeEnv.Type' m))) {  	var currArity = currCtor.ValueParameters.Count;  	var thisRank = 0;  	switch (state) {  	case InstanceState.ManagedOnly:  		if (currArity == 1)  			// .ctor(C this)  			thisRank = 1;  		break;  	case InstanceState.ManagedAndJavaScript:  	case InstanceState.JavaScriptOnly:  		if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  			// .ctor(C this' JSContext ctxt)  			thisRank = 2;  		break;  	case InstanceState.Merged:  		throw new InvalidOperationException ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (thisRank > 0 && currCtor.Annotations.OfType<CST.AccessibilityAnnotation> ().Where (a => a.Accessibility != CST.Accessibility.Public).Any ()) {  		env.Log (new InvalidInteropMessage (CST.MessageContextBuilders.Member (env.Global' typeEnv.Assembly' typeEnv.Type' currCtor)' "importing constructors must be public"));  		throw new DefinitionException ();  	}  	if (thisRank > bestRank) {  		bestRank = thisRank;  		bestCtor = currCtor;  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DefaultImportingConstructor,The following statement contains a magic number: foreach (var currCtor in typeEnv.Type.Members.OfType<CST.MethodDef> ().Where (m => m.Invalid == null && !m.IsStatic && m.IsConstructor && !IsImported (typeEnv.Assembly' typeEnv.Type' m))) {  	var currArity = currCtor.ValueParameters.Count;  	var thisRank = 0;  	switch (state) {  	case InstanceState.ManagedOnly:  		if (currArity == 1)  			// .ctor(C this)  			thisRank = 1;  		break;  	case InstanceState.ManagedAndJavaScript:  	case InstanceState.JavaScriptOnly:  		if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  			// .ctor(C this' JSContext ctxt)  			thisRank = 2;  		break;  	case InstanceState.Merged:  		throw new InvalidOperationException ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (thisRank > 0 && currCtor.Annotations.OfType<CST.AccessibilityAnnotation> ().Where (a => a.Accessibility != CST.Accessibility.Public).Any ()) {  		env.Log (new InvalidInteropMessage (CST.MessageContextBuilders.Member (env.Global' typeEnv.Assembly' typeEnv.Type' currCtor)' "importing constructors must be public"));  		throw new DefinitionException ();  	}  	if (thisRank > bestRank) {  		bestRank = thisRank;  		bestCtor = currCtor;  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DefaultImportingConstructor,The following statement contains a magic number: switch (state) {  case InstanceState.ManagedOnly:  	if (currArity == 1)  		// .ctor(C this)  		thisRank = 1;  	break;  case InstanceState.ManagedAndJavaScript:  case InstanceState.JavaScriptOnly:  	if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  		// .ctor(C this' JSContext ctxt)  		thisRank = 2;  	break;  case InstanceState.Merged:  	throw new InvalidOperationException ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DefaultImportingConstructor,The following statement contains a magic number: switch (state) {  case InstanceState.ManagedOnly:  	if (currArity == 1)  		// .ctor(C this)  		thisRank = 1;  	break;  case InstanceState.ManagedAndJavaScript:  case InstanceState.JavaScriptOnly:  	if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  		// .ctor(C this' JSContext ctxt)  		thisRank = 2;  	break;  case InstanceState.Merged:  	throw new InvalidOperationException ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DefaultImportingConstructor,The following statement contains a magic number: if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  	// .ctor(C this' JSContext ctxt)  	thisRank = 2;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DefaultImportingConstructor,The following statement contains a magic number: if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  	// .ctor(C this' JSContext ctxt)  	thisRank = 2;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,DefaultImportingConstructor,The following statement contains a magic number: thisRank = 2;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: foreach (var currCtor in polyMethEnv.Type.Members.OfType<CST.MethodDef> ().Where (m => m.Invalid == null && !m.IsStatic && m.IsConstructor && !IsImported (polyMethEnv.Assembly' polyMethEnv.Type' m))) {  	var currRank = 0;  	var currArity = currCtor.ValueParameters.Count;  	switch (state) {  	case InstanceState.ManagedOnly:  		if (currArity == 1)  			// .ctor(C this)  			currRank = 1;  		break;  	case InstanceState.ManagedAndJavaScript:  	case InstanceState.JavaScriptOnly:  		if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  			// .ctor(C this' JSContext ctxt)  			currRank = 1;  		else if (currArity == polyMethEnv.Method.Arity + 1 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef)) {  			// .ctor(C this' JSContext ctxt' T t' U u)  			currRank = 2;  			for (var i = 2; i < currArity; i++) {  				if (!currCtor.ValueParameters [i].Type.IsEquivalentTo (polyMethEnv' polyMethEnv.Method.ValueParameters [i - 1].Type)) {  					currRank = 0;  					break;  				}  			}  		}  		break;  	case InstanceState.Merged:  		throw new InvalidOperationException ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (currRank > 0 && currCtor.Annotations.OfType<CST.AccessibilityAnnotation> ().Where (a => a.Accessibility != CST.Accessibility.Public).Any ()) {  		env.Log (new InvalidInteropMessage (CST.MessageContextBuilders.Member (env.Global' polyMethEnv.Assembly' polyMethEnv.Type' currCtor)' "importing constructors must be public"));  		throw new DefinitionException ();  	}  	if (currRank > bestRank) {  		bestRank = currRank;  		bestCtor = new CST.MethodRef (polyMethEnv.TypeRef' currCtor.MethodSignature' null);  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: foreach (var currCtor in polyMethEnv.Type.Members.OfType<CST.MethodDef> ().Where (m => m.Invalid == null && !m.IsStatic && m.IsConstructor && !IsImported (polyMethEnv.Assembly' polyMethEnv.Type' m))) {  	var currRank = 0;  	var currArity = currCtor.ValueParameters.Count;  	switch (state) {  	case InstanceState.ManagedOnly:  		if (currArity == 1)  			// .ctor(C this)  			currRank = 1;  		break;  	case InstanceState.ManagedAndJavaScript:  	case InstanceState.JavaScriptOnly:  		if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  			// .ctor(C this' JSContext ctxt)  			currRank = 1;  		else if (currArity == polyMethEnv.Method.Arity + 1 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef)) {  			// .ctor(C this' JSContext ctxt' T t' U u)  			currRank = 2;  			for (var i = 2; i < currArity; i++) {  				if (!currCtor.ValueParameters [i].Type.IsEquivalentTo (polyMethEnv' polyMethEnv.Method.ValueParameters [i - 1].Type)) {  					currRank = 0;  					break;  				}  			}  		}  		break;  	case InstanceState.Merged:  		throw new InvalidOperationException ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (currRank > 0 && currCtor.Annotations.OfType<CST.AccessibilityAnnotation> ().Where (a => a.Accessibility != CST.Accessibility.Public).Any ()) {  		env.Log (new InvalidInteropMessage (CST.MessageContextBuilders.Member (env.Global' polyMethEnv.Assembly' polyMethEnv.Type' currCtor)' "importing constructors must be public"));  		throw new DefinitionException ();  	}  	if (currRank > bestRank) {  		bestRank = currRank;  		bestCtor = new CST.MethodRef (polyMethEnv.TypeRef' currCtor.MethodSignature' null);  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: foreach (var currCtor in polyMethEnv.Type.Members.OfType<CST.MethodDef> ().Where (m => m.Invalid == null && !m.IsStatic && m.IsConstructor && !IsImported (polyMethEnv.Assembly' polyMethEnv.Type' m))) {  	var currRank = 0;  	var currArity = currCtor.ValueParameters.Count;  	switch (state) {  	case InstanceState.ManagedOnly:  		if (currArity == 1)  			// .ctor(C this)  			currRank = 1;  		break;  	case InstanceState.ManagedAndJavaScript:  	case InstanceState.JavaScriptOnly:  		if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  			// .ctor(C this' JSContext ctxt)  			currRank = 1;  		else if (currArity == polyMethEnv.Method.Arity + 1 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef)) {  			// .ctor(C this' JSContext ctxt' T t' U u)  			currRank = 2;  			for (var i = 2; i < currArity; i++) {  				if (!currCtor.ValueParameters [i].Type.IsEquivalentTo (polyMethEnv' polyMethEnv.Method.ValueParameters [i - 1].Type)) {  					currRank = 0;  					break;  				}  			}  		}  		break;  	case InstanceState.Merged:  		throw new InvalidOperationException ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");  	default:  		throw new ArgumentOutOfRangeException ();  	}  	if (currRank > 0 && currCtor.Annotations.OfType<CST.AccessibilityAnnotation> ().Where (a => a.Accessibility != CST.Accessibility.Public).Any ()) {  		env.Log (new InvalidInteropMessage (CST.MessageContextBuilders.Member (env.Global' polyMethEnv.Assembly' polyMethEnv.Type' currCtor)' "importing constructors must be public"));  		throw new DefinitionException ();  	}  	if (currRank > bestRank) {  		bestRank = currRank;  		bestCtor = new CST.MethodRef (polyMethEnv.TypeRef' currCtor.MethodSignature' null);  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: switch (state) {  case InstanceState.ManagedOnly:  	if (currArity == 1)  		// .ctor(C this)  		currRank = 1;  	break;  case InstanceState.ManagedAndJavaScript:  case InstanceState.JavaScriptOnly:  	if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  		// .ctor(C this' JSContext ctxt)  		currRank = 1;  	else if (currArity == polyMethEnv.Method.Arity + 1 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef)) {  		// .ctor(C this' JSContext ctxt' T t' U u)  		currRank = 2;  		for (var i = 2; i < currArity; i++) {  			if (!currCtor.ValueParameters [i].Type.IsEquivalentTo (polyMethEnv' polyMethEnv.Method.ValueParameters [i - 1].Type)) {  				currRank = 0;  				break;  			}  		}  	}  	break;  case InstanceState.Merged:  	throw new InvalidOperationException ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: switch (state) {  case InstanceState.ManagedOnly:  	if (currArity == 1)  		// .ctor(C this)  		currRank = 1;  	break;  case InstanceState.ManagedAndJavaScript:  case InstanceState.JavaScriptOnly:  	if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  		// .ctor(C this' JSContext ctxt)  		currRank = 1;  	else if (currArity == polyMethEnv.Method.Arity + 1 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef)) {  		// .ctor(C this' JSContext ctxt' T t' U u)  		currRank = 2;  		for (var i = 2; i < currArity; i++) {  			if (!currCtor.ValueParameters [i].Type.IsEquivalentTo (polyMethEnv' polyMethEnv.Method.ValueParameters [i - 1].Type)) {  				currRank = 0;  				break;  			}  		}  	}  	break;  case InstanceState.Merged:  	throw new InvalidOperationException ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: switch (state) {  case InstanceState.ManagedOnly:  	if (currArity == 1)  		// .ctor(C this)  		currRank = 1;  	break;  case InstanceState.ManagedAndJavaScript:  case InstanceState.JavaScriptOnly:  	if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  		// .ctor(C this' JSContext ctxt)  		currRank = 1;  	else if (currArity == polyMethEnv.Method.Arity + 1 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef)) {  		// .ctor(C this' JSContext ctxt' T t' U u)  		currRank = 2;  		for (var i = 2; i < currArity; i++) {  			if (!currCtor.ValueParameters [i].Type.IsEquivalentTo (polyMethEnv' polyMethEnv.Method.ValueParameters [i - 1].Type)) {  				currRank = 0;  				break;  			}  		}  	}  	break;  case InstanceState.Merged:  	throw new InvalidOperationException ("'ManagedAndJavaScript' or 'JavaScriptOnly' type derived from a 'Merged' type");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  	// .ctor(C this' JSContext ctxt)  	currRank = 1;  else if (currArity == polyMethEnv.Method.Arity + 1 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef)) {  	// .ctor(C this' JSContext ctxt' T t' U u)  	currRank = 2;  	for (var i = 2; i < currArity; i++) {  		if (!currCtor.ValueParameters [i].Type.IsEquivalentTo (polyMethEnv' polyMethEnv.Method.ValueParameters [i - 1].Type)) {  			currRank = 0;  			break;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  	// .ctor(C this' JSContext ctxt)  	currRank = 1;  else if (currArity == polyMethEnv.Method.Arity + 1 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef)) {  	// .ctor(C this' JSContext ctxt' T t' U u)  	currRank = 2;  	for (var i = 2; i < currArity; i++) {  		if (!currCtor.ValueParameters [i].Type.IsEquivalentTo (polyMethEnv' polyMethEnv.Method.ValueParameters [i - 1].Type)) {  			currRank = 0;  			break;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: if (currArity == 2 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef))  	// .ctor(C this' JSContext ctxt)  	currRank = 1;  else if (currArity == polyMethEnv.Method.Arity + 1 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef)) {  	// .ctor(C this' JSContext ctxt' T t' U u)  	currRank = 2;  	for (var i = 2; i < currArity; i++) {  		if (!currCtor.ValueParameters [i].Type.IsEquivalentTo (polyMethEnv' polyMethEnv.Method.ValueParameters [i - 1].Type)) {  			currRank = 0;  			break;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: if (currArity == polyMethEnv.Method.Arity + 1 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef)) {  	// .ctor(C this' JSContext ctxt' T t' U u)  	currRank = 2;  	for (var i = 2; i < currArity; i++) {  		if (!currCtor.ValueParameters [i].Type.IsEquivalentTo (polyMethEnv' polyMethEnv.Method.ValueParameters [i - 1].Type)) {  			currRank = 0;  			break;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: if (currArity == polyMethEnv.Method.Arity + 1 && currCtor.ValueParameters [1].Type.Equals (env.JSContextRef)) {  	// .ctor(C this' JSContext ctxt' T t' U u)  	currRank = 2;  	for (var i = 2; i < currArity; i++) {  		if (!currCtor.ValueParameters [i].Type.IsEquivalentTo (polyMethEnv' polyMethEnv.Method.ValueParameters [i - 1].Type)) {  			currRank = 0;  			break;  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: currRank = 2;  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,MatchingImportingConstructor,The following statement contains a magic number: for (var i = 2; i < currArity; i++) {  	if (!currCtor.ValueParameters [i].Type.IsEquivalentTo (polyMethEnv' polyMethEnv.Method.ValueParameters [i - 1].Type)) {  		currRank = 0;  		break;  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && methodDef.IsConstructor) {  	// Constructor  	if (script == null) {  		var creation = default(Creation);  		attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheCreationProperty' true' false' ref creation);  		switch (creation) {  		case Creation.Constructor:  			script = PrefixName (assemblyDef' typeDef' methodDef' null' false);  			break;  		case Creation.Object:  			if (arguments.Count > 0) {  				env.Log (new InvalidInteropMessage (ctxt' "imported constructors for object literals cannot have arguments"));  				throw new DefinitionException ();  			}  			script = Constants.Object.ToE ();  			break;  		case Creation.Array:  			script = Constants.Array.ToE ();  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  		var call = AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		return new JST.NewExpression (call);  	}  	else if (script is JST.FunctionExpression)  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	else {  		script = PrefixName (assemblyDef' typeDef' methodDef' script' false);  		var call = AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		return new JST.NewExpression (call);  	}  }  else {  	var outer = typeDef.OuterPropertyOrEvent (methodDef.MethodSignature);  	if (outer != null) {  		var isOnMethod = attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);  		var localScript = default(JST.Expression);  		if (isOnMethod)  			attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' false' false' ref localScript);  		switch (outer.Flavor) {  		case CST.MemberDefFlavor.Property: {  			var propDef = (CST.PropertyDef)outer;  			if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  				// Getter  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  						return new JST.IndexExpression (arguments [0]' arguments [1]);  					else {  						script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  						if (methodDef.IsStatic && arguments.Count == 0)  							return script;  						else if (!methodDef.IsStatic && arguments.Count == 1)  							return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  						else {  							env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  							throw new DefinitionException ();  						}  					}  				}  			}  			else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  				// Setter  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  						return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  					else {  						script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  						if (methodDef.IsStatic && arguments.Count == 1)  							return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  						else if (!methodDef.IsStatic && arguments.Count == 2)  							return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  						else {  							env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  							throw new DefinitionException ();  						}  					}  				}  			}  			else  				throw new InvalidOperationException ();  		}  		case CST.MemberDefFlavor.Event: {  			var eventDef = (CST.EventDef)outer;  			// XREF1201  			if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  				// Adder  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					// The delegate argument has already taken account of the combine' so   					// just a field assignment  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else  						throw new InvalidOperationException ("mismatched event adder arity");  				}  			}  			else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  				// Remover  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					// The delegate argument has already taken account of the delete' so   					// just a field assignment  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else  						throw new InvalidOperationException ("mismatched event remover arity");  				}  			}  			else  				throw new InvalidOperationException ();  		}  		case CST.MemberDefFlavor.Field:  		case CST.MemberDefFlavor.Method:  			throw new InvalidOperationException ("outer is not property or event");  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	else {  		// Normal method  		script = PrefixName (assemblyDef' typeDef' methodDef' RecaseMethod (assemblyDef' typeDef' methodDef' script)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && methodDef.IsConstructor) {  	// Constructor  	if (script == null) {  		var creation = default(Creation);  		attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheCreationProperty' true' false' ref creation);  		switch (creation) {  		case Creation.Constructor:  			script = PrefixName (assemblyDef' typeDef' methodDef' null' false);  			break;  		case Creation.Object:  			if (arguments.Count > 0) {  				env.Log (new InvalidInteropMessage (ctxt' "imported constructors for object literals cannot have arguments"));  				throw new DefinitionException ();  			}  			script = Constants.Object.ToE ();  			break;  		case Creation.Array:  			script = Constants.Array.ToE ();  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  		var call = AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		return new JST.NewExpression (call);  	}  	else if (script is JST.FunctionExpression)  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	else {  		script = PrefixName (assemblyDef' typeDef' methodDef' script' false);  		var call = AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		return new JST.NewExpression (call);  	}  }  else {  	var outer = typeDef.OuterPropertyOrEvent (methodDef.MethodSignature);  	if (outer != null) {  		var isOnMethod = attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);  		var localScript = default(JST.Expression);  		if (isOnMethod)  			attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' false' false' ref localScript);  		switch (outer.Flavor) {  		case CST.MemberDefFlavor.Property: {  			var propDef = (CST.PropertyDef)outer;  			if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  				// Getter  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  						return new JST.IndexExpression (arguments [0]' arguments [1]);  					else {  						script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  						if (methodDef.IsStatic && arguments.Count == 0)  							return script;  						else if (!methodDef.IsStatic && arguments.Count == 1)  							return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  						else {  							env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  							throw new DefinitionException ();  						}  					}  				}  			}  			else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  				// Setter  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  						return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  					else {  						script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  						if (methodDef.IsStatic && arguments.Count == 1)  							return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  						else if (!methodDef.IsStatic && arguments.Count == 2)  							return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  						else {  							env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  							throw new DefinitionException ();  						}  					}  				}  			}  			else  				throw new InvalidOperationException ();  		}  		case CST.MemberDefFlavor.Event: {  			var eventDef = (CST.EventDef)outer;  			// XREF1201  			if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  				// Adder  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					// The delegate argument has already taken account of the combine' so   					// just a field assignment  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else  						throw new InvalidOperationException ("mismatched event adder arity");  				}  			}  			else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  				// Remover  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					// The delegate argument has already taken account of the delete' so   					// just a field assignment  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else  						throw new InvalidOperationException ("mismatched event remover arity");  				}  			}  			else  				throw new InvalidOperationException ();  		}  		case CST.MemberDefFlavor.Field:  		case CST.MemberDefFlavor.Method:  			throw new InvalidOperationException ("outer is not property or event");  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	else {  		// Normal method  		script = PrefixName (assemblyDef' typeDef' methodDef' RecaseMethod (assemblyDef' typeDef' methodDef' script)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && methodDef.IsConstructor) {  	// Constructor  	if (script == null) {  		var creation = default(Creation);  		attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheCreationProperty' true' false' ref creation);  		switch (creation) {  		case Creation.Constructor:  			script = PrefixName (assemblyDef' typeDef' methodDef' null' false);  			break;  		case Creation.Object:  			if (arguments.Count > 0) {  				env.Log (new InvalidInteropMessage (ctxt' "imported constructors for object literals cannot have arguments"));  				throw new DefinitionException ();  			}  			script = Constants.Object.ToE ();  			break;  		case Creation.Array:  			script = Constants.Array.ToE ();  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  		var call = AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		return new JST.NewExpression (call);  	}  	else if (script is JST.FunctionExpression)  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	else {  		script = PrefixName (assemblyDef' typeDef' methodDef' script' false);  		var call = AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		return new JST.NewExpression (call);  	}  }  else {  	var outer = typeDef.OuterPropertyOrEvent (methodDef.MethodSignature);  	if (outer != null) {  		var isOnMethod = attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);  		var localScript = default(JST.Expression);  		if (isOnMethod)  			attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' false' false' ref localScript);  		switch (outer.Flavor) {  		case CST.MemberDefFlavor.Property: {  			var propDef = (CST.PropertyDef)outer;  			if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  				// Getter  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  						return new JST.IndexExpression (arguments [0]' arguments [1]);  					else {  						script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  						if (methodDef.IsStatic && arguments.Count == 0)  							return script;  						else if (!methodDef.IsStatic && arguments.Count == 1)  							return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  						else {  							env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  							throw new DefinitionException ();  						}  					}  				}  			}  			else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  				// Setter  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  						return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  					else {  						script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  						if (methodDef.IsStatic && arguments.Count == 1)  							return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  						else if (!methodDef.IsStatic && arguments.Count == 2)  							return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  						else {  							env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  							throw new DefinitionException ();  						}  					}  				}  			}  			else  				throw new InvalidOperationException ();  		}  		case CST.MemberDefFlavor.Event: {  			var eventDef = (CST.EventDef)outer;  			// XREF1201  			if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  				// Adder  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					// The delegate argument has already taken account of the combine' so   					// just a field assignment  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else  						throw new InvalidOperationException ("mismatched event adder arity");  				}  			}  			else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  				// Remover  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					// The delegate argument has already taken account of the delete' so   					// just a field assignment  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else  						throw new InvalidOperationException ("mismatched event remover arity");  				}  			}  			else  				throw new InvalidOperationException ();  		}  		case CST.MemberDefFlavor.Field:  		case CST.MemberDefFlavor.Method:  			throw new InvalidOperationException ("outer is not property or event");  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	else {  		// Normal method  		script = PrefixName (assemblyDef' typeDef' methodDef' RecaseMethod (assemblyDef' typeDef' methodDef' script)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && methodDef.IsConstructor) {  	// Constructor  	if (script == null) {  		var creation = default(Creation);  		attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheCreationProperty' true' false' ref creation);  		switch (creation) {  		case Creation.Constructor:  			script = PrefixName (assemblyDef' typeDef' methodDef' null' false);  			break;  		case Creation.Object:  			if (arguments.Count > 0) {  				env.Log (new InvalidInteropMessage (ctxt' "imported constructors for object literals cannot have arguments"));  				throw new DefinitionException ();  			}  			script = Constants.Object.ToE ();  			break;  		case Creation.Array:  			script = Constants.Array.ToE ();  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  		var call = AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		return new JST.NewExpression (call);  	}  	else if (script is JST.FunctionExpression)  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	else {  		script = PrefixName (assemblyDef' typeDef' methodDef' script' false);  		var call = AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		return new JST.NewExpression (call);  	}  }  else {  	var outer = typeDef.OuterPropertyOrEvent (methodDef.MethodSignature);  	if (outer != null) {  		var isOnMethod = attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);  		var localScript = default(JST.Expression);  		if (isOnMethod)  			attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' false' false' ref localScript);  		switch (outer.Flavor) {  		case CST.MemberDefFlavor.Property: {  			var propDef = (CST.PropertyDef)outer;  			if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  				// Getter  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  						return new JST.IndexExpression (arguments [0]' arguments [1]);  					else {  						script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  						if (methodDef.IsStatic && arguments.Count == 0)  							return script;  						else if (!methodDef.IsStatic && arguments.Count == 1)  							return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  						else {  							env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  							throw new DefinitionException ();  						}  					}  				}  			}  			else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  				// Setter  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  						return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  					else {  						script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  						if (methodDef.IsStatic && arguments.Count == 1)  							return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  						else if (!methodDef.IsStatic && arguments.Count == 2)  							return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  						else {  							env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  							throw new DefinitionException ();  						}  					}  				}  			}  			else  				throw new InvalidOperationException ();  		}  		case CST.MemberDefFlavor.Event: {  			var eventDef = (CST.EventDef)outer;  			// XREF1201  			if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  				// Adder  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					// The delegate argument has already taken account of the combine' so   					// just a field assignment  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else  						throw new InvalidOperationException ("mismatched event adder arity");  				}  			}  			else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  				// Remover  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					// The delegate argument has already taken account of the delete' so   					// just a field assignment  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else  						throw new InvalidOperationException ("mismatched event remover arity");  				}  			}  			else  				throw new InvalidOperationException ();  		}  		case CST.MemberDefFlavor.Field:  		case CST.MemberDefFlavor.Method:  			throw new InvalidOperationException ("outer is not property or event");  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	else {  		// Normal method  		script = PrefixName (assemblyDef' typeDef' methodDef' RecaseMethod (assemblyDef' typeDef' methodDef' script)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && methodDef.IsConstructor) {  	// Constructor  	if (script == null) {  		var creation = default(Creation);  		attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheCreationProperty' true' false' ref creation);  		switch (creation) {  		case Creation.Constructor:  			script = PrefixName (assemblyDef' typeDef' methodDef' null' false);  			break;  		case Creation.Object:  			if (arguments.Count > 0) {  				env.Log (new InvalidInteropMessage (ctxt' "imported constructors for object literals cannot have arguments"));  				throw new DefinitionException ();  			}  			script = Constants.Object.ToE ();  			break;  		case Creation.Array:  			script = Constants.Array.ToE ();  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  		var call = AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		return new JST.NewExpression (call);  	}  	else if (script is JST.FunctionExpression)  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	else {  		script = PrefixName (assemblyDef' typeDef' methodDef' script' false);  		var call = AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		return new JST.NewExpression (call);  	}  }  else {  	var outer = typeDef.OuterPropertyOrEvent (methodDef.MethodSignature);  	if (outer != null) {  		var isOnMethod = attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);  		var localScript = default(JST.Expression);  		if (isOnMethod)  			attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' false' false' ref localScript);  		switch (outer.Flavor) {  		case CST.MemberDefFlavor.Property: {  			var propDef = (CST.PropertyDef)outer;  			if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  				// Getter  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  						return new JST.IndexExpression (arguments [0]' arguments [1]);  					else {  						script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  						if (methodDef.IsStatic && arguments.Count == 0)  							return script;  						else if (!methodDef.IsStatic && arguments.Count == 1)  							return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  						else {  							env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  							throw new DefinitionException ();  						}  					}  				}  			}  			else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  				// Setter  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  						return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  					else {  						script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  						if (methodDef.IsStatic && arguments.Count == 1)  							return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  						else if (!methodDef.IsStatic && arguments.Count == 2)  							return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  						else {  							env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  							throw new DefinitionException ();  						}  					}  				}  			}  			else  				throw new InvalidOperationException ();  		}  		case CST.MemberDefFlavor.Event: {  			var eventDef = (CST.EventDef)outer;  			// XREF1201  			if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  				// Adder  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					// The delegate argument has already taken account of the combine' so   					// just a field assignment  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else  						throw new InvalidOperationException ("mismatched event adder arity");  				}  			}  			else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  				// Remover  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					// The delegate argument has already taken account of the delete' so   					// just a field assignment  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else  						throw new InvalidOperationException ("mismatched event remover arity");  				}  			}  			else  				throw new InvalidOperationException ();  		}  		case CST.MemberDefFlavor.Field:  		case CST.MemberDefFlavor.Method:  			throw new InvalidOperationException ("outer is not property or event");  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	else {  		// Normal method  		script = PrefixName (assemblyDef' typeDef' methodDef' RecaseMethod (assemblyDef' typeDef' methodDef' script)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && methodDef.IsConstructor) {  	// Constructor  	if (script == null) {  		var creation = default(Creation);  		attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheCreationProperty' true' false' ref creation);  		switch (creation) {  		case Creation.Constructor:  			script = PrefixName (assemblyDef' typeDef' methodDef' null' false);  			break;  		case Creation.Object:  			if (arguments.Count > 0) {  				env.Log (new InvalidInteropMessage (ctxt' "imported constructors for object literals cannot have arguments"));  				throw new DefinitionException ();  			}  			script = Constants.Object.ToE ();  			break;  		case Creation.Array:  			script = Constants.Array.ToE ();  			break;  		default:  			throw new ArgumentOutOfRangeException ();  		}  		var call = AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		return new JST.NewExpression (call);  	}  	else if (script is JST.FunctionExpression)  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	else {  		script = PrefixName (assemblyDef' typeDef' methodDef' script' false);  		var call = AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		return new JST.NewExpression (call);  	}  }  else {  	var outer = typeDef.OuterPropertyOrEvent (methodDef.MethodSignature);  	if (outer != null) {  		var isOnMethod = attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);  		var localScript = default(JST.Expression);  		if (isOnMethod)  			attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' false' false' ref localScript);  		switch (outer.Flavor) {  		case CST.MemberDefFlavor.Property: {  			var propDef = (CST.PropertyDef)outer;  			if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  				// Getter  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  						return new JST.IndexExpression (arguments [0]' arguments [1]);  					else {  						script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  						if (methodDef.IsStatic && arguments.Count == 0)  							return script;  						else if (!methodDef.IsStatic && arguments.Count == 1)  							return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  						else {  							env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  							throw new DefinitionException ();  						}  					}  				}  			}  			else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  				// Setter  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  						return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  					else {  						script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  						if (methodDef.IsStatic && arguments.Count == 1)  							return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  						else if (!methodDef.IsStatic && arguments.Count == 2)  							return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  						else {  							env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  							throw new DefinitionException ();  						}  					}  				}  			}  			else  				throw new InvalidOperationException ();  		}  		case CST.MemberDefFlavor.Event: {  			var eventDef = (CST.EventDef)outer;  			// XREF1201  			if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  				// Adder  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					// The delegate argument has already taken account of the combine' so   					// just a field assignment  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else  						throw new InvalidOperationException ("mismatched event adder arity");  				}  			}  			else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  				// Remover  				if (isOnMethod) {  					script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  					return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  				}  				else if (script != null && script is JST.FunctionExpression) {  					env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  					throw new DefinitionException ();  				}  				else {  					// The delegate argument has already taken account of the delete' so   					// just a field assignment  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else  						throw new InvalidOperationException ("mismatched event remover arity");  				}  			}  			else  				throw new InvalidOperationException ();  		}  		case CST.MemberDefFlavor.Field:  		case CST.MemberDefFlavor.Method:  			throw new InvalidOperationException ("outer is not property or event");  		default:  			throw new ArgumentOutOfRangeException ();  		}  	}  	else {  		// Normal method  		script = PrefixName (assemblyDef' typeDef' methodDef' RecaseMethod (assemblyDef' typeDef' methodDef' script)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (outer != null) {  	var isOnMethod = attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);  	var localScript = default(JST.Expression);  	if (isOnMethod)  		attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' false' false' ref localScript);  	switch (outer.Flavor) {  	case CST.MemberDefFlavor.Property: {  		var propDef = (CST.PropertyDef)outer;  		if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  			// Getter  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  					return new JST.IndexExpression (arguments [0]' arguments [1]);  				else {  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 0)  						return script;  					else if (!methodDef.IsStatic && arguments.Count == 1)  						return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  					else {  						env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  						throw new DefinitionException ();  					}  				}  			}  		}  		else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  			// Setter  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  					return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  				else {  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else {  						env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  						throw new DefinitionException ();  					}  				}  			}  		}  		else  			throw new InvalidOperationException ();  	}  	case CST.MemberDefFlavor.Event: {  		var eventDef = (CST.EventDef)outer;  		// XREF1201  		if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  			// Adder  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				// The delegate argument has already taken account of the combine' so   				// just a field assignment  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else  					throw new InvalidOperationException ("mismatched event adder arity");  			}  		}  		else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  			// Remover  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				// The delegate argument has already taken account of the delete' so   				// just a field assignment  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else  					throw new InvalidOperationException ("mismatched event remover arity");  			}  		}  		else  			throw new InvalidOperationException ();  	}  	case CST.MemberDefFlavor.Field:  	case CST.MemberDefFlavor.Method:  		throw new InvalidOperationException ("outer is not property or event");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  else {  	// Normal method  	script = PrefixName (assemblyDef' typeDef' methodDef' RecaseMethod (assemblyDef' typeDef' methodDef' script)' false);  	return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (outer != null) {  	var isOnMethod = attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);  	var localScript = default(JST.Expression);  	if (isOnMethod)  		attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' false' false' ref localScript);  	switch (outer.Flavor) {  	case CST.MemberDefFlavor.Property: {  		var propDef = (CST.PropertyDef)outer;  		if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  			// Getter  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  					return new JST.IndexExpression (arguments [0]' arguments [1]);  				else {  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 0)  						return script;  					else if (!methodDef.IsStatic && arguments.Count == 1)  						return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  					else {  						env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  						throw new DefinitionException ();  					}  				}  			}  		}  		else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  			// Setter  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  					return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  				else {  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else {  						env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  						throw new DefinitionException ();  					}  				}  			}  		}  		else  			throw new InvalidOperationException ();  	}  	case CST.MemberDefFlavor.Event: {  		var eventDef = (CST.EventDef)outer;  		// XREF1201  		if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  			// Adder  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				// The delegate argument has already taken account of the combine' so   				// just a field assignment  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else  					throw new InvalidOperationException ("mismatched event adder arity");  			}  		}  		else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  			// Remover  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				// The delegate argument has already taken account of the delete' so   				// just a field assignment  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else  					throw new InvalidOperationException ("mismatched event remover arity");  			}  		}  		else  			throw new InvalidOperationException ();  	}  	case CST.MemberDefFlavor.Field:  	case CST.MemberDefFlavor.Method:  		throw new InvalidOperationException ("outer is not property or event");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  else {  	// Normal method  	script = PrefixName (assemblyDef' typeDef' methodDef' RecaseMethod (assemblyDef' typeDef' methodDef' script)' false);  	return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (outer != null) {  	var isOnMethod = attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);  	var localScript = default(JST.Expression);  	if (isOnMethod)  		attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' false' false' ref localScript);  	switch (outer.Flavor) {  	case CST.MemberDefFlavor.Property: {  		var propDef = (CST.PropertyDef)outer;  		if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  			// Getter  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  					return new JST.IndexExpression (arguments [0]' arguments [1]);  				else {  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 0)  						return script;  					else if (!methodDef.IsStatic && arguments.Count == 1)  						return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  					else {  						env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  						throw new DefinitionException ();  					}  				}  			}  		}  		else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  			// Setter  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  					return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  				else {  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else {  						env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  						throw new DefinitionException ();  					}  				}  			}  		}  		else  			throw new InvalidOperationException ();  	}  	case CST.MemberDefFlavor.Event: {  		var eventDef = (CST.EventDef)outer;  		// XREF1201  		if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  			// Adder  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				// The delegate argument has already taken account of the combine' so   				// just a field assignment  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else  					throw new InvalidOperationException ("mismatched event adder arity");  			}  		}  		else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  			// Remover  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				// The delegate argument has already taken account of the delete' so   				// just a field assignment  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else  					throw new InvalidOperationException ("mismatched event remover arity");  			}  		}  		else  			throw new InvalidOperationException ();  	}  	case CST.MemberDefFlavor.Field:  	case CST.MemberDefFlavor.Method:  		throw new InvalidOperationException ("outer is not property or event");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  else {  	// Normal method  	script = PrefixName (assemblyDef' typeDef' methodDef' RecaseMethod (assemblyDef' typeDef' methodDef' script)' false);  	return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (outer != null) {  	var isOnMethod = attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);  	var localScript = default(JST.Expression);  	if (isOnMethod)  		attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' false' false' ref localScript);  	switch (outer.Flavor) {  	case CST.MemberDefFlavor.Property: {  		var propDef = (CST.PropertyDef)outer;  		if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  			// Getter  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  					return new JST.IndexExpression (arguments [0]' arguments [1]);  				else {  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 0)  						return script;  					else if (!methodDef.IsStatic && arguments.Count == 1)  						return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  					else {  						env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  						throw new DefinitionException ();  					}  				}  			}  		}  		else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  			// Setter  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  					return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  				else {  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else {  						env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  						throw new DefinitionException ();  					}  				}  			}  		}  		else  			throw new InvalidOperationException ();  	}  	case CST.MemberDefFlavor.Event: {  		var eventDef = (CST.EventDef)outer;  		// XREF1201  		if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  			// Adder  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				// The delegate argument has already taken account of the combine' so   				// just a field assignment  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else  					throw new InvalidOperationException ("mismatched event adder arity");  			}  		}  		else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  			// Remover  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				// The delegate argument has already taken account of the delete' so   				// just a field assignment  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else  					throw new InvalidOperationException ("mismatched event remover arity");  			}  		}  		else  			throw new InvalidOperationException ();  	}  	case CST.MemberDefFlavor.Field:  	case CST.MemberDefFlavor.Method:  		throw new InvalidOperationException ("outer is not property or event");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  else {  	// Normal method  	script = PrefixName (assemblyDef' typeDef' methodDef' RecaseMethod (assemblyDef' typeDef' methodDef' script)' false);  	return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (outer != null) {  	var isOnMethod = attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);  	var localScript = default(JST.Expression);  	if (isOnMethod)  		attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' false' false' ref localScript);  	switch (outer.Flavor) {  	case CST.MemberDefFlavor.Property: {  		var propDef = (CST.PropertyDef)outer;  		if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  			// Getter  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  					return new JST.IndexExpression (arguments [0]' arguments [1]);  				else {  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 0)  						return script;  					else if (!methodDef.IsStatic && arguments.Count == 1)  						return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  					else {  						env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  						throw new DefinitionException ();  					}  				}  			}  		}  		else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  			// Setter  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  					return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  				else {  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else {  						env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  						throw new DefinitionException ();  					}  				}  			}  		}  		else  			throw new InvalidOperationException ();  	}  	case CST.MemberDefFlavor.Event: {  		var eventDef = (CST.EventDef)outer;  		// XREF1201  		if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  			// Adder  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				// The delegate argument has already taken account of the combine' so   				// just a field assignment  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else  					throw new InvalidOperationException ("mismatched event adder arity");  			}  		}  		else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  			// Remover  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				// The delegate argument has already taken account of the delete' so   				// just a field assignment  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else  					throw new InvalidOperationException ("mismatched event remover arity");  			}  		}  		else  			throw new InvalidOperationException ();  	}  	case CST.MemberDefFlavor.Field:  	case CST.MemberDefFlavor.Method:  		throw new InvalidOperationException ("outer is not property or event");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  else {  	// Normal method  	script = PrefixName (assemblyDef' typeDef' methodDef' RecaseMethod (assemblyDef' typeDef' methodDef' script)' false);  	return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (outer != null) {  	var isOnMethod = attributeHelper.MethodHasAttribute (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' false' false);  	var localScript = default(JST.Expression);  	if (isOnMethod)  		attributeHelper.GetValueFromMethod (assemblyDef' typeDef' methodDef' attributeHelper.ImportAttributeRef' attributeHelper.TheScriptProperty' false' false' ref localScript);  	switch (outer.Flavor) {  	case CST.MemberDefFlavor.Property: {  		var propDef = (CST.PropertyDef)outer;  		if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  			// Getter  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  					return new JST.IndexExpression (arguments [0]' arguments [1]);  				else {  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 0)  						return script;  					else if (!methodDef.IsStatic && arguments.Count == 1)  						return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  					else {  						env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  						throw new DefinitionException ();  					}  				}  			}  		}  		else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  			// Setter  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  					return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  				else {  					script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  					if (methodDef.IsStatic && arguments.Count == 1)  						return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  					else if (!methodDef.IsStatic && arguments.Count == 2)  						return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  					else {  						env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  						throw new DefinitionException ();  					}  				}  			}  		}  		else  			throw new InvalidOperationException ();  	}  	case CST.MemberDefFlavor.Event: {  		var eventDef = (CST.EventDef)outer;  		// XREF1201  		if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  			// Adder  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				// The delegate argument has already taken account of the combine' so   				// just a field assignment  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else  					throw new InvalidOperationException ("mismatched event adder arity");  			}  		}  		else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  			// Remover  			if (isOnMethod) {  				script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  				return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  			}  			else if (script != null && script is JST.FunctionExpression) {  				env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  				throw new DefinitionException ();  			}  			else {  				// The delegate argument has already taken account of the delete' so   				// just a field assignment  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else  					throw new InvalidOperationException ("mismatched event remover arity");  			}  		}  		else  			throw new InvalidOperationException ();  	}  	case CST.MemberDefFlavor.Field:  	case CST.MemberDefFlavor.Method:  		throw new InvalidOperationException ("outer is not property or event");  	default:  		throw new ArgumentOutOfRangeException ();  	}  }  else {  	// Normal method  	script = PrefixName (assemblyDef' typeDef' methodDef' RecaseMethod (assemblyDef' typeDef' methodDef' script)' false);  	return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: switch (outer.Flavor) {  case CST.MemberDefFlavor.Property: {  	var propDef = (CST.PropertyDef)outer;  	if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  		// Getter  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  				return new JST.IndexExpression (arguments [0]' arguments [1]);  			else {  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 0)  					return script;  				else if (!methodDef.IsStatic && arguments.Count == 1)  					return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  				else {  					env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  					throw new DefinitionException ();  				}  			}  		}  	}  	else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  		// Setter  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  				return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  			else {  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else {  					env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  					throw new DefinitionException ();  				}  			}  		}  	}  	else  		throw new InvalidOperationException ();  }  case CST.MemberDefFlavor.Event: {  	var eventDef = (CST.EventDef)outer;  	// XREF1201  	if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  		// Adder  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			// The delegate argument has already taken account of the combine' so   			// just a field assignment  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else  				throw new InvalidOperationException ("mismatched event adder arity");  		}  	}  	else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  		// Remover  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			// The delegate argument has already taken account of the delete' so   			// just a field assignment  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else  				throw new InvalidOperationException ("mismatched event remover arity");  		}  	}  	else  		throw new InvalidOperationException ();  }  case CST.MemberDefFlavor.Field:  case CST.MemberDefFlavor.Method:  	throw new InvalidOperationException ("outer is not property or event");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: switch (outer.Flavor) {  case CST.MemberDefFlavor.Property: {  	var propDef = (CST.PropertyDef)outer;  	if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  		// Getter  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  				return new JST.IndexExpression (arguments [0]' arguments [1]);  			else {  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 0)  					return script;  				else if (!methodDef.IsStatic && arguments.Count == 1)  					return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  				else {  					env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  					throw new DefinitionException ();  				}  			}  		}  	}  	else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  		// Setter  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  				return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  			else {  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else {  					env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  					throw new DefinitionException ();  				}  			}  		}  	}  	else  		throw new InvalidOperationException ();  }  case CST.MemberDefFlavor.Event: {  	var eventDef = (CST.EventDef)outer;  	// XREF1201  	if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  		// Adder  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			// The delegate argument has already taken account of the combine' so   			// just a field assignment  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else  				throw new InvalidOperationException ("mismatched event adder arity");  		}  	}  	else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  		// Remover  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			// The delegate argument has already taken account of the delete' so   			// just a field assignment  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else  				throw new InvalidOperationException ("mismatched event remover arity");  		}  	}  	else  		throw new InvalidOperationException ();  }  case CST.MemberDefFlavor.Field:  case CST.MemberDefFlavor.Method:  	throw new InvalidOperationException ("outer is not property or event");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: switch (outer.Flavor) {  case CST.MemberDefFlavor.Property: {  	var propDef = (CST.PropertyDef)outer;  	if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  		// Getter  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  				return new JST.IndexExpression (arguments [0]' arguments [1]);  			else {  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 0)  					return script;  				else if (!methodDef.IsStatic && arguments.Count == 1)  					return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  				else {  					env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  					throw new DefinitionException ();  				}  			}  		}  	}  	else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  		// Setter  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  				return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  			else {  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else {  					env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  					throw new DefinitionException ();  				}  			}  		}  	}  	else  		throw new InvalidOperationException ();  }  case CST.MemberDefFlavor.Event: {  	var eventDef = (CST.EventDef)outer;  	// XREF1201  	if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  		// Adder  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			// The delegate argument has already taken account of the combine' so   			// just a field assignment  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else  				throw new InvalidOperationException ("mismatched event adder arity");  		}  	}  	else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  		// Remover  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			// The delegate argument has already taken account of the delete' so   			// just a field assignment  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else  				throw new InvalidOperationException ("mismatched event remover arity");  		}  	}  	else  		throw new InvalidOperationException ();  }  case CST.MemberDefFlavor.Field:  case CST.MemberDefFlavor.Method:  	throw new InvalidOperationException ("outer is not property or event");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: switch (outer.Flavor) {  case CST.MemberDefFlavor.Property: {  	var propDef = (CST.PropertyDef)outer;  	if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  		// Getter  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  				return new JST.IndexExpression (arguments [0]' arguments [1]);  			else {  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 0)  					return script;  				else if (!methodDef.IsStatic && arguments.Count == 1)  					return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  				else {  					env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  					throw new DefinitionException ();  				}  			}  		}  	}  	else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  		// Setter  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  				return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  			else {  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else {  					env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  					throw new DefinitionException ();  				}  			}  		}  	}  	else  		throw new InvalidOperationException ();  }  case CST.MemberDefFlavor.Event: {  	var eventDef = (CST.EventDef)outer;  	// XREF1201  	if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  		// Adder  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			// The delegate argument has already taken account of the combine' so   			// just a field assignment  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else  				throw new InvalidOperationException ("mismatched event adder arity");  		}  	}  	else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  		// Remover  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			// The delegate argument has already taken account of the delete' so   			// just a field assignment  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else  				throw new InvalidOperationException ("mismatched event remover arity");  		}  	}  	else  		throw new InvalidOperationException ();  }  case CST.MemberDefFlavor.Field:  case CST.MemberDefFlavor.Method:  	throw new InvalidOperationException ("outer is not property or event");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: switch (outer.Flavor) {  case CST.MemberDefFlavor.Property: {  	var propDef = (CST.PropertyDef)outer;  	if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  		// Getter  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  				return new JST.IndexExpression (arguments [0]' arguments [1]);  			else {  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 0)  					return script;  				else if (!methodDef.IsStatic && arguments.Count == 1)  					return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  				else {  					env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  					throw new DefinitionException ();  				}  			}  		}  	}  	else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  		// Setter  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  				return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  			else {  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else {  					env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  					throw new DefinitionException ();  				}  			}  		}  	}  	else  		throw new InvalidOperationException ();  }  case CST.MemberDefFlavor.Event: {  	var eventDef = (CST.EventDef)outer;  	// XREF1201  	if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  		// Adder  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			// The delegate argument has already taken account of the combine' so   			// just a field assignment  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else  				throw new InvalidOperationException ("mismatched event adder arity");  		}  	}  	else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  		// Remover  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			// The delegate argument has already taken account of the delete' so   			// just a field assignment  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else  				throw new InvalidOperationException ("mismatched event remover arity");  		}  	}  	else  		throw new InvalidOperationException ();  }  case CST.MemberDefFlavor.Field:  case CST.MemberDefFlavor.Method:  	throw new InvalidOperationException ("outer is not property or event");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: switch (outer.Flavor) {  case CST.MemberDefFlavor.Property: {  	var propDef = (CST.PropertyDef)outer;  	if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  		// Getter  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  				return new JST.IndexExpression (arguments [0]' arguments [1]);  			else {  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 0)  					return script;  				else if (!methodDef.IsStatic && arguments.Count == 1)  					return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  				else {  					env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  					throw new DefinitionException ();  				}  			}  		}  	}  	else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  		// Setter  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  				return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  			else {  				script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  				if (methodDef.IsStatic && arguments.Count == 1)  					return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  				else if (!methodDef.IsStatic && arguments.Count == 2)  					return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  				else {  					env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  					throw new DefinitionException ();  				}  			}  		}  	}  	else  		throw new InvalidOperationException ();  }  case CST.MemberDefFlavor.Event: {  	var eventDef = (CST.EventDef)outer;  	// XREF1201  	if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  		// Adder  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			// The delegate argument has already taken account of the combine' so   			// just a field assignment  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else  				throw new InvalidOperationException ("mismatched event adder arity");  		}  	}  	else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  		// Remover  		if (isOnMethod) {  			script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  			return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  		}  		else if (script != null && script is JST.FunctionExpression) {  			env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  			throw new DefinitionException ();  		}  		else {  			// The delegate argument has already taken account of the delete' so   			// just a field assignment  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else  				throw new InvalidOperationException ("mismatched event remover arity");  		}  	}  	else  		throw new InvalidOperationException ();  }  case CST.MemberDefFlavor.Field:  case CST.MemberDefFlavor.Method:  	throw new InvalidOperationException ("outer is not property or event");  default:  	throw new ArgumentOutOfRangeException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  	// Getter  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  			return new JST.IndexExpression (arguments [0]' arguments [1]);  		else {  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 0)  				return script;  			else if (!methodDef.IsStatic && arguments.Count == 1)  				return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  			else {  				env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  				throw new DefinitionException ();  			}  		}  	}  }  else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  	// Setter  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  			return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  		else {  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else {  				env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  				throw new DefinitionException ();  			}  		}  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  	// Getter  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  			return new JST.IndexExpression (arguments [0]' arguments [1]);  		else {  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 0)  				return script;  			else if (!methodDef.IsStatic && arguments.Count == 1)  				return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  			else {  				env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  				throw new DefinitionException ();  			}  		}  	}  }  else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  	// Setter  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  			return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  		else {  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else {  				env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  				throw new DefinitionException ();  			}  		}  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  	// Getter  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  			return new JST.IndexExpression (arguments [0]' arguments [1]);  		else {  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 0)  				return script;  			else if (!methodDef.IsStatic && arguments.Count == 1)  				return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  			else {  				env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  				throw new DefinitionException ();  			}  		}  	}  }  else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  	// Setter  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  			return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  		else {  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else {  				env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  				throw new DefinitionException ();  			}  		}  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (propDef.Get != null && methodDef.Signature.Equals (propDef.Get)) {  	// Getter  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  			return new JST.IndexExpression (arguments [0]' arguments [1]);  		else {  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 0)  				return script;  			else if (!methodDef.IsStatic && arguments.Count == 1)  				return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  			else {  				env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  				throw new DefinitionException ();  			}  		}  	}  }  else if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  	// Setter  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  			return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  		else {  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else {  				env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  				throw new DefinitionException ();  			}  		}  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (isOnMethod) {  	script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "get"' localScript)' false);  	return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  }  else if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  		return new JST.IndexExpression (arguments [0]' arguments [1]);  	else {  		script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  		if (methodDef.IsStatic && arguments.Count == 0)  			return script;  		else if (!methodDef.IsStatic && arguments.Count == 1)  			return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  		else {  			env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  			throw new DefinitionException ();  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  		return new JST.IndexExpression (arguments [0]' arguments [1]);  	else {  		script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  		if (methodDef.IsStatic && arguments.Count == 0)  			return script;  		else if (!methodDef.IsStatic && arguments.Count == 1)  			return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  		else {  			env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  			throw new DefinitionException ();  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (script == null && arguments.Count == 2 && !methodDef.IsStatic)  	return new JST.IndexExpression (arguments [0]' arguments [1]);  else {  	script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  	if (methodDef.IsStatic && arguments.Count == 0)  		return script;  	else if (!methodDef.IsStatic && arguments.Count == 1)  		return JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script));  	else {  		env.Log (new InvalidInteropMessage (ctxt' "additional getter parameters not supported for default getters"));  		throw new DefinitionException ();  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  	// Setter  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  			return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  		else {  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else {  				env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  				throw new DefinitionException ();  			}  		}  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  	// Setter  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  			return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  		else {  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else {  				env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  				throw new DefinitionException ();  			}  		}  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (propDef.Set != null && methodDef.Signature.Equals (propDef.Set)) {  	// Setter  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  			return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  		else {  			script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  			if (methodDef.IsStatic && arguments.Count == 1)  				return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  			else if (!methodDef.IsStatic && arguments.Count == 2)  				return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  			else {  				env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  				throw new DefinitionException ();  			}  		}  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (isOnMethod) {  	script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  	return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  }  else if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  		return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  	else {  		script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  		if (methodDef.IsStatic && arguments.Count == 1)  			return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  		else if (!methodDef.IsStatic && arguments.Count == 2)  			return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  		else {  			env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  			throw new DefinitionException ();  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (isOnMethod) {  	script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  	return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  }  else if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  		return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  	else {  		script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  		if (methodDef.IsStatic && arguments.Count == 1)  			return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  		else if (!methodDef.IsStatic && arguments.Count == 2)  			return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  		else {  			env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  			throw new DefinitionException ();  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (isOnMethod) {  	script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "set"' localScript)' false);  	return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  }  else if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  		return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  	else {  		script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  		if (methodDef.IsStatic && arguments.Count == 1)  			return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  		else if (!methodDef.IsStatic && arguments.Count == 2)  			return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  		else {  			env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  			throw new DefinitionException ();  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  		return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  	else {  		script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  		if (methodDef.IsStatic && arguments.Count == 1)  			return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  		else if (!methodDef.IsStatic && arguments.Count == 2)  			return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  		else {  			env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  			throw new DefinitionException ();  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  		return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  	else {  		script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  		if (methodDef.IsStatic && arguments.Count == 1)  			return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  		else if (!methodDef.IsStatic && arguments.Count == 2)  			return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  		else {  			env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  			throw new DefinitionException ();  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (ctxt' "property import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  		return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  	else {  		script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  		if (methodDef.IsStatic && arguments.Count == 1)  			return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  		else if (!methodDef.IsStatic && arguments.Count == 2)  			return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  		else {  			env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  			throw new DefinitionException ();  		}  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  	return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  else {  	script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  	if (methodDef.IsStatic && arguments.Count == 1)  		return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  	else if (!methodDef.IsStatic && arguments.Count == 2)  		return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  	else {  		env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  		throw new DefinitionException ();  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  	return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  else {  	script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  	if (methodDef.IsStatic && arguments.Count == 1)  		return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  	else if (!methodDef.IsStatic && arguments.Count == 2)  		return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  	else {  		env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  		throw new DefinitionException ();  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (script == null && arguments.Count == 3 && !methodDef.IsStatic)  	return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  else {  	script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  	if (methodDef.IsStatic && arguments.Count == 1)  		return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  	else if (!methodDef.IsStatic && arguments.Count == 2)  		return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  	else {  		env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  		throw new DefinitionException ();  	}  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: return new JST.BinaryExpression (new JST.IndexExpression (arguments [0]' arguments [1])' JST.BinaryOp.Assignment' arguments [2]);  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (methodDef.IsStatic && arguments.Count == 1)  	return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  else if (!methodDef.IsStatic && arguments.Count == 2)  	return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  else {  	env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  	throw new DefinitionException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && arguments.Count == 2)  	return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  else {  	env.Log (new InvalidInteropMessage (ctxt' "additional setter parameters not supported for default setters"));  	throw new DefinitionException ();  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  	// Adder  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		// The delegate argument has already taken account of the combine' so   		// just a field assignment  		script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  		if (methodDef.IsStatic && arguments.Count == 1)  			return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  		else if (!methodDef.IsStatic && arguments.Count == 2)  			return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  		else  			throw new InvalidOperationException ("mismatched event adder arity");  	}  }  else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  	// Remover  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		// The delegate argument has already taken account of the delete' so   		// just a field assignment  		script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  		if (methodDef.IsStatic && arguments.Count == 1)  			return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  		else if (!methodDef.IsStatic && arguments.Count == 2)  			return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  		else  			throw new InvalidOperationException ("mismatched event remover arity");  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (eventDef.Add != null && methodDef.Signature.Equals (eventDef.Add)) {  	// Adder  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		// The delegate argument has already taken account of the combine' so   		// just a field assignment  		script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  		if (methodDef.IsStatic && arguments.Count == 1)  			return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  		else if (!methodDef.IsStatic && arguments.Count == 2)  			return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  		else  			throw new InvalidOperationException ("mismatched event adder arity");  	}  }  else if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  	// Remover  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		// The delegate argument has already taken account of the delete' so   		// just a field assignment  		script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  		if (methodDef.IsStatic && arguments.Count == 1)  			return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  		else if (!methodDef.IsStatic && arguments.Count == 2)  			return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  		else  			throw new InvalidOperationException ("mismatched event remover arity");  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (isOnMethod) {  	script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "add"' localScript)' false);  	return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  }  else if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	// The delegate argument has already taken account of the combine' so   	// just a field assignment  	script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  	if (methodDef.IsStatic && arguments.Count == 1)  		return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  	else if (!methodDef.IsStatic && arguments.Count == 2)  		return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  	else  		throw new InvalidOperationException ("mismatched event adder arity");  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	// The delegate argument has already taken account of the combine' so   	// just a field assignment  	script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  	if (methodDef.IsStatic && arguments.Count == 1)  		return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  	else if (!methodDef.IsStatic && arguments.Count == 2)  		return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  	else  		throw new InvalidOperationException ("mismatched event adder arity");  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (methodDef.IsStatic && arguments.Count == 1)  	return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  else if (!methodDef.IsStatic && arguments.Count == 2)  	return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  else  	throw new InvalidOperationException ("mismatched event adder arity");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && arguments.Count == 2)  	return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  else  	throw new InvalidOperationException ("mismatched event adder arity");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (eventDef.Remove != null && methodDef.Signature.Equals (eventDef.Remove)) {  	// Remover  	if (isOnMethod) {  		script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  		return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  	}  	else if (script != null && script is JST.FunctionExpression) {  		env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  		throw new DefinitionException ();  	}  	else {  		// The delegate argument has already taken account of the delete' so   		// just a field assignment  		script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  		if (methodDef.IsStatic && arguments.Count == 1)  			return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  		else if (!methodDef.IsStatic && arguments.Count == 2)  			return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  		else  			throw new InvalidOperationException ("mismatched event remover arity");  	}  }  else  	throw new InvalidOperationException ();  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (isOnMethod) {  	script = PrefixName (assemblyDef' typeDef' methodDef' GetterSetterAdderRemoverNameFromMethod (assemblyDef' typeDef' methodDef' "remove"' localScript)' false);  	return AppendFinalImport (nameSupply' rootId' assemblyDef' typeDef' methodDef' script' body' arguments);  }  else if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	// The delegate argument has already taken account of the delete' so   	// just a field assignment  	script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  	if (methodDef.IsStatic && arguments.Count == 1)  		return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  	else if (!methodDef.IsStatic && arguments.Count == 2)  		return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  	else  		throw new InvalidOperationException ("mismatched event remover arity");  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (script != null && script is JST.FunctionExpression) {  	env.Log (new InvalidInteropMessage (ctxt' "event import script cannot be a function"));  	throw new DefinitionException ();  }  else {  	// The delegate argument has already taken account of the delete' so   	// just a field assignment  	script = PrefixName (assemblyDef' typeDef' methodDef' RecasePropertyEvent (assemblyDef' typeDef' methodDef' script)' false);  	if (methodDef.IsStatic && arguments.Count == 1)  		return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  	else if (!methodDef.IsStatic && arguments.Count == 2)  		return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  	else  		throw new InvalidOperationException ("mismatched event remover arity");  }  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (methodDef.IsStatic && arguments.Count == 1)  	return new JST.BinaryExpression (script' JST.BinaryOp.Assignment' arguments [0]);  else if (!methodDef.IsStatic && arguments.Count == 2)  	return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  else  	throw new InvalidOperationException ("mismatched event remover arity");  
Magic Number,Microsoft.LiveLabs.JavaScript.IL2JS.Interop,InteropManager,C:\repos\Reactive-Extensions_IL2JS\Compiler\InteropManager.cs,AppendImport,The following statement contains a magic number: if (!methodDef.IsStatic && arguments.Count == 2)  	return new JST.BinaryExpression (JST.Expression.Dot (arguments [0]' JST.Expression.ExplodePath (script))' JST.BinaryOp.Assignment' arguments [1]);  else  	throw new InvalidOperationException ("mismatched event remover arity");  
