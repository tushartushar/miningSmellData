Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,LongVersionOf,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,ShortVersionOf,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,SizeOfOffset,Cyclomatic complexity of the method is 15
Long Statement,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The length of the statement  "				if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) { " is 134.
Long Statement,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The length of the statement  "				// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes " is 121.
Long Statement,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The length of the statement  "					//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one. " is 140.
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == (OperationCode)int.MaxValue) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  				numberOfAdjustments++;  				adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  				operation.operationCode = OperationCode.Ret;  				operation.value = null;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = (OperationCode)int.MaxValue;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == (OperationCode)int.MaxValue) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  				numberOfAdjustments++;  				adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  				operation.operationCode = OperationCode.Ret;  				operation.value = null;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = (OperationCode)int.MaxValue;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == (OperationCode)int.MaxValue) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  				numberOfAdjustments++;  				adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  				operation.operationCode = OperationCode.Ret;  				operation.value = null;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = (OperationCode)int.MaxValue;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == (OperationCode)int.MaxValue) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  				numberOfAdjustments++;  				adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  				operation.operationCode = OperationCode.Ret;  				operation.value = null;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = (OperationCode)int.MaxValue;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == (OperationCode)int.MaxValue) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  				numberOfAdjustments++;  				adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  				operation.operationCode = OperationCode.Ret;  				operation.value = null;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = (OperationCode)int.MaxValue;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == (OperationCode)int.MaxValue) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  				numberOfAdjustments++;  				adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  				operation.operationCode = OperationCode.Ret;  				operation.value = null;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = (OperationCode)int.MaxValue;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == (OperationCode)int.MaxValue) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  			numberOfAdjustments++;  			adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  			operation.operationCode = OperationCode.Ret;  			operation.value = null;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = (OperationCode)int.MaxValue;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == (OperationCode)int.MaxValue) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  			numberOfAdjustments++;  			adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  			operation.operationCode = OperationCode.Ret;  			operation.value = null;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = (OperationCode)int.MaxValue;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == (OperationCode)int.MaxValue) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  			numberOfAdjustments++;  			adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  			operation.operationCode = OperationCode.Ret;  			operation.value = null;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = (OperationCode)int.MaxValue;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == (OperationCode)int.MaxValue) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  			numberOfAdjustments++;  			adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  			operation.operationCode = OperationCode.Ret;  			operation.value = null;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = (OperationCode)int.MaxValue;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == (OperationCode)int.MaxValue) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  			numberOfAdjustments++;  			adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  			operation.operationCode = OperationCode.Ret;  			operation.value = null;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = (OperationCode)int.MaxValue;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == (OperationCode)int.MaxValue) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  			numberOfAdjustments++;  			adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  			operation.operationCode = OperationCode.Ret;  			operation.value = null;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = (OperationCode)int.MaxValue;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == (OperationCode)int.MaxValue) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  		numberOfAdjustments++;  		adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  		operation.operationCode = OperationCode.Ret;  		operation.value = null;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = (OperationCode)int.MaxValue;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == (OperationCode)int.MaxValue) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  		numberOfAdjustments++;  		adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  		operation.operationCode = OperationCode.Ret;  		operation.value = null;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = (OperationCode)int.MaxValue;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == (OperationCode)int.MaxValue) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  		numberOfAdjustments++;  		adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  		operation.operationCode = OperationCode.Ret;  		operation.value = null;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = (OperationCode)int.MaxValue;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == (OperationCode)int.MaxValue) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  		numberOfAdjustments++;  		adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  		operation.operationCode = OperationCode.Ret;  		operation.value = null;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = (OperationCode)int.MaxValue;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == (OperationCode)int.MaxValue) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  		numberOfAdjustments++;  		adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  		operation.operationCode = OperationCode.Ret;  		operation.value = null;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = (OperationCode)int.MaxValue;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == (OperationCode)int.MaxValue) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  		numberOfAdjustments++;  		adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  		operation.operationCode = OperationCode.Ret;  		operation.value = null;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : oldOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = (OperationCode)int.MaxValue;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label.labelsReturnInstruction && (operation.OperationCode == OperationCode.Br || operation.OperationCode == OperationCode.Br_S)) {  	numberOfAdjustments++;  	adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  	operation.operationCode = OperationCode.Ret;  	operation.value = null;  	continue;  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: adjustment -= (operation.OperationCode == OperationCode.Br ? 4 : 1);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (shortOffsetOk) {  	operation.operationCode = ShortVersionOf (operation.OperationCode);  	if (operation.operationCode != oldOpCode) {  		numberOfAdjustments++;  		adjustment -= 3;  	}  }  else {  	if (operation.operationCode != LongVersionOf (operation.operationCode))  		throw new InvalidOperationException ();  	//A short branch was specified for an offset that is long.  	//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (operation.operationCode != oldOpCode) {  	numberOfAdjustments++;  	adjustment -= 3;  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: adjustment -= 3;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  	//eliminate branch to the next instruction  	operation.operationCode = (OperationCode)int.MaxValue;  	numberOfAdjustments++;  	adjustment -= 2;  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  	//eliminate branch to the next instruction  	operation.operationCode = (OperationCode)int.MaxValue;  	numberOfAdjustments++;  	adjustment -= 2;  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: adjustment -= 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 8;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4 * ((uint)labels.Length + 1);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: if (opcode == OperationCode.Ldloc_S || opcode == OperationCode.Ldloca_S || opcode == OperationCode.Stloc_S)  	this.offset += 1;  else if (opcode == OperationCode.Ldloc || opcode == OperationCode.Ldloca || opcode == OperationCode.Stloc)  	this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: if (opcode == OperationCode.Ldloc || opcode == OperationCode.Ldloca || opcode == OperationCode.Stloc)  	this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 8;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: if (opcode == OperationCode.Ldarg_S || opcode == OperationCode.Ldarga_S || opcode == OperationCode.Starg_S)  	this.offset += 1;  else if (opcode == OperationCode.Ldarg || opcode == OperationCode.Ldarga || opcode == OperationCode.Starg)  	this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: if (opcode == OperationCode.Ldarg || opcode == OperationCode.Ldarga || opcode == OperationCode.Starg)  	this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,SizeOfOffset,The following statement contains a magic number: switch (opcode) {  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_S:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un_S:  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Leave_S:  	return 1;  default:  	return 4;  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,SizeOfOffset,The following statement contains a magic number: return 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,SizeOfOperationCode,The following statement contains a magic number: if (((int)opcode) > 0xff && (opcode < OperationCode.Array_Create))  	return 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\Reactive-Extensions_IL2JS\CCI2\ILGenerator\ILGenerator.cs,SizeOfOperationCode,The following statement contains a magic number: return 2;  
