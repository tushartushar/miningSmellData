Implementation smell,Namespace,Class,File,Method,Description
Long Method,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadSteam3Async,The method has 354 lines of code.
Long Method,DepotDownloader,Program,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Program.cs,MainAsync,The method has 148 lines of code.
Complex Method,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,GetSteam3DepotManifest,Cyclomatic complexity of the method is 13
Complex Method,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadAppAsync,Cyclomatic complexity of the method is 18
Complex Method,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,GetDepotInfo,Cyclomatic complexity of the method is 8
Complex Method,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadSteam3Async,Cyclomatic complexity of the method is 16
Complex Method,DepotDownloader,Program,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Program.cs,MainAsync,Cyclomatic complexity of the method is 12
Complex Method,DepotDownloader,Steam3Session,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Steam3Session.cs,LogOnCallback,Cyclomatic complexity of the method is 9
Long Parameter List,DepotDownloader,CDNClientPool,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\CDNClientPool.cs,BuildConnectionAsync,The method has 5 parameters. Parameters: appId' depotId' depotKey' serverSeed' token
Long Parameter List,DepotDownloader,CDNClientPool,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\CDNClientPool.cs,ReauthConnectionAsync,The method has 5 parameters. Parameters: client' server' appId' depotId' depotKey
Long Parameter List,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadAppAsync,The method has 6 parameters. Parameters: appId' depotId' manifestId' branch' os' isUgc
Long Statement,DepotDownloader,CDNClientPool,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\CDNClientPool.cs,FetchBootstrapServerListAsync,The length of the statement  "                    var cdnServers = await ContentServerDirectoryService.LoadAsync(this.steamSession.steamClient.Configuration' ContentDownloader.Config.CellID' shutdownToken.Token); " is 162.
Long Statement,DepotDownloader,CDNClientPool,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\CDNClientPool.cs,ConnectionPoolMonitorAsync,The length of the statement  "                // We want the Steam session so we can take the CellID from the session and pass it through to the ContentServer Directory Service " is 130.
Long Statement,DepotDownloader,CDNClientPool,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\CDNClientPool.cs,ReauthConnectionAsync,The length of the statement  "            DebugLog.Assert(server.Type == "CDN" || server.Type == "SteamCache" || steamSession.AppTickets[depotId] == null' "CDNClientPool"' "Re-authing a CDN or anonymous connection"); " is 174.
Long Statement,DepotDownloader,CDNClientPool,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\CDNClientPool.cs,GetConnectionForDepotAsync,The length of the statement  "                if ((authData.Item2.Type == "CDN" || authData.Item2.Type == "SteamCache") && await ReauthConnectionAsync(client' authData.Item2' appId' depotId' depotKey).ConfigureAwait(false)) " is 177.
Long Statement,DepotDownloader,CDNClientPool,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\CDNClientPool.cs,GetConnectionForDepotAsync,The length of the statement  "                    Console.WriteLine("Re-authed CDN connection to content server {0} from {1} to {2}"' authData.Item2' authData.Item1' depotId); " is 125.
Long Statement,DepotDownloader,CDNClientPool,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\CDNClientPool.cs,GetConnectionForDepotAsync,The length of the statement  "                else if (authData.Item2.Type == "CS" && steamSession.AppTickets[depotId] == null && await ReauthConnectionAsync(client' authData.Item2' appId' depotId' depotKey).ConfigureAwait(false)) " is 184.
Long Statement,DepotDownloader,CDNClientPool,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\CDNClientPool.cs,GetConnectionForDepotAsync,The length of the statement  "                    Console.WriteLine("Re-authed anonymous connection to content server {0} from {1} to {2}"' authData.Item2' authData.Item1' depotId); " is 131.
Long Statement,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,AccountHasAccess,The length of the statement  "            if ( steam3 == null || steam3.steamUser.SteamID == null || ( steam3.Licenses == null && steam3.steamUser.SteamID.AccountType != EAccountType.AnonUser ) ) " is 153.
Long Statement,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadPubfileAsync,The length of the statement  "                await DownloadAppAsync( details.consumer_appid' details.consumer_appid' details.hcontent_file' DEFAULT_BRANCH' null' true ); " is 124.
Long Statement,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadAppAsync,The length of the statement  "                    throw new ContentDownloaderException( String.Format( "App {0} ({1}) is not available from this account."' appId' contentName ) ); " is 129.
Long Statement,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadAppAsync,The length of the statement  "                            if ( depotConfig != KeyValue.Invalid && depotConfig[ "oslist" ] != KeyValue.Invalid && !string.IsNullOrWhiteSpace( depotConfig[ "oslist" ].Value ) ) " is 148.
Long Statement,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadSteam3Async,The length of the statement  "                                client = await cdnPool.GetConnectionForDepotAsync( appId' depot.id' depot.depotKey' CancellationToken.None ).ConfigureAwait( false ); " is 133.
Long Statement,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadSteam3Async,The length of the statement  "                                        Console.WriteLine( "Encountered error downloading depot manifest {0} {1}: {2}"' depot.id' depot.manifestId' response.StatusCode ); " is 130.
Long Statement,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadSteam3Async,The length of the statement  "                                    Console.WriteLine( "Encountered error downloading manifest for depot {0} {1}: {2}"' depot.id' depot.manifestId' e.Status ); " is 123.
Long Statement,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadSteam3Async,The length of the statement  "                                Console.WriteLine( "Encountered error downloading manifest for depot {0} {1}: {2}"' depot.id' depot.manifestId' e.Message ); " is 124.
Long Statement,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadSteam3Async,The length of the statement  "                                    Console.WriteLine( "{0'6:#00.00}% {1}"' ( ( float )size_downloaded / ( float )complete_download_size ) * 100.0f' fileFinalPath ); " is 129.
Long Statement,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadSteam3Async,The length of the statement  "                                        client = await cdnPool.GetConnectionForDepotAsync( appId' depot.id' depot.depotKey' cts.Token ).ConfigureAwait( false ); " is 120.
Long Statement,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadSteam3Async,The length of the statement  "                            Console.WriteLine( "{0'6:#00.00}% {1}"' ( ( float )size_downloaded / ( float )complete_download_size ) * 100.0f' fileFinalPath ); " is 129.
Long Statement,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadSteam3Async,The length of the statement  "                Console.WriteLine( "Depot {0} - Downloaded {1} bytes ({2} bytes uncompressed)"' depot.id' DepotBytesCompressed' DepotBytesUncompressed ); " is 137.
Long Statement,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadSteam3Async,The length of the statement  "            Console.WriteLine( "Total downloaded: {0} bytes ({1} bytes uncompressed) from {2} depots"' TotalBytesCompressed' TotalBytesUncompressed' depots.Count ); " is 152.
Long Statement,DepotDownloader,Program,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Program.cs,MainAsync,The length of the statement  "            ContentDownloader.Config.VerifyAll = HasParameter( args' "-verify-all" ) || HasParameter( args' "-verify_all" ) || HasParameter( args' "-validate" ); " is 149.
Long Statement,DepotDownloader,Program,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Program.cs,MainAsync,The length of the statement  "            ContentDownloader.Config.MaxServers = Math.Max( ContentDownloader.Config.MaxServers' ContentDownloader.Config.MaxDownloads ); " is 125.
Long Statement,DepotDownloader,Program,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Program.cs,MainAsync,The length of the statement  "                string branch = GetParameter<string>( args' "-branch" ) ?? GetParameter<string>( args' "-beta" ) ?? ContentDownloader.DEFAULT_BRANCH; " is 133.
Long Statement,DepotDownloader,Program,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Program.cs,InitializeSteam,The length of the statement  "            if ( username != null && password == null && ( !ContentDownloader.Config.RememberPassword || !ConfigStore.TheConfig.LoginKeys.ContainsKey( username ) ) ) " is 153.
Long Statement,DepotDownloader,Program,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Program.cs,PrintUsage,The length of the statement  "            Console.WriteLine( "\t-manifest <id>\t\t\t- manifest id of content to download (requires -depot' default: current for branch)." ); " is 130.
Long Statement,DepotDownloader,Program,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Program.cs,PrintUsage,The length of the statement  "            Console.WriteLine( "\t-os <os>\t\t\t\t- the operating system for which to download the game (windows' macos or linux' default: OS the program is currently running on)" ); " is 170.
Long Statement,DepotDownloader,Program,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Program.cs,PrintUsage,The length of the statement  "            Console.WriteLine( "\t-filelist <file.txt>\t- a list of files to download (from the manifest). Can optionally use regex to download only certain files." ); " is 155.
Long Statement,DepotDownloader,Program,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Program.cs,PrintUsage,The length of the statement  "            Console.WriteLine( "\t-manifest-only\t\t\t- downloads a human readable manifest for any depots that would be downloaded." ); " is 124.
Long Statement,DepotDownloader,Steam3Session,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Steam3Session.cs,RequestAppInfo,The length of the statement  "                callbacks.Subscribe( steamApps.PICSGetAccessTokens( new List<uint>() { appId }' new List<uint>() { } )' cbMethodTokens ); " is 121.
Long Statement,DepotDownloader,Steam3Session,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Steam3Session.cs,RequestAppInfo,The length of the statement  "                callbacks.Subscribe( steamApps.PICSGetProductInfo( new List<SteamApps.PICSRequest>() { request }' new List<SteamApps.PICSRequest>() { } )' cbMethod ); " is 150.
Long Statement,DepotDownloader,Steam3Session,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Steam3Session.cs,GetPubfileDetails,The length of the statement  "                    throw new Exception( $"EResult {(int)callback.Result} ({callback.Result}) while retrieving UGC id for pubfile {pubFile}."); " is 123.
Long Statement,DepotDownloader,Steam3Session,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Steam3Session.cs,LogOnCallback,The length of the statement  "            bool isLoginKey = ContentDownloader.Config.RememberPassword && logonDetails.LoginKey != null && loggedOn.Result == EResult.InvalidPassword; " is 139.
Long Statement,DepotDownloader,Steam3Session,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Steam3Session.cs,UpdateMachineAuthCallback,The length of the statement  "            Console.WriteLine( "Got Machine Auth: {0} {1} {2} {3}"' machineAuth.FileName' machineAuth.Offset' machineAuth.BytesToWrite' machineAuth.Data.Length' hash ); " is 156.
Long Statement,DepotDownloader,Steam3Session,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Steam3Session.cs,UpdateMachineAuthCallback,The length of the statement  "                OneTimePassword = machineAuth.OneTimePassword' // not sure on this one yet' since we've had no examples of steam using OTPs " is 123.
Complex Conditional,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,AccountHasAccess,The conditional expression  "steam3 == null || steam3.steamUser.SteamID == null || ( steam3.Licenses == null && steam3.steamUser.SteamID.AccountType != EAccountType.AnonUser )"  is complex.
Complex Conditional,DepotDownloader,Program,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Program.cs,InitializeSteam,The conditional expression  "username != null && password == null && ( !ContentDownloader.Config.RememberPassword || !ConfigStore.TheConfig.LoginKeys.ContainsKey( username ) )"  is complex.
Magic Number,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,AccountHasAccess,The following statement contains a magic number: licenseQuery = new List<uint>() { 17906 };
Magic Number,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadSteam3Async,The following statement contains a magic number: var task = Task.Run( async () =>                      {                          cts.Token.ThrowIfCancellationRequested();                                                    try                          {                              await semaphore.WaitAsync().ConfigureAwait( false );                              cts.Token.ThrowIfCancellationRequested();                                string fileFinalPath = Path.Combine( depot.installDir' file.FileName );                              string fileStagingPath = Path.Combine( stagingDir' file.FileName );                                // This may still exist if the previous run exited before cleanup                              if ( File.Exists( fileStagingPath ) )                              {                                  File.Delete( fileStagingPath );                              }                                FileStream fs = null;                              List<ProtoManifest.ChunkData> neededChunks;                              FileInfo fi = new FileInfo( fileFinalPath );                              if ( !fi.Exists )                              {                                  // create new file. need all chunks                                  fs = File.Create( fileFinalPath );                                  fs.SetLength( ( long )file.TotalSize );                                  neededChunks = new List<ProtoManifest.ChunkData>( file.Chunks );                              }                              else                              {                                  // open existing                                  ProtoManifest.FileData oldManifestFile = null;                                  if ( oldProtoManifest != null )                                  {                                      oldManifestFile = oldProtoManifest.Files.SingleOrDefault( f => f.FileName == file.FileName );                                  }                                    if ( oldManifestFile != null )                                  {                                      neededChunks = new List<ProtoManifest.ChunkData>();                                        if ( Config.VerifyAll || !oldManifestFile.FileHash.SequenceEqual( file.FileHash ) )                                      {                                          // we have a version of this file' but it doesn't fully match what we want                                            var matchingChunks = new List<ChunkMatch>();                                            foreach ( var chunk in file.Chunks )                                          {                                              var oldChunk = oldManifestFile.Chunks.FirstOrDefault( c => c.ChunkID.SequenceEqual( chunk.ChunkID ) );                                              if ( oldChunk != null )                                              {                                                  matchingChunks.Add( new ChunkMatch( oldChunk' chunk ) );                                              }                                              else                                              {                                                  neededChunks.Add( chunk );                                              }                                          }                                            File.Move( fileFinalPath' fileStagingPath );                                            fs = File.Open( fileFinalPath' FileMode.Create );                                          fs.SetLength( ( long )file.TotalSize );                                            using ( var fsOld = File.Open( fileStagingPath' FileMode.Open ) )                                          {                                              foreach ( var match in matchingChunks )                                              {                                                  fsOld.Seek( ( long )match.OldChunk.Offset' SeekOrigin.Begin );                                                    byte[] tmp = new byte[ match.OldChunk.UncompressedLength ];                                                  fsOld.Read( tmp' 0' tmp.Length );                                                    byte[] adler = Util.AdlerHash( tmp );                                                  if ( !adler.SequenceEqual( match.OldChunk.Checksum ) )                                                  {                                                      neededChunks.Add( match.NewChunk );                                                  }                                                  else                                                  {                                                      fs.Seek( ( long )match.NewChunk.Offset' SeekOrigin.Begin );                                                      fs.Write( tmp' 0' tmp.Length );                                                  }                                              }                                          }                                            File.Delete( fileStagingPath );                                      }                                  }                                  else                                  {                                      // No old manifest or file not in old manifest. We must validate.                                        fs = File.Open( fileFinalPath' FileMode.Open );                                      if ( ( ulong )fi.Length != file.TotalSize )                                      {                                          fs.SetLength( ( long )file.TotalSize );                                      }                                        neededChunks = Util.ValidateSteam3FileChecksums( fs' file.Chunks.OrderBy( x => x.Offset ).ToArray() );                                  }                                    if ( neededChunks.Count() == 0 )                                  {                                      size_downloaded += file.TotalSize;                                      Console.WriteLine( "{0'6:#00.00}% {1}"' ( ( float )size_downloaded / ( float )complete_download_size ) * 100.0f' fileFinalPath );                                      if ( fs != null )                                          fs.Dispose();                                      return;                                  }                                  else                                  {                                      size_downloaded += ( file.TotalSize - ( ulong )neededChunks.Select( x => ( long )x.UncompressedLength ).Sum() );                                  }                              }                                foreach ( var chunk in neededChunks )                              {                                  if ( cts.IsCancellationRequested ) break;                                    string chunkID = Util.EncodeHexString( chunk.ChunkID );                                  CDNClient.DepotChunk chunkData = null;                                    while ( !cts.IsCancellationRequested )                                  {                                      CDNClient client;                                      try                                      {                                          client = await cdnPool.GetConnectionForDepotAsync( appId' depot.id' depot.depotKey' cts.Token ).ConfigureAwait( false );                                      }                                      catch ( OperationCanceledException )                                      {                                          break;                                      }                                        DepotManifest.ChunkData data = new DepotManifest.ChunkData();                                      data.ChunkID = chunk.ChunkID;                                      data.Checksum = chunk.Checksum;                                      data.Offset = chunk.Offset;                                      data.CompressedLength = chunk.CompressedLength;                                      data.UncompressedLength = chunk.UncompressedLength;                                        try                                      {                                          chunkData = await client.DownloadDepotChunkAsync( depot.id' data ).ConfigureAwait( false );                                          cdnPool.ReturnConnection( client );                                          break;                                      }                                      catch ( WebException e )                                      {                                          cdnPool.ReturnBrokenConnection( client );                                            if ( e.Status == WebExceptionStatus.ProtocolError )                                          {                                              var response = e.Response as HttpWebResponse;                                              if ( response.StatusCode == HttpStatusCode.Unauthorized || response.StatusCode == HttpStatusCode.Forbidden )                                              {                                                  Console.WriteLine( "Encountered 401 for chunk {0}. Aborting."' chunkID );                                                  cts.Cancel();                                                  break;                                              }                                              else                                              {                                                  Console.WriteLine( "Encountered error downloading chunk {0}: {1}"' chunkID' response.StatusCode );                                              }                                          }                                          else                                          {                                              Console.WriteLine( "Encountered error downloading chunk {0}: {1}"' chunkID' e.Status );                                          }                                      }                                      catch ( Exception e )                                      {                                          cdnPool.ReturnBrokenConnection( client );                                          Console.WriteLine( "Encountered unexpected error downloading chunk {0}: {1}"' chunkID' e.Message );                                      }                                  }                                    if ( chunkData == null )                                  {                                      Console.WriteLine( "Failed to find any server with chunk {0} for depot {1}. Aborting."' chunkID' depot.id );                                      cts.Cancel();                                  }                                    // Throw the cancellation exception if requested so that this task is marked failed                                  cts.Token.ThrowIfCancellationRequested();                                    TotalBytesCompressed += chunk.CompressedLength;                                  DepotBytesCompressed += chunk.CompressedLength;                                  TotalBytesUncompressed += chunk.UncompressedLength;                                  DepotBytesUncompressed += chunk.UncompressedLength;                                    fs.Seek( ( long )chunk.Offset' SeekOrigin.Begin );                                  fs.Write( chunkData.Data' 0' chunkData.Data.Length );                                    size_downloaded += chunk.UncompressedLength;                              }                                fs.Dispose();                                Console.WriteLine( "{0'6:#00.00}% {1}"' ( ( float )size_downloaded / ( float )complete_download_size ) * 100.0f' fileFinalPath );                          }                          finally                          {                              semaphore.Release();                          }                      } );
Magic Number,DepotDownloader,ContentDownloader,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\ContentDownloader.cs,DownloadSteam3Async,The following statement contains a magic number: var task = Task.Run( async () =>                      {                          cts.Token.ThrowIfCancellationRequested();                                                    try                          {                              await semaphore.WaitAsync().ConfigureAwait( false );                              cts.Token.ThrowIfCancellationRequested();                                string fileFinalPath = Path.Combine( depot.installDir' file.FileName );                              string fileStagingPath = Path.Combine( stagingDir' file.FileName );                                // This may still exist if the previous run exited before cleanup                              if ( File.Exists( fileStagingPath ) )                              {                                  File.Delete( fileStagingPath );                              }                                FileStream fs = null;                              List<ProtoManifest.ChunkData> neededChunks;                              FileInfo fi = new FileInfo( fileFinalPath );                              if ( !fi.Exists )                              {                                  // create new file. need all chunks                                  fs = File.Create( fileFinalPath );                                  fs.SetLength( ( long )file.TotalSize );                                  neededChunks = new List<ProtoManifest.ChunkData>( file.Chunks );                              }                              else                              {                                  // open existing                                  ProtoManifest.FileData oldManifestFile = null;                                  if ( oldProtoManifest != null )                                  {                                      oldManifestFile = oldProtoManifest.Files.SingleOrDefault( f => f.FileName == file.FileName );                                  }                                    if ( oldManifestFile != null )                                  {                                      neededChunks = new List<ProtoManifest.ChunkData>();                                        if ( Config.VerifyAll || !oldManifestFile.FileHash.SequenceEqual( file.FileHash ) )                                      {                                          // we have a version of this file' but it doesn't fully match what we want                                            var matchingChunks = new List<ChunkMatch>();                                            foreach ( var chunk in file.Chunks )                                          {                                              var oldChunk = oldManifestFile.Chunks.FirstOrDefault( c => c.ChunkID.SequenceEqual( chunk.ChunkID ) );                                              if ( oldChunk != null )                                              {                                                  matchingChunks.Add( new ChunkMatch( oldChunk' chunk ) );                                              }                                              else                                              {                                                  neededChunks.Add( chunk );                                              }                                          }                                            File.Move( fileFinalPath' fileStagingPath );                                            fs = File.Open( fileFinalPath' FileMode.Create );                                          fs.SetLength( ( long )file.TotalSize );                                            using ( var fsOld = File.Open( fileStagingPath' FileMode.Open ) )                                          {                                              foreach ( var match in matchingChunks )                                              {                                                  fsOld.Seek( ( long )match.OldChunk.Offset' SeekOrigin.Begin );                                                    byte[] tmp = new byte[ match.OldChunk.UncompressedLength ];                                                  fsOld.Read( tmp' 0' tmp.Length );                                                    byte[] adler = Util.AdlerHash( tmp );                                                  if ( !adler.SequenceEqual( match.OldChunk.Checksum ) )                                                  {                                                      neededChunks.Add( match.NewChunk );                                                  }                                                  else                                                  {                                                      fs.Seek( ( long )match.NewChunk.Offset' SeekOrigin.Begin );                                                      fs.Write( tmp' 0' tmp.Length );                                                  }                                              }                                          }                                            File.Delete( fileStagingPath );                                      }                                  }                                  else                                  {                                      // No old manifest or file not in old manifest. We must validate.                                        fs = File.Open( fileFinalPath' FileMode.Open );                                      if ( ( ulong )fi.Length != file.TotalSize )                                      {                                          fs.SetLength( ( long )file.TotalSize );                                      }                                        neededChunks = Util.ValidateSteam3FileChecksums( fs' file.Chunks.OrderBy( x => x.Offset ).ToArray() );                                  }                                    if ( neededChunks.Count() == 0 )                                  {                                      size_downloaded += file.TotalSize;                                      Console.WriteLine( "{0'6:#00.00}% {1}"' ( ( float )size_downloaded / ( float )complete_download_size ) * 100.0f' fileFinalPath );                                      if ( fs != null )                                          fs.Dispose();                                      return;                                  }                                  else                                  {                                      size_downloaded += ( file.TotalSize - ( ulong )neededChunks.Select( x => ( long )x.UncompressedLength ).Sum() );                                  }                              }                                foreach ( var chunk in neededChunks )                              {                                  if ( cts.IsCancellationRequested ) break;                                    string chunkID = Util.EncodeHexString( chunk.ChunkID );                                  CDNClient.DepotChunk chunkData = null;                                    while ( !cts.IsCancellationRequested )                                  {                                      CDNClient client;                                      try                                      {                                          client = await cdnPool.GetConnectionForDepotAsync( appId' depot.id' depot.depotKey' cts.Token ).ConfigureAwait( false );                                      }                                      catch ( OperationCanceledException )                                      {                                          break;                                      }                                        DepotManifest.ChunkData data = new DepotManifest.ChunkData();                                      data.ChunkID = chunk.ChunkID;                                      data.Checksum = chunk.Checksum;                                      data.Offset = chunk.Offset;                                      data.CompressedLength = chunk.CompressedLength;                                      data.UncompressedLength = chunk.UncompressedLength;                                        try                                      {                                          chunkData = await client.DownloadDepotChunkAsync( depot.id' data ).ConfigureAwait( false );                                          cdnPool.ReturnConnection( client );                                          break;                                      }                                      catch ( WebException e )                                      {                                          cdnPool.ReturnBrokenConnection( client );                                            if ( e.Status == WebExceptionStatus.ProtocolError )                                          {                                              var response = e.Response as HttpWebResponse;                                              if ( response.StatusCode == HttpStatusCode.Unauthorized || response.StatusCode == HttpStatusCode.Forbidden )                                              {                                                  Console.WriteLine( "Encountered 401 for chunk {0}. Aborting."' chunkID );                                                  cts.Cancel();                                                  break;                                              }                                              else                                              {                                                  Console.WriteLine( "Encountered error downloading chunk {0}: {1}"' chunkID' response.StatusCode );                                              }                                          }                                          else                                          {                                              Console.WriteLine( "Encountered error downloading chunk {0}: {1}"' chunkID' e.Status );                                          }                                      }                                      catch ( Exception e )                                      {                                          cdnPool.ReturnBrokenConnection( client );                                          Console.WriteLine( "Encountered unexpected error downloading chunk {0}: {1}"' chunkID' e.Message );                                      }                                  }                                    if ( chunkData == null )                                  {                                      Console.WriteLine( "Failed to find any server with chunk {0} for depot {1}. Aborting."' chunkID' depot.id );                                      cts.Cancel();                                  }                                    // Throw the cancellation exception if requested so that this task is marked failed                                  cts.Token.ThrowIfCancellationRequested();                                    TotalBytesCompressed += chunk.CompressedLength;                                  DepotBytesCompressed += chunk.CompressedLength;                                  TotalBytesUncompressed += chunk.UncompressedLength;                                  DepotBytesUncompressed += chunk.UncompressedLength;                                    fs.Seek( ( long )chunk.Offset' SeekOrigin.Begin );                                  fs.Write( chunkData.Data' 0' chunkData.Data.Length );                                    size_downloaded += chunk.UncompressedLength;                              }                                fs.Dispose();                                Console.WriteLine( "{0'6:#00.00}% {1}"' ( ( float )size_downloaded / ( float )complete_download_size ) * 100.0f' fileFinalPath );                          }                          finally                          {                              semaphore.Release();                          }                      } );
Magic Number,DepotDownloader,Program,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Program.cs,MainAsync,The following statement contains a magic number: ContentDownloader.Config.MaxServers = GetParameter<int>( args' "-max-servers"' 20 );
Magic Number,DepotDownloader,Program,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Program.cs,MainAsync,The following statement contains a magic number: ContentDownloader.Config.MaxDownloads = GetParameter<int>( args' "-max-downloads"' 4 );
Magic Number,DepotDownloader,Steam3Session,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Steam3Session.cs,Disconnect,The following statement contains a magic number: callbacks.RunWaitAllCallbacks( TimeSpan.FromMilliseconds( 100 ) );
Magic Number,DepotDownloader,Steam3Session,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Steam3Session.cs,TryWaitForLoginKey,The following statement contains a magic number: DateTime waitUntil = new DateTime().AddSeconds( 10 );
Magic Number,DepotDownloader,Steam3Session,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Steam3Session.cs,TryWaitForLoginKey,The following statement contains a magic number: callbacks.RunWaitAllCallbacks( TimeSpan.FromMilliseconds( 100 ) );
Magic Number,DepotDownloader,Util,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Util.cs,AdlerHash,The following statement contains a magic number: a = (a + input[i]) % 65521;
Magic Number,DepotDownloader,Util,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Util.cs,AdlerHash,The following statement contains a magic number: b = (b + a) % 65521;
Magic Number,DepotDownloader,Util,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Util.cs,AdlerHash,The following statement contains a magic number: return BitConverter.GetBytes(a | (b << 16));
Magic Number,DepotDownloader,Util,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Util.cs,DecodeHexString,The following statement contains a magic number: byte[] bytes = new byte[ chars / 2 ];
Magic Number,DepotDownloader,Util,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Util.cs,DecodeHexString,The following statement contains a magic number: bytes[ i / 2 ] = Convert.ToByte( hex.Substring( i' 2 )' 16 );
Magic Number,DepotDownloader,Util,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Util.cs,DecodeHexString,The following statement contains a magic number: bytes[ i / 2 ] = Convert.ToByte( hex.Substring( i' 2 )' 16 );
Magic Number,DepotDownloader,Util,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Util.cs,DecodeHexString,The following statement contains a magic number: bytes[ i / 2 ] = Convert.ToByte( hex.Substring( i' 2 )' 16 );
Duplicate Code,DepotDownloader,Program,D:\research\architectureSmells\repos1\SteamRE_DepotDownloader\DepotDownloader\Program.cs,MainAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((83' 103)' (152' 172))
