Implementation smell,Namespace,Class,File,Method,Description
Long Method,BitMiracle.TiffCP,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Program.cs,Main,The method has 242 lines of code.
Long Method,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,Copy,The method has 283 lines of code.
Long Method,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,pickFuncAndCopy,The method has 125 lines of code.
Complex Method,BitMiracle.TiffCP,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Program.cs,Main,Cyclomatic complexity of the method is 45
Complex Method,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,ProcessCompressOptions,Cyclomatic complexity of the method is 14
Complex Method,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,Copy,Cyclomatic complexity of the method is 49
Complex Method,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,pickFuncAndCopy,Cyclomatic complexity of the method is 29
Complex Method,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,Cyclomatic complexity of the method is 10
Complex Method,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,copyTag,Cyclomatic complexity of the method is 14
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,pickFuncAndCopy,The method has 6 parameters. Parameters: inImage' outImage' bitspersample' samplesperpixel' length' width
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContig2ContigByRow,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpDecodedStrips,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparate2SeparateByRow,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContig2SeparateByRow,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparate2ContigByRow,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpStripToTile,The method has 8 parameters. Parameters: outImage' outOffset' inImage' inOffset' rows' cols' outskew' inskew
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContigBufToSeparateBuf,The method has 9 parameters. Parameters: outImage' inImage' inOffset' rows' cols' outskew' inskew' spp' bytes_per_sample
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparateBufToContigBuf,The method has 9 parameters. Parameters: outImage' outOffset' inImage' rows' cols' outskew' inskew' spp' bytes_per_sample
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpImage,The method has 7 parameters. Parameters: inImage' outImage' fin' fout' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContigStrips2ContigTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContigStrips2SeparateTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparateStrips2ContigTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparateStrips2SeparateTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContigTiles2ContigTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContigTiles2SeparateTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparateTiles2ContigTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparateTiles2SeparateTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContigTiles2ContigStrips,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContigTiles2SeparateStrips,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparateTiles2ContigStrips,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparateTiles2SeparateStrips,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,readContigStripsIntoBuffer,The method has 5 parameters. Parameters: inImage' buffer' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,readSeparateStripsIntoBuffer,The method has 5 parameters. Parameters: inImage' buf' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,readContigTilesIntoBuffer,The method has 5 parameters. Parameters: inImage' buf' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,readSeparateTilesIntoBuffer,The method has 5 parameters. Parameters: inImage' buf' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,writeBufferToContigStrips,The method has 5 parameters. Parameters: outImage' buffer' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,writeBufferToSeparateStrips,The method has 5 parameters. Parameters: outImage' buf' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,writeBufferToContigTiles,The method has 5 parameters. Parameters: outImage' buf' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,writeBufferToSeparateTiles,The method has 5 parameters. Parameters: outImage' buf' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,copyTag,The method has 5 parameters. Parameters: inImage' outImage' tag' count' type
Long Statement,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,readSeparateTilesIntoBuffer,The length of the statement  "                            cpSeparateBufToContigBuf(buf' bufp + colb + s * bytes_per_sample' tilebuf' nrow' width / (spp * bytes_per_sample)' oskew + iskew' oskew / spp' spp' bytes_per_sample); " is 166.
Long Statement,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,writeBufferToSeparateTiles,The length of the statement  "                            cpContigBufToSeparateBuf(obuf' buf' bufp + (colb * spp) + s' nrow' width / bytes_per_sample' oskew' (oskew * spp) + iskew' spp' bytes_per_sample); " is 146.
Magic Number,BitMiracle.TiffCP,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Program.cs,Main,The following statement contains a magic number: switch (option[0])                  {                      case ''':                          if (option[1] != '=')                          {                              usage();                              return;                          }                            imageNumberSeparator = option[2];                          break;                      case 'b':                          // this file is bias image subtracted from others                          if (c.m_bias != null)                          {                              Console.Error.Write("Only 1 bias image may be specified\n");                              return;                          }                            string biasName = args[argn + 1];                          c.m_bias = Tiff.Open(biasName' "r");                          if (c.m_bias == null)                          {                              Console.Error.WriteLine("Failed to open '{0}' as input."' biasName);                              return;                          }                            if (c.m_bias.IsTiled())                          {                              Console.Error.Write("Bias image must be organized in strips\n");                              return;                          }                            FieldValue[] result = c.m_bias.GetField(TiffTag.SAMPLESPERPIXEL);                          short samples = result[0].ToShort();                          if (samples != 1)                          {                              Console.Error.Write("Bias image must be monochrome\n");                              return;                          }                            argn++;                          break;                      case 'a':                          // append to output                          mode[0] = 'a';                          break;                      case 'c':                          // compression scheme                          if (!c.ProcessCompressOptions(optionArg))                          {                              usage();                              return;                          }                            argn++;                          break;                      case 'f':                          // fill order                          if (optionArg == "lsb2msb")                              defaultFillOrder = FillOrder.LSB2MSB;                          else if (optionArg == "msb2lsb")                              defaultFillOrder = FillOrder.MSB2LSB;                          else                          {                              usage();                              return;                          }                            argn++;                          break;                      case 'i':                          // ignore errors                          c.m_ignore = true;                          break;                      case 'l':                          // tile length                          c.m_outtiled = 1;                          defaultTileLength = int.Parse(optionArg' CultureInfo.InvariantCulture);                          argn++;                          break;                      case 'o':                          // initial directory offset                          initialDirectoryOffset = int.Parse(optionArg' CultureInfo.InvariantCulture);                          break;                      case 'p':                          // planar configuration                          if (optionArg == "separate")                              defaultPlanarConfig = PlanarConfig.SEPARATE;                          else if (optionArg == "contig")                              defaultPlanarConfig = PlanarConfig.CONTIG;                          else                          {                              usage();                              return;                          }                            argn++;                          break;                      case 'r':                          // rows/strip                          defaultRowsPerStrip = int.Parse(optionArg' CultureInfo.InvariantCulture);                          argn++;                          break;                      case 's':                          // generate stripped output                          c.m_outtiled = 0;                          break;                      case 't':                          // generate tiled output                          c.m_outtiled = 1;                          break;                      case 'w':                          // tile width                          c.m_outtiled = 1;                          defaultTileWidth = int.Parse(optionArg' CultureInfo.InvariantCulture);                          argn++;                          break;                      case 'B':                          mode.Append('b');                          break;                      case 'L':                          mode.Append('l');                          break;                      case 'M':                          mode.Append('m');                          break;                      case 'C':                          mode.Append('c');                          break;                      case 'x':                          c.m_pageInSeq = 1;                          break;                      case '?':                          usage();                          return;                  }
Magic Number,BitMiracle.TiffCP,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Program.cs,Main,The following statement contains a magic number: args.Length - argn < 2
Magic Number,BitMiracle.TiffCP,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Program.cs,Main,The following statement contains a magic number: (args.Length - argn) == 2
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,Copy,The following statement contains a magic number: copyTag(inImage' outImage' TiffTag.TRANSFERFUNCTION' 4' TiffType.SHORT);
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,Copy,The following statement contains a magic number: samplesperpixel <= 4
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,Copy,The following statement contains a magic number: copyTag(inImage' outImage' TiffTag.COLORMAP' 4' TiffType.SHORT);
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,pickFuncAndCopy,The following statement contains a magic number: shortv != m_config && bitspersample != 8 && samplesperpixel > 1
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The following statement contains a magic number: switch (sampleBits)                              {                                  case 8:                                      subtract8(buf' biasBuf' imagewidth);                                      break;                                  case 16:                                      subtract16(buf' biasBuf' imagewidth);                                      break;                                  case 32:                                      subtract32(buf' biasBuf' imagewidth);                                      break;                              }
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The following statement contains a magic number: switch (sampleBits)                              {                                  case 8:                                      subtract8(buf' biasBuf' imagewidth);                                      break;                                  case 16:                                      subtract16(buf' biasBuf' imagewidth);                                      break;                                  case 32:                                      subtract32(buf' biasBuf' imagewidth);                                      break;                              }
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The following statement contains a magic number: switch (sampleBits)                              {                                  case 8:                                      subtract8(buf' biasBuf' imagewidth);                                      break;                                  case 16:                                      subtract16(buf' biasBuf' imagewidth);                                      break;                                  case 32:                                      subtract32(buf' biasBuf' imagewidth);                                      break;                              }
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The following statement contains a magic number: sampleBits == 8 || sampleBits == 16 || sampleBits == 32
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The following statement contains a magic number: sampleBits == 8 || sampleBits == 16 || sampleBits == 32
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The following statement contains a magic number: sampleBits == 8 || sampleBits == 16 || sampleBits == 32
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,readSeparateTilesIntoBuffer,The following statement contains a magic number: Debug.Assert(bps % 8 == 0);
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,readSeparateTilesIntoBuffer,The following statement contains a magic number: short bytes_per_sample = (short)(bps / 8);
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,writeBufferToSeparateTiles,The following statement contains a magic number: Debug.Assert(bps % 8 == 0);
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,writeBufferToSeparateTiles,The following statement contains a magic number: short bytes_per_sample = (short)(bps / 8);
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,copyTag,The following statement contains a magic number: switch (type)              {                  case TiffType.SHORT:                      result = inImage.GetField(tag);                      if (result != null)                      {                          switch (count)                          {                              case 1:                                  outImage.SetField(tag' result[0]);                                  break;                              case 2:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                              case 4:                                  outImage.SetField(tag' result[0]' result[1]' result[2]);                                  break;                              case -1:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                          }                      }                      break;                  case TiffType.LONG:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.RATIONAL:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.ASCII:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.DOUBLE:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  default:                      Tiff.Error(inImage' inImage.FileName()'                          "Data type {0} is not supported' tag {1} skipped."' tag' type);                      break;              }
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,copyTag,The following statement contains a magic number: switch (type)              {                  case TiffType.SHORT:                      result = inImage.GetField(tag);                      if (result != null)                      {                          switch (count)                          {                              case 1:                                  outImage.SetField(tag' result[0]);                                  break;                              case 2:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                              case 4:                                  outImage.SetField(tag' result[0]' result[1]' result[2]);                                  break;                              case -1:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                          }                      }                      break;                  case TiffType.LONG:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.RATIONAL:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.ASCII:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.DOUBLE:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  default:                      Tiff.Error(inImage' inImage.FileName()'                          "Data type {0} is not supported' tag {1} skipped."' tag' type);                      break;              }
Magic Number,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,copyTag,The following statement contains a magic number: switch (type)              {                  case TiffType.SHORT:                      result = inImage.GetField(tag);                      if (result != null)                      {                          switch (count)                          {                              case 1:                                  outImage.SetField(tag' result[0]);                                  break;                              case 2:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                              case 4:                                  outImage.SetField(tag' result[0]' result[1]' result[2]);                                  break;                              case -1:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                          }                      }                      break;                  case TiffType.LONG:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.RATIONAL:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.ASCII:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.DOUBLE:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  default:                      Tiff.Error(inImage' inImage.FileName()'                          "Data type {0} is not supported' tag {1} skipped."' tag' type);                      break;              }
Missing Default,BitMiracle.TiffCP,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Program.cs,Main,The following switch statement is missing a default case: switch (option[0])                  {                      case ''':                          if (option[1] != '=')                          {                              usage();                              return;                          }                            imageNumberSeparator = option[2];                          break;                      case 'b':                          // this file is bias image subtracted from others                          if (c.m_bias != null)                          {                              Console.Error.Write("Only 1 bias image may be specified\n");                              return;                          }                            string biasName = args[argn + 1];                          c.m_bias = Tiff.Open(biasName' "r");                          if (c.m_bias == null)                          {                              Console.Error.WriteLine("Failed to open '{0}' as input."' biasName);                              return;                          }                            if (c.m_bias.IsTiled())                          {                              Console.Error.Write("Bias image must be organized in strips\n");                              return;                          }                            FieldValue[] result = c.m_bias.GetField(TiffTag.SAMPLESPERPIXEL);                          short samples = result[0].ToShort();                          if (samples != 1)                          {                              Console.Error.Write("Bias image must be monochrome\n");                              return;                          }                            argn++;                          break;                      case 'a':                          // append to output                          mode[0] = 'a';                          break;                      case 'c':                          // compression scheme                          if (!c.ProcessCompressOptions(optionArg))                          {                              usage();                              return;                          }                            argn++;                          break;                      case 'f':                          // fill order                          if (optionArg == "lsb2msb")                              defaultFillOrder = FillOrder.LSB2MSB;                          else if (optionArg == "msb2lsb")                              defaultFillOrder = FillOrder.MSB2LSB;                          else                          {                              usage();                              return;                          }                            argn++;                          break;                      case 'i':                          // ignore errors                          c.m_ignore = true;                          break;                      case 'l':                          // tile length                          c.m_outtiled = 1;                          defaultTileLength = int.Parse(optionArg' CultureInfo.InvariantCulture);                          argn++;                          break;                      case 'o':                          // initial directory offset                          initialDirectoryOffset = int.Parse(optionArg' CultureInfo.InvariantCulture);                          break;                      case 'p':                          // planar configuration                          if (optionArg == "separate")                              defaultPlanarConfig = PlanarConfig.SEPARATE;                          else if (optionArg == "contig")                              defaultPlanarConfig = PlanarConfig.CONTIG;                          else                          {                              usage();                              return;                          }                            argn++;                          break;                      case 'r':                          // rows/strip                          defaultRowsPerStrip = int.Parse(optionArg' CultureInfo.InvariantCulture);                          argn++;                          break;                      case 's':                          // generate stripped output                          c.m_outtiled = 0;                          break;                      case 't':                          // generate tiled output                          c.m_outtiled = 1;                          break;                      case 'w':                          // tile width                          c.m_outtiled = 1;                          defaultTileWidth = int.Parse(optionArg' CultureInfo.InvariantCulture);                          argn++;                          break;                      case 'B':                          mode.Append('b');                          break;                      case 'L':                          mode.Append('l');                          break;                      case 'M':                          mode.Append('m');                          break;                      case 'C':                          mode.Append('c');                          break;                      case 'x':                          c.m_pageInSeq = 1;                          break;                      case '?':                          usage();                          return;                  }
Missing Default,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,Copy,The following switch statement is missing a default case: switch (m_compression)              {                  case Compression.JPEG:                      outImage.SetField(TiffTag.JPEGQUALITY' m_quality);                      outImage.SetField(TiffTag.JPEGCOLORMODE' m_jpegcolormode);                      break;                  case Compression.LZW:                  case Compression.ADOBE_DEFLATE:                  case Compression.DEFLATE:                      if (m_predictor != -1)                          outImage.SetField(TiffTag.PREDICTOR' m_predictor);                      else                      {                          result = inImage.GetField(TiffTag.PREDICTOR);                          if (result != null)                          {                              m_predictor = result[0].ToShort();                              outImage.SetField(TiffTag.PREDICTOR' m_predictor);                          }                      }                      break;                  case Compression.CCITTFAX3:                  case Compression.CCITTFAX4:                      if (m_compression == Compression.CCITTFAX3)                      {                          if (m_g3opts != Group3Opt.UNKNOWN)                              outImage.SetField(TiffTag.GROUP3OPTIONS' m_g3opts);                          else                          {                              result = inImage.GetField(TiffTag.GROUP3OPTIONS);                              if (result != null)                              {                                  m_g3opts = (Group3Opt)result[0].ToShort();                                  outImage.SetField(TiffTag.GROUP3OPTIONS' m_g3opts);                              }                          }                      }                      else                          copyTag(inImage' outImage' TiffTag.GROUP4OPTIONS' 1' TiffType.LONG);                        copyTag(inImage' outImage' TiffTag.BADFAXLINES' 1' TiffType.LONG);                      copyTag(inImage' outImage' TiffTag.CLEANFAXDATA' 1' TiffType.LONG);                      copyTag(inImage' outImage' TiffTag.CONSECUTIVEBADFAXLINES' 1' TiffType.LONG);                      copyTag(inImage' outImage' TiffTag.FAXRECVPARAMS' 1' TiffType.LONG);                      copyTag(inImage' outImage' TiffTag.FAXRECVTIME' 1' TiffType.LONG);                      copyTag(inImage' outImage' TiffTag.FAXSUBADDRESS' 1' TiffType.ASCII);                      break;              }
Missing Default,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The following switch statement is missing a default case: switch (sampleBits)                              {                                  case 8:                                      subtract8(buf' biasBuf' imagewidth);                                      break;                                  case 16:                                      subtract16(buf' biasBuf' imagewidth);                                      break;                                  case 32:                                      subtract32(buf' biasBuf' imagewidth);                                      break;                              }
Missing Default,BitMiracle.TiffCP,Copier,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,copyTag,The following switch statement is missing a default case: switch (count)                          {                              case 1:                                  outImage.SetField(tag' result[0]);                                  break;                              case 2:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                              case 4:                                  outImage.SetField(tag' result[0]' result[1]' result[2]);                                  break;                              case -1:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                          }
