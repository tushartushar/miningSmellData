Implementation smell,Namespace,Class,File,Method,Description
Long Method,BitMiracle.TiffCP,Program,C:\repos\BitMiracle_libtiff.net\TiffCP\Program.cs,Main,The method has 242 lines of code.
Long Method,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,Copy,The method has 283 lines of code.
Long Method,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,pickFuncAndCopy,The method has 125 lines of code.
Complex Method,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,Copy,Cyclomatic complexity of the method is 29
Complex Method,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,Cyclomatic complexity of the method is 9
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,pickFuncAndCopy,The method has 6 parameters. Parameters: inImage' outImage' bitspersample' samplesperpixel' length' width
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContig2ContigByRow,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpDecodedStrips,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparate2SeparateByRow,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContig2SeparateByRow,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparate2ContigByRow,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpStripToTile,The method has 8 parameters. Parameters: outImage' outOffset' inImage' inOffset' rows' cols' outskew' inskew
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContigBufToSeparateBuf,The method has 9 parameters. Parameters: outImage' inImage' inOffset' rows' cols' outskew' inskew' spp' bytes_per_sample
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparateBufToContigBuf,The method has 9 parameters. Parameters: outImage' outOffset' inImage' rows' cols' outskew' inskew' spp' bytes_per_sample
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpImage,The method has 7 parameters. Parameters: inImage' outImage' fin' fout' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContigStrips2ContigTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContigStrips2SeparateTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparateStrips2ContigTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparateStrips2SeparateTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContigTiles2ContigTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContigTiles2SeparateTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparateTiles2ContigTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparateTiles2SeparateTiles,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContigTiles2ContigStrips,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpContigTiles2SeparateStrips,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparateTiles2ContigStrips,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpSeparateTiles2SeparateStrips,The method has 5 parameters. Parameters: inImage' outImage' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,readContigStripsIntoBuffer,The method has 5 parameters. Parameters: inImage' buffer' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,readSeparateStripsIntoBuffer,The method has 5 parameters. Parameters: inImage' buf' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,readContigTilesIntoBuffer,The method has 5 parameters. Parameters: inImage' buf' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,readSeparateTilesIntoBuffer,The method has 5 parameters. Parameters: inImage' buf' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,writeBufferToContigStrips,The method has 5 parameters. Parameters: outImage' buffer' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,writeBufferToSeparateStrips,The method has 5 parameters. Parameters: outImage' buf' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,writeBufferToContigTiles,The method has 5 parameters. Parameters: outImage' buf' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,writeBufferToSeparateTiles,The method has 5 parameters. Parameters: outImage' buf' imagelength' imagewidth' spp
Long Parameter List,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,copyTag,The method has 5 parameters. Parameters: inImage' outImage' tag' count' type
Long Statement,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,readSeparateTilesIntoBuffer,The length of the statement  "                            cpSeparateBufToContigBuf(buf' bufp + colb + s * bytes_per_sample' tilebuf' nrow' width / (spp * bytes_per_sample)' oskew + iskew' oskew / spp' spp' bytes_per_sample); " is 166.
Long Statement,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,writeBufferToSeparateTiles,The length of the statement  "                            cpContigBufToSeparateBuf(obuf' buf' bufp + (colb * spp) + s' nrow' width / bytes_per_sample' oskew' (oskew * spp) + iskew' spp' bytes_per_sample); " is 146.
Magic Number,BitMiracle.TiffCP,Program,C:\repos\BitMiracle_libtiff.net\TiffCP\Program.cs,Main,The following statement contains a magic number: for (; argn < args.Length; argn++)              {                  string option = args[argn];                  if (option[0] == '-')                      option = option.Substring(1);                  else                      break;                    string optionArg = null;                  if (argn < (args.Length - 1))                      optionArg = args[argn + 1];                                        switch (option[0])                  {                      case ''':                          if (option[1] != '=')                          {                              usage();                              return;                          }                            imageNumberSeparator = option[2];                          break;                      case 'b':                          // this file is bias image subtracted from others                          if (c.m_bias != null)                          {                              Console.Error.Write("Only 1 bias image may be specified\n");                              return;                          }                            string biasName = args[argn + 1];                          c.m_bias = Tiff.Open(biasName' "r");                          if (c.m_bias == null)                          {                              Console.Error.WriteLine("Failed to open '{0}' as input."' biasName);                              return;                          }                            if (c.m_bias.IsTiled())                          {                              Console.Error.Write("Bias image must be organized in strips\n");                              return;                          }                            FieldValue[] result = c.m_bias.GetField(TiffTag.SAMPLESPERPIXEL);                          short samples = result[0].ToShort();                          if (samples != 1)                          {                              Console.Error.Write("Bias image must be monochrome\n");                              return;                          }                            argn++;                          break;                      case 'a':                          // append to output                          mode[0] = 'a';                          break;                      case 'c':                          // compression scheme                          if (!c.ProcessCompressOptions(optionArg))                          {                              usage();                              return;                          }                            argn++;                          break;                      case 'f':                          // fill order                          if (optionArg == "lsb2msb")                              defaultFillOrder = FillOrder.LSB2MSB;                          else if (optionArg == "msb2lsb")                              defaultFillOrder = FillOrder.MSB2LSB;                          else                          {                              usage();                              return;                          }                            argn++;                          break;                      case 'i':                          // ignore errors                          c.m_ignore = true;                          break;                      case 'l':                          // tile length                          c.m_outtiled = 1;                          defaultTileLength = int.Parse(optionArg' CultureInfo.InvariantCulture);                          argn++;                          break;                      case 'o':                          // initial directory offset                          initialDirectoryOffset = int.Parse(optionArg' CultureInfo.InvariantCulture);                          break;                      case 'p':                          // planar configuration                          if (optionArg == "separate")                              defaultPlanarConfig = PlanarConfig.SEPARATE;                          else if (optionArg == "contig")                              defaultPlanarConfig = PlanarConfig.CONTIG;                          else                          {                              usage();                              return;                          }                            argn++;                          break;                      case 'r':                          // rows/strip                          defaultRowsPerStrip = int.Parse(optionArg' CultureInfo.InvariantCulture);                          argn++;                          break;                      case 's':                          // generate stripped output                          c.m_outtiled = 0;                          break;                      case 't':                          // generate tiled output                          c.m_outtiled = 1;                          break;                      case 'w':                          // tile width                          c.m_outtiled = 1;                          defaultTileWidth = int.Parse(optionArg' CultureInfo.InvariantCulture);                          argn++;                          break;                      case 'B':                          mode.Append('b');                          break;                      case 'L':                          mode.Append('l');                          break;                      case 'M':                          mode.Append('m');                          break;                      case 'C':                          mode.Append('c');                          break;                      case 'x':                          c.m_pageInSeq = 1;                          break;                      case '?':                          usage();                          return;                  }              }
Magic Number,BitMiracle.TiffCP,Program,C:\repos\BitMiracle_libtiff.net\TiffCP\Program.cs,Main,The following statement contains a magic number: if (args.Length - argn < 2)              {                  // there must be at least one input and one output image names after options                  usage();                  return;              }
Magic Number,BitMiracle.TiffCP,Program,C:\repos\BitMiracle_libtiff.net\TiffCP\Program.cs,Main,The following statement contains a magic number: using (Tiff outImage = Tiff.Open(args[args.Length - 1]' mode.ToString()))              {                  if (outImage == null)                  {                      Console.Error.WriteLine("Failed to open '{0}' as output."' args[args.Length - 1]);                      return;                  }                    if ((args.Length - argn) == 2)                      c.m_pageNum = -1;                    for (; argn < args.Length - 1; argn++)                  {                      string[] fileAndPageNums = args[argn].Split(new char[] { imageNumberSeparator });                                            using (Tiff inImage = Tiff.Open(fileAndPageNums[0]' "r"))                      {                          if (inImage == null)                              return;                            if (initialDirectoryOffset != 0 && !inImage.SetSubDirectory(initialDirectoryOffset))                          {                              Tiff.Error(inImage' inImage.FileName()' "Error' setting subdirectory at 0x{0:x}"' initialDirectoryOffset);                              break;                          }                            int initialPage = 0;                          int pageNumPos = 1;                                                    if (pageNumPos < fileAndPageNums.Length && !string.IsNullOrEmpty(fileAndPageNums[pageNumPos]))                              initialPage = int.Parse(fileAndPageNums[pageNumPos]);                            int totalPages = inImage.NumberOfDirectories();                          for (int i = initialPage; i < totalPages; )                          {                              c.m_config = defaultPlanarConfig;                              c.m_compression = c.m_defcompression;                              c.m_predictor = c.m_defpredictor;                              c.m_fillorder = defaultFillOrder;                              c.m_rowsperstrip = defaultRowsPerStrip;                              c.m_tilewidth = defaultTileWidth;                              c.m_tilelength = defaultTileLength;                              c.m_g3opts = c.m_defg3opts;                                if (!inImage.SetDirectory((short)i))                              {                                  Console.Error.Write("{0}{1}{2} not found!\n"'                                      inImage.FileName()' imageNumberSeparator' i);                                  return;                              }                                if (!c.Copy(inImage' outImage) || !outImage.WriteDirectory())                                  return;                                // if we have at least one page specifier and current specifier is not empty.                              // specifier is empty when trailing separator used like this: "file'num'"                              if (pageNumPos < fileAndPageNums.Length && !string.IsNullOrEmpty(fileAndPageNums[pageNumPos]))                              {                                  // move to next page specifier                                  pageNumPos++;                                    if (pageNumPos < fileAndPageNums.Length)                                  {                                      // new page specifier position is valid                                        if (!string.IsNullOrEmpty(fileAndPageNums[pageNumPos]))                                      {                                          // new page specifier is not empty. use specified page number                                          i = int.Parse(fileAndPageNums[pageNumPos]);                                      }                                      else                                      {                                          // new page specifier is empty. just move to the next page                                          i++;                                      }                                  }                                  else                                  {                                      // new page specifier position is invalid. done all pages.                                      break;                                  }                              }                              else                              {                                  // we have no page specifiers or current page specifier is empty                                  // just move to the next page                                  i++;                              }                          }                      }                  }              }
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,Copy,The following statement contains a magic number: if (samplesperpixel <= 4)                  copyTag(inImage' outImage' TiffTag.TRANSFERFUNCTION' 4' TiffType.SHORT);
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,Copy,The following statement contains a magic number: if (samplesperpixel <= 4)                  copyTag(inImage' outImage' TiffTag.TRANSFERFUNCTION' 4' TiffType.SHORT);
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,Copy,The following statement contains a magic number: copyTag(inImage' outImage' TiffTag.COLORMAP' 4' TiffType.SHORT);
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,pickFuncAndCopy,The following statement contains a magic number: using (TextWriter stderr = Console.Error)              {                  FieldValue[] result = inImage.GetField(TiffTag.PLANARCONFIG);                  PlanarConfig shortv = (PlanarConfig)result[0].ToShort();                    if (shortv != m_config && bitspersample != 8 && samplesperpixel > 1)                  {                      stderr.Write("{0}: Cannot handle different planar configuration w/ bits/sample != 8\n"' inImage.FileName());                      return false;                  }                    result = inImage.GetField(TiffTag.IMAGEWIDTH);                  int w = result[0].ToInt();                    result = inImage.GetField(TiffTag.IMAGELENGTH);                  int l = result[0].ToInt();                    bool bychunk;                  if (!(outImage.IsTiled() || inImage.IsTiled()))                  {                      result = inImage.GetField(TiffTag.ROWSPERSTRIP);                      if (result != null)                      {                          int irps = result[0].ToInt();                            /* if biased' force decoded copying to allow image subtraction */                          bychunk = (m_bias == null) && (m_rowsperstrip == irps);                      }                      else                          bychunk = false;                  }                  else                  {                      /* either inImage or outImage is tiled */                      if (m_bias != null)                      {                          stderr.Write("{0}: Cannot handle tiled configuration w/bias image\n"' inImage.FileName());                          return false;                      }                        if (outImage.IsTiled())                      {                          int tw;                          result = inImage.GetField(TiffTag.TILEWIDTH);                          if (result == null)                              tw = w;                          else                              tw = result[0].ToInt();                            int tl;                          result = inImage.GetField(TiffTag.TILELENGTH);                          if (result == null)                              tl = l;                          else                              tl = result[0].ToInt();                            bychunk = (tw == m_tilewidth && tl == m_tilelength);                      }                      else                      {                          /* outImage's not' so inImage must be tiled */                          result = inImage.GetField(TiffTag.TILEWIDTH);                          int tw = result[0].ToInt();                            result = inImage.GetField(TiffTag.TILELENGTH);                          int tl = result[0].ToInt();                            bychunk = (tw == w && tl == m_rowsperstrip);                      }                  }                    if (inImage.IsTiled())                  {                      if (outImage.IsTiled())                      {                          /* Tiles -> Tiles */                          if (shortv == PlanarConfig.CONTIG && m_config == PlanarConfig.CONTIG)                              return cpContigTiles2ContigTiles(inImage' outImage' length' width' samplesperpixel);                          else if (shortv == PlanarConfig.CONTIG && m_config == PlanarConfig.SEPARATE)                              return cpContigTiles2SeparateTiles(inImage' outImage' length' width' samplesperpixel);                          else if (shortv == PlanarConfig.SEPARATE && m_config == PlanarConfig.CONTIG)                              return cpSeparateTiles2ContigTiles(inImage' outImage' length' width' samplesperpixel);                          else if (shortv == PlanarConfig.SEPARATE && m_config == PlanarConfig.SEPARATE)                              return cpSeparateTiles2SeparateTiles(inImage' outImage' length' width' samplesperpixel);                      }                      else                      {                          /* Tiles -> Strips */                          if (shortv == PlanarConfig.CONTIG && m_config == PlanarConfig.CONTIG)                              return cpContigTiles2ContigStrips(inImage' outImage' length' width' samplesperpixel);                          else if (shortv == PlanarConfig.CONTIG && m_config == PlanarConfig.SEPARATE)                              return cpContigTiles2SeparateStrips(inImage' outImage' length' width' samplesperpixel);                          else if (shortv == PlanarConfig.SEPARATE && m_config == PlanarConfig.CONTIG)                              return cpSeparateTiles2ContigStrips(inImage' outImage' length' width' samplesperpixel);                          else if (shortv == PlanarConfig.SEPARATE && m_config == PlanarConfig.SEPARATE)                              return cpSeparateTiles2SeparateStrips(inImage' outImage' length' width' samplesperpixel);                      }                  }                  else                  {                      if (outImage.IsTiled())                      {                          /* Strips -> Tiles */                          if (shortv == PlanarConfig.CONTIG && m_config == PlanarConfig.CONTIG)                              return cpContigStrips2ContigTiles(inImage' outImage' length' width' samplesperpixel);                          else if (shortv == PlanarConfig.CONTIG && m_config == PlanarConfig.SEPARATE)                              return cpContigStrips2SeparateTiles(inImage' outImage' length' width' samplesperpixel);                          else if (shortv == PlanarConfig.SEPARATE && m_config == PlanarConfig.CONTIG)                              return cpSeparateStrips2ContigTiles(inImage' outImage' length' width' samplesperpixel);                          else if (shortv == PlanarConfig.SEPARATE && m_config == PlanarConfig.SEPARATE)                              return cpSeparateStrips2SeparateTiles(inImage' outImage' length' width' samplesperpixel);                      }                      else                      {                          /* Strips -> Strips */                          if (shortv == PlanarConfig.CONTIG && m_config == PlanarConfig.CONTIG && !bychunk)                          {                              if (m_bias != null)                                  return cpBiasedContig2Contig(inImage' outImage' length' width' samplesperpixel);                                return cpContig2ContigByRow(inImage' outImage' length' width' samplesperpixel);                          }                          else if (shortv == PlanarConfig.CONTIG && m_config == PlanarConfig.CONTIG && bychunk)                              return cpDecodedStrips(inImage' outImage' length' width' samplesperpixel);                          else if (shortv == PlanarConfig.CONTIG && m_config == PlanarConfig.SEPARATE)                              return cpContig2SeparateByRow(inImage' outImage' length' width' samplesperpixel);                          else if (shortv == PlanarConfig.SEPARATE && m_config == PlanarConfig.CONTIG)                              return cpSeparate2ContigByRow(inImage' outImage' length' width' samplesperpixel);                          else if (shortv == PlanarConfig.SEPARATE && m_config == PlanarConfig.SEPARATE)                              return cpSeparate2SeparateByRow(inImage' outImage' length' width' samplesperpixel);                      }                  }                    stderr.Write("tiffcp: {0}: Don't know how to copy/convert image.\n"' inImage.FileName());              }
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The following statement contains a magic number: if (spp == 1)              {                  int biasSize = m_bias.ScanlineSize();                  int bufSize = inImage.ScanlineSize();                    FieldValue[] result = m_bias.GetField(TiffTag.IMAGEWIDTH);                  int biasWidth = result[0].ToInt();                    result = m_bias.GetField(TiffTag.IMAGELENGTH);                  int biasLength = result[0].ToInt();                    if (biasSize == bufSize && imagelength == biasLength && imagewidth == biasWidth)                  {                      result = inImage.GetField(TiffTag.BITSPERSAMPLE);                      short sampleBits = result[0].ToShort();                        if (sampleBits == 8 || sampleBits == 16 || sampleBits == 32)                      {                          byte[] buf = new byte[bufSize];                          byte[] biasBuf = new byte[bufSize];                            for (int row = 0; row < imagelength; row++)                          {                              if (!inImage.ReadScanline(buf' row' 0) && !m_ignore)                              {                                  Tiff.Error(inImage' inImage.FileName()' "Error' can't read scanline {0}"' row);                                  return false;                              }                                if (!m_bias.ReadScanline(biasBuf' row' 0) && !m_ignore)                              {                                  Tiff.Error(inImage' inImage.FileName()' "Error' can't read biased scanline {0}"' row);                                  return false;                              }                                switch (sampleBits)                              {                                  case 8:                                      subtract8(buf' biasBuf' imagewidth);                                      break;                                  case 16:                                      subtract16(buf' biasBuf' imagewidth);                                      break;                                  case 32:                                      subtract32(buf' biasBuf' imagewidth);                                      break;                              }                                if (!outImage.WriteScanline(buf' row' 0))                              {                                  Tiff.Error(outImage' outImage.FileName()' "Error' can't write scanline {0}"' row);                                  return false;                              }                          }                            m_bias.SetDirectory(m_bias.CurrentDirectory()); /* rewind */                          return true;                      }                      else                      {                          Tiff.Error(inImage' inImage.FileName()' "No support for biasing {0} bit pixels\n"' sampleBits);                          return false;                      }                  }                    Tiff.Error(inImage' inImage.FileName()' "Bias image {0}'{1}\nis not the same size as {2}'{3}\n"'                      m_bias.FileName()' m_bias.CurrentDirectory()' inImage.FileName()' inImage.CurrentDirectory());                  return false;              }              else              {                  Tiff.Error(inImage' inImage.FileName()' "Can't bias {0}'{1} as it has >1 Sample/Pixel\n"'                      inImage.FileName()' inImage.CurrentDirectory());                  return false;              }
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The following statement contains a magic number: if (spp == 1)              {                  int biasSize = m_bias.ScanlineSize();                  int bufSize = inImage.ScanlineSize();                    FieldValue[] result = m_bias.GetField(TiffTag.IMAGEWIDTH);                  int biasWidth = result[0].ToInt();                    result = m_bias.GetField(TiffTag.IMAGELENGTH);                  int biasLength = result[0].ToInt();                    if (biasSize == bufSize && imagelength == biasLength && imagewidth == biasWidth)                  {                      result = inImage.GetField(TiffTag.BITSPERSAMPLE);                      short sampleBits = result[0].ToShort();                        if (sampleBits == 8 || sampleBits == 16 || sampleBits == 32)                      {                          byte[] buf = new byte[bufSize];                          byte[] biasBuf = new byte[bufSize];                            for (int row = 0; row < imagelength; row++)                          {                              if (!inImage.ReadScanline(buf' row' 0) && !m_ignore)                              {                                  Tiff.Error(inImage' inImage.FileName()' "Error' can't read scanline {0}"' row);                                  return false;                              }                                if (!m_bias.ReadScanline(biasBuf' row' 0) && !m_ignore)                              {                                  Tiff.Error(inImage' inImage.FileName()' "Error' can't read biased scanline {0}"' row);                                  return false;                              }                                switch (sampleBits)                              {                                  case 8:                                      subtract8(buf' biasBuf' imagewidth);                                      break;                                  case 16:                                      subtract16(buf' biasBuf' imagewidth);                                      break;                                  case 32:                                      subtract32(buf' biasBuf' imagewidth);                                      break;                              }                                if (!outImage.WriteScanline(buf' row' 0))                              {                                  Tiff.Error(outImage' outImage.FileName()' "Error' can't write scanline {0}"' row);                                  return false;                              }                          }                            m_bias.SetDirectory(m_bias.CurrentDirectory()); /* rewind */                          return true;                      }                      else                      {                          Tiff.Error(inImage' inImage.FileName()' "No support for biasing {0} bit pixels\n"' sampleBits);                          return false;                      }                  }                    Tiff.Error(inImage' inImage.FileName()' "Bias image {0}'{1}\nis not the same size as {2}'{3}\n"'                      m_bias.FileName()' m_bias.CurrentDirectory()' inImage.FileName()' inImage.CurrentDirectory());                  return false;              }              else              {                  Tiff.Error(inImage' inImage.FileName()' "Can't bias {0}'{1} as it has >1 Sample/Pixel\n"'                      inImage.FileName()' inImage.CurrentDirectory());                  return false;              }
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The following statement contains a magic number: if (spp == 1)              {                  int biasSize = m_bias.ScanlineSize();                  int bufSize = inImage.ScanlineSize();                    FieldValue[] result = m_bias.GetField(TiffTag.IMAGEWIDTH);                  int biasWidth = result[0].ToInt();                    result = m_bias.GetField(TiffTag.IMAGELENGTH);                  int biasLength = result[0].ToInt();                    if (biasSize == bufSize && imagelength == biasLength && imagewidth == biasWidth)                  {                      result = inImage.GetField(TiffTag.BITSPERSAMPLE);                      short sampleBits = result[0].ToShort();                        if (sampleBits == 8 || sampleBits == 16 || sampleBits == 32)                      {                          byte[] buf = new byte[bufSize];                          byte[] biasBuf = new byte[bufSize];                            for (int row = 0; row < imagelength; row++)                          {                              if (!inImage.ReadScanline(buf' row' 0) && !m_ignore)                              {                                  Tiff.Error(inImage' inImage.FileName()' "Error' can't read scanline {0}"' row);                                  return false;                              }                                if (!m_bias.ReadScanline(biasBuf' row' 0) && !m_ignore)                              {                                  Tiff.Error(inImage' inImage.FileName()' "Error' can't read biased scanline {0}"' row);                                  return false;                              }                                switch (sampleBits)                              {                                  case 8:                                      subtract8(buf' biasBuf' imagewidth);                                      break;                                  case 16:                                      subtract16(buf' biasBuf' imagewidth);                                      break;                                  case 32:                                      subtract32(buf' biasBuf' imagewidth);                                      break;                              }                                if (!outImage.WriteScanline(buf' row' 0))                              {                                  Tiff.Error(outImage' outImage.FileName()' "Error' can't write scanline {0}"' row);                                  return false;                              }                          }                            m_bias.SetDirectory(m_bias.CurrentDirectory()); /* rewind */                          return true;                      }                      else                      {                          Tiff.Error(inImage' inImage.FileName()' "No support for biasing {0} bit pixels\n"' sampleBits);                          return false;                      }                  }                    Tiff.Error(inImage' inImage.FileName()' "Bias image {0}'{1}\nis not the same size as {2}'{3}\n"'                      m_bias.FileName()' m_bias.CurrentDirectory()' inImage.FileName()' inImage.CurrentDirectory());                  return false;              }              else              {                  Tiff.Error(inImage' inImage.FileName()' "Can't bias {0}'{1} as it has >1 Sample/Pixel\n"'                      inImage.FileName()' inImage.CurrentDirectory());                  return false;              }
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The following statement contains a magic number: if (spp == 1)              {                  int biasSize = m_bias.ScanlineSize();                  int bufSize = inImage.ScanlineSize();                    FieldValue[] result = m_bias.GetField(TiffTag.IMAGEWIDTH);                  int biasWidth = result[0].ToInt();                    result = m_bias.GetField(TiffTag.IMAGELENGTH);                  int biasLength = result[0].ToInt();                    if (biasSize == bufSize && imagelength == biasLength && imagewidth == biasWidth)                  {                      result = inImage.GetField(TiffTag.BITSPERSAMPLE);                      short sampleBits = result[0].ToShort();                        if (sampleBits == 8 || sampleBits == 16 || sampleBits == 32)                      {                          byte[] buf = new byte[bufSize];                          byte[] biasBuf = new byte[bufSize];                            for (int row = 0; row < imagelength; row++)                          {                              if (!inImage.ReadScanline(buf' row' 0) && !m_ignore)                              {                                  Tiff.Error(inImage' inImage.FileName()' "Error' can't read scanline {0}"' row);                                  return false;                              }                                if (!m_bias.ReadScanline(biasBuf' row' 0) && !m_ignore)                              {                                  Tiff.Error(inImage' inImage.FileName()' "Error' can't read biased scanline {0}"' row);                                  return false;                              }                                switch (sampleBits)                              {                                  case 8:                                      subtract8(buf' biasBuf' imagewidth);                                      break;                                  case 16:                                      subtract16(buf' biasBuf' imagewidth);                                      break;                                  case 32:                                      subtract32(buf' biasBuf' imagewidth);                                      break;                              }                                if (!outImage.WriteScanline(buf' row' 0))                              {                                  Tiff.Error(outImage' outImage.FileName()' "Error' can't write scanline {0}"' row);                                  return false;                              }                          }                            m_bias.SetDirectory(m_bias.CurrentDirectory()); /* rewind */                          return true;                      }                      else                      {                          Tiff.Error(inImage' inImage.FileName()' "No support for biasing {0} bit pixels\n"' sampleBits);                          return false;                      }                  }                    Tiff.Error(inImage' inImage.FileName()' "Bias image {0}'{1}\nis not the same size as {2}'{3}\n"'                      m_bias.FileName()' m_bias.CurrentDirectory()' inImage.FileName()' inImage.CurrentDirectory());                  return false;              }              else              {                  Tiff.Error(inImage' inImage.FileName()' "Can't bias {0}'{1} as it has >1 Sample/Pixel\n"'                      inImage.FileName()' inImage.CurrentDirectory());                  return false;              }
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The following statement contains a magic number: if (spp == 1)              {                  int biasSize = m_bias.ScanlineSize();                  int bufSize = inImage.ScanlineSize();                    FieldValue[] result = m_bias.GetField(TiffTag.IMAGEWIDTH);                  int biasWidth = result[0].ToInt();                    result = m_bias.GetField(TiffTag.IMAGELENGTH);                  int biasLength = result[0].ToInt();                    if (biasSize == bufSize && imagelength == biasLength && imagewidth == biasWidth)                  {                      result = inImage.GetField(TiffTag.BITSPERSAMPLE);                      short sampleBits = result[0].ToShort();                        if (sampleBits == 8 || sampleBits == 16 || sampleBits == 32)                      {                          byte[] buf = new byte[bufSize];                          byte[] biasBuf = new byte[bufSize];                            for (int row = 0; row < imagelength; row++)                          {                              if (!inImage.ReadScanline(buf' row' 0) && !m_ignore)                              {                                  Tiff.Error(inImage' inImage.FileName()' "Error' can't read scanline {0}"' row);                                  return false;                              }                                if (!m_bias.ReadScanline(biasBuf' row' 0) && !m_ignore)                              {                                  Tiff.Error(inImage' inImage.FileName()' "Error' can't read biased scanline {0}"' row);                                  return false;                              }                                switch (sampleBits)                              {                                  case 8:                                      subtract8(buf' biasBuf' imagewidth);                                      break;                                  case 16:                                      subtract16(buf' biasBuf' imagewidth);                                      break;                                  case 32:                                      subtract32(buf' biasBuf' imagewidth);                                      break;                              }                                if (!outImage.WriteScanline(buf' row' 0))                              {                                  Tiff.Error(outImage' outImage.FileName()' "Error' can't write scanline {0}"' row);                                  return false;                              }                          }                            m_bias.SetDirectory(m_bias.CurrentDirectory()); /* rewind */                          return true;                      }                      else                      {                          Tiff.Error(inImage' inImage.FileName()' "No support for biasing {0} bit pixels\n"' sampleBits);                          return false;                      }                  }                    Tiff.Error(inImage' inImage.FileName()' "Bias image {0}'{1}\nis not the same size as {2}'{3}\n"'                      m_bias.FileName()' m_bias.CurrentDirectory()' inImage.FileName()' inImage.CurrentDirectory());                  return false;              }              else              {                  Tiff.Error(inImage' inImage.FileName()' "Can't bias {0}'{1} as it has >1 Sample/Pixel\n"'                      inImage.FileName()' inImage.CurrentDirectory());                  return false;              }
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The following statement contains a magic number: if (spp == 1)              {                  int biasSize = m_bias.ScanlineSize();                  int bufSize = inImage.ScanlineSize();                    FieldValue[] result = m_bias.GetField(TiffTag.IMAGEWIDTH);                  int biasWidth = result[0].ToInt();                    result = m_bias.GetField(TiffTag.IMAGELENGTH);                  int biasLength = result[0].ToInt();                    if (biasSize == bufSize && imagelength == biasLength && imagewidth == biasWidth)                  {                      result = inImage.GetField(TiffTag.BITSPERSAMPLE);                      short sampleBits = result[0].ToShort();                        if (sampleBits == 8 || sampleBits == 16 || sampleBits == 32)                      {                          byte[] buf = new byte[bufSize];                          byte[] biasBuf = new byte[bufSize];                            for (int row = 0; row < imagelength; row++)                          {                              if (!inImage.ReadScanline(buf' row' 0) && !m_ignore)                              {                                  Tiff.Error(inImage' inImage.FileName()' "Error' can't read scanline {0}"' row);                                  return false;                              }                                if (!m_bias.ReadScanline(biasBuf' row' 0) && !m_ignore)                              {                                  Tiff.Error(inImage' inImage.FileName()' "Error' can't read biased scanline {0}"' row);                                  return false;                              }                                switch (sampleBits)                              {                                  case 8:                                      subtract8(buf' biasBuf' imagewidth);                                      break;                                  case 16:                                      subtract16(buf' biasBuf' imagewidth);                                      break;                                  case 32:                                      subtract32(buf' biasBuf' imagewidth);                                      break;                              }                                if (!outImage.WriteScanline(buf' row' 0))                              {                                  Tiff.Error(outImage' outImage.FileName()' "Error' can't write scanline {0}"' row);                                  return false;                              }                          }                            m_bias.SetDirectory(m_bias.CurrentDirectory()); /* rewind */                          return true;                      }                      else                      {                          Tiff.Error(inImage' inImage.FileName()' "No support for biasing {0} bit pixels\n"' sampleBits);                          return false;                      }                  }                    Tiff.Error(inImage' inImage.FileName()' "Bias image {0}'{1}\nis not the same size as {2}'{3}\n"'                      m_bias.FileName()' m_bias.CurrentDirectory()' inImage.FileName()' inImage.CurrentDirectory());                  return false;              }              else              {                  Tiff.Error(inImage' inImage.FileName()' "Can't bias {0}'{1} as it has >1 Sample/Pixel\n"'                      inImage.FileName()' inImage.CurrentDirectory());                  return false;              }
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,readSeparateTilesIntoBuffer,The following statement contains a magic number: Debug.Assert(bps % 8 == 0);
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,readSeparateTilesIntoBuffer,The following statement contains a magic number: short bytes_per_sample = (short)(bps / 8);
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,writeBufferToSeparateTiles,The following statement contains a magic number: Debug.Assert(bps % 8 == 0);
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,writeBufferToSeparateTiles,The following statement contains a magic number: short bytes_per_sample = (short)(bps / 8);
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,copyTag,The following statement contains a magic number: switch (type)              {                  case TiffType.SHORT:                      result = inImage.GetField(tag);                      if (result != null)                      {                          switch (count)                          {                              case 1:                                  outImage.SetField(tag' result[0]);                                  break;                              case 2:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                              case 4:                                  outImage.SetField(tag' result[0]' result[1]' result[2]);                                  break;                              case -1:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                          }                      }                      break;                  case TiffType.LONG:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.RATIONAL:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.ASCII:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.DOUBLE:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  default:                      Tiff.Error(inImage' inImage.FileName()'                          "Data type {0} is not supported' tag {1} skipped."' tag' type);                      break;              }
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,copyTag,The following statement contains a magic number: switch (type)              {                  case TiffType.SHORT:                      result = inImage.GetField(tag);                      if (result != null)                      {                          switch (count)                          {                              case 1:                                  outImage.SetField(tag' result[0]);                                  break;                              case 2:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                              case 4:                                  outImage.SetField(tag' result[0]' result[1]' result[2]);                                  break;                              case -1:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                          }                      }                      break;                  case TiffType.LONG:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.RATIONAL:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.ASCII:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.DOUBLE:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  default:                      Tiff.Error(inImage' inImage.FileName()'                          "Data type {0} is not supported' tag {1} skipped."' tag' type);                      break;              }
Magic Number,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,copyTag,The following statement contains a magic number: switch (type)              {                  case TiffType.SHORT:                      result = inImage.GetField(tag);                      if (result != null)                      {                          switch (count)                          {                              case 1:                                  outImage.SetField(tag' result[0]);                                  break;                              case 2:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                              case 4:                                  outImage.SetField(tag' result[0]' result[1]' result[2]);                                  break;                              case -1:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                          }                      }                      break;                  case TiffType.LONG:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.RATIONAL:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.ASCII:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  case TiffType.DOUBLE:                      result = inImage.GetField(tag);                      if (result != null)                          outImage.SetField(tag' result[0]);                      break;                  default:                      Tiff.Error(inImage' inImage.FileName()'                          "Data type {0} is not supported' tag {1} skipped."' tag' type);                      break;              }
Missing Default,BitMiracle.TiffCP,Program,C:\repos\BitMiracle_libtiff.net\TiffCP\Program.cs,Main,The following switch statement is missing a default case: switch (option[0])                  {                      case ''':                          if (option[1] != '=')                          {                              usage();                              return;                          }                            imageNumberSeparator = option[2];                          break;                      case 'b':                          // this file is bias image subtracted from others                          if (c.m_bias != null)                          {                              Console.Error.Write("Only 1 bias image may be specified\n");                              return;                          }                            string biasName = args[argn + 1];                          c.m_bias = Tiff.Open(biasName' "r");                          if (c.m_bias == null)                          {                              Console.Error.WriteLine("Failed to open '{0}' as input."' biasName);                              return;                          }                            if (c.m_bias.IsTiled())                          {                              Console.Error.Write("Bias image must be organized in strips\n");                              return;                          }                            FieldValue[] result = c.m_bias.GetField(TiffTag.SAMPLESPERPIXEL);                          short samples = result[0].ToShort();                          if (samples != 1)                          {                              Console.Error.Write("Bias image must be monochrome\n");                              return;                          }                            argn++;                          break;                      case 'a':                          // append to output                          mode[0] = 'a';                          break;                      case 'c':                          // compression scheme                          if (!c.ProcessCompressOptions(optionArg))                          {                              usage();                              return;                          }                            argn++;                          break;                      case 'f':                          // fill order                          if (optionArg == "lsb2msb")                              defaultFillOrder = FillOrder.LSB2MSB;                          else if (optionArg == "msb2lsb")                              defaultFillOrder = FillOrder.MSB2LSB;                          else                          {                              usage();                              return;                          }                            argn++;                          break;                      case 'i':                          // ignore errors                          c.m_ignore = true;                          break;                      case 'l':                          // tile length                          c.m_outtiled = 1;                          defaultTileLength = int.Parse(optionArg' CultureInfo.InvariantCulture);                          argn++;                          break;                      case 'o':                          // initial directory offset                          initialDirectoryOffset = int.Parse(optionArg' CultureInfo.InvariantCulture);                          break;                      case 'p':                          // planar configuration                          if (optionArg == "separate")                              defaultPlanarConfig = PlanarConfig.SEPARATE;                          else if (optionArg == "contig")                              defaultPlanarConfig = PlanarConfig.CONTIG;                          else                          {                              usage();                              return;                          }                            argn++;                          break;                      case 'r':                          // rows/strip                          defaultRowsPerStrip = int.Parse(optionArg' CultureInfo.InvariantCulture);                          argn++;                          break;                      case 's':                          // generate stripped output                          c.m_outtiled = 0;                          break;                      case 't':                          // generate tiled output                          c.m_outtiled = 1;                          break;                      case 'w':                          // tile width                          c.m_outtiled = 1;                          defaultTileWidth = int.Parse(optionArg' CultureInfo.InvariantCulture);                          argn++;                          break;                      case 'B':                          mode.Append('b');                          break;                      case 'L':                          mode.Append('l');                          break;                      case 'M':                          mode.Append('m');                          break;                      case 'C':                          mode.Append('c');                          break;                      case 'x':                          c.m_pageInSeq = 1;                          break;                      case '?':                          usage();                          return;                  }
Missing Default,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,Copy,The following switch statement is missing a default case: switch (m_compression)              {                  case Compression.JPEG:                      outImage.SetField(TiffTag.JPEGQUALITY' m_quality);                      outImage.SetField(TiffTag.JPEGCOLORMODE' m_jpegcolormode);                      break;                  case Compression.LZW:                  case Compression.ADOBE_DEFLATE:                  case Compression.DEFLATE:                      if (m_predictor != -1)                          outImage.SetField(TiffTag.PREDICTOR' m_predictor);                      else                      {                          result = inImage.GetField(TiffTag.PREDICTOR);                          if (result != null)                          {                              m_predictor = result[0].ToShort();                              outImage.SetField(TiffTag.PREDICTOR' m_predictor);                          }                      }                      break;                  case Compression.CCITTFAX3:                  case Compression.CCITTFAX4:                      if (m_compression == Compression.CCITTFAX3)                      {                          if (m_g3opts != Group3Opt.UNKNOWN)                              outImage.SetField(TiffTag.GROUP3OPTIONS' m_g3opts);                          else                          {                              result = inImage.GetField(TiffTag.GROUP3OPTIONS);                              if (result != null)                              {                                  m_g3opts = (Group3Opt)result[0].ToShort();                                  outImage.SetField(TiffTag.GROUP3OPTIONS' m_g3opts);                              }                          }                      }                      else                          copyTag(inImage' outImage' TiffTag.GROUP4OPTIONS' 1' TiffType.LONG);                        copyTag(inImage' outImage' TiffTag.BADFAXLINES' 1' TiffType.LONG);                      copyTag(inImage' outImage' TiffTag.CLEANFAXDATA' 1' TiffType.LONG);                      copyTag(inImage' outImage' TiffTag.CONSECUTIVEBADFAXLINES' 1' TiffType.LONG);                      copyTag(inImage' outImage' TiffTag.FAXRECVPARAMS' 1' TiffType.LONG);                      copyTag(inImage' outImage' TiffTag.FAXRECVTIME' 1' TiffType.LONG);                      copyTag(inImage' outImage' TiffTag.FAXSUBADDRESS' 1' TiffType.ASCII);                      break;              }
Missing Default,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,cpBiasedContig2Contig,The following switch statement is missing a default case: switch (sampleBits)                              {                                  case 8:                                      subtract8(buf' biasBuf' imagewidth);                                      break;                                  case 16:                                      subtract16(buf' biasBuf' imagewidth);                                      break;                                  case 32:                                      subtract32(buf' biasBuf' imagewidth);                                      break;                              }
Missing Default,BitMiracle.TiffCP,Copier,C:\repos\BitMiracle_libtiff.net\TiffCP\Copier.cs,copyTag,The following switch statement is missing a default case: switch (count)                          {                              case 1:                                  outImage.SetField(tag' result[0]);                                  break;                              case 2:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                              case 4:                                  outImage.SetField(tag' result[0]' result[1]' result[2]);                                  break;                              case -1:                                  outImage.SetField(tag' result[0]' result[1]);                                  break;                          }
