Implementation smell,Namespace,Class,File,Method,Description
Long Method,BitMiracle.Tiff2Pdf,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The method has 206 lines of code.
Long Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf,The method has 158 lines of code.
Long Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The method has 132 lines of code.
Long Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The method has 552 lines of code.
Long Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The method has 261 lines of code.
Long Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The method has 212 lines of code.
Long Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The method has 184 lines of code.
Long Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page,The method has 167 lines of code.
Complex Method,BitMiracle.Tiff2Pdf,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,Cyclomatic complexity of the method is 36
Complex Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf,Cyclomatic complexity of the method is 12
Complex Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,Cyclomatic complexity of the method is 24
Complex Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,Cyclomatic complexity of the method is 82
Complex Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_size,Cyclomatic complexity of the method is 10
Complex Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,Cyclomatic complexity of the method is 45
Complex Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,Cyclomatic complexity of the method is 38
Complex Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,Cyclomatic complexity of the method is 29
Complex Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page,Cyclomatic complexity of the method is 20
Complex Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_cs,Cyclomatic complexity of the method is 10
Complex Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_stream_dict,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_stream_filter,Cyclomatic complexity of the method is 11
Complex Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,Cyclomatic complexity of the method is 13
Complex Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_string,Cyclomatic complexity of the method is 11
Complex Method,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,Cyclomatic complexity of the method is 10
Long Parameter List,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The method has 7 parameters. Parameters: strip' striplength' buffer' bufferoffset' stripCount' no' height
Long Parameter List,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,tile_collapse_left,The method has 5 parameters. Parameters: buffer' scanwidth' tilewidth' edgetilewidth' tilelength
Long Identifier,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,,The length of the parameter m_pdf_defaultcompressionquality is 31.
Long Statement,BitMiracle.Tiff2Pdf,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The length of the statement  "                        t2p.m_pdf_defaultpagewidth = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F); " is 155.
Long Statement,BitMiracle.Tiff2Pdf,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The length of the statement  "                        t2p.m_pdf_defaultpagelength = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F); " is 156.
Long Statement,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The length of the statement  "                if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null) " is 123.
Long Statement,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The length of the statement  "            if ((m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW) && (!edge || (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_JPEG))) " is 129.
Long Statement,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The length of the statement  "                    m_tiff_datasize = sample_rgba_to_rgb(buffer' m_tiff_pages[m_pdf_page].tiles_tilewidth * m_tiff_pages[m_pdf_page].tiles_tilelength); " is 131.
Long Statement,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The length of the statement  "                    m_tiff_datasize = sample_rgbaa_to_rgb(buffer' m_tiff_pages[m_pdf_page].tiles_tilewidth * m_tiff_pages[m_pdf_page].tiles_tilelength); " is 132.
Long Statement,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The length of the statement  "                    m_tiff_datasize = sample_lab_signed_to_unsigned(buffer' m_tiff_pages[m_pdf_page].tiles_tilewidth * m_tiff_pages[m_pdf_page].tiles_tilelength); " is 142.
Long Statement,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The length of the statement  "                tile_collapse_left(buffer' input.TileRowSize()' m_tiff_pages[m_pdf_page].tiles_tilewidth' m_tiff_pages[m_pdf_page].tiles_edgetilewidth' m_tiff_pages[m_pdf_page].tiles_tilelength); " is 179.
Long Statement,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_stream_dict,The length of the statement  "            if (!iccBased && m_pdf_switchdecode && !(m_pdf_colorspace == t2p_cs_t.T2P_CS_BILEVEL && m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)) " is 141.
Complex Conditional,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The conditional expression  "m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15"  is complex.
Complex Conditional,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The conditional expression  "(xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough"  is complex.
Complex Conditional,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page,The conditional expression  "(m_tiff_resunit != ResUnit.CENTIMETER && m_tiff_resunit != ResUnit.INCH) &&                  (m_tiff_xres < Tiff2PdfConstants.PS_UNIT_SIZE && m_tiff_yres < Tiff2PdfConstants.PS_UNIT_SIZE)"  is complex.
Complex Conditional,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_stream_dict,The conditional expression  "!iccBased && m_pdf_switchdecode && !(m_pdf_colorspace == t2p_cs_t.T2P_CS_BILEVEL && m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)"  is complex.
Magic Number,BitMiracle.Tiff2Pdf,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The following statement contains a magic number: switch (arg[0])                  {                      case 'o':                          outfilename = optarg;                          argn++;                          break;                        case 'j':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_JPEG;                          break;                        case 'z':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_ZIP;                          break;                                            case 'q':                           t2p.m_pdf_defaultcompressionquality = short.Parse(optarg' CultureInfo.InvariantCulture);                          argn++;                          break;                                            case 'n':                           t2p.m_pdf_nopassthrough = true;                          break;                                            case 'd':                           t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_NONE;                          break;                                            case 'u':                           if (optarg[0] == 'm')                              t2p.m_pdf_centimeters = true;                            argn++;                          break;                        case 'x':                           t2p.m_pdf_defaultxres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'y':                          t2p.m_pdf_defaultyres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'w':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagewidth = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'l':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagelength = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'r':                           if (optarg[0] == 'o')                              t2p.m_pdf_overrideres = true;                            argn++;                          break;                        case 'p':                           if (tiff2pdf_match_paper_size(out t2p.m_pdf_defaultpagewidth' out t2p.m_pdf_defaultpagelength' optarg))                              t2p.m_pdf_overridepagesize = true;                          else                              Tiff.Warning(Tiff2PdfConstants.TIFF2PDF_MODULE' "Unknown paper size {0}' ignoring option"' optarg);                            argn++;                          break;                        case 'i':                          t2p.m_pdf_colorspace_invert = true;                          break;                        case 'f':                           t2p.m_pdf_fitwindow = true;                          break;                        case 'e':                          t2p.m_pdf_datetime = new byte [17];                          if (optarg.Length == 0)                          {                              t2p.m_pdf_datetime[0] = 0;                          }                          else                          {                              t2p.m_pdf_datetime[0] = (byte)'D';                              t2p.m_pdf_datetime[1] = (byte)':';                                bytes = T2P.Latin1Encoding.GetBytes(optarg);                              Buffer.BlockCopy(bytes' 0' t2p.m_pdf_datetime' 2' Math.Min(bytes.Length' 14));                          }                            argn++;                          break;                        case 'c':                          t2p.m_pdf_creator = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 'a':                          t2p.m_pdf_author = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 't':                          t2p.m_pdf_title = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 's':                          t2p.m_pdf_subject = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'k':                          t2p.m_pdf_keywords = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'b':                          t2p.m_pdf_image_interpolate = true;                          break;                        case 'h':                       case '?':                           tiff2pdf_usage();                          return;                  }
Magic Number,BitMiracle.Tiff2Pdf,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The following statement contains a magic number: switch (arg[0])                  {                      case 'o':                          outfilename = optarg;                          argn++;                          break;                        case 'j':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_JPEG;                          break;                        case 'z':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_ZIP;                          break;                                            case 'q':                           t2p.m_pdf_defaultcompressionquality = short.Parse(optarg' CultureInfo.InvariantCulture);                          argn++;                          break;                                            case 'n':                           t2p.m_pdf_nopassthrough = true;                          break;                                            case 'd':                           t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_NONE;                          break;                                            case 'u':                           if (optarg[0] == 'm')                              t2p.m_pdf_centimeters = true;                            argn++;                          break;                        case 'x':                           t2p.m_pdf_defaultxres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'y':                          t2p.m_pdf_defaultyres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'w':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagewidth = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'l':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagelength = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'r':                           if (optarg[0] == 'o')                              t2p.m_pdf_overrideres = true;                            argn++;                          break;                        case 'p':                           if (tiff2pdf_match_paper_size(out t2p.m_pdf_defaultpagewidth' out t2p.m_pdf_defaultpagelength' optarg))                              t2p.m_pdf_overridepagesize = true;                          else                              Tiff.Warning(Tiff2PdfConstants.TIFF2PDF_MODULE' "Unknown paper size {0}' ignoring option"' optarg);                            argn++;                          break;                        case 'i':                          t2p.m_pdf_colorspace_invert = true;                          break;                        case 'f':                           t2p.m_pdf_fitwindow = true;                          break;                        case 'e':                          t2p.m_pdf_datetime = new byte [17];                          if (optarg.Length == 0)                          {                              t2p.m_pdf_datetime[0] = 0;                          }                          else                          {                              t2p.m_pdf_datetime[0] = (byte)'D';                              t2p.m_pdf_datetime[1] = (byte)':';                                bytes = T2P.Latin1Encoding.GetBytes(optarg);                              Buffer.BlockCopy(bytes' 0' t2p.m_pdf_datetime' 2' Math.Min(bytes.Length' 14));                          }                            argn++;                          break;                        case 'c':                          t2p.m_pdf_creator = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 'a':                          t2p.m_pdf_author = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 't':                          t2p.m_pdf_title = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 's':                          t2p.m_pdf_subject = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'k':                          t2p.m_pdf_keywords = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'b':                          t2p.m_pdf_image_interpolate = true;                          break;                        case 'h':                       case '?':                           tiff2pdf_usage();                          return;                  }
Magic Number,BitMiracle.Tiff2Pdf,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The following statement contains a magic number: switch (arg[0])                  {                      case 'o':                          outfilename = optarg;                          argn++;                          break;                        case 'j':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_JPEG;                          break;                        case 'z':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_ZIP;                          break;                                            case 'q':                           t2p.m_pdf_defaultcompressionquality = short.Parse(optarg' CultureInfo.InvariantCulture);                          argn++;                          break;                                            case 'n':                           t2p.m_pdf_nopassthrough = true;                          break;                                            case 'd':                           t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_NONE;                          break;                                            case 'u':                           if (optarg[0] == 'm')                              t2p.m_pdf_centimeters = true;                            argn++;                          break;                        case 'x':                           t2p.m_pdf_defaultxres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'y':                          t2p.m_pdf_defaultyres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'w':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagewidth = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'l':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagelength = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'r':                           if (optarg[0] == 'o')                              t2p.m_pdf_overrideres = true;                            argn++;                          break;                        case 'p':                           if (tiff2pdf_match_paper_size(out t2p.m_pdf_defaultpagewidth' out t2p.m_pdf_defaultpagelength' optarg))                              t2p.m_pdf_overridepagesize = true;                          else                              Tiff.Warning(Tiff2PdfConstants.TIFF2PDF_MODULE' "Unknown paper size {0}' ignoring option"' optarg);                            argn++;                          break;                        case 'i':                          t2p.m_pdf_colorspace_invert = true;                          break;                        case 'f':                           t2p.m_pdf_fitwindow = true;                          break;                        case 'e':                          t2p.m_pdf_datetime = new byte [17];                          if (optarg.Length == 0)                          {                              t2p.m_pdf_datetime[0] = 0;                          }                          else                          {                              t2p.m_pdf_datetime[0] = (byte)'D';                              t2p.m_pdf_datetime[1] = (byte)':';                                bytes = T2P.Latin1Encoding.GetBytes(optarg);                              Buffer.BlockCopy(bytes' 0' t2p.m_pdf_datetime' 2' Math.Min(bytes.Length' 14));                          }                            argn++;                          break;                        case 'c':                          t2p.m_pdf_creator = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 'a':                          t2p.m_pdf_author = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 't':                          t2p.m_pdf_title = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 's':                          t2p.m_pdf_subject = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'k':                          t2p.m_pdf_keywords = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'b':                          t2p.m_pdf_image_interpolate = true;                          break;                        case 'h':                       case '?':                           tiff2pdf_usage();                          return;                  }
Magic Number,BitMiracle.Tiff2Pdf,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The following statement contains a magic number: switch (arg[0])                  {                      case 'o':                          outfilename = optarg;                          argn++;                          break;                        case 'j':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_JPEG;                          break;                        case 'z':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_ZIP;                          break;                                            case 'q':                           t2p.m_pdf_defaultcompressionquality = short.Parse(optarg' CultureInfo.InvariantCulture);                          argn++;                          break;                                            case 'n':                           t2p.m_pdf_nopassthrough = true;                          break;                                            case 'd':                           t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_NONE;                          break;                                            case 'u':                           if (optarg[0] == 'm')                              t2p.m_pdf_centimeters = true;                            argn++;                          break;                        case 'x':                           t2p.m_pdf_defaultxres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'y':                          t2p.m_pdf_defaultyres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'w':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagewidth = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'l':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagelength = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'r':                           if (optarg[0] == 'o')                              t2p.m_pdf_overrideres = true;                            argn++;                          break;                        case 'p':                           if (tiff2pdf_match_paper_size(out t2p.m_pdf_defaultpagewidth' out t2p.m_pdf_defaultpagelength' optarg))                              t2p.m_pdf_overridepagesize = true;                          else                              Tiff.Warning(Tiff2PdfConstants.TIFF2PDF_MODULE' "Unknown paper size {0}' ignoring option"' optarg);                            argn++;                          break;                        case 'i':                          t2p.m_pdf_colorspace_invert = true;                          break;                        case 'f':                           t2p.m_pdf_fitwindow = true;                          break;                        case 'e':                          t2p.m_pdf_datetime = new byte [17];                          if (optarg.Length == 0)                          {                              t2p.m_pdf_datetime[0] = 0;                          }                          else                          {                              t2p.m_pdf_datetime[0] = (byte)'D';                              t2p.m_pdf_datetime[1] = (byte)':';                                bytes = T2P.Latin1Encoding.GetBytes(optarg);                              Buffer.BlockCopy(bytes' 0' t2p.m_pdf_datetime' 2' Math.Min(bytes.Length' 14));                          }                            argn++;                          break;                        case 'c':                          t2p.m_pdf_creator = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 'a':                          t2p.m_pdf_author = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 't':                          t2p.m_pdf_title = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 's':                          t2p.m_pdf_subject = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'k':                          t2p.m_pdf_keywords = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'b':                          t2p.m_pdf_image_interpolate = true;                          break;                        case 'h':                       case '?':                           tiff2pdf_usage();                          return;                  }
Magic Number,BitMiracle.Tiff2Pdf,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The following statement contains a magic number: switch (arg[0])                  {                      case 'o':                          outfilename = optarg;                          argn++;                          break;                        case 'j':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_JPEG;                          break;                        case 'z':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_ZIP;                          break;                                            case 'q':                           t2p.m_pdf_defaultcompressionquality = short.Parse(optarg' CultureInfo.InvariantCulture);                          argn++;                          break;                                            case 'n':                           t2p.m_pdf_nopassthrough = true;                          break;                                            case 'd':                           t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_NONE;                          break;                                            case 'u':                           if (optarg[0] == 'm')                              t2p.m_pdf_centimeters = true;                            argn++;                          break;                        case 'x':                           t2p.m_pdf_defaultxres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'y':                          t2p.m_pdf_defaultyres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'w':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagewidth = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'l':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagelength = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'r':                           if (optarg[0] == 'o')                              t2p.m_pdf_overrideres = true;                            argn++;                          break;                        case 'p':                           if (tiff2pdf_match_paper_size(out t2p.m_pdf_defaultpagewidth' out t2p.m_pdf_defaultpagelength' optarg))                              t2p.m_pdf_overridepagesize = true;                          else                              Tiff.Warning(Tiff2PdfConstants.TIFF2PDF_MODULE' "Unknown paper size {0}' ignoring option"' optarg);                            argn++;                          break;                        case 'i':                          t2p.m_pdf_colorspace_invert = true;                          break;                        case 'f':                           t2p.m_pdf_fitwindow = true;                          break;                        case 'e':                          t2p.m_pdf_datetime = new byte [17];                          if (optarg.Length == 0)                          {                              t2p.m_pdf_datetime[0] = 0;                          }                          else                          {                              t2p.m_pdf_datetime[0] = (byte)'D';                              t2p.m_pdf_datetime[1] = (byte)':';                                bytes = T2P.Latin1Encoding.GetBytes(optarg);                              Buffer.BlockCopy(bytes' 0' t2p.m_pdf_datetime' 2' Math.Min(bytes.Length' 14));                          }                            argn++;                          break;                        case 'c':                          t2p.m_pdf_creator = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 'a':                          t2p.m_pdf_author = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 't':                          t2p.m_pdf_title = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 's':                          t2p.m_pdf_subject = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'k':                          t2p.m_pdf_keywords = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'b':                          t2p.m_pdf_image_interpolate = true;                          break;                        case 'h':                       case '?':                           tiff2pdf_usage();                          return;                  }
Magic Number,BitMiracle.Tiff2Pdf,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The following statement contains a magic number: switch (arg[0])                  {                      case 'o':                          outfilename = optarg;                          argn++;                          break;                        case 'j':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_JPEG;                          break;                        case 'z':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_ZIP;                          break;                                            case 'q':                           t2p.m_pdf_defaultcompressionquality = short.Parse(optarg' CultureInfo.InvariantCulture);                          argn++;                          break;                                            case 'n':                           t2p.m_pdf_nopassthrough = true;                          break;                                            case 'd':                           t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_NONE;                          break;                                            case 'u':                           if (optarg[0] == 'm')                              t2p.m_pdf_centimeters = true;                            argn++;                          break;                        case 'x':                           t2p.m_pdf_defaultxres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'y':                          t2p.m_pdf_defaultyres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'w':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagewidth = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'l':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagelength = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'r':                           if (optarg[0] == 'o')                              t2p.m_pdf_overrideres = true;                            argn++;                          break;                        case 'p':                           if (tiff2pdf_match_paper_size(out t2p.m_pdf_defaultpagewidth' out t2p.m_pdf_defaultpagelength' optarg))                              t2p.m_pdf_overridepagesize = true;                          else                              Tiff.Warning(Tiff2PdfConstants.TIFF2PDF_MODULE' "Unknown paper size {0}' ignoring option"' optarg);                            argn++;                          break;                        case 'i':                          t2p.m_pdf_colorspace_invert = true;                          break;                        case 'f':                           t2p.m_pdf_fitwindow = true;                          break;                        case 'e':                          t2p.m_pdf_datetime = new byte [17];                          if (optarg.Length == 0)                          {                              t2p.m_pdf_datetime[0] = 0;                          }                          else                          {                              t2p.m_pdf_datetime[0] = (byte)'D';                              t2p.m_pdf_datetime[1] = (byte)':';                                bytes = T2P.Latin1Encoding.GetBytes(optarg);                              Buffer.BlockCopy(bytes' 0' t2p.m_pdf_datetime' 2' Math.Min(bytes.Length' 14));                          }                            argn++;                          break;                        case 'c':                          t2p.m_pdf_creator = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 'a':                          t2p.m_pdf_author = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 't':                          t2p.m_pdf_title = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 's':                          t2p.m_pdf_subject = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'k':                          t2p.m_pdf_keywords = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'b':                          t2p.m_pdf_image_interpolate = true;                          break;                        case 'h':                       case '?':                           tiff2pdf_usage();                          return;                  }
Magic Number,BitMiracle.Tiff2Pdf,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The following statement contains a magic number: switch (arg[0])                  {                      case 'o':                          outfilename = optarg;                          argn++;                          break;                        case 'j':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_JPEG;                          break;                        case 'z':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_ZIP;                          break;                                            case 'q':                           t2p.m_pdf_defaultcompressionquality = short.Parse(optarg' CultureInfo.InvariantCulture);                          argn++;                          break;                                            case 'n':                           t2p.m_pdf_nopassthrough = true;                          break;                                            case 'd':                           t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_NONE;                          break;                                            case 'u':                           if (optarg[0] == 'm')                              t2p.m_pdf_centimeters = true;                            argn++;                          break;                        case 'x':                           t2p.m_pdf_defaultxres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'y':                          t2p.m_pdf_defaultyres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'w':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagewidth = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'l':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagelength = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'r':                           if (optarg[0] == 'o')                              t2p.m_pdf_overrideres = true;                            argn++;                          break;                        case 'p':                           if (tiff2pdf_match_paper_size(out t2p.m_pdf_defaultpagewidth' out t2p.m_pdf_defaultpagelength' optarg))                              t2p.m_pdf_overridepagesize = true;                          else                              Tiff.Warning(Tiff2PdfConstants.TIFF2PDF_MODULE' "Unknown paper size {0}' ignoring option"' optarg);                            argn++;                          break;                        case 'i':                          t2p.m_pdf_colorspace_invert = true;                          break;                        case 'f':                           t2p.m_pdf_fitwindow = true;                          break;                        case 'e':                          t2p.m_pdf_datetime = new byte [17];                          if (optarg.Length == 0)                          {                              t2p.m_pdf_datetime[0] = 0;                          }                          else                          {                              t2p.m_pdf_datetime[0] = (byte)'D';                              t2p.m_pdf_datetime[1] = (byte)':';                                bytes = T2P.Latin1Encoding.GetBytes(optarg);                              Buffer.BlockCopy(bytes' 0' t2p.m_pdf_datetime' 2' Math.Min(bytes.Length' 14));                          }                            argn++;                          break;                        case 'c':                          t2p.m_pdf_creator = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 'a':                          t2p.m_pdf_author = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 't':                          t2p.m_pdf_title = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 's':                          t2p.m_pdf_subject = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'k':                          t2p.m_pdf_keywords = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'b':                          t2p.m_pdf_image_interpolate = true;                          break;                        case 'h':                       case '?':                           tiff2pdf_usage();                          return;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,T2P,The following statement contains a magic number: m_pdf_defaultxres = 300.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,T2P,The following statement contains a magic number: m_pdf_defaultyres = 300.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,T2P,The following statement contains a magic number: m_pdf_defaultpagewidth = 612.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,T2P,The following statement contains a magic number: m_pdf_defaultpagelength = 792.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,T2P,The following statement contains a magic number: m_pdf_xrefcount = 3;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: m_pdf_defaultcompressionquality > 100 || m_pdf_defaultcompressionquality < 1
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: int m = m_pdf_defaultcompressionquality % 100;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: m_pdf_defaultcompressionquality /= 100;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: m_pdf_defaultcompressionquality *= 100;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: m_pdf_defaultcompressionquality % 100 != 0
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: m_pdf_defaultcompressionquality %= 100;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: m_pdf_minorversion = 2;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: m_pdf_minorversion < 2
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf,The following statement contains a magic number: m_pdf_info = 2;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf,The following statement contains a magic number: m_pdf_pages = 3;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: m_pdf_xrefcount += 5;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: m_pdf_minorversion = 2;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: m_pdf_minorversion < 2
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: m_tiff_transferfunction[2] = result[2].GetBytes();
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: m_tiff_transferfunction[2] = result[2].GetBytes();
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: m_tiff_transferfunctioncount = 3;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: m_tiff_pages[i].page_extra += 4;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: m_pdf_xrefcount += 4;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: m_pdf_minorversion = 2;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: m_pdf_minorversion < 2
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: m_pdf_minorversion = 3;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: m_pdf_minorversion < 3
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_bitspersample)              {                  case 1:                  case 2:                  case 4:                  case 8:                      break;                  case 0:                      Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                           "Image {0} has 0 bits per sample' assuming 1"' input.FileName());                      m_tiff_bitspersample = 1;                      break;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                           "No support for {0} with {1} bits per sample"'                          input.FileName()' m_tiff_bitspersample);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_bitspersample)              {                  case 1:                  case 2:                  case 4:                  case 8:                      break;                  case 0:                      Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                           "Image {0} has 0 bits per sample' assuming 1"' input.FileName());                      m_tiff_bitspersample = 1;                      break;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                           "No support for {0} with {1} bits per sample"'                          input.FileName()' m_tiff_bitspersample);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_bitspersample)              {                  case 1:                  case 2:                  case 4:                  case 8:                      break;                  case 0:                      Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                           "Image {0} has 0 bits per sample' assuming 1"' input.FileName());                      m_tiff_bitspersample = 1;                      break;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                           "No support for {0} with {1} bits per sample"'                          input.FileName()' m_tiff_bitspersample);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_samplesperpixel > 4
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_planar)                  {                      case 0:                          Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Image {0} has planar configuration 0' assuming 1"' input.FileName());                          m_tiff_planar = PlanarConfig.CONTIG;                          break;                        case PlanarConfig.CONTIG:                          break;                                            case PlanarConfig.SEPARATE:                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG;                          if (m_tiff_bitspersample != 8)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} with separated planar configuration and {1} bits per sample"'                                  input.FileName()' m_tiff_bitspersample);                              m_error = true;                              return;                          }                          break;                                            default:                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "No support for {0} with planar configuration {1}"'                              input.FileName()' m_tiff_planar);                          m_error = true;                          return;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_xres *= 2.54F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_yres *= 2.54F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_samplesperpixel = 4;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_transferfunction[2] = result[2].GetBytes();
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_transferfunction[2] = result[2].GetBytes();
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_transferfunctioncount = 3;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_primarychromaticities[2] = xfloatp[2];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_primarychromaticities[2] = xfloatp[2];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_primarychromaticities[3] = xfloatp[3];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_primarychromaticities[3] = xfloatp[3];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_primarychromaticities[4] = xfloatp[4];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_primarychromaticities[4] = xfloatp[4];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_primarychromaticities[5] = xfloatp[5];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: m_tiff_primarychromaticities[5] = xfloatp[5];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_size,The following statement contains a magic number: m_tiff_datasize -= 2;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_size,The following statement contains a magic number: count > 4
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_size,The following statement contains a magic number: m_tiff_datasize -= 4;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_size,The following statement contains a magic number: m_tiff_datasize += 2;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The following statement contains a magic number: bufferoffset += count - 2;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The following statement contains a magic number: count > 4
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                        if (!m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG))                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Unable to use JPEG compression for input {0} and output {1}"'                              input.FileName()' m_output.FileName());                          m_error = true;                          return 0;                      }                        m_output.SetField(TiffTag.JPEGTABLESMODE' 0);                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                            if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                                            if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                        if (!m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG))                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Unable to use JPEG compression for input {0} and output {1}"'                              input.FileName()' m_output.FileName());                          m_error = true;                          return 0;                      }                        m_output.SetField(TiffTag.JPEGTABLESMODE' 0);                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                            if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                                            if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                        if (!m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG))                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Unable to use JPEG compression for input {0} and output {1}"'                              input.FileName()' m_output.FileName());                          m_error = true;                          return 0;                      }                        m_output.SetField(TiffTag.JPEGTABLESMODE' 0);                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                            if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                                            if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                        if (!m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG))                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Unable to use JPEG compression for input {0} and output {1}"'                              input.FileName()' m_output.FileName());                          m_error = true;                          return 0;                      }                        m_output.SetField(TiffTag.JPEGTABLESMODE' 0);                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                            if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                                            if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: byte[] table_end = new byte[2];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: bufferoffset += count - 2;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: table_end[0] = buffer[bufferoffset - 2];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: bufferoffset += input.ReadRawTile(tile' buffer' bufferoffset - 2' -1);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: buffer[xuint32 - 2] = table_end[0];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                                            m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG);                      m_output.SetField(TiffTag.JPEGTABLESMODE' 0); /* JpegTablesMode.NONE */                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                          if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                        if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                                            m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG);                      m_output.SetField(TiffTag.JPEGTABLESMODE' 0); /* JpegTablesMode.NONE */                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                          if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                        if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                                            m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG);                      m_output.SetField(TiffTag.JPEGTABLESMODE' 0); /* JpegTablesMode.NONE */                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                          if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                        if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                                            m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG);                      m_output.SetField(TiffTag.JPEGTABLESMODE' 0); /* JpegTablesMode.NONE */                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                          if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                        if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_header,The following statement contains a magic number: byte[] octals = new byte [4];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_header,The following statement contains a magic number: octals[0] = Convert.ToByte("342"' 8);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_header,The following statement contains a magic number: octals[1] = Convert.ToByte("343"' 8);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_header,The following statement contains a magic number: octals[2] = Convert.ToByte("317"' 8);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_header,The following statement contains a magic number: octals[2] = Convert.ToByte("317"' 8);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_header,The following statement contains a magic number: octals[3] = Convert.ToByte("323"' 8);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_header,The following statement contains a magic number: octals[3] = Convert.ToByte("323"' 8);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: buf = new byte[512];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: Buffer.BlockCopy(m_pdf_creator' 0' buf' 0' 511);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: strlen(m_pdf_creator) > 511
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: buf = new byte[512];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: Buffer.BlockCopy(m_pdf_author' 0' buf' 0' 511);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: strlen(m_pdf_author) > 511
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: buf = new byte[512];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: Buffer.BlockCopy(m_pdf_title' 0' buf' 0' 511);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: strlen(m_pdf_title) > 511
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: buf = new byte[512];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: Buffer.BlockCopy(m_pdf_subject' 0' buf' 0' 511);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: strlen(m_pdf_subject) > 511
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: buf = new byte[512];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: Buffer.BlockCopy(m_pdf_keywords' 0' buf' 0' 511);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: strlen(m_pdf_keywords) > 511
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_currenttime,The following statement contains a magic number: string s = string.Format(CultureInfo.InvariantCulture'                  "D:{0:0000}{1:00}{2:00}{3:00}{4:00}{5:00}"'                   dt.Year % 65536' dt.Month % 256' dt.Day % 256' dt.Hour % 256'                   dt.Minute % 256' dt.Second % 256);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_currenttime,The following statement contains a magic number: string s = string.Format(CultureInfo.InvariantCulture'                  "D:{0:0000}{1:00}{2:00}{3:00}{4:00}{5:00}"'                   dt.Year % 65536' dt.Month % 256' dt.Day % 256' dt.Hour % 256'                   dt.Minute % 256' dt.Second % 256);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_currenttime,The following statement contains a magic number: string s = string.Format(CultureInfo.InvariantCulture'                  "D:{0:0000}{1:00}{2:00}{3:00}{4:00}{5:00}"'                   dt.Year % 65536' dt.Month % 256' dt.Day % 256' dt.Hour % 256'                   dt.Minute % 256' dt.Second % 256);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_currenttime,The following statement contains a magic number: string s = string.Format(CultureInfo.InvariantCulture'                  "D:{0:0000}{1:00}{2:00}{3:00}{4:00}{5:00}"'                   dt.Year % 65536' dt.Month % 256' dt.Day % 256' dt.Hour % 256'                   dt.Minute % 256' dt.Second % 256);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_currenttime,The following statement contains a magic number: string s = string.Format(CultureInfo.InvariantCulture'                  "D:{0:0000}{1:00}{2:00}{3:00}{4:00}{5:00}"'                   dt.Year % 65536' dt.Month % 256' dt.Day % 256' dt.Hour % 256'                   dt.Minute % 256' dt.Second % 256);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_currenttime,The following statement contains a magic number: string s = string.Format(CultureInfo.InvariantCulture'                  "D:{0:0000}{1:00}{2:00}{3:00}{4:00}{5:00}"'                   dt.Year % 65536' dt.Month % 256' dt.Day % 256' dt.Hour % 256'                   dt.Minute % 256' dt.Second % 256);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime = new byte[16];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[2] = (byte)datetime[0];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[3] = (byte)datetime[1];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[4] = (byte)datetime[2];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[4] = (byte)datetime[2];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[5] = (byte)datetime[3];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[5] = (byte)datetime[3];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[6] = (byte)datetime[5];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[6] = (byte)datetime[5];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[7] = (byte)datetime[6];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[7] = (byte)datetime[6];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[8] = (byte)datetime[8];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[8] = (byte)datetime[8];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[9] = (byte)datetime[9];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[9] = (byte)datetime[9];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[10] = (byte)datetime[11];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[10] = (byte)datetime[11];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[11] = (byte)datetime[12];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[11] = (byte)datetime[12];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[12] = (byte)datetime[14];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[12] = (byte)datetime[14];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[13] = (byte)datetime[15];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[13] = (byte)datetime[15];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[14] = (byte)datetime[17];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[14] = (byte)datetime[17];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[15] = (byte)datetime[18];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: m_pdf_datetime[15] = (byte)datetime[18];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: result != null && (result[0].ToString()).Length >= 19
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_pages,The following statement contains a magic number: ((i + 1) % 8) == 0
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_pages,The following statement contains a magic number: page += 3;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_pages,The following statement contains a magic number: page += (2 * m_tiff_pages[i].page_tilecount);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page,The following statement contains a magic number: m_pdf_imagebox.x1 += (m_pdf_pagewidth - m_pdf_imagewidth) / 2.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page,The following statement contains a magic number: m_pdf_imagebox.y1 += (m_pdf_pagelength - m_pdf_imagelength) / 2.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page,The following statement contains a magic number: m_pdf_imagebox.x2 += (m_pdf_pagewidth - m_pdf_imagewidth) / 2.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page,The following statement contains a magic number: m_pdf_imagebox.y2 += (m_pdf_pagelength - m_pdf_imagelength) / 2.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_cs,The following statement contains a magic number: X_W = 0.3457F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_cs,The following statement contains a magic number: Y_W = 0.3585F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_cs,The following statement contains a magic number: buffer = string.Format(CultureInfo.InvariantCulture'                      "[{0} {1} {2} {3}] \n"' m_pdf_labrange[0]' m_pdf_labrange[1]' m_pdf_labrange[2]' m_pdf_labrange[3]);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_cs,The following statement contains a magic number: buffer = string.Format(CultureInfo.InvariantCulture'                      "[{0} {1} {2} {3}] \n"' m_pdf_labrange[0]' m_pdf_labrange[1]' m_pdf_labrange[2]' m_pdf_labrange[3]);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_calcs,The following statement contains a magic number: float x_g = m_tiff_primarychromaticities[2];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_calcs,The following statement contains a magic number: float y_g = m_tiff_primarychromaticities[3];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_calcs,The following statement contains a magic number: float x_b = m_tiff_primarychromaticities[4];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_calcs,The following statement contains a magic number: float y_b = m_tiff_primarychromaticities[5];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: m_pdf_fileid = new byte [33];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: m_pdf_fileid[2 * i] = (byte)(fileidbuf[2 * i]);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: m_pdf_fileid[2 * i] = (byte)(fileidbuf[2 * i]);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: m_pdf_fileid[2 * i + 1] = (byte)(fileidbuf[2 * i + 1]);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: m_pdf_fileid[2 * i + 1] = (byte)(fileidbuf[2 * i + 1]);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: i < 16
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: written += writeToFile(m_pdf_fileid' 32);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: written += writeToFile(m_pdf_fileid' 32);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_stream_filter,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_G4:                      written += writeToFile("/CCITTFaxDecode ");                      written += writeToFile("/DecodeParms ");                      written += writeToFile("<< /K -1 ");                                            if (tile == 0)                      {                          written += writeToFile("/Columns ");                          buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_tiff_width);                          written += writeToFile(buffer);                          written += writeToFile(" /Rows ");                          buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_tiff_length);                          written += writeToFile(buffer);                      }                      else                      {                          if (!tile_is_right_edge(m_tiff_pages[m_pdf_page]' tile - 1))                          {                              written += writeToFile("/Columns ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                   "{0}"' m_tiff_pages[m_pdf_page].tiles_tilewidth);                              written += writeToFile(buffer);                          }                          else                          {                              written += writeToFile("/Columns ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                  "{0}"' m_tiff_pages[m_pdf_page].tiles_edgetilewidth);                              written += writeToFile(buffer);                          }                            if (!tile_is_bottom_edge(m_tiff_pages[m_pdf_page]' tile - 1))                          {                              written += writeToFile(" /Rows ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                  "{0}"' m_tiff_pages[m_pdf_page].tiles_tilelength);                              written += writeToFile(buffer);                          }                          else                          {                              written += writeToFile(" /Rows ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                  "{0}"' m_tiff_pages[m_pdf_page].tiles_edgetilelength);                              written += writeToFile(buffer);                          }                      }                        if (!m_pdf_switchdecode)                          written += writeToFile(" /BlackIs1 true ");                        written += writeToFile(">>\n");                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      written += writeToFile("/DCTDecode ");                        if (m_tiff_photometric != Photometric.YCBCR)                      {                          written += writeToFile("/DecodeParms ");                          written += writeToFile("<< /ColorTransform 0 >>\n");                      }                      break;                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      written += writeToFile("/FlateDecode ");                      if ((m_pdf_defaultcompressionquality % 100) != 0)                      {                          written += writeToFile("/DecodeParms ");                          written += writeToFile("<< /Predictor ");                          buffer = string.Format(CultureInfo.InvariantCulture'                               "{0}"' m_pdf_defaultcompressionquality % 100);                          written += writeToFile(buffer);                          written += writeToFile(" /Columns ");                          buffer = string.Format(CultureInfo.InvariantCulture'                              "{0}"' m_tiff_width);                          written += writeToFile(buffer);                          written += writeToFile(" /Colors ");                          buffer = string.Format(CultureInfo.InvariantCulture'                              "{0}"' m_tiff_samplesperpixel);                          written += writeToFile(buffer);                          written += writeToFile(" /BitsPerComponent ");                          buffer = string.Format(CultureInfo.InvariantCulture'                              "{0}"' m_tiff_bitspersample);                          written += writeToFile(buffer);                          written += writeToFile(">>\n");                      }                      break;                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_stream_filter,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_G4:                      written += writeToFile("/CCITTFaxDecode ");                      written += writeToFile("/DecodeParms ");                      written += writeToFile("<< /K -1 ");                                            if (tile == 0)                      {                          written += writeToFile("/Columns ");                          buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_tiff_width);                          written += writeToFile(buffer);                          written += writeToFile(" /Rows ");                          buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_tiff_length);                          written += writeToFile(buffer);                      }                      else                      {                          if (!tile_is_right_edge(m_tiff_pages[m_pdf_page]' tile - 1))                          {                              written += writeToFile("/Columns ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                   "{0}"' m_tiff_pages[m_pdf_page].tiles_tilewidth);                              written += writeToFile(buffer);                          }                          else                          {                              written += writeToFile("/Columns ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                  "{0}"' m_tiff_pages[m_pdf_page].tiles_edgetilewidth);                              written += writeToFile(buffer);                          }                            if (!tile_is_bottom_edge(m_tiff_pages[m_pdf_page]' tile - 1))                          {                              written += writeToFile(" /Rows ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                  "{0}"' m_tiff_pages[m_pdf_page].tiles_tilelength);                              written += writeToFile(buffer);                          }                          else                          {                              written += writeToFile(" /Rows ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                  "{0}"' m_tiff_pages[m_pdf_page].tiles_edgetilelength);                              written += writeToFile(buffer);                          }                      }                        if (!m_pdf_switchdecode)                          written += writeToFile(" /BlackIs1 true ");                        written += writeToFile(">>\n");                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      written += writeToFile("/DCTDecode ");                        if (m_tiff_photometric != Photometric.YCBCR)                      {                          written += writeToFile("/DecodeParms ");                          written += writeToFile("<< /ColorTransform 0 >>\n");                      }                      break;                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      written += writeToFile("/FlateDecode ");                      if ((m_pdf_defaultcompressionquality % 100) != 0)                      {                          written += writeToFile("/DecodeParms ");                          written += writeToFile("<< /Predictor ");                          buffer = string.Format(CultureInfo.InvariantCulture'                               "{0}"' m_pdf_defaultcompressionquality % 100);                          written += writeToFile(buffer);                          written += writeToFile(" /Columns ");                          buffer = string.Format(CultureInfo.InvariantCulture'                              "{0}"' m_tiff_width);                          written += writeToFile(buffer);                          written += writeToFile(" /Colors ");                          buffer = string.Format(CultureInfo.InvariantCulture'                              "{0}"' m_tiff_samplesperpixel);                          written += writeToFile(buffer);                          written += writeToFile(" /BitsPerComponent ");                          buffer = string.Format(CultureInfo.InvariantCulture'                              "{0}"' m_tiff_bitspersample);                          written += writeToFile(buffer);                          written += writeToFile(">>\n");                      }                      break;                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page_content_stream,The following statement contains a magic number: buffer = string.Format(CultureInfo.InvariantCulture'                           "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7}_{8} Do Q\n"'                           m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                           box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1' i + 1);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page_content_stream,The following statement contains a magic number: buffer = string.Format(CultureInfo.InvariantCulture'                           "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7}_{8} Do Q\n"'                           m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                           box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1' i + 1);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page_content_stream,The following statement contains a magic number: buffer = string.Format(CultureInfo.InvariantCulture'                           "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7}_{8} Do Q\n"'                           m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                           box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1' i + 1);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page_content_stream,The following statement contains a magic number: buffer = string.Format(CultureInfo.InvariantCulture'                           "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7}_{8} Do Q\n"'                           m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                           box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1' i + 1);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: byte alpha = (byte)(255 - ((sample >> 24) & 0xff));
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: byte alpha = (byte)(255 - ((sample >> 24) & 0xff));
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: data[i * 3] = (byte)(((sample >> 16) & 0xff) + alpha);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: data[i * 3] = (byte)(((sample >> 16) & 0xff) + alpha);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: data[i * 3 + 1] = (byte)(((sample >> 8) & 0xff) + alpha);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: data[i * 3 + 1] = (byte)(((sample >> 8) & 0xff) + alpha);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: data[i * 3 + 2] = (byte)((sample & 0xff) + alpha);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: data[i * 3 + 2] = (byte)((sample & 0xff) + alpha);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: return (i * 3);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgbaa_to_rgb,The following statement contains a magic number: Buffer.BlockCopy(data' i * 4' data' i * 3' 3);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgbaa_to_rgb,The following statement contains a magic number: Buffer.BlockCopy(data' i * 4' data' i * 3' 3);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgbaa_to_rgb,The following statement contains a magic number: Buffer.BlockCopy(data' i * 4' data' i * 3' 3);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgbaa_to_rgb,The following statement contains a magic number: return (i * 3);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_abgr_to_rgb,The following statement contains a magic number: data[i * 3] = (byte)(sample & 0xff);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_abgr_to_rgb,The following statement contains a magic number: data[i * 3 + 1] = (byte)((sample >> 8) & 0xff);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_abgr_to_rgb,The following statement contains a magic number: data[i * 3 + 1] = (byte)((sample >> 8) & 0xff);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_abgr_to_rgb,The following statement contains a magic number: data[i * 3 + 2] = (byte)((sample >> 16) & 0xff);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_abgr_to_rgb,The following statement contains a magic number: data[i * 3 + 2] = (byte)((sample >> 16) & 0xff);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_abgr_to_rgb,The following statement contains a magic number: data[i * 3 + 2] = (byte)((sample >> 16) & 0xff);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_abgr_to_rgb,The following statement contains a magic number: return (i * 3);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: buffer[i * 3 + 1] = (byte)(0x80 + (sbyte)buffer[i * 3 + 1]);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: buffer[i * 3 + 1] = (byte)(0x80 + (sbyte)buffer[i * 3 + 1]);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: (buffer[i * 3 + 1] & 0x80) != 0
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: (buffer[i * 3 + 2] & 0x80) != 0
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: (buffer[i * 3 + 2] & 0x80) != 0
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: return (samplecount * 3);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,encodeOctalString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' @"\{0}{1}{2}"' (x >> 6) & 7' (x >> 3) & 7' x & 7);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,encodeOctalString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' @"\{0}{1}{2}"' (x >> 6) & 7' (x >> 3) & 7' x & 7);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,encodeOctalString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' @"\{0}{1}{2}"' (x >> 6) & 7' (x >> 3) & 7' x & 7);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,encodeOctalString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' @"\{0}{1}{2}"' (x >> 6) & 7' (x >> 3) & 7' x & 7);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,encodeOctalString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' @"\{0}{1}{2}"' (x >> 6) & 7' (x >> 3) & 7' x & 7);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_string,The following statement contains a magic number: (pdfstr[i] & 0x80) != 0 || (pdfstr[i] == 127) || (pdfstr[i] < 32)
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_string,The following statement contains a magic number: (pdfstr[i] & 0x80) != 0 || (pdfstr[i] == 127) || (pdfstr[i] < 32)
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: float[] m1 = new float[9];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[2] = m1[2] = 0.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[2] = m1[2] = 0.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[3] = m1[3] = 0.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[3] = m1[3] = 0.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[4] = m1[4] = boxp.y2 - boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[4] = m1[4] = boxp.y2 - boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[5] = m1[5] = 0.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[5] = m1[5] = 0.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[6] = m1[6] = boxp.x1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[6] = m1[6] = boxp.x1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[7] = m1[7] = boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[7] = m1[7] = boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[8] = m1[8] = 1.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[8] = m1[8] = 1.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: float[] m1 = new float[9];
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[2] = m1[2] = 0.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[2] = m1[2] = 0.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[3] = m1[3] = 0.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[3] = m1[3] = 0.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[4] = m1[4] = boxp.y2 - boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[4] = m1[4] = boxp.y2 - boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[5] = m1[5] = 0.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[5] = m1[5] = 0.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[6] = m1[6] = boxp.x1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[6] = m1[6] = boxp.x1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[7] = m1[7] = boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[7] = m1[7] = boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[8] = m1[8] = 1.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[8] = m1[8] = 1.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page,The following statement contains a magic number: buffer = string.Format(CultureInfo.InvariantCulture'                          "{0}"' obj + 3 + 2 * i + m_tiff_pages[m_pdf_page].page_extra);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page,The following statement contains a magic number: buffer = string.Format(CultureInfo.InvariantCulture'                          "{0}"' obj + 3 + 2 * i + m_tiff_pages[m_pdf_page].page_extra);
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page,The following statement contains a magic number: i % 4 == 3
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page,The following statement contains a magic number: i % 4 == 3
Magic Number,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page,The following statement contains a magic number: buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' obj + 3);
Missing Default,BitMiracle.Tiff2Pdf,Program,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The following switch statement is missing a default case: switch (arg[0])                  {                      case 'o':                          outfilename = optarg;                          argn++;                          break;                        case 'j':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_JPEG;                          break;                        case 'z':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_ZIP;                          break;                                            case 'q':                           t2p.m_pdf_defaultcompressionquality = short.Parse(optarg' CultureInfo.InvariantCulture);                          argn++;                          break;                                            case 'n':                           t2p.m_pdf_nopassthrough = true;                          break;                                            case 'd':                           t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_NONE;                          break;                                            case 'u':                           if (optarg[0] == 'm')                              t2p.m_pdf_centimeters = true;                            argn++;                          break;                        case 'x':                           t2p.m_pdf_defaultxres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'y':                          t2p.m_pdf_defaultyres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'w':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagewidth = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'l':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagelength = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'r':                           if (optarg[0] == 'o')                              t2p.m_pdf_overrideres = true;                            argn++;                          break;                        case 'p':                           if (tiff2pdf_match_paper_size(out t2p.m_pdf_defaultpagewidth' out t2p.m_pdf_defaultpagelength' optarg))                              t2p.m_pdf_overridepagesize = true;                          else                              Tiff.Warning(Tiff2PdfConstants.TIFF2PDF_MODULE' "Unknown paper size {0}' ignoring option"' optarg);                            argn++;                          break;                        case 'i':                          t2p.m_pdf_colorspace_invert = true;                          break;                        case 'f':                           t2p.m_pdf_fitwindow = true;                          break;                        case 'e':                          t2p.m_pdf_datetime = new byte [17];                          if (optarg.Length == 0)                          {                              t2p.m_pdf_datetime[0] = 0;                          }                          else                          {                              t2p.m_pdf_datetime[0] = (byte)'D';                              t2p.m_pdf_datetime[1] = (byte)':';                                bytes = T2P.Latin1Encoding.GetBytes(optarg);                              Buffer.BlockCopy(bytes' 0' t2p.m_pdf_datetime' 2' Math.Min(bytes.Length' 14));                          }                            argn++;                          break;                        case 'c':                          t2p.m_pdf_creator = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 'a':                          t2p.m_pdf_author = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 't':                          t2p.m_pdf_title = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 's':                          t2p.m_pdf_subject = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'k':                          t2p.m_pdf_keywords = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'b':                          t2p.m_pdf_image_interpolate = true;                          break;                        case 'h':                       case '?':                           tiff2pdf_usage();                          return;                  }
Missing Default,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following switch statement is missing a default case: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Missing Default,BitMiracle.Tiff2Pdf,T2P,D:\research\architectureSmells\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following switch statement is missing a default case: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
