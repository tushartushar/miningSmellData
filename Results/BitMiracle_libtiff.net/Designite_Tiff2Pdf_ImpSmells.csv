Implementation smell,Namespace,Class,File,Method,Description
Long Method,BitMiracle.Tiff2Pdf,Program,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The method has 206 lines of code.
Long Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf,The method has 158 lines of code.
Long Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The method has 132 lines of code.
Long Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The method has 552 lines of code.
Long Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The method has 261 lines of code.
Long Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The method has 212 lines of code.
Long Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The method has 184 lines of code.
Long Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page,The method has 167 lines of code.
Complex Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf,Cyclomatic complexity of the method is 11
Complex Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,Cyclomatic complexity of the method is 20
Complex Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,Cyclomatic complexity of the method is 42
Complex Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_size,Cyclomatic complexity of the method is 10
Complex Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,Cyclomatic complexity of the method is 19
Complex Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,Cyclomatic complexity of the method is 17
Complex Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,Cyclomatic complexity of the method is 19
Complex Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page,Cyclomatic complexity of the method is 17
Complex Method,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_cs,Cyclomatic complexity of the method is 10
Long Parameter List,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The method has 7 parameters. Parameters: strip' striplength' buffer' bufferoffset' stripCount' no' height
Long Parameter List,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,tile_collapse_left,The method has 5 parameters. Parameters: buffer' scanwidth' tilewidth' edgetilewidth' tilelength
Long Identifier,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,,The length of the parameter m_pdf_defaultcompressionquality is 31.
Long Statement,BitMiracle.Tiff2Pdf,Program,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The length of the statement  "                        t2p.m_pdf_defaultpagewidth = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F); " is 155.
Long Statement,BitMiracle.Tiff2Pdf,Program,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The length of the statement  "                        t2p.m_pdf_defaultpagelength = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F); " is 156.
Long Statement,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The length of the statement  "                if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null) " is 123.
Long Statement,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The length of the statement  "            if ((m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW) && (!edge || (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_JPEG))) " is 129.
Long Statement,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The length of the statement  "                    m_tiff_datasize = sample_rgba_to_rgb(buffer' m_tiff_pages[m_pdf_page].tiles_tilewidth * m_tiff_pages[m_pdf_page].tiles_tilelength); " is 131.
Long Statement,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The length of the statement  "                    m_tiff_datasize = sample_rgbaa_to_rgb(buffer' m_tiff_pages[m_pdf_page].tiles_tilewidth * m_tiff_pages[m_pdf_page].tiles_tilelength); " is 132.
Long Statement,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The length of the statement  "                    m_tiff_datasize = sample_lab_signed_to_unsigned(buffer' m_tiff_pages[m_pdf_page].tiles_tilewidth * m_tiff_pages[m_pdf_page].tiles_tilelength); " is 142.
Long Statement,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The length of the statement  "                tile_collapse_left(buffer' input.TileRowSize()' m_tiff_pages[m_pdf_page].tiles_tilewidth' m_tiff_pages[m_pdf_page].tiles_edgetilewidth' m_tiff_pages[m_pdf_page].tiles_tilelength); " is 179.
Long Statement,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_stream_dict,The length of the statement  "            if (m_pdf_switchdecode && !(m_pdf_colorspace == t2p_cs_t.T2P_CS_BILEVEL && m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)) " is 128.
Complex Conditional,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The conditional expression  "m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15"  is complex.
Complex Conditional,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The conditional expression  "(xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough"  is complex.
Complex Conditional,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page,The conditional expression  "(m_tiff_resunit != ResUnit.CENTIMETER && m_tiff_resunit != ResUnit.INCH) &&                  (m_tiff_xres < Tiff2PdfConstants.PS_UNIT_SIZE && m_tiff_yres < Tiff2PdfConstants.PS_UNIT_SIZE)"  is complex.
Magic Number,BitMiracle.Tiff2Pdf,Program,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The following statement contains a magic number: for (; argn < args.Length; argn++)              {                  string arg = args[argn];                  if (arg[0] != '-')                      break;                    string optarg = null;                  if (argn < (args.Length - 1))                      optarg = args[argn + 1];                    arg = arg.Substring(1);                  byte[] bytes = null;                    switch (arg[0])                  {                      case 'o':                          outfilename = optarg;                          argn++;                          break;                        case 'j':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_JPEG;                          break;                        case 'z':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_ZIP;                          break;                                            case 'q':                           t2p.m_pdf_defaultcompressionquality = short.Parse(optarg' CultureInfo.InvariantCulture);                          argn++;                          break;                                            case 'n':                           t2p.m_pdf_nopassthrough = true;                          break;                                            case 'd':                           t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_NONE;                          break;                                            case 'u':                           if (optarg[0] == 'm')                              t2p.m_pdf_centimeters = true;                            argn++;                          break;                        case 'x':                           t2p.m_pdf_defaultxres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'y':                          t2p.m_pdf_defaultyres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'w':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagewidth = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'l':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagelength = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'r':                           if (optarg[0] == 'o')                              t2p.m_pdf_overrideres = true;                            argn++;                          break;                        case 'p':                           if (tiff2pdf_match_paper_size(out t2p.m_pdf_defaultpagewidth' out t2p.m_pdf_defaultpagelength' optarg))                              t2p.m_pdf_overridepagesize = true;                          else                              Tiff.Warning(Tiff2PdfConstants.TIFF2PDF_MODULE' "Unknown paper size {0}' ignoring option"' optarg);                            argn++;                          break;                        case 'i':                          t2p.m_pdf_colorspace_invert = true;                          break;                        case 'f':                           t2p.m_pdf_fitwindow = true;                          break;                        case 'e':                          t2p.m_pdf_datetime = new byte [17];                          if (optarg.Length == 0)                          {                              t2p.m_pdf_datetime[0] = 0;                          }                          else                          {                              t2p.m_pdf_datetime[0] = (byte)'D';                              t2p.m_pdf_datetime[1] = (byte)':';                                bytes = T2P.Latin1Encoding.GetBytes(optarg);                              Buffer.BlockCopy(bytes' 0' t2p.m_pdf_datetime' 2' Math.Min(bytes.Length' 14));                          }                            argn++;                          break;                        case 'c':                          t2p.m_pdf_creator = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 'a':                          t2p.m_pdf_author = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 't':                          t2p.m_pdf_title = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 's':                          t2p.m_pdf_subject = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'k':                          t2p.m_pdf_keywords = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'b':                          t2p.m_pdf_image_interpolate = true;                          break;                        case 'h':                       case '?':                           tiff2pdf_usage();                          return;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,Program,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The following statement contains a magic number: for (; argn < args.Length; argn++)              {                  string arg = args[argn];                  if (arg[0] != '-')                      break;                    string optarg = null;                  if (argn < (args.Length - 1))                      optarg = args[argn + 1];                    arg = arg.Substring(1);                  byte[] bytes = null;                    switch (arg[0])                  {                      case 'o':                          outfilename = optarg;                          argn++;                          break;                        case 'j':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_JPEG;                          break;                        case 'z':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_ZIP;                          break;                                            case 'q':                           t2p.m_pdf_defaultcompressionquality = short.Parse(optarg' CultureInfo.InvariantCulture);                          argn++;                          break;                                            case 'n':                           t2p.m_pdf_nopassthrough = true;                          break;                                            case 'd':                           t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_NONE;                          break;                                            case 'u':                           if (optarg[0] == 'm')                              t2p.m_pdf_centimeters = true;                            argn++;                          break;                        case 'x':                           t2p.m_pdf_defaultxres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'y':                          t2p.m_pdf_defaultyres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'w':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagewidth = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'l':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagelength = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'r':                           if (optarg[0] == 'o')                              t2p.m_pdf_overrideres = true;                            argn++;                          break;                        case 'p':                           if (tiff2pdf_match_paper_size(out t2p.m_pdf_defaultpagewidth' out t2p.m_pdf_defaultpagelength' optarg))                              t2p.m_pdf_overridepagesize = true;                          else                              Tiff.Warning(Tiff2PdfConstants.TIFF2PDF_MODULE' "Unknown paper size {0}' ignoring option"' optarg);                            argn++;                          break;                        case 'i':                          t2p.m_pdf_colorspace_invert = true;                          break;                        case 'f':                           t2p.m_pdf_fitwindow = true;                          break;                        case 'e':                          t2p.m_pdf_datetime = new byte [17];                          if (optarg.Length == 0)                          {                              t2p.m_pdf_datetime[0] = 0;                          }                          else                          {                              t2p.m_pdf_datetime[0] = (byte)'D';                              t2p.m_pdf_datetime[1] = (byte)':';                                bytes = T2P.Latin1Encoding.GetBytes(optarg);                              Buffer.BlockCopy(bytes' 0' t2p.m_pdf_datetime' 2' Math.Min(bytes.Length' 14));                          }                            argn++;                          break;                        case 'c':                          t2p.m_pdf_creator = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 'a':                          t2p.m_pdf_author = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 't':                          t2p.m_pdf_title = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 's':                          t2p.m_pdf_subject = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'k':                          t2p.m_pdf_keywords = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'b':                          t2p.m_pdf_image_interpolate = true;                          break;                        case 'h':                       case '?':                           tiff2pdf_usage();                          return;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,Program,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The following statement contains a magic number: for (; argn < args.Length; argn++)              {                  string arg = args[argn];                  if (arg[0] != '-')                      break;                    string optarg = null;                  if (argn < (args.Length - 1))                      optarg = args[argn + 1];                    arg = arg.Substring(1);                  byte[] bytes = null;                    switch (arg[0])                  {                      case 'o':                          outfilename = optarg;                          argn++;                          break;                        case 'j':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_JPEG;                          break;                        case 'z':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_ZIP;                          break;                                            case 'q':                           t2p.m_pdf_defaultcompressionquality = short.Parse(optarg' CultureInfo.InvariantCulture);                          argn++;                          break;                                            case 'n':                           t2p.m_pdf_nopassthrough = true;                          break;                                            case 'd':                           t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_NONE;                          break;                                            case 'u':                           if (optarg[0] == 'm')                              t2p.m_pdf_centimeters = true;                            argn++;                          break;                        case 'x':                           t2p.m_pdf_defaultxres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'y':                          t2p.m_pdf_defaultyres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'w':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagewidth = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'l':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagelength = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'r':                           if (optarg[0] == 'o')                              t2p.m_pdf_overrideres = true;                            argn++;                          break;                        case 'p':                           if (tiff2pdf_match_paper_size(out t2p.m_pdf_defaultpagewidth' out t2p.m_pdf_defaultpagelength' optarg))                              t2p.m_pdf_overridepagesize = true;                          else                              Tiff.Warning(Tiff2PdfConstants.TIFF2PDF_MODULE' "Unknown paper size {0}' ignoring option"' optarg);                            argn++;                          break;                        case 'i':                          t2p.m_pdf_colorspace_invert = true;                          break;                        case 'f':                           t2p.m_pdf_fitwindow = true;                          break;                        case 'e':                          t2p.m_pdf_datetime = new byte [17];                          if (optarg.Length == 0)                          {                              t2p.m_pdf_datetime[0] = 0;                          }                          else                          {                              t2p.m_pdf_datetime[0] = (byte)'D';                              t2p.m_pdf_datetime[1] = (byte)':';                                bytes = T2P.Latin1Encoding.GetBytes(optarg);                              Buffer.BlockCopy(bytes' 0' t2p.m_pdf_datetime' 2' Math.Min(bytes.Length' 14));                          }                            argn++;                          break;                        case 'c':                          t2p.m_pdf_creator = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 'a':                          t2p.m_pdf_author = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 't':                          t2p.m_pdf_title = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 's':                          t2p.m_pdf_subject = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'k':                          t2p.m_pdf_keywords = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'b':                          t2p.m_pdf_image_interpolate = true;                          break;                        case 'h':                       case '?':                           tiff2pdf_usage();                          return;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,T2P,The following statement contains a magic number: m_pdf_xrefcount = 3;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)              {                  if (m_pdf_defaultcompressionquality > 100 || m_pdf_defaultcompressionquality < 1)                      m_pdf_defaultcompressionquality = 0;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_ZIP)              {                  int m = m_pdf_defaultcompressionquality % 100;                  if (m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15)                      m_pdf_defaultcompressionquality = 0;                    if (m_pdf_defaultcompressionquality % 100 != 0)                  {                      m_pdf_defaultcompressionquality /= 100;                      m_pdf_defaultcompressionquality *= 100;                      Tiff.Error(Tiff2PdfConstants.TIFF2PDF_MODULE'                           "PNG Group predictor differencing not implemented' assuming compression quality {0}"'                          m_pdf_defaultcompressionquality);                  }                                    m_pdf_defaultcompressionquality %= 100;                  if (m_pdf_minorversion < 2)                      m_pdf_minorversion = 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_ZIP)              {                  int m = m_pdf_defaultcompressionquality % 100;                  if (m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15)                      m_pdf_defaultcompressionquality = 0;                    if (m_pdf_defaultcompressionquality % 100 != 0)                  {                      m_pdf_defaultcompressionquality /= 100;                      m_pdf_defaultcompressionquality *= 100;                      Tiff.Error(Tiff2PdfConstants.TIFF2PDF_MODULE'                           "PNG Group predictor differencing not implemented' assuming compression quality {0}"'                          m_pdf_defaultcompressionquality);                  }                                    m_pdf_defaultcompressionquality %= 100;                  if (m_pdf_minorversion < 2)                      m_pdf_minorversion = 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_ZIP)              {                  int m = m_pdf_defaultcompressionquality % 100;                  if (m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15)                      m_pdf_defaultcompressionquality = 0;                    if (m_pdf_defaultcompressionquality % 100 != 0)                  {                      m_pdf_defaultcompressionquality /= 100;                      m_pdf_defaultcompressionquality *= 100;                      Tiff.Error(Tiff2PdfConstants.TIFF2PDF_MODULE'                           "PNG Group predictor differencing not implemented' assuming compression quality {0}"'                          m_pdf_defaultcompressionquality);                  }                                    m_pdf_defaultcompressionquality %= 100;                  if (m_pdf_minorversion < 2)                      m_pdf_minorversion = 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_ZIP)              {                  int m = m_pdf_defaultcompressionquality % 100;                  if (m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15)                      m_pdf_defaultcompressionquality = 0;                    if (m_pdf_defaultcompressionquality % 100 != 0)                  {                      m_pdf_defaultcompressionquality /= 100;                      m_pdf_defaultcompressionquality *= 100;                      Tiff.Error(Tiff2PdfConstants.TIFF2PDF_MODULE'                           "PNG Group predictor differencing not implemented' assuming compression quality {0}"'                          m_pdf_defaultcompressionquality);                  }                                    m_pdf_defaultcompressionquality %= 100;                  if (m_pdf_minorversion < 2)                      m_pdf_minorversion = 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_ZIP)              {                  int m = m_pdf_defaultcompressionquality % 100;                  if (m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15)                      m_pdf_defaultcompressionquality = 0;                    if (m_pdf_defaultcompressionquality % 100 != 0)                  {                      m_pdf_defaultcompressionquality /= 100;                      m_pdf_defaultcompressionquality *= 100;                      Tiff.Error(Tiff2PdfConstants.TIFF2PDF_MODULE'                           "PNG Group predictor differencing not implemented' assuming compression quality {0}"'                          m_pdf_defaultcompressionquality);                  }                                    m_pdf_defaultcompressionquality %= 100;                  if (m_pdf_minorversion < 2)                      m_pdf_minorversion = 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_ZIP)              {                  int m = m_pdf_defaultcompressionquality % 100;                  if (m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15)                      m_pdf_defaultcompressionquality = 0;                    if (m_pdf_defaultcompressionquality % 100 != 0)                  {                      m_pdf_defaultcompressionquality /= 100;                      m_pdf_defaultcompressionquality *= 100;                      Tiff.Error(Tiff2PdfConstants.TIFF2PDF_MODULE'                           "PNG Group predictor differencing not implemented' assuming compression quality {0}"'                          m_pdf_defaultcompressionquality);                  }                                    m_pdf_defaultcompressionquality %= 100;                  if (m_pdf_minorversion < 2)                      m_pdf_minorversion = 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_ZIP)              {                  int m = m_pdf_defaultcompressionquality % 100;                  if (m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15)                      m_pdf_defaultcompressionquality = 0;                    if (m_pdf_defaultcompressionquality % 100 != 0)                  {                      m_pdf_defaultcompressionquality /= 100;                      m_pdf_defaultcompressionquality *= 100;                      Tiff.Error(Tiff2PdfConstants.TIFF2PDF_MODULE'                           "PNG Group predictor differencing not implemented' assuming compression quality {0}"'                          m_pdf_defaultcompressionquality);                  }                                    m_pdf_defaultcompressionquality %= 100;                  if (m_pdf_minorversion < 2)                      m_pdf_minorversion = 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_ZIP)              {                  int m = m_pdf_defaultcompressionquality % 100;                  if (m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15)                      m_pdf_defaultcompressionquality = 0;                    if (m_pdf_defaultcompressionquality % 100 != 0)                  {                      m_pdf_defaultcompressionquality /= 100;                      m_pdf_defaultcompressionquality *= 100;                      Tiff.Error(Tiff2PdfConstants.TIFF2PDF_MODULE'                           "PNG Group predictor differencing not implemented' assuming compression quality {0}"'                          m_pdf_defaultcompressionquality);                  }                                    m_pdf_defaultcompressionquality %= 100;                  if (m_pdf_minorversion < 2)                      m_pdf_minorversion = 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_ZIP)              {                  int m = m_pdf_defaultcompressionquality % 100;                  if (m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15)                      m_pdf_defaultcompressionquality = 0;                    if (m_pdf_defaultcompressionquality % 100 != 0)                  {                      m_pdf_defaultcompressionquality /= 100;                      m_pdf_defaultcompressionquality *= 100;                      Tiff.Error(Tiff2PdfConstants.TIFF2PDF_MODULE'                           "PNG Group predictor differencing not implemented' assuming compression quality {0}"'                          m_pdf_defaultcompressionquality);                  }                                    m_pdf_defaultcompressionquality %= 100;                  if (m_pdf_minorversion < 2)                      m_pdf_minorversion = 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_ZIP)              {                  int m = m_pdf_defaultcompressionquality % 100;                  if (m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15)                      m_pdf_defaultcompressionquality = 0;                    if (m_pdf_defaultcompressionquality % 100 != 0)                  {                      m_pdf_defaultcompressionquality /= 100;                      m_pdf_defaultcompressionquality *= 100;                      Tiff.Error(Tiff2PdfConstants.TIFF2PDF_MODULE'                           "PNG Group predictor differencing not implemented' assuming compression quality {0}"'                          m_pdf_defaultcompressionquality);                  }                                    m_pdf_defaultcompressionquality %= 100;                  if (m_pdf_minorversion < 2)                      m_pdf_minorversion = 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,validate,The following statement contains a magic number: if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_ZIP)              {                  int m = m_pdf_defaultcompressionquality % 100;                  if (m_pdf_defaultcompressionquality / 100 > 9 || (m > 1 && m < 10) || m > 15)                      m_pdf_defaultcompressionquality = 0;                    if (m_pdf_defaultcompressionquality % 100 != 0)                  {                      m_pdf_defaultcompressionquality /= 100;                      m_pdf_defaultcompressionquality *= 100;                      Tiff.Error(Tiff2PdfConstants.TIFF2PDF_MODULE'                           "PNG Group predictor differencing not implemented' assuming compression quality {0}"'                          m_pdf_defaultcompressionquality);                  }                                    m_pdf_defaultcompressionquality %= 100;                  if (m_pdf_minorversion < 2)                      m_pdf_minorversion = 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf,The following statement contains a magic number: m_pdf_info = 2;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf,The following statement contains a magic number: m_pdf_pages = 3;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_init,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  m_pdf_xrefcount += 5;                  input.SetDirectory(m_tiff_pages[i].page_directory);                    result = input.GetField(TiffTag.PHOTOMETRIC);                  if ((result != null && ((Photometric)result[0].ToInt() == Photometric.PALETTE)) || input.GetField(TiffTag.INDEXED) != null)                  {                      m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                  }                    result = input.GetField(TiffTag.COMPRESSION);                  if (result != null)                  {                      Compression xuint16 = (Compression)result[0].ToInt();                      if ((xuint16 == Compression.DEFLATE || xuint16 == Compression.ADOBE_DEFLATE)                           && ((m_tiff_pages[i].page_tilecount != 0) || input.NumberOfStrips() == 1)                           && !m_pdf_nopassthrough)                      {                          if (m_pdf_minorversion < 2)                              m_pdf_minorversion = 2;                      }                  }                    result = input.GetField(TiffTag.TRANSFERFUNCTION);                  if (result != null)                  {                      m_tiff_transferfunction[0] = result[0].GetBytes();                      m_tiff_transferfunction[1] = result[1].GetBytes();                      m_tiff_transferfunction[2] = result[2].GetBytes();                        if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      {                          m_tiff_transferfunctioncount = 3;                          m_tiff_pages[i].page_extra += 4;                          m_pdf_xrefcount += 4;                      }                      else                      {                          m_tiff_transferfunctioncount = 1;                          m_tiff_pages[i].page_extra += 2;                          m_pdf_xrefcount += 2;                      }                        if (m_pdf_minorversion < 2)                          m_pdf_minorversion = 2;                  }                  else                  {                      m_tiff_transferfunctioncount = 0;                  }                    result = input.GetField(TiffTag.ICCPROFILE);                  if (result != null)                  {                      m_tiff_iccprofilelength = result[0].ToInt();                      m_tiff_iccprofile = result[1].ToByteArray();                        m_tiff_pages[i].page_extra++;                      m_pdf_xrefcount++;                      if (m_pdf_minorversion < 3)                          m_pdf_minorversion = 3;                  }                    //m_tiff_tiles[i].tiles_tilecount = m_tiff_pages[i].page_tilecount;                    result = input.GetField(TiffTag.PLANARCONFIG);                  if (result != null && ((PlanarConfig)result[0].ToShort() == PlanarConfig.SEPARATE))                  {                      result = input.GetField(TiffTag.SAMPLESPERPIXEL);                      int xuint16 = result[0].ToInt();                      m_tiff_pages[i].page_tilecount /= xuint16;                  }                    if (m_tiff_pages[i].page_tilecount > 0)                  {                      m_pdf_xrefcount += (m_tiff_pages[i].page_tilecount - 1) * 2;                      result = input.GetField(TiffTag.TILEWIDTH);                      m_tiff_pages[i].tiles_tilewidth = result[0].ToInt();                        input.GetField(TiffTag.TILELENGTH);                      m_tiff_pages[i].tiles_tilelength = result[0].ToInt();                        m_tiff_pages[i].tiles_tiles = new T2P_TILE[m_tiff_pages[i].page_tilecount];                      for (int idx = 0; idx < m_tiff_pages[i].page_tilecount; idx++)                          m_tiff_pages[i].tiles_tiles[idx] = new T2P_TILE();                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_bitspersample)              {                  case 1:                  case 2:                  case 4:                  case 8:                      break;                  case 0:                      Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                           "Image {0} has 0 bits per sample' assuming 1"' input.FileName());                      m_tiff_bitspersample = 1;                      break;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                           "No support for {0} with {1} bits per sample"'                          input.FileName()' m_tiff_bitspersample);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_bitspersample)              {                  case 1:                  case 2:                  case 4:                  case 8:                      break;                  case 0:                      Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                           "Image {0} has 0 bits per sample' assuming 1"' input.FileName());                      m_tiff_bitspersample = 1;                      break;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                           "No support for {0} with {1} bits per sample"'                          input.FileName()' m_tiff_bitspersample);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_bitspersample)              {                  case 1:                  case 2:                  case 4:                  case 8:                      break;                  case 0:                      Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                           "Image {0} has 0 bits per sample' assuming 1"' input.FileName());                      m_tiff_bitspersample = 1;                      break;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                           "No support for {0} with {1} bits per sample"'                          input.FileName()' m_tiff_bitspersample);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if (m_tiff_samplesperpixel > 4)              {                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                       "No support for {0} with {1} samples per pixel"' input.FileName()' m_tiff_samplesperpixel);                  m_error = true;                  return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: switch (m_tiff_photometric)              {                  case Photometric.MINISWHITE:                  case Photometric.MINISBLACK:                      if (m_tiff_bitspersample == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_BILEVEL;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      else                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          if (m_tiff_photometric == Photometric.MINISWHITE)                              m_pdf_switchdecode ^= true;                      }                      break;                                   case Photometric.RGB:                  case Photometric.PALETTE:                      photometric_palette = (m_tiff_photometric == Photometric.PALETTE);                      if (!photometric_palette)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                          if (m_tiff_samplesperpixel == 3)                              break;                            result = input.GetField(TiffTag.INDEXED);                          if (result != null)                          {                              if (result[0].ToInt() == 1)                                  photometric_palette = true;                          }                      }                        if (!photometric_palette)                      {                          if (m_tiff_samplesperpixel > 3)                          {                              if (m_tiff_samplesperpixel == 4)                              {                                  m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                                    result = input.GetField(TiffTag.EXTRASAMPLES);                                  if (result != null && result[0].ToInt() == 1)                                  {                                      byte[] xuint16p = result[1].ToByteArray();                                      if ((ExtraSample)xuint16p[0] == ExtraSample.ASSOCALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB;                                          break;                                      }                                        if ((ExtraSample)xuint16p[0] == ExtraSample.UNASSALPHA)                                      {                                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB;                                          break;                                      }                                                                            Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                          "RGB image {0} has 4 samples per pixel' assuming RGBA"' input.FileName());                                      break;                                  }                                    m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                                  m_pdf_switchdecode ^= true;                                  Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                       "RGB image {0} has 4 samples per pixel' assuming inverse CMYK"' input.FileName());                                  break;                              }                              else                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for RGB image {0} with {1} samples per pixel"'                                       input.FileName()' m_tiff_samplesperpixel);                                  m_error = true;                                  break;                              }                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for RGB image {0} with {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              break;                          }                      }                        if (photometric_palette)                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                            m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                            result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                   "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                          }                            m_pdf_palette = new byte [m_pdf_palettesize * 3];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 3] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 3 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 3 + 2] = (byte)(b[i] >> 8);                          }                            m_pdf_palettesize *= 3;                      }                      break;                    case Photometric.SEPARATED:                      photometric_palette_cmyk = false;                      result = input.GetField(TiffTag.INDEXED);                      if (result != null)                      {                          if (result[0].ToInt() == 1)                              photometric_palette_cmyk = true;                      }                        if (!photometric_palette_cmyk)                      {                          result = input.GetField(TiffTag.INKSET);                          if (result != null)                          {                              if ((InkSet)result[0].ToByte() != InkSet.CMYK)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "No support for {0} because its inkset is not CMYK"' input.FileName());                                  m_error = true;                                  return;                              }                          }                                                    if (m_tiff_samplesperpixel == 4)                          {                              m_pdf_colorspace = t2p_cs_t.T2P_CS_CMYK;                          }                          else                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} because it has {1} samples per pixel"'                                  input.FileName()' m_tiff_samplesperpixel);                              m_error = true;                              return;                          }                      }                      else                      {                          if (m_tiff_samplesperpixel != 1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for palletized CMYK image {0} with not one sample per pixel"'                                  input.FileName());                              m_error = true;                              return;                          }                                                    m_pdf_colorspace = (t2p_cs_t)(t2p_cs_t.T2P_CS_CMYK | t2p_cs_t.T2P_CS_PALETTE);                          m_pdf_palettesize = 0x0001 << m_tiff_bitspersample;                                                    result = input.GetField(TiffTag.COLORMAP);                          if (result == null)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Palletized image {0} has no color map"' input.FileName());                              m_error = true;                              return;                          }                          else                          {                              r = result[0].ToShortArray();                              g = result[1].ToShortArray();                              b = result[2].ToShortArray();                              a = result[3].ToShortArray();                          }                                                    m_pdf_palette = new byte [m_pdf_palettesize * 4];                          for (int i = 0; i < m_pdf_palettesize; i++)                          {                              m_pdf_palette[i * 4] = (byte)(r[i] >> 8);                              m_pdf_palette[i * 4 + 1] = (byte)(g[i] >> 8);                              m_pdf_palette[i * 4 + 2] = (byte)(b[i] >> 8);                              m_pdf_palette[i * 4 + 3] = (byte)(a[i] >> 8);                          }                            m_pdf_palettesize *= 4;                      }                      break;                                    case Photometric.YCBCR:                      m_pdf_colorspace = t2p_cs_t.T2P_CS_RGB;                      if (m_tiff_samplesperpixel == 1)                      {                          m_pdf_colorspace = t2p_cs_t.T2P_CS_GRAY;                          m_tiff_photometric = Photometric.MINISBLACK;                          break;                      }                        m_pdf_sample = t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB;                      if (m_pdf_defaultcompression == t2p_compress_t.T2P_COMPRESS_JPEG)                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_NOTHING;                        break;                    case Photometric.CIELAB:                      m_pdf_labrange[0] = -127;                      m_pdf_labrange[1] = 127;                      m_pdf_labrange[2] = -127;                      m_pdf_labrange[3] = 127;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ICCLAB:                      m_pdf_labrange[0] = 0;                      m_pdf_labrange[1] = 255;                      m_pdf_labrange[2] = 0;                      m_pdf_labrange[3] = 255;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.ITULAB:                      m_pdf_labrange[0] = -85;                      m_pdf_labrange[1] = 85;                      m_pdf_labrange[2] = -75;                      m_pdf_labrange[3] = 124;                      m_pdf_sample = t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;                      m_pdf_colorspace = t2p_cs_t.T2P_CS_LAB;                      break;                    case Photometric.LOGL:                  case Photometric.LOGLUV:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation LogL/LogLuv"' input.FileName());                      m_error = true;                      return;                  default:                      Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                          "No support for {0} with photometric interpretation {1}"'                          input.FileName()' m_tiff_photometric);                      m_error = true;                      return;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if (result != null)              {                  m_tiff_planar = (PlanarConfig)result[0].ToShort();                  switch (m_tiff_planar)                  {                      case 0:                          Tiff.Warning(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Image {0} has planar configuration 0' assuming 1"' input.FileName());                          m_tiff_planar = PlanarConfig.CONTIG;                          break;                        case PlanarConfig.CONTIG:                          break;                                            case PlanarConfig.SEPARATE:                          m_pdf_sample = t2p_sample_t.T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG;                          if (m_tiff_bitspersample != 8)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "No support for {0} with separated planar configuration and {1} bits per sample"'                                  input.FileName()' m_tiff_bitspersample);                              m_error = true;                              return;                          }                          break;                                            default:                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "No support for {0} with planar configuration {1}"'                              input.FileName()' m_tiff_planar);                          m_error = true;                          return;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if ((m_pdf_sample & t2p_sample_t.T2P_SAMPLE_REALIZE_PALETTE) != 0)              {                  if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_CMYK) != 0)                  {                      m_tiff_samplesperpixel = 4;                      m_tiff_photometric = Photometric.SEPARATED;                  }                  else                  {                      m_tiff_samplesperpixel = 3;                      m_tiff_photometric = Photometric.RGB;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if ((m_pdf_sample & t2p_sample_t.T2P_SAMPLE_REALIZE_PALETTE) != 0)              {                  if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_CMYK) != 0)                  {                      m_tiff_samplesperpixel = 4;                      m_tiff_photometric = Photometric.SEPARATED;                  }                  else                  {                      m_tiff_samplesperpixel = 3;                      m_tiff_photometric = Photometric.RGB;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if (result != null)              {                  m_tiff_transferfunction[0] = result[0].GetBytes();                  m_tiff_transferfunction[1] = result[1].GetBytes();                  m_tiff_transferfunction[2] = result[2].GetBytes();                    if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      m_tiff_transferfunctioncount = 3;                  else                      m_tiff_transferfunctioncount = 1;              }              else              {                  m_tiff_transferfunctioncount = 0;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if (result != null)              {                  m_tiff_transferfunction[0] = result[0].GetBytes();                  m_tiff_transferfunction[1] = result[1].GetBytes();                  m_tiff_transferfunction[2] = result[2].GetBytes();                    if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      m_tiff_transferfunctioncount = 3;                  else                      m_tiff_transferfunctioncount = 1;              }              else              {                  m_tiff_transferfunctioncount = 0;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if (result != null)              {                  m_tiff_transferfunction[0] = result[0].GetBytes();                  m_tiff_transferfunction[1] = result[1].GetBytes();                  m_tiff_transferfunction[2] = result[2].GetBytes();                    if (m_tiff_transferfunction[1] != m_tiff_transferfunction[0])                      m_tiff_transferfunctioncount = 3;                  else                      m_tiff_transferfunctioncount = 1;              }              else              {                  m_tiff_transferfunctioncount = 0;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if (result != null)              {                  float[] xfloatp = result[0].ToFloatArray();                  m_tiff_primarychromaticities[0] = xfloatp[0];                  m_tiff_primarychromaticities[1] = xfloatp[1];                  m_tiff_primarychromaticities[2] = xfloatp[2];                  m_tiff_primarychromaticities[3] = xfloatp[3];                  m_tiff_primarychromaticities[4] = xfloatp[4];                  m_tiff_primarychromaticities[5] = xfloatp[5];                    if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_RGB) != 0)                      m_pdf_colorspace = (t2p_cs_t)(m_pdf_colorspace | t2p_cs_t.T2P_CS_CALRGB);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if (result != null)              {                  float[] xfloatp = result[0].ToFloatArray();                  m_tiff_primarychromaticities[0] = xfloatp[0];                  m_tiff_primarychromaticities[1] = xfloatp[1];                  m_tiff_primarychromaticities[2] = xfloatp[2];                  m_tiff_primarychromaticities[3] = xfloatp[3];                  m_tiff_primarychromaticities[4] = xfloatp[4];                  m_tiff_primarychromaticities[5] = xfloatp[5];                    if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_RGB) != 0)                      m_pdf_colorspace = (t2p_cs_t)(m_pdf_colorspace | t2p_cs_t.T2P_CS_CALRGB);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if (result != null)              {                  float[] xfloatp = result[0].ToFloatArray();                  m_tiff_primarychromaticities[0] = xfloatp[0];                  m_tiff_primarychromaticities[1] = xfloatp[1];                  m_tiff_primarychromaticities[2] = xfloatp[2];                  m_tiff_primarychromaticities[3] = xfloatp[3];                  m_tiff_primarychromaticities[4] = xfloatp[4];                  m_tiff_primarychromaticities[5] = xfloatp[5];                    if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_RGB) != 0)                      m_pdf_colorspace = (t2p_cs_t)(m_pdf_colorspace | t2p_cs_t.T2P_CS_CALRGB);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if (result != null)              {                  float[] xfloatp = result[0].ToFloatArray();                  m_tiff_primarychromaticities[0] = xfloatp[0];                  m_tiff_primarychromaticities[1] = xfloatp[1];                  m_tiff_primarychromaticities[2] = xfloatp[2];                  m_tiff_primarychromaticities[3] = xfloatp[3];                  m_tiff_primarychromaticities[4] = xfloatp[4];                  m_tiff_primarychromaticities[5] = xfloatp[5];                    if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_RGB) != 0)                      m_pdf_colorspace = (t2p_cs_t)(m_pdf_colorspace | t2p_cs_t.T2P_CS_CALRGB);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if (result != null)              {                  float[] xfloatp = result[0].ToFloatArray();                  m_tiff_primarychromaticities[0] = xfloatp[0];                  m_tiff_primarychromaticities[1] = xfloatp[1];                  m_tiff_primarychromaticities[2] = xfloatp[2];                  m_tiff_primarychromaticities[3] = xfloatp[3];                  m_tiff_primarychromaticities[4] = xfloatp[4];                  m_tiff_primarychromaticities[5] = xfloatp[5];                    if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_RGB) != 0)                      m_pdf_colorspace = (t2p_cs_t)(m_pdf_colorspace | t2p_cs_t.T2P_CS_CALRGB);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if (result != null)              {                  float[] xfloatp = result[0].ToFloatArray();                  m_tiff_primarychromaticities[0] = xfloatp[0];                  m_tiff_primarychromaticities[1] = xfloatp[1];                  m_tiff_primarychromaticities[2] = xfloatp[2];                  m_tiff_primarychromaticities[3] = xfloatp[3];                  m_tiff_primarychromaticities[4] = xfloatp[4];                  m_tiff_primarychromaticities[5] = xfloatp[5];                    if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_RGB) != 0)                      m_pdf_colorspace = (t2p_cs_t)(m_pdf_colorspace | t2p_cs_t.T2P_CS_CALRGB);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if (result != null)              {                  float[] xfloatp = result[0].ToFloatArray();                  m_tiff_primarychromaticities[0] = xfloatp[0];                  m_tiff_primarychromaticities[1] = xfloatp[1];                  m_tiff_primarychromaticities[2] = xfloatp[2];                  m_tiff_primarychromaticities[3] = xfloatp[3];                  m_tiff_primarychromaticities[4] = xfloatp[4];                  m_tiff_primarychromaticities[5] = xfloatp[5];                    if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_RGB) != 0)                      m_pdf_colorspace = (t2p_cs_t)(m_pdf_colorspace | t2p_cs_t.T2P_CS_CALRGB);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_data,The following statement contains a magic number: if (result != null)              {                  float[] xfloatp = result[0].ToFloatArray();                  m_tiff_primarychromaticities[0] = xfloatp[0];                  m_tiff_primarychromaticities[1] = xfloatp[1];                  m_tiff_primarychromaticities[2] = xfloatp[2];                  m_tiff_primarychromaticities[3] = xfloatp[3];                  m_tiff_primarychromaticities[4] = xfloatp[4];                  m_tiff_primarychromaticities[5] = xfloatp[5];                    if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_RGB) != 0)                      m_pdf_colorspace = (t2p_cs_t)(m_pdf_colorspace | t2p_cs_t.T2P_CS_CALRGB);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_size,The following statement contains a magic number: if (m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW)              {                  FieldValue[] result = null;                  if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)                  {                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      int[] sbc = result[0].ToIntArray();                      m_tiff_datasize = sbc[0];                      return;                  }                    if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_ZIP)                  {                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      int[] sbc = result[0].ToIntArray();                      m_tiff_datasize = sbc[0];                      return;                  }                                    if (m_tiff_compression == Compression.JPEG)                  {                      result = input.GetField(TiffTag.JPEGTABLES);                      if (result != null)                      {                          int count = result[0].ToInt();                          if (count > 4)                          {                              m_tiff_datasize += count;                              m_tiff_datasize -= 2; /* don't use EOI of header */                          }                      }                      else                      {                          m_tiff_datasize = 2; /* SOI for first strip */                      }                        int stripcount = input.NumberOfStrips();                      int[] sbc = null;                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      if (result == null)                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Input file {0} missing field: STRIPBYTECOUNTS"'                              input.FileName());                          m_error = true;                          return;                      }                      else                          sbc = result[0].ToIntArray();                        for (int i = 0; i < stripcount; i++)                      {                          m_tiff_datasize += sbc[i];                          m_tiff_datasize -= 4; /* don't use SOI or EOI of strip */                      }                                            m_tiff_datasize += 2; /* use EOI of last strip */                      return;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_size,The following statement contains a magic number: if (m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW)              {                  FieldValue[] result = null;                  if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)                  {                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      int[] sbc = result[0].ToIntArray();                      m_tiff_datasize = sbc[0];                      return;                  }                    if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_ZIP)                  {                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      int[] sbc = result[0].ToIntArray();                      m_tiff_datasize = sbc[0];                      return;                  }                                    if (m_tiff_compression == Compression.JPEG)                  {                      result = input.GetField(TiffTag.JPEGTABLES);                      if (result != null)                      {                          int count = result[0].ToInt();                          if (count > 4)                          {                              m_tiff_datasize += count;                              m_tiff_datasize -= 2; /* don't use EOI of header */                          }                      }                      else                      {                          m_tiff_datasize = 2; /* SOI for first strip */                      }                        int stripcount = input.NumberOfStrips();                      int[] sbc = null;                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      if (result == null)                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Input file {0} missing field: STRIPBYTECOUNTS"'                              input.FileName());                          m_error = true;                          return;                      }                      else                          sbc = result[0].ToIntArray();                        for (int i = 0; i < stripcount; i++)                      {                          m_tiff_datasize += sbc[i];                          m_tiff_datasize -= 4; /* don't use SOI or EOI of strip */                      }                                            m_tiff_datasize += 2; /* use EOI of last strip */                      return;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_size,The following statement contains a magic number: if (m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW)              {                  FieldValue[] result = null;                  if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)                  {                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      int[] sbc = result[0].ToIntArray();                      m_tiff_datasize = sbc[0];                      return;                  }                    if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_ZIP)                  {                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      int[] sbc = result[0].ToIntArray();                      m_tiff_datasize = sbc[0];                      return;                  }                                    if (m_tiff_compression == Compression.JPEG)                  {                      result = input.GetField(TiffTag.JPEGTABLES);                      if (result != null)                      {                          int count = result[0].ToInt();                          if (count > 4)                          {                              m_tiff_datasize += count;                              m_tiff_datasize -= 2; /* don't use EOI of header */                          }                      }                      else                      {                          m_tiff_datasize = 2; /* SOI for first strip */                      }                        int stripcount = input.NumberOfStrips();                      int[] sbc = null;                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      if (result == null)                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Input file {0} missing field: STRIPBYTECOUNTS"'                              input.FileName());                          m_error = true;                          return;                      }                      else                          sbc = result[0].ToIntArray();                        for (int i = 0; i < stripcount; i++)                      {                          m_tiff_datasize += sbc[i];                          m_tiff_datasize -= 4; /* don't use SOI or EOI of strip */                      }                                            m_tiff_datasize += 2; /* use EOI of last strip */                      return;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_size,The following statement contains a magic number: if (m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW)              {                  FieldValue[] result = null;                  if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)                  {                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      int[] sbc = result[0].ToIntArray();                      m_tiff_datasize = sbc[0];                      return;                  }                    if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_ZIP)                  {                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      int[] sbc = result[0].ToIntArray();                      m_tiff_datasize = sbc[0];                      return;                  }                                    if (m_tiff_compression == Compression.JPEG)                  {                      result = input.GetField(TiffTag.JPEGTABLES);                      if (result != null)                      {                          int count = result[0].ToInt();                          if (count > 4)                          {                              m_tiff_datasize += count;                              m_tiff_datasize -= 2; /* don't use EOI of header */                          }                      }                      else                      {                          m_tiff_datasize = 2; /* SOI for first strip */                      }                        int stripcount = input.NumberOfStrips();                      int[] sbc = null;                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      if (result == null)                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Input file {0} missing field: STRIPBYTECOUNTS"'                              input.FileName());                          m_error = true;                          return;                      }                      else                          sbc = result[0].ToIntArray();                        for (int i = 0; i < stripcount; i++)                      {                          m_tiff_datasize += sbc[i];                          m_tiff_datasize -= 4; /* don't use SOI or EOI of strip */                      }                                            m_tiff_datasize += 2; /* use EOI of last strip */                      return;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_size,The following statement contains a magic number: if (m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW)              {                  FieldValue[] result = null;                  if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)                  {                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      int[] sbc = result[0].ToIntArray();                      m_tiff_datasize = sbc[0];                      return;                  }                    if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_ZIP)                  {                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      int[] sbc = result[0].ToIntArray();                      m_tiff_datasize = sbc[0];                      return;                  }                                    if (m_tiff_compression == Compression.JPEG)                  {                      result = input.GetField(TiffTag.JPEGTABLES);                      if (result != null)                      {                          int count = result[0].ToInt();                          if (count > 4)                          {                              m_tiff_datasize += count;                              m_tiff_datasize -= 2; /* don't use EOI of header */                          }                      }                      else                      {                          m_tiff_datasize = 2; /* SOI for first strip */                      }                        int stripcount = input.NumberOfStrips();                      int[] sbc = null;                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      if (result == null)                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Input file {0} missing field: STRIPBYTECOUNTS"'                              input.FileName());                          m_error = true;                          return;                      }                      else                          sbc = result[0].ToIntArray();                        for (int i = 0; i < stripcount; i++)                      {                          m_tiff_datasize += sbc[i];                          m_tiff_datasize -= 4; /* don't use SOI or EOI of strip */                      }                                            m_tiff_datasize += 2; /* use EOI of last strip */                      return;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_size_tile,The following statement contains a magic number: if (m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW)              {                  if (edge && m_pdf_compression != t2p_compress_t.T2P_COMPRESS_JPEG)                  {                      m_tiff_datasize = input.TileSize();                      return;                  }                  else                  {                      FieldValue[] result = input.GetField(TiffTag.TILEBYTECOUNTS);                      int[] tbc = result[0].ToIntArray();                      m_tiff_datasize = tbc[tile];                      if (m_tiff_compression == Compression.JPEG)                      {                          result = input.GetField(TiffTag.JPEGTABLES);                          if (result != null)                          {                              int count = result[0].ToInt();                              if (count > 4)                              {                                  m_tiff_datasize += count;                                  m_tiff_datasize -= 4; /* don't use EOI of header or SOI of tile */                              }                          }                      }                      return;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,read_tiff_size_tile,The following statement contains a magic number: if (m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW)              {                  if (edge && m_pdf_compression != t2p_compress_t.T2P_COMPRESS_JPEG)                  {                      m_tiff_datasize = input.TileSize();                      return;                  }                  else                  {                      FieldValue[] result = input.GetField(TiffTag.TILEBYTECOUNTS);                      int[] tbc = result[0].ToIntArray();                      m_tiff_datasize = tbc[tile];                      if (m_tiff_compression == Compression.JPEG)                      {                          result = input.GetField(TiffTag.JPEGTABLES);                          if (result != null)                          {                              int count = result[0].ToInt();                              if (count > 4)                              {                                  m_tiff_datasize += count;                                  m_tiff_datasize -= 4; /* don't use EOI of header or SOI of tile */                              }                          }                      }                      return;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The following statement contains a magic number: if (m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW)              {                  if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)                  {                      buffer = new byte [m_tiff_datasize];                      input.ReadRawStrip(0' buffer' 0' m_tiff_datasize);                      if (m_tiff_fillorder == FillOrder.LSB2MSB)                      {                          /*                          * make sure is lsb-to-msb                          * bit-endianness fill order                          */                          Tiff.ReverseBits(buffer' m_tiff_datasize);                      }                                            writeToFile(buffer' m_tiff_datasize);                      return m_tiff_datasize;                  }                    if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_ZIP)                  {                      buffer = new byte [m_tiff_datasize];                      input.ReadRawStrip(0' buffer' 0' m_tiff_datasize);                      if (m_tiff_fillorder == FillOrder.LSB2MSB)                          Tiff.ReverseBits(buffer' m_tiff_datasize);                        writeToFile(buffer' m_tiff_datasize);                      return m_tiff_datasize;                  }                                    if (m_tiff_compression == Compression.JPEG)                  {                      buffer = new byte [m_tiff_datasize];                      result = input.GetField(TiffTag.JPEGTABLES);                      if (result != null)                      {                          int count = result[0].ToInt();                          byte[] jpt = result[1].ToByteArray();                          if (count > 4)                          {                              Buffer.BlockCopy(jpt' 0' buffer' 0' count);                              bufferoffset += count - 2;                          }                      }                        stripcount = input.NumberOfStrips();                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      int[] sbc = result[0].ToIntArray();                      for (int i = 0; i < stripcount; i++)                      {                          if (sbc[i] > max_striplength)                              max_striplength = sbc[i];                      }                                            byte[] stripbuffer = new byte [max_striplength];                      for (int i = 0; i < stripcount; i++)                      {                          int striplength = input.ReadRawStrip(i' stripbuffer' 0' -1);                          if (!process_jpeg_strip(stripbuffer' striplength' buffer' ref bufferoffset' stripcount' i' m_tiff_length))                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Can't process JPEG data in input file {0}"' input.FileName());                              m_error = true;                              return 0;                          }                      }                        buffer[bufferoffset++] = 0xff;                      buffer[bufferoffset++] = 0xd9;                      writeToFile(buffer' bufferoffset);                      return bufferoffset;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The following statement contains a magic number: if (m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW)              {                  if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)                  {                      buffer = new byte [m_tiff_datasize];                      input.ReadRawStrip(0' buffer' 0' m_tiff_datasize);                      if (m_tiff_fillorder == FillOrder.LSB2MSB)                      {                          /*                          * make sure is lsb-to-msb                          * bit-endianness fill order                          */                          Tiff.ReverseBits(buffer' m_tiff_datasize);                      }                                            writeToFile(buffer' m_tiff_datasize);                      return m_tiff_datasize;                  }                    if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_ZIP)                  {                      buffer = new byte [m_tiff_datasize];                      input.ReadRawStrip(0' buffer' 0' m_tiff_datasize);                      if (m_tiff_fillorder == FillOrder.LSB2MSB)                          Tiff.ReverseBits(buffer' m_tiff_datasize);                        writeToFile(buffer' m_tiff_datasize);                      return m_tiff_datasize;                  }                                    if (m_tiff_compression == Compression.JPEG)                  {                      buffer = new byte [m_tiff_datasize];                      result = input.GetField(TiffTag.JPEGTABLES);                      if (result != null)                      {                          int count = result[0].ToInt();                          byte[] jpt = result[1].ToByteArray();                          if (count > 4)                          {                              Buffer.BlockCopy(jpt' 0' buffer' 0' count);                              bufferoffset += count - 2;                          }                      }                        stripcount = input.NumberOfStrips();                      result = input.GetField(TiffTag.STRIPBYTECOUNTS);                      int[] sbc = result[0].ToIntArray();                      for (int i = 0; i < stripcount; i++)                      {                          if (sbc[i] > max_striplength)                              max_striplength = sbc[i];                      }                                            byte[] stripbuffer = new byte [max_striplength];                      for (int i = 0; i < stripcount; i++)                      {                          int striplength = input.ReadRawStrip(i' stripbuffer' 0' -1);                          if (!process_jpeg_strip(stripbuffer' striplength' buffer' ref bufferoffset' stripcount' i' m_tiff_length))                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Can't process JPEG data in input file {0}"' input.FileName());                              m_error = true;                              return 0;                          }                      }                        buffer[bufferoffset++] = 0xff;                      buffer[bufferoffset++] = 0xd9;                      writeToFile(buffer' bufferoffset);                      return bufferoffset;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The following statement contains a magic number: if (m_pdf_sample == t2p_sample_t.T2P_SAMPLE_NOTHING)              {                  buffer = new byte [m_tiff_datasize];                  stripsize = input.StripSize();                  stripcount = input.NumberOfStrips();                  for (int i = 0; i < stripcount; i++)                  {                      int read = input.ReadEncodedStrip(i' buffer' bufferoffset' stripsize);                      if (read == -1)                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Error on decoding strip {0} of {1}"' i' input.FileName());                          m_error = true;                          return 0;                      }                        bufferoffset += read;                  }              }              else              {                  byte[] samplebuffer = null;                  bool dataready = false;                    if ((m_pdf_sample & t2p_sample_t.T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG) != 0)                  {                      int sepstripsize = input.StripSize();                      int sepstripcount = input.NumberOfStrips();                        stripsize = sepstripsize * m_tiff_samplesperpixel;                      stripcount = sepstripcount / m_tiff_samplesperpixel;                        buffer = new byte [m_tiff_datasize];                      samplebuffer = new byte [stripsize];                      for (int i = 0; i < stripcount; i++)                      {                          int samplebufferoffset = 0;                          for (int j = 0; j < m_tiff_samplesperpixel; j++)                          {                              int read = input.ReadEncodedStrip(i + j * stripcount' samplebuffer' samplebufferoffset' sepstripsize);                              if (read == -1)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "Error on decoding strip {0} of {1}"'                                       i + j * stripcount' input.FileName());                                  m_error = true;                                  return 0;                              }                              samplebufferoffset += read;                          }                            sample_planar_separate_to_contig(buffer' bufferoffset' samplebuffer' samplebufferoffset);                          bufferoffset += samplebufferoffset;                      }                        dataready = true;                  }                    if (!dataready)                  {                      buffer = new byte [m_tiff_datasize];                      stripsize = input.StripSize();                      stripcount = input.NumberOfStrips();                      for (int i = 0; i < stripcount; i++)                      {                          int read = input.ReadEncodedStrip(i' buffer' bufferoffset' stripsize);                          if (read == -1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Error on decoding strip {0} of {1}"' i' input.FileName());                              m_error = true;                              return 0;                          }                            bufferoffset += read;                      }                        if ((m_pdf_sample & t2p_sample_t.T2P_SAMPLE_REALIZE_PALETTE) != 0)                      {                          samplebuffer = Tiff.Realloc(buffer' m_tiff_datasize * m_tiff_samplesperpixel);                          buffer = samplebuffer;                          m_tiff_datasize *= m_tiff_samplesperpixel;                          sample_realize_palette(buffer);                      }                        if ((m_pdf_sample & t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB) != 0)                          m_tiff_datasize = sample_rgba_to_rgb(buffer' m_tiff_width * m_tiff_length);                        if ((m_pdf_sample & t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB) != 0)                          m_tiff_datasize = sample_rgbaa_to_rgb(buffer' m_tiff_width * m_tiff_length);                        if ((m_pdf_sample & t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB) != 0)                      {                          samplebuffer = Tiff.Realloc(buffer' m_tiff_width * m_tiff_length * 4);                          buffer = samplebuffer;                            int[] buffer32 = Tiff.ByteArrayToInts(buffer' 0' m_tiff_width * m_tiff_length * 4);                          if (!input.ReadRGBAImageOriented(m_tiff_width' m_tiff_length' buffer32' Orientation.TOPLEFT' false))                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Can't use ReadRGBAImageOriented to extract RGB image from {0}"'                                  input.FileName());                              m_error = true;                              return 0;                          }                            Tiff.IntsToByteArray(buffer32' 0' m_tiff_width * m_tiff_length' buffer' 0);                            m_tiff_datasize = sample_abgr_to_rgb(buffer' m_tiff_width * m_tiff_length);                      }                        if ((m_pdf_sample & t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED) != 0)                          m_tiff_datasize = sample_lab_signed_to_unsigned(buffer' m_tiff_width * m_tiff_length);                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The following statement contains a magic number: if (m_pdf_sample == t2p_sample_t.T2P_SAMPLE_NOTHING)              {                  buffer = new byte [m_tiff_datasize];                  stripsize = input.StripSize();                  stripcount = input.NumberOfStrips();                  for (int i = 0; i < stripcount; i++)                  {                      int read = input.ReadEncodedStrip(i' buffer' bufferoffset' stripsize);                      if (read == -1)                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Error on decoding strip {0} of {1}"' i' input.FileName());                          m_error = true;                          return 0;                      }                        bufferoffset += read;                  }              }              else              {                  byte[] samplebuffer = null;                  bool dataready = false;                    if ((m_pdf_sample & t2p_sample_t.T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG) != 0)                  {                      int sepstripsize = input.StripSize();                      int sepstripcount = input.NumberOfStrips();                        stripsize = sepstripsize * m_tiff_samplesperpixel;                      stripcount = sepstripcount / m_tiff_samplesperpixel;                        buffer = new byte [m_tiff_datasize];                      samplebuffer = new byte [stripsize];                      for (int i = 0; i < stripcount; i++)                      {                          int samplebufferoffset = 0;                          for (int j = 0; j < m_tiff_samplesperpixel; j++)                          {                              int read = input.ReadEncodedStrip(i + j * stripcount' samplebuffer' samplebufferoffset' sepstripsize);                              if (read == -1)                              {                                  Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                      "Error on decoding strip {0} of {1}"'                                       i + j * stripcount' input.FileName());                                  m_error = true;                                  return 0;                              }                              samplebufferoffset += read;                          }                            sample_planar_separate_to_contig(buffer' bufferoffset' samplebuffer' samplebufferoffset);                          bufferoffset += samplebufferoffset;                      }                        dataready = true;                  }                    if (!dataready)                  {                      buffer = new byte [m_tiff_datasize];                      stripsize = input.StripSize();                      stripcount = input.NumberOfStrips();                      for (int i = 0; i < stripcount; i++)                      {                          int read = input.ReadEncodedStrip(i' buffer' bufferoffset' stripsize);                          if (read == -1)                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Error on decoding strip {0} of {1}"' i' input.FileName());                              m_error = true;                              return 0;                          }                            bufferoffset += read;                      }                        if ((m_pdf_sample & t2p_sample_t.T2P_SAMPLE_REALIZE_PALETTE) != 0)                      {                          samplebuffer = Tiff.Realloc(buffer' m_tiff_datasize * m_tiff_samplesperpixel);                          buffer = samplebuffer;                          m_tiff_datasize *= m_tiff_samplesperpixel;                          sample_realize_palette(buffer);                      }                        if ((m_pdf_sample & t2p_sample_t.T2P_SAMPLE_RGBA_TO_RGB) != 0)                          m_tiff_datasize = sample_rgba_to_rgb(buffer' m_tiff_width * m_tiff_length);                        if ((m_pdf_sample & t2p_sample_t.T2P_SAMPLE_RGBAA_TO_RGB) != 0)                          m_tiff_datasize = sample_rgbaa_to_rgb(buffer' m_tiff_width * m_tiff_length);                        if ((m_pdf_sample & t2p_sample_t.T2P_SAMPLE_YCBCR_TO_RGB) != 0)                      {                          samplebuffer = Tiff.Realloc(buffer' m_tiff_width * m_tiff_length * 4);                          buffer = samplebuffer;                            int[] buffer32 = Tiff.ByteArrayToInts(buffer' 0' m_tiff_width * m_tiff_length * 4);                          if (!input.ReadRGBAImageOriented(m_tiff_width' m_tiff_length' buffer32' Orientation.TOPLEFT' false))                          {                              Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                                  "Can't use ReadRGBAImageOriented to extract RGB image from {0}"'                                  input.FileName());                              m_error = true;                              return 0;                          }                            Tiff.IntsToByteArray(buffer32' 0' m_tiff_width * m_tiff_length' buffer' 0);                            m_tiff_datasize = sample_abgr_to_rgb(buffer' m_tiff_width * m_tiff_length);                      }                        if ((m_pdf_sample & t2p_sample_t.T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED) != 0)                          m_tiff_datasize = sample_lab_signed_to_unsigned(buffer' m_tiff_width * m_tiff_length);                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                        if (!m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG))                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Unable to use JPEG compression for input {0} and output {1}"'                              input.FileName()' m_output.FileName());                          m_error = true;                          return 0;                      }                        m_output.SetField(TiffTag.JPEGTABLESMODE' 0);                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                            if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                                            if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                        if (!m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG))                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Unable to use JPEG compression for input {0} and output {1}"'                              input.FileName()' m_output.FileName());                          m_error = true;                          return 0;                      }                        m_output.SetField(TiffTag.JPEGTABLESMODE' 0);                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                            if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                                            if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                        if (!m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG))                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Unable to use JPEG compression for input {0} and output {1}"'                              input.FileName()' m_output.FileName());                          m_error = true;                          return 0;                      }                        m_output.SetField(TiffTag.JPEGTABLESMODE' 0);                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                            if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                                            if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                        if (!m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG))                      {                          Tiff.Error(input' Tiff2PdfConstants.TIFF2PDF_MODULE'                              "Unable to use JPEG compression for input {0} and output {1}"'                              input.FileName()' m_output.FileName());                          m_error = true;                          return 0;                      }                        m_output.SetField(TiffTag.JPEGTABLESMODE' 0);                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                            if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                                            if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: if ((m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW) && (!edge || (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_JPEG)))              {                  if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)                  {                      buffer = new byte [m_tiff_datasize];                      input.ReadRawTile(tile' buffer' 0' m_tiff_datasize);                      if (m_tiff_fillorder == FillOrder.LSB2MSB)                          Tiff.ReverseBits(buffer' m_tiff_datasize);                        writeToFile(buffer' m_tiff_datasize);                      return m_tiff_datasize;                  }                                    if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_ZIP)                  {                      buffer = new byte [m_tiff_datasize];                      input.ReadRawTile(tile' buffer' 0' m_tiff_datasize);                      if (m_tiff_fillorder == FillOrder.LSB2MSB)                          Tiff.ReverseBits(buffer' m_tiff_datasize);                        writeToFile(buffer' m_tiff_datasize);                      return m_tiff_datasize;                  }                                    if (m_tiff_compression == Compression.JPEG)                  {                      byte[] table_end = new byte[2];                      buffer = new byte [m_tiff_datasize];                      result = input.GetField(TiffTag.JPEGTABLES);                      if (result != null)                      {                          int count = result[0].ToInt();                          byte[] jpt = result[1].ToByteArray();                          if (count > 0)                          {                              Buffer.BlockCopy(jpt' 0' buffer' 0' count);                              bufferoffset += count - 2;                              table_end[0] = buffer[bufferoffset - 2];                              table_end[1] = buffer[bufferoffset - 1];                          }                            if (count > 0)                          {                              int xuint32 = bufferoffset;                              bufferoffset += input.ReadRawTile(tile' buffer' bufferoffset - 2' -1);                              buffer[xuint32 - 2] = table_end[0];                              buffer[xuint32 - 1] = table_end[1];                          }                          else                          {                              bufferoffset += input.ReadRawTile(tile' buffer' bufferoffset' -1);                          }                      }                        writeToFile(buffer' bufferoffset);                      return bufferoffset;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: if ((m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW) && (!edge || (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_JPEG)))              {                  if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)                  {                      buffer = new byte [m_tiff_datasize];                      input.ReadRawTile(tile' buffer' 0' m_tiff_datasize);                      if (m_tiff_fillorder == FillOrder.LSB2MSB)                          Tiff.ReverseBits(buffer' m_tiff_datasize);                        writeToFile(buffer' m_tiff_datasize);                      return m_tiff_datasize;                  }                                    if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_ZIP)                  {                      buffer = new byte [m_tiff_datasize];                      input.ReadRawTile(tile' buffer' 0' m_tiff_datasize);                      if (m_tiff_fillorder == FillOrder.LSB2MSB)                          Tiff.ReverseBits(buffer' m_tiff_datasize);                        writeToFile(buffer' m_tiff_datasize);                      return m_tiff_datasize;                  }                                    if (m_tiff_compression == Compression.JPEG)                  {                      byte[] table_end = new byte[2];                      buffer = new byte [m_tiff_datasize];                      result = input.GetField(TiffTag.JPEGTABLES);                      if (result != null)                      {                          int count = result[0].ToInt();                          byte[] jpt = result[1].ToByteArray();                          if (count > 0)                          {                              Buffer.BlockCopy(jpt' 0' buffer' 0' count);                              bufferoffset += count - 2;                              table_end[0] = buffer[bufferoffset - 2];                              table_end[1] = buffer[bufferoffset - 1];                          }                            if (count > 0)                          {                              int xuint32 = bufferoffset;                              bufferoffset += input.ReadRawTile(tile' buffer' bufferoffset - 2' -1);                              buffer[xuint32 - 2] = table_end[0];                              buffer[xuint32 - 1] = table_end[1];                          }                          else                          {                              bufferoffset += input.ReadRawTile(tile' buffer' bufferoffset' -1);                          }                      }                        writeToFile(buffer' bufferoffset);                      return bufferoffset;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: if ((m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW) && (!edge || (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_JPEG)))              {                  if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)                  {                      buffer = new byte [m_tiff_datasize];                      input.ReadRawTile(tile' buffer' 0' m_tiff_datasize);                      if (m_tiff_fillorder == FillOrder.LSB2MSB)                          Tiff.ReverseBits(buffer' m_tiff_datasize);                        writeToFile(buffer' m_tiff_datasize);                      return m_tiff_datasize;                  }                                    if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_ZIP)                  {                      buffer = new byte [m_tiff_datasize];                      input.ReadRawTile(tile' buffer' 0' m_tiff_datasize);                      if (m_tiff_fillorder == FillOrder.LSB2MSB)                          Tiff.ReverseBits(buffer' m_tiff_datasize);                        writeToFile(buffer' m_tiff_datasize);                      return m_tiff_datasize;                  }                                    if (m_tiff_compression == Compression.JPEG)                  {                      byte[] table_end = new byte[2];                      buffer = new byte [m_tiff_datasize];                      result = input.GetField(TiffTag.JPEGTABLES);                      if (result != null)                      {                          int count = result[0].ToInt();                          byte[] jpt = result[1].ToByteArray();                          if (count > 0)                          {                              Buffer.BlockCopy(jpt' 0' buffer' 0' count);                              bufferoffset += count - 2;                              table_end[0] = buffer[bufferoffset - 2];                              table_end[1] = buffer[bufferoffset - 1];                          }                            if (count > 0)                          {                              int xuint32 = bufferoffset;                              bufferoffset += input.ReadRawTile(tile' buffer' bufferoffset - 2' -1);                              buffer[xuint32 - 2] = table_end[0];                              buffer[xuint32 - 1] = table_end[1];                          }                          else                          {                              bufferoffset += input.ReadRawTile(tile' buffer' bufferoffset' -1);                          }                      }                        writeToFile(buffer' bufferoffset);                      return bufferoffset;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: if ((m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW) && (!edge || (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_JPEG)))              {                  if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)                  {                      buffer = new byte [m_tiff_datasize];                      input.ReadRawTile(tile' buffer' 0' m_tiff_datasize);                      if (m_tiff_fillorder == FillOrder.LSB2MSB)                          Tiff.ReverseBits(buffer' m_tiff_datasize);                        writeToFile(buffer' m_tiff_datasize);                      return m_tiff_datasize;                  }                                    if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_ZIP)                  {                      buffer = new byte [m_tiff_datasize];                      input.ReadRawTile(tile' buffer' 0' m_tiff_datasize);                      if (m_tiff_fillorder == FillOrder.LSB2MSB)                          Tiff.ReverseBits(buffer' m_tiff_datasize);                        writeToFile(buffer' m_tiff_datasize);                      return m_tiff_datasize;                  }                                    if (m_tiff_compression == Compression.JPEG)                  {                      byte[] table_end = new byte[2];                      buffer = new byte [m_tiff_datasize];                      result = input.GetField(TiffTag.JPEGTABLES);                      if (result != null)                      {                          int count = result[0].ToInt();                          byte[] jpt = result[1].ToByteArray();                          if (count > 0)                          {                              Buffer.BlockCopy(jpt' 0' buffer' 0' count);                              bufferoffset += count - 2;                              table_end[0] = buffer[bufferoffset - 2];                              table_end[1] = buffer[bufferoffset - 1];                          }                            if (count > 0)                          {                              int xuint32 = bufferoffset;                              bufferoffset += input.ReadRawTile(tile' buffer' bufferoffset - 2' -1);                              buffer[xuint32 - 2] = table_end[0];                              buffer[xuint32 - 1] = table_end[1];                          }                          else                          {                              bufferoffset += input.ReadRawTile(tile' buffer' bufferoffset' -1);                          }                      }                        writeToFile(buffer' bufferoffset);                      return bufferoffset;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: if ((m_pdf_transcode == t2p_transcode_t.T2P_TRANSCODE_RAW) && (!edge || (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_JPEG)))              {                  if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_G4)                  {                      buffer = new byte [m_tiff_datasize];                      input.ReadRawTile(tile' buffer' 0' m_tiff_datasize);                      if (m_tiff_fillorder == FillOrder.LSB2MSB)                          Tiff.ReverseBits(buffer' m_tiff_datasize);                        writeToFile(buffer' m_tiff_datasize);                      return m_tiff_datasize;                  }                                    if (m_pdf_compression == t2p_compress_t.T2P_COMPRESS_ZIP)                  {                      buffer = new byte [m_tiff_datasize];                      input.ReadRawTile(tile' buffer' 0' m_tiff_datasize);                      if (m_tiff_fillorder == FillOrder.LSB2MSB)                          Tiff.ReverseBits(buffer' m_tiff_datasize);                        writeToFile(buffer' m_tiff_datasize);                      return m_tiff_datasize;                  }                                    if (m_tiff_compression == Compression.JPEG)                  {                      byte[] table_end = new byte[2];                      buffer = new byte [m_tiff_datasize];                      result = input.GetField(TiffTag.JPEGTABLES);                      if (result != null)                      {                          int count = result[0].ToInt();                          byte[] jpt = result[1].ToByteArray();                          if (count > 0)                          {                              Buffer.BlockCopy(jpt' 0' buffer' 0' count);                              bufferoffset += count - 2;                              table_end[0] = buffer[bufferoffset - 2];                              table_end[1] = buffer[bufferoffset - 1];                          }                            if (count > 0)                          {                              int xuint32 = bufferoffset;                              bufferoffset += input.ReadRawTile(tile' buffer' bufferoffset - 2' -1);                              buffer[xuint32 - 2] = table_end[0];                              buffer[xuint32 - 1] = table_end[1];                          }                          else                          {                              bufferoffset += input.ReadRawTile(tile' buffer' bufferoffset' -1);                          }                      }                        writeToFile(buffer' bufferoffset);                      return bufferoffset;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                                            m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG);                      m_output.SetField(TiffTag.JPEGTABLESMODE' 0); /* JpegTablesMode.NONE */                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                          if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                        if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                                            m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG);                      m_output.SetField(TiffTag.JPEGTABLESMODE' 0); /* JpegTablesMode.NONE */                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                          if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                        if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                                            m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG);                      m_output.SetField(TiffTag.JPEGTABLESMODE' 0); /* JpegTablesMode.NONE */                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                          if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                        if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,readwrite_pdf_image_tile,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_NONE:                      m_output.SetField(TiffTag.COMPRESSION' Compression.NONE);                      break;                    case t2p_compress_t.T2P_COMPRESS_G4:                      m_output.SetField(TiffTag.COMPRESSION' Compression.CCITTFAX4);                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      if (m_tiff_photometric == Photometric.YCBCR)                      {                          result = input.GetField(TiffTag.YCBCRSUBSAMPLING);                          if (result != null)                          {                              short hor = result[0].ToShort();                              short ver = result[1].ToShort();                              if (hor != 0 && ver != 0)                                  m_output.SetField(TiffTag.YCBCRSUBSAMPLING' hor' ver);                          }                            result = input.GetField(TiffTag.REFERENCEBLACKWHITE);                          if (result != null)                          {                              float[] xfloatp = result[0].ToFloatArray();                              m_output.SetField(TiffTag.REFERENCEBLACKWHITE' xfloatp);                          }                      }                                            m_output.SetField(TiffTag.COMPRESSION' Compression.JPEG);                      m_output.SetField(TiffTag.JPEGTABLESMODE' 0); /* JpegTablesMode.NONE */                        if ((m_pdf_colorspace & (t2p_cs_t.T2P_CS_RGB | t2p_cs_t.T2P_CS_LAB)) != 0)                      {                          m_output.SetField(TiffTag.PHOTOMETRIC' Photometric.YCBCR);                          if (m_tiff_photometric != Photometric.YCBCR)                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RGB);                          else                              m_output.SetField(TiffTag.JPEGCOLORMODE' JpegColorMode.RAW);                      }                        if (m_pdf_defaultcompressionquality != 0)                          m_output.SetField(TiffTag.JPEGQUALITY' m_pdf_defaultcompressionquality);                        break;                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      m_output.SetField(TiffTag.COMPRESSION' Compression.DEFLATE);                      if (m_pdf_defaultcompressionquality % 100 != 0)                          m_output.SetField(TiffTag.PREDICTOR' m_pdf_defaultcompressionquality % 100);                        if (m_pdf_defaultcompressionquality / 100 != 0)                          m_output.SetField(TiffTag.ZIPQUALITY' (m_pdf_defaultcompressionquality / 100));                        break;                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_header,The following statement contains a magic number: byte[] octals = new byte [4];
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_header,The following statement contains a magic number: octals[0] = Convert.ToByte("342"' 8);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_header,The following statement contains a magic number: octals[1] = Convert.ToByte("343"' 8);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_header,The following statement contains a magic number: octals[2] = Convert.ToByte("317"' 8);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_header,The following statement contains a magic number: octals[2] = Convert.ToByte("317"' 8);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_header,The following statement contains a magic number: octals[3] = Convert.ToByte("323"' 8);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_header,The following statement contains a magic number: octals[3] = Convert.ToByte("323"' 8);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_creator != null)              {                  if (strlen(m_pdf_creator) > 0)                  {                      byte[] buf = m_pdf_creator;                      if (strlen(m_pdf_creator) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_creator' 0' buf' 0' 511);                      }                        written += writeToFile("/Creator ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.SOFTWARE);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Creator ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_creator != null)              {                  if (strlen(m_pdf_creator) > 0)                  {                      byte[] buf = m_pdf_creator;                      if (strlen(m_pdf_creator) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_creator' 0' buf' 0' 511);                      }                        written += writeToFile("/Creator ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.SOFTWARE);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Creator ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_creator != null)              {                  if (strlen(m_pdf_creator) > 0)                  {                      byte[] buf = m_pdf_creator;                      if (strlen(m_pdf_creator) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_creator' 0' buf' 0' 511);                      }                        written += writeToFile("/Creator ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.SOFTWARE);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Creator ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_creator != null)              {                  if (strlen(m_pdf_creator) > 0)                  {                      byte[] buf = m_pdf_creator;                      if (strlen(m_pdf_creator) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_creator' 0' buf' 0' 511);                      }                        written += writeToFile("/Creator ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.SOFTWARE);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Creator ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_creator != null)              {                  if (strlen(m_pdf_creator) > 0)                  {                      byte[] buf = m_pdf_creator;                      if (strlen(m_pdf_creator) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_creator' 0' buf' 0' 511);                      }                        written += writeToFile("/Creator ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.SOFTWARE);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Creator ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_creator != null)              {                  if (strlen(m_pdf_creator) > 0)                  {                      byte[] buf = m_pdf_creator;                      if (strlen(m_pdf_creator) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_creator' 0' buf' 0' 511);                      }                        written += writeToFile("/Creator ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.SOFTWARE);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Creator ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_author != null)              {                  if (strlen(m_pdf_author) > 0)                  {                      byte[] buf = m_pdf_author;                      if (strlen(m_pdf_author) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_author' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.ARTIST);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }                  else                  {                      result = input.GetField(TiffTag.COPYRIGHT);                      if (result != null)                      {                          byte[] info = result[0].ToByteArray();                          byte[] buf = info;                          if (strlen(info) > 511)                          {                              buf = new byte[512];                              Buffer.BlockCopy(info' 0' buf' 0' 511);                          }                            written += writeToFile("/Author ");                          written += write_pdf_string(buf);                          written += writeToFile("\n");                      }                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_author != null)              {                  if (strlen(m_pdf_author) > 0)                  {                      byte[] buf = m_pdf_author;                      if (strlen(m_pdf_author) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_author' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.ARTIST);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }                  else                  {                      result = input.GetField(TiffTag.COPYRIGHT);                      if (result != null)                      {                          byte[] info = result[0].ToByteArray();                          byte[] buf = info;                          if (strlen(info) > 511)                          {                              buf = new byte[512];                              Buffer.BlockCopy(info' 0' buf' 0' 511);                          }                            written += writeToFile("/Author ");                          written += write_pdf_string(buf);                          written += writeToFile("\n");                      }                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_author != null)              {                  if (strlen(m_pdf_author) > 0)                  {                      byte[] buf = m_pdf_author;                      if (strlen(m_pdf_author) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_author' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.ARTIST);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }                  else                  {                      result = input.GetField(TiffTag.COPYRIGHT);                      if (result != null)                      {                          byte[] info = result[0].ToByteArray();                          byte[] buf = info;                          if (strlen(info) > 511)                          {                              buf = new byte[512];                              Buffer.BlockCopy(info' 0' buf' 0' 511);                          }                            written += writeToFile("/Author ");                          written += write_pdf_string(buf);                          written += writeToFile("\n");                      }                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_author != null)              {                  if (strlen(m_pdf_author) > 0)                  {                      byte[] buf = m_pdf_author;                      if (strlen(m_pdf_author) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_author' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.ARTIST);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }                  else                  {                      result = input.GetField(TiffTag.COPYRIGHT);                      if (result != null)                      {                          byte[] info = result[0].ToByteArray();                          byte[] buf = info;                          if (strlen(info) > 511)                          {                              buf = new byte[512];                              Buffer.BlockCopy(info' 0' buf' 0' 511);                          }                            written += writeToFile("/Author ");                          written += write_pdf_string(buf);                          written += writeToFile("\n");                      }                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_author != null)              {                  if (strlen(m_pdf_author) > 0)                  {                      byte[] buf = m_pdf_author;                      if (strlen(m_pdf_author) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_author' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.ARTIST);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }                  else                  {                      result = input.GetField(TiffTag.COPYRIGHT);                      if (result != null)                      {                          byte[] info = result[0].ToByteArray();                          byte[] buf = info;                          if (strlen(info) > 511)                          {                              buf = new byte[512];                              Buffer.BlockCopy(info' 0' buf' 0' 511);                          }                            written += writeToFile("/Author ");                          written += write_pdf_string(buf);                          written += writeToFile("\n");                      }                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_author != null)              {                  if (strlen(m_pdf_author) > 0)                  {                      byte[] buf = m_pdf_author;                      if (strlen(m_pdf_author) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_author' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.ARTIST);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }                  else                  {                      result = input.GetField(TiffTag.COPYRIGHT);                      if (result != null)                      {                          byte[] info = result[0].ToByteArray();                          byte[] buf = info;                          if (strlen(info) > 511)                          {                              buf = new byte[512];                              Buffer.BlockCopy(info' 0' buf' 0' 511);                          }                            written += writeToFile("/Author ");                          written += write_pdf_string(buf);                          written += writeToFile("\n");                      }                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_author != null)              {                  if (strlen(m_pdf_author) > 0)                  {                      byte[] buf = m_pdf_author;                      if (strlen(m_pdf_author) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_author' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.ARTIST);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }                  else                  {                      result = input.GetField(TiffTag.COPYRIGHT);                      if (result != null)                      {                          byte[] info = result[0].ToByteArray();                          byte[] buf = info;                          if (strlen(info) > 511)                          {                              buf = new byte[512];                              Buffer.BlockCopy(info' 0' buf' 0' 511);                          }                            written += writeToFile("/Author ");                          written += write_pdf_string(buf);                          written += writeToFile("\n");                      }                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_author != null)              {                  if (strlen(m_pdf_author) > 0)                  {                      byte[] buf = m_pdf_author;                      if (strlen(m_pdf_author) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_author' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.ARTIST);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }                  else                  {                      result = input.GetField(TiffTag.COPYRIGHT);                      if (result != null)                      {                          byte[] info = result[0].ToByteArray();                          byte[] buf = info;                          if (strlen(info) > 511)                          {                              buf = new byte[512];                              Buffer.BlockCopy(info' 0' buf' 0' 511);                          }                            written += writeToFile("/Author ");                          written += write_pdf_string(buf);                          written += writeToFile("\n");                      }                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_author != null)              {                  if (strlen(m_pdf_author) > 0)                  {                      byte[] buf = m_pdf_author;                      if (strlen(m_pdf_author) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_author' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.ARTIST);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Author ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }                  else                  {                      result = input.GetField(TiffTag.COPYRIGHT);                      if (result != null)                      {                          byte[] info = result[0].ToByteArray();                          byte[] buf = info;                          if (strlen(info) > 511)                          {                              buf = new byte[512];                              Buffer.BlockCopy(info' 0' buf' 0' 511);                          }                            written += writeToFile("/Author ");                          written += write_pdf_string(buf);                          written += writeToFile("\n");                      }                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_title != null)              {                  if (strlen(m_pdf_title) > 0)                  {                      byte[] buf = m_pdf_title;                      if (strlen(m_pdf_title) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_title' 0' buf' 0' 511);                      }                        written += writeToFile("/Title ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.DOCUMENTNAME);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Title ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_title != null)              {                  if (strlen(m_pdf_title) > 0)                  {                      byte[] buf = m_pdf_title;                      if (strlen(m_pdf_title) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_title' 0' buf' 0' 511);                      }                        written += writeToFile("/Title ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.DOCUMENTNAME);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Title ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_title != null)              {                  if (strlen(m_pdf_title) > 0)                  {                      byte[] buf = m_pdf_title;                      if (strlen(m_pdf_title) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_title' 0' buf' 0' 511);                      }                        written += writeToFile("/Title ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.DOCUMENTNAME);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Title ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_title != null)              {                  if (strlen(m_pdf_title) > 0)                  {                      byte[] buf = m_pdf_title;                      if (strlen(m_pdf_title) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_title' 0' buf' 0' 511);                      }                        written += writeToFile("/Title ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.DOCUMENTNAME);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Title ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_title != null)              {                  if (strlen(m_pdf_title) > 0)                  {                      byte[] buf = m_pdf_title;                      if (strlen(m_pdf_title) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_title' 0' buf' 0' 511);                      }                        written += writeToFile("/Title ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.DOCUMENTNAME);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Title ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_title != null)              {                  if (strlen(m_pdf_title) > 0)                  {                      byte[] buf = m_pdf_title;                      if (strlen(m_pdf_title) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_title' 0' buf' 0' 511);                      }                        written += writeToFile("/Title ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.DOCUMENTNAME);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Title ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_subject != null)              {                  if (strlen(m_pdf_subject) > 0)                  {                      byte[] buf = m_pdf_subject;                      if (strlen(m_pdf_subject) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_subject' 0' buf' 0' 511);                      }                        written += writeToFile("/Subject ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.IMAGEDESCRIPTION);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Subject ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_subject != null)              {                  if (strlen(m_pdf_subject) > 0)                  {                      byte[] buf = m_pdf_subject;                      if (strlen(m_pdf_subject) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_subject' 0' buf' 0' 511);                      }                        written += writeToFile("/Subject ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.IMAGEDESCRIPTION);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Subject ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_subject != null)              {                  if (strlen(m_pdf_subject) > 0)                  {                      byte[] buf = m_pdf_subject;                      if (strlen(m_pdf_subject) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_subject' 0' buf' 0' 511);                      }                        written += writeToFile("/Subject ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.IMAGEDESCRIPTION);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Subject ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_subject != null)              {                  if (strlen(m_pdf_subject) > 0)                  {                      byte[] buf = m_pdf_subject;                      if (strlen(m_pdf_subject) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_subject' 0' buf' 0' 511);                      }                        written += writeToFile("/Subject ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.IMAGEDESCRIPTION);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Subject ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_subject != null)              {                  if (strlen(m_pdf_subject) > 0)                  {                      byte[] buf = m_pdf_subject;                      if (strlen(m_pdf_subject) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_subject' 0' buf' 0' 511);                      }                        written += writeToFile("/Subject ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.IMAGEDESCRIPTION);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Subject ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_subject != null)              {                  if (strlen(m_pdf_subject) > 0)                  {                      byte[] buf = m_pdf_subject;                      if (strlen(m_pdf_subject) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_subject' 0' buf' 0' 511);                      }                        written += writeToFile("/Subject ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }              else              {                  result = input.GetField(TiffTag.IMAGEDESCRIPTION);                  if (result != null)                  {                      byte[] info = result[0].ToByteArray();                      byte[] buf = info;                      if (strlen(info) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(info' 0' buf' 0' 511);                      }                        written += writeToFile("/Subject ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_keywords != null)              {                  if (strlen(m_pdf_keywords) > 0)                  {                      byte[] buf = m_pdf_keywords;                      if (strlen(m_pdf_keywords) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_keywords' 0' buf' 0' 511);                      }                        written += writeToFile("/Keywords ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_keywords != null)              {                  if (strlen(m_pdf_keywords) > 0)                  {                      byte[] buf = m_pdf_keywords;                      if (strlen(m_pdf_keywords) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_keywords' 0' buf' 0' 511);                      }                        written += writeToFile("/Keywords ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_info,The following statement contains a magic number: if (m_pdf_keywords != null)              {                  if (strlen(m_pdf_keywords) > 0)                  {                      byte[] buf = m_pdf_keywords;                      if (strlen(m_pdf_keywords) > 511)                      {                          buf = new byte[512];                          Buffer.BlockCopy(m_pdf_keywords' 0' buf' 0' 511);                      }                        written += writeToFile("/Keywords ");                      written += write_pdf_string(buf);                      written += writeToFile("\n");                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_currenttime,The following statement contains a magic number: string s = string.Format(CultureInfo.InvariantCulture'                  "D:{0:0000}{1:00}{2:00}{3:00}{4:00}{5:00}"'                   dt.Year % 65536' dt.Month % 256' dt.Day % 256' dt.Hour % 256'                   dt.Minute % 256' dt.Second % 256);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_currenttime,The following statement contains a magic number: string s = string.Format(CultureInfo.InvariantCulture'                  "D:{0:0000}{1:00}{2:00}{3:00}{4:00}{5:00}"'                   dt.Year % 65536' dt.Month % 256' dt.Day % 256' dt.Hour % 256'                   dt.Minute % 256' dt.Second % 256);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_currenttime,The following statement contains a magic number: string s = string.Format(CultureInfo.InvariantCulture'                  "D:{0:0000}{1:00}{2:00}{3:00}{4:00}{5:00}"'                   dt.Year % 65536' dt.Month % 256' dt.Day % 256' dt.Hour % 256'                   dt.Minute % 256' dt.Second % 256);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_currenttime,The following statement contains a magic number: string s = string.Format(CultureInfo.InvariantCulture'                  "D:{0:0000}{1:00}{2:00}{3:00}{4:00}{5:00}"'                   dt.Year % 65536' dt.Month % 256' dt.Day % 256' dt.Hour % 256'                   dt.Minute % 256' dt.Second % 256);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_currenttime,The following statement contains a magic number: string s = string.Format(CultureInfo.InvariantCulture'                  "D:{0:0000}{1:00}{2:00}{3:00}{4:00}{5:00}"'                   dt.Year % 65536' dt.Month % 256' dt.Day % 256' dt.Hour % 256'                   dt.Minute % 256' dt.Second % 256);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_currenttime,The following statement contains a magic number: string s = string.Format(CultureInfo.InvariantCulture'                  "D:{0:0000}{1:00}{2:00}{3:00}{4:00}{5:00}"'                   dt.Year % 65536' dt.Month % 256' dt.Day % 256' dt.Hour % 256'                   dt.Minute % 256' dt.Second % 256);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,pdf_tifftime,The following statement contains a magic number: if (result != null && (result[0].ToString()).Length >= 19)              {                  string datetime = result[0].ToString();                    m_pdf_datetime = new byte[16];                  m_pdf_datetime[0] = (byte)'D';                  m_pdf_datetime[1] = (byte)':';                  m_pdf_datetime[2] = (byte)datetime[0];                  m_pdf_datetime[3] = (byte)datetime[1];                  m_pdf_datetime[4] = (byte)datetime[2];                  m_pdf_datetime[5] = (byte)datetime[3];                  m_pdf_datetime[6] = (byte)datetime[5];                  m_pdf_datetime[7] = (byte)datetime[6];                  m_pdf_datetime[8] = (byte)datetime[8];                  m_pdf_datetime[9] = (byte)datetime[9];                  m_pdf_datetime[10] = (byte)datetime[11];                  m_pdf_datetime[11] = (byte)datetime[12];                  m_pdf_datetime[12] = (byte)datetime[14];                  m_pdf_datetime[13] = (byte)datetime[15];                  m_pdf_datetime[14] = (byte)datetime[17];                  m_pdf_datetime[15] = (byte)datetime[18];              }              else              {                  pdf_currenttime();              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_pages,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' page);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                    if (((i + 1) % 8) == 0)                      written += writeToFile("\n");                    page += 3;                  page += m_tiff_pages[i].page_extra;                    if (m_tiff_pages[i].page_tilecount > 0)                      page += (2 * m_tiff_pages[i].page_tilecount);                  else                      page += 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_pages,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' page);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                    if (((i + 1) % 8) == 0)                      written += writeToFile("\n");                    page += 3;                  page += m_tiff_pages[i].page_extra;                    if (m_tiff_pages[i].page_tilecount > 0)                      page += (2 * m_tiff_pages[i].page_tilecount);                  else                      page += 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_pages,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' page);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                    if (((i + 1) % 8) == 0)                      written += writeToFile("\n");                    page += 3;                  page += m_tiff_pages[i].page_extra;                    if (m_tiff_pages[i].page_tilecount > 0)                      page += (2 * m_tiff_pages[i].page_tilecount);                  else                      page += 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_pages,The following statement contains a magic number: for (short i = 0; i < m_tiff_pagecount; i++)              {                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' page);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                    if (((i + 1) % 8) == 0)                      written += writeToFile("\n");                    page += 3;                  page += m_tiff_pages[i].page_extra;                    if (m_tiff_pages[i].page_tilecount > 0)                      page += (2 * m_tiff_pages[i].page_tilecount);                  else                      page += 2;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_cs,The following statement contains a magic number: if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_LAB) != 0)              {                  written += writeToFile("[/Lab << \n");                  written += writeToFile("/WhitePoint ");                                    float X_W = m_tiff_whitechromaticities[0];                  float Y_W = m_tiff_whitechromaticities[1];                  float Z_W = 1.0F - (X_W + Y_W);                  X_W /= Y_W;                  Z_W /= Y_W;                  Y_W = 1.0F;                  buffer = string.Format(CultureInfo.InvariantCulture'                      "[{0:F4} {1:F4} {2:F4}] \n"' X_W' Y_W' Z_W);                  written += writeToFile(buffer);                    written += writeToFile("/BlackPoint ");                  X_W = 0.3457F; /* 0.3127F; */ /* D50' commented D65 */                  Y_W = 0.3585F; /* 0.3290F; */                  Z_W = 1.0F - (X_W + Y_W);                  X_W /= Y_W;                  Z_W /= Y_W;                  Y_W = 1.0F;                  buffer = string.Format(CultureInfo.InvariantCulture'                      "[{0:F4} {1:F4} {2:F4}] \n"' X_W' Y_W' Z_W);                  written += writeToFile(buffer);                  written += writeToFile("/Range ");                  buffer = string.Format(CultureInfo.InvariantCulture'                      "[{0} {1} {2} {3}] \n"' m_pdf_labrange[0]' m_pdf_labrange[1]' m_pdf_labrange[2]' m_pdf_labrange[3]);                  written += writeToFile(buffer);                  written += writeToFile(">>] \n");              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_cs,The following statement contains a magic number: if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_LAB) != 0)              {                  written += writeToFile("[/Lab << \n");                  written += writeToFile("/WhitePoint ");                                    float X_W = m_tiff_whitechromaticities[0];                  float Y_W = m_tiff_whitechromaticities[1];                  float Z_W = 1.0F - (X_W + Y_W);                  X_W /= Y_W;                  Z_W /= Y_W;                  Y_W = 1.0F;                  buffer = string.Format(CultureInfo.InvariantCulture'                      "[{0:F4} {1:F4} {2:F4}] \n"' X_W' Y_W' Z_W);                  written += writeToFile(buffer);                    written += writeToFile("/BlackPoint ");                  X_W = 0.3457F; /* 0.3127F; */ /* D50' commented D65 */                  Y_W = 0.3585F; /* 0.3290F; */                  Z_W = 1.0F - (X_W + Y_W);                  X_W /= Y_W;                  Z_W /= Y_W;                  Y_W = 1.0F;                  buffer = string.Format(CultureInfo.InvariantCulture'                      "[{0:F4} {1:F4} {2:F4}] \n"' X_W' Y_W' Z_W);                  written += writeToFile(buffer);                  written += writeToFile("/Range ");                  buffer = string.Format(CultureInfo.InvariantCulture'                      "[{0} {1} {2} {3}] \n"' m_pdf_labrange[0]' m_pdf_labrange[1]' m_pdf_labrange[2]' m_pdf_labrange[3]);                  written += writeToFile(buffer);                  written += writeToFile(">>] \n");              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_transfer,The following statement contains a magic number: if (m_tiff_transferfunctioncount == 1)              {                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_xrefcount + 1);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");              }              else              {                  written += writeToFile("[ ");                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_xrefcount + 1);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_xrefcount + 2);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_xrefcount + 3);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                  written += writeToFile("/Identity ] ");              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_transfer,The following statement contains a magic number: if (m_tiff_transferfunctioncount == 1)              {                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_xrefcount + 1);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");              }              else              {                  written += writeToFile("[ ");                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_xrefcount + 1);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_xrefcount + 2);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_xrefcount + 3);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                  written += writeToFile("/Identity ] ");              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_calcs,The following statement contains a magic number: if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_CALRGB) != 0)              {                  written += writeToFile("/CalRGB ");                  float x_w = m_tiff_whitechromaticities[0];                  float y_w = m_tiff_whitechromaticities[1];                  float x_r = m_tiff_primarychromaticities[0];                  float y_r = m_tiff_primarychromaticities[1];                  float x_g = m_tiff_primarychromaticities[2];                  float y_g = m_tiff_primarychromaticities[3];                  float x_b = m_tiff_primarychromaticities[4];                  float y_b = m_tiff_primarychromaticities[5];                    const float R = 1.0f;                  const float G = 1.0f;                  const float B = 1.0f;                    float z_w = y_w * ((x_g - x_b) * y_r - (x_r - x_b) * y_g + (x_r - x_g) * y_b);                  Y_R = (y_r / R) * ((x_g - x_b) * y_w - (x_w - x_b) * y_g + (x_w - x_g) * y_b) / z_w;                  X_R = Y_R * x_r / y_r;                  Z_R = Y_R * (((1 - x_r) / y_r) - 1);                  Y_G = ((0.0F - y_g) / G) * ((x_r - x_b) * y_w - (x_w - x_b) * y_r + (x_w - x_r) * y_b) / z_w;                  X_G = Y_G * x_g / y_g;                  Z_G = Y_G * (((1 - x_g) / y_g) - 1);                  Y_B = (y_b / B) * ((x_r - x_g) * y_w - (x_w - x_g) * y_r + (x_w - x_r) * y_g) / z_w;                  X_B = Y_B * x_b / y_b;                  Z_B = Y_B * (((1 - x_b) / y_b) - 1);                  X_W = (X_R * R) + (X_G * G) + (X_B * B);                  Y_W = (Y_R * R) + (Y_G * G) + (Y_B * B);                  Z_W = (Z_R * R) + (Z_G * G) + (Z_B * B);                  X_W /= Y_W;                  Z_W /= Y_W;                  Y_W = 1.0f;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_calcs,The following statement contains a magic number: if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_CALRGB) != 0)              {                  written += writeToFile("/CalRGB ");                  float x_w = m_tiff_whitechromaticities[0];                  float y_w = m_tiff_whitechromaticities[1];                  float x_r = m_tiff_primarychromaticities[0];                  float y_r = m_tiff_primarychromaticities[1];                  float x_g = m_tiff_primarychromaticities[2];                  float y_g = m_tiff_primarychromaticities[3];                  float x_b = m_tiff_primarychromaticities[4];                  float y_b = m_tiff_primarychromaticities[5];                    const float R = 1.0f;                  const float G = 1.0f;                  const float B = 1.0f;                    float z_w = y_w * ((x_g - x_b) * y_r - (x_r - x_b) * y_g + (x_r - x_g) * y_b);                  Y_R = (y_r / R) * ((x_g - x_b) * y_w - (x_w - x_b) * y_g + (x_w - x_g) * y_b) / z_w;                  X_R = Y_R * x_r / y_r;                  Z_R = Y_R * (((1 - x_r) / y_r) - 1);                  Y_G = ((0.0F - y_g) / G) * ((x_r - x_b) * y_w - (x_w - x_b) * y_r + (x_w - x_r) * y_b) / z_w;                  X_G = Y_G * x_g / y_g;                  Z_G = Y_G * (((1 - x_g) / y_g) - 1);                  Y_B = (y_b / B) * ((x_r - x_g) * y_w - (x_w - x_g) * y_r + (x_w - x_r) * y_g) / z_w;                  X_B = Y_B * x_b / y_b;                  Z_B = Y_B * (((1 - x_b) / y_b) - 1);                  X_W = (X_R * R) + (X_G * G) + (X_B * B);                  Y_W = (Y_R * R) + (Y_G * G) + (Y_B * B);                  Z_W = (Z_R * R) + (Z_G * G) + (Z_B * B);                  X_W /= Y_W;                  Z_W /= Y_W;                  Y_W = 1.0f;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_calcs,The following statement contains a magic number: if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_CALRGB) != 0)              {                  written += writeToFile("/CalRGB ");                  float x_w = m_tiff_whitechromaticities[0];                  float y_w = m_tiff_whitechromaticities[1];                  float x_r = m_tiff_primarychromaticities[0];                  float y_r = m_tiff_primarychromaticities[1];                  float x_g = m_tiff_primarychromaticities[2];                  float y_g = m_tiff_primarychromaticities[3];                  float x_b = m_tiff_primarychromaticities[4];                  float y_b = m_tiff_primarychromaticities[5];                    const float R = 1.0f;                  const float G = 1.0f;                  const float B = 1.0f;                    float z_w = y_w * ((x_g - x_b) * y_r - (x_r - x_b) * y_g + (x_r - x_g) * y_b);                  Y_R = (y_r / R) * ((x_g - x_b) * y_w - (x_w - x_b) * y_g + (x_w - x_g) * y_b) / z_w;                  X_R = Y_R * x_r / y_r;                  Z_R = Y_R * (((1 - x_r) / y_r) - 1);                  Y_G = ((0.0F - y_g) / G) * ((x_r - x_b) * y_w - (x_w - x_b) * y_r + (x_w - x_r) * y_b) / z_w;                  X_G = Y_G * x_g / y_g;                  Z_G = Y_G * (((1 - x_g) / y_g) - 1);                  Y_B = (y_b / B) * ((x_r - x_g) * y_w - (x_w - x_g) * y_r + (x_w - x_r) * y_g) / z_w;                  X_B = Y_B * x_b / y_b;                  Z_B = Y_B * (((1 - x_b) / y_b) - 1);                  X_W = (X_R * R) + (X_G * G) + (X_B * B);                  Y_W = (Y_R * R) + (Y_G * G) + (Y_B * B);                  Z_W = (Z_R * R) + (Z_G * G) + (Z_B * B);                  X_W /= Y_W;                  Z_W /= Y_W;                  Y_W = 1.0f;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_calcs,The following statement contains a magic number: if ((m_pdf_colorspace & t2p_cs_t.T2P_CS_CALRGB) != 0)              {                  written += writeToFile("/CalRGB ");                  float x_w = m_tiff_whitechromaticities[0];                  float y_w = m_tiff_whitechromaticities[1];                  float x_r = m_tiff_primarychromaticities[0];                  float y_r = m_tiff_primarychromaticities[1];                  float x_g = m_tiff_primarychromaticities[2];                  float y_g = m_tiff_primarychromaticities[3];                  float x_b = m_tiff_primarychromaticities[4];                  float y_b = m_tiff_primarychromaticities[5];                    const float R = 1.0f;                  const float G = 1.0f;                  const float B = 1.0f;                    float z_w = y_w * ((x_g - x_b) * y_r - (x_r - x_b) * y_g + (x_r - x_g) * y_b);                  Y_R = (y_r / R) * ((x_g - x_b) * y_w - (x_w - x_b) * y_g + (x_w - x_g) * y_b) / z_w;                  X_R = Y_R * x_r / y_r;                  Z_R = Y_R * (((1 - x_r) / y_r) - 1);                  Y_G = ((0.0F - y_g) / G) * ((x_r - x_b) * y_w - (x_w - x_b) * y_r + (x_w - x_r) * y_b) / z_w;                  X_G = Y_G * x_g / y_g;                  Z_G = Y_G * (((1 - x_g) / y_g) - 1);                  Y_B = (y_b / B) * ((x_r - x_g) * y_w - (x_w - x_g) * y_r + (x_w - x_r) * y_g) / z_w;                  X_B = Y_B * x_b / y_b;                  Z_B = Y_B * (((1 - x_b) / y_b) - 1);                  X_W = (X_R * R) + (X_G * G) + (X_B * B);                  Y_W = (Y_R * R) + (Y_G * G) + (Y_B * B);                  Z_W = (Z_R * R) + (Z_G * G) + (Z_B * B);                  X_W /= Y_W;                  Z_W /= Y_W;                  Y_W = 1.0f;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: m_pdf_fileid = new byte [33];
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: if (m_testFriendly)              {                  string fileidbuf = "2900000023480000FF180000FF670000";                  for (int i = 0; i < 16; i++)                  {                      m_pdf_fileid[2 * i] = (byte)(fileidbuf[2 * i]);                      m_pdf_fileid[2 * i + 1] = (byte)(fileidbuf[2 * i + 1]);                  }              }              else              {                  Random rnd = new Random(DateTime.Now.Millisecond);                  byte[] temp = new byte[16];                  rnd.NextBytes(temp);                    for (int i = 0; i < 16; i++)                  {                      string s = string.Format(CultureInfo.InvariantCulture' "{0:X2}"' temp[i]);                      m_pdf_fileid[i * 2] = (byte)s[0];                      m_pdf_fileid[i * 2 + 1] = (byte)s[1];                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: if (m_testFriendly)              {                  string fileidbuf = "2900000023480000FF180000FF670000";                  for (int i = 0; i < 16; i++)                  {                      m_pdf_fileid[2 * i] = (byte)(fileidbuf[2 * i]);                      m_pdf_fileid[2 * i + 1] = (byte)(fileidbuf[2 * i + 1]);                  }              }              else              {                  Random rnd = new Random(DateTime.Now.Millisecond);                  byte[] temp = new byte[16];                  rnd.NextBytes(temp);                    for (int i = 0; i < 16; i++)                  {                      string s = string.Format(CultureInfo.InvariantCulture' "{0:X2}"' temp[i]);                      m_pdf_fileid[i * 2] = (byte)s[0];                      m_pdf_fileid[i * 2 + 1] = (byte)s[1];                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: if (m_testFriendly)              {                  string fileidbuf = "2900000023480000FF180000FF670000";                  for (int i = 0; i < 16; i++)                  {                      m_pdf_fileid[2 * i] = (byte)(fileidbuf[2 * i]);                      m_pdf_fileid[2 * i + 1] = (byte)(fileidbuf[2 * i + 1]);                  }              }              else              {                  Random rnd = new Random(DateTime.Now.Millisecond);                  byte[] temp = new byte[16];                  rnd.NextBytes(temp);                    for (int i = 0; i < 16; i++)                  {                      string s = string.Format(CultureInfo.InvariantCulture' "{0:X2}"' temp[i]);                      m_pdf_fileid[i * 2] = (byte)s[0];                      m_pdf_fileid[i * 2 + 1] = (byte)s[1];                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: if (m_testFriendly)              {                  string fileidbuf = "2900000023480000FF180000FF670000";                  for (int i = 0; i < 16; i++)                  {                      m_pdf_fileid[2 * i] = (byte)(fileidbuf[2 * i]);                      m_pdf_fileid[2 * i + 1] = (byte)(fileidbuf[2 * i + 1]);                  }              }              else              {                  Random rnd = new Random(DateTime.Now.Millisecond);                  byte[] temp = new byte[16];                  rnd.NextBytes(temp);                    for (int i = 0; i < 16; i++)                  {                      string s = string.Format(CultureInfo.InvariantCulture' "{0:X2}"' temp[i]);                      m_pdf_fileid[i * 2] = (byte)s[0];                      m_pdf_fileid[i * 2 + 1] = (byte)s[1];                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: if (m_testFriendly)              {                  string fileidbuf = "2900000023480000FF180000FF670000";                  for (int i = 0; i < 16; i++)                  {                      m_pdf_fileid[2 * i] = (byte)(fileidbuf[2 * i]);                      m_pdf_fileid[2 * i + 1] = (byte)(fileidbuf[2 * i + 1]);                  }              }              else              {                  Random rnd = new Random(DateTime.Now.Millisecond);                  byte[] temp = new byte[16];                  rnd.NextBytes(temp);                    for (int i = 0; i < 16; i++)                  {                      string s = string.Format(CultureInfo.InvariantCulture' "{0:X2}"' temp[i]);                      m_pdf_fileid[i * 2] = (byte)s[0];                      m_pdf_fileid[i * 2 + 1] = (byte)s[1];                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: if (m_testFriendly)              {                  string fileidbuf = "2900000023480000FF180000FF670000";                  for (int i = 0; i < 16; i++)                  {                      m_pdf_fileid[2 * i] = (byte)(fileidbuf[2 * i]);                      m_pdf_fileid[2 * i + 1] = (byte)(fileidbuf[2 * i + 1]);                  }              }              else              {                  Random rnd = new Random(DateTime.Now.Millisecond);                  byte[] temp = new byte[16];                  rnd.NextBytes(temp);                    for (int i = 0; i < 16; i++)                  {                      string s = string.Format(CultureInfo.InvariantCulture' "{0:X2}"' temp[i]);                      m_pdf_fileid[i * 2] = (byte)s[0];                      m_pdf_fileid[i * 2 + 1] = (byte)s[1];                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: if (m_testFriendly)              {                  string fileidbuf = "2900000023480000FF180000FF670000";                  for (int i = 0; i < 16; i++)                  {                      m_pdf_fileid[2 * i] = (byte)(fileidbuf[2 * i]);                      m_pdf_fileid[2 * i + 1] = (byte)(fileidbuf[2 * i + 1]);                  }              }              else              {                  Random rnd = new Random(DateTime.Now.Millisecond);                  byte[] temp = new byte[16];                  rnd.NextBytes(temp);                    for (int i = 0; i < 16; i++)                  {                      string s = string.Format(CultureInfo.InvariantCulture' "{0:X2}"' temp[i]);                      m_pdf_fileid[i * 2] = (byte)s[0];                      m_pdf_fileid[i * 2 + 1] = (byte)s[1];                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: if (m_testFriendly)              {                  string fileidbuf = "2900000023480000FF180000FF670000";                  for (int i = 0; i < 16; i++)                  {                      m_pdf_fileid[2 * i] = (byte)(fileidbuf[2 * i]);                      m_pdf_fileid[2 * i + 1] = (byte)(fileidbuf[2 * i + 1]);                  }              }              else              {                  Random rnd = new Random(DateTime.Now.Millisecond);                  byte[] temp = new byte[16];                  rnd.NextBytes(temp);                    for (int i = 0; i < 16; i++)                  {                      string s = string.Format(CultureInfo.InvariantCulture' "{0:X2}"' temp[i]);                      m_pdf_fileid[i * 2] = (byte)s[0];                      m_pdf_fileid[i * 2 + 1] = (byte)s[1];                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: if (m_testFriendly)              {                  string fileidbuf = "2900000023480000FF180000FF670000";                  for (int i = 0; i < 16; i++)                  {                      m_pdf_fileid[2 * i] = (byte)(fileidbuf[2 * i]);                      m_pdf_fileid[2 * i + 1] = (byte)(fileidbuf[2 * i + 1]);                  }              }              else              {                  Random rnd = new Random(DateTime.Now.Millisecond);                  byte[] temp = new byte[16];                  rnd.NextBytes(temp);                    for (int i = 0; i < 16; i++)                  {                      string s = string.Format(CultureInfo.InvariantCulture' "{0:X2}"' temp[i]);                      m_pdf_fileid[i * 2] = (byte)s[0];                      m_pdf_fileid[i * 2 + 1] = (byte)s[1];                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: written += writeToFile(m_pdf_fileid' 32);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_trailer,The following statement contains a magic number: written += writeToFile(m_pdf_fileid' 32);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_stream_filter,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_G4:                      written += writeToFile("/CCITTFaxDecode ");                      written += writeToFile("/DecodeParms ");                      written += writeToFile("<< /K -1 ");                                            if (tile == 0)                      {                          written += writeToFile("/Columns ");                          buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_tiff_width);                          written += writeToFile(buffer);                          written += writeToFile(" /Rows ");                          buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_tiff_length);                          written += writeToFile(buffer);                      }                      else                      {                          if (!tile_is_right_edge(m_tiff_pages[m_pdf_page]' tile - 1))                          {                              written += writeToFile("/Columns ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                   "{0}"' m_tiff_pages[m_pdf_page].tiles_tilewidth);                              written += writeToFile(buffer);                          }                          else                          {                              written += writeToFile("/Columns ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                  "{0}"' m_tiff_pages[m_pdf_page].tiles_edgetilewidth);                              written += writeToFile(buffer);                          }                            if (!tile_is_bottom_edge(m_tiff_pages[m_pdf_page]' tile - 1))                          {                              written += writeToFile(" /Rows ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                  "{0}"' m_tiff_pages[m_pdf_page].tiles_tilelength);                              written += writeToFile(buffer);                          }                          else                          {                              written += writeToFile(" /Rows ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                  "{0}"' m_tiff_pages[m_pdf_page].tiles_edgetilelength);                              written += writeToFile(buffer);                          }                      }                        if (!m_pdf_switchdecode)                          written += writeToFile(" /BlackIs1 true ");                        written += writeToFile(">>\n");                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      written += writeToFile("/DCTDecode ");                        if (m_tiff_photometric != Photometric.YCBCR)                      {                          written += writeToFile("/DecodeParms ");                          written += writeToFile("<< /ColorTransform 0 >>\n");                      }                      break;                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      written += writeToFile("/FlateDecode ");                      if ((m_pdf_defaultcompressionquality % 100) != 0)                      {                          written += writeToFile("/DecodeParms ");                          written += writeToFile("<< /Predictor ");                          buffer = string.Format(CultureInfo.InvariantCulture'                               "{0}"' m_pdf_defaultcompressionquality % 100);                          written += writeToFile(buffer);                          written += writeToFile(" /Columns ");                          buffer = string.Format(CultureInfo.InvariantCulture'                              "{0}"' m_tiff_width);                          written += writeToFile(buffer);                          written += writeToFile(" /Colors ");                          buffer = string.Format(CultureInfo.InvariantCulture'                              "{0}"' m_tiff_samplesperpixel);                          written += writeToFile(buffer);                          written += writeToFile(" /BitsPerComponent ");                          buffer = string.Format(CultureInfo.InvariantCulture'                              "{0}"' m_tiff_bitspersample);                          written += writeToFile(buffer);                          written += writeToFile(">>\n");                      }                      break;                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_xobject_stream_filter,The following statement contains a magic number: switch (m_pdf_compression)              {                  case t2p_compress_t.T2P_COMPRESS_G4:                      written += writeToFile("/CCITTFaxDecode ");                      written += writeToFile("/DecodeParms ");                      written += writeToFile("<< /K -1 ");                                            if (tile == 0)                      {                          written += writeToFile("/Columns ");                          buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_tiff_width);                          written += writeToFile(buffer);                          written += writeToFile(" /Rows ");                          buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_tiff_length);                          written += writeToFile(buffer);                      }                      else                      {                          if (!tile_is_right_edge(m_tiff_pages[m_pdf_page]' tile - 1))                          {                              written += writeToFile("/Columns ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                   "{0}"' m_tiff_pages[m_pdf_page].tiles_tilewidth);                              written += writeToFile(buffer);                          }                          else                          {                              written += writeToFile("/Columns ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                  "{0}"' m_tiff_pages[m_pdf_page].tiles_edgetilewidth);                              written += writeToFile(buffer);                          }                            if (!tile_is_bottom_edge(m_tiff_pages[m_pdf_page]' tile - 1))                          {                              written += writeToFile(" /Rows ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                  "{0}"' m_tiff_pages[m_pdf_page].tiles_tilelength);                              written += writeToFile(buffer);                          }                          else                          {                              written += writeToFile(" /Rows ");                              buffer = string.Format(CultureInfo.InvariantCulture'                                  "{0}"' m_tiff_pages[m_pdf_page].tiles_edgetilelength);                              written += writeToFile(buffer);                          }                      }                        if (!m_pdf_switchdecode)                          written += writeToFile(" /BlackIs1 true ");                        written += writeToFile(">>\n");                      break;                                    case t2p_compress_t.T2P_COMPRESS_JPEG:                      written += writeToFile("/DCTDecode ");                        if (m_tiff_photometric != Photometric.YCBCR)                      {                          written += writeToFile("/DecodeParms ");                          written += writeToFile("<< /ColorTransform 0 >>\n");                      }                      break;                    case t2p_compress_t.T2P_COMPRESS_ZIP:                      written += writeToFile("/FlateDecode ");                      if ((m_pdf_defaultcompressionquality % 100) != 0)                      {                          written += writeToFile("/DecodeParms ");                          written += writeToFile("<< /Predictor ");                          buffer = string.Format(CultureInfo.InvariantCulture'                               "{0}"' m_pdf_defaultcompressionquality % 100);                          written += writeToFile(buffer);                          written += writeToFile(" /Columns ");                          buffer = string.Format(CultureInfo.InvariantCulture'                              "{0}"' m_tiff_width);                          written += writeToFile(buffer);                          written += writeToFile(" /Colors ");                          buffer = string.Format(CultureInfo.InvariantCulture'                              "{0}"' m_tiff_samplesperpixel);                          written += writeToFile(buffer);                          written += writeToFile(" /BitsPerComponent ");                          buffer = string.Format(CultureInfo.InvariantCulture'                              "{0}"' m_tiff_bitspersample);                          written += writeToFile(buffer);                          written += writeToFile(">>\n");                      }                      break;                    default:                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page_content_stream,The following statement contains a magic number: if (m_tiff_pages[m_pdf_page].page_tilecount > 0)              {                  for (int i = 0; i < m_tiff_pages[m_pdf_page].page_tilecount; i++)                  {                      T2P_BOX box = m_tiff_pages[m_pdf_page].tiles_tiles[i].tile_box;                      buffer = string.Format(CultureInfo.InvariantCulture'                           "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7}_{8} Do Q\n"'                           m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                           box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1' i + 1);                        byte[] bytes = Latin1Encoding.GetBytes(buffer);                      written += write_pdf_stream(bytes' bytes.Length);                  }              }              else              {                  T2P_BOX box = m_pdf_imagebox;                  buffer = string.Format(CultureInfo.InvariantCulture'                       "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7} Do Q\n"'                       m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                      box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1);                    byte[] bytes = Latin1Encoding.GetBytes(buffer);                  written += write_pdf_stream(bytes' bytes.Length);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page_content_stream,The following statement contains a magic number: if (m_tiff_pages[m_pdf_page].page_tilecount > 0)              {                  for (int i = 0; i < m_tiff_pages[m_pdf_page].page_tilecount; i++)                  {                      T2P_BOX box = m_tiff_pages[m_pdf_page].tiles_tiles[i].tile_box;                      buffer = string.Format(CultureInfo.InvariantCulture'                           "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7}_{8} Do Q\n"'                           m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                           box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1' i + 1);                        byte[] bytes = Latin1Encoding.GetBytes(buffer);                      written += write_pdf_stream(bytes' bytes.Length);                  }              }              else              {                  T2P_BOX box = m_pdf_imagebox;                  buffer = string.Format(CultureInfo.InvariantCulture'                       "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7} Do Q\n"'                       m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                      box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1);                    byte[] bytes = Latin1Encoding.GetBytes(buffer);                  written += write_pdf_stream(bytes' bytes.Length);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page_content_stream,The following statement contains a magic number: if (m_tiff_pages[m_pdf_page].page_tilecount > 0)              {                  for (int i = 0; i < m_tiff_pages[m_pdf_page].page_tilecount; i++)                  {                      T2P_BOX box = m_tiff_pages[m_pdf_page].tiles_tiles[i].tile_box;                      buffer = string.Format(CultureInfo.InvariantCulture'                           "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7}_{8} Do Q\n"'                           m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                           box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1' i + 1);                        byte[] bytes = Latin1Encoding.GetBytes(buffer);                      written += write_pdf_stream(bytes' bytes.Length);                  }              }              else              {                  T2P_BOX box = m_pdf_imagebox;                  buffer = string.Format(CultureInfo.InvariantCulture'                       "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7} Do Q\n"'                       m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                      box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1);                    byte[] bytes = Latin1Encoding.GetBytes(buffer);                  written += write_pdf_stream(bytes' bytes.Length);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page_content_stream,The following statement contains a magic number: if (m_tiff_pages[m_pdf_page].page_tilecount > 0)              {                  for (int i = 0; i < m_tiff_pages[m_pdf_page].page_tilecount; i++)                  {                      T2P_BOX box = m_tiff_pages[m_pdf_page].tiles_tiles[i].tile_box;                      buffer = string.Format(CultureInfo.InvariantCulture'                           "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7}_{8} Do Q\n"'                           m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                           box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1' i + 1);                        byte[] bytes = Latin1Encoding.GetBytes(buffer);                      written += write_pdf_stream(bytes' bytes.Length);                  }              }              else              {                  T2P_BOX box = m_pdf_imagebox;                  buffer = string.Format(CultureInfo.InvariantCulture'                       "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7} Do Q\n"'                       m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                      box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1);                    byte[] bytes = Latin1Encoding.GetBytes(buffer);                  written += write_pdf_stream(bytes' bytes.Length);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page_content_stream,The following statement contains a magic number: if (m_tiff_pages[m_pdf_page].page_tilecount > 0)              {                  for (int i = 0; i < m_tiff_pages[m_pdf_page].page_tilecount; i++)                  {                      T2P_BOX box = m_tiff_pages[m_pdf_page].tiles_tiles[i].tile_box;                      buffer = string.Format(CultureInfo.InvariantCulture'                           "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7}_{8} Do Q\n"'                           m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                           box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1' i + 1);                        byte[] bytes = Latin1Encoding.GetBytes(buffer);                      written += write_pdf_stream(bytes' bytes.Length);                  }              }              else              {                  T2P_BOX box = m_pdf_imagebox;                  buffer = string.Format(CultureInfo.InvariantCulture'                       "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7} Do Q\n"'                       m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                      box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1);                    byte[] bytes = Latin1Encoding.GetBytes(buffer);                  written += write_pdf_stream(bytes' bytes.Length);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page_content_stream,The following statement contains a magic number: if (m_tiff_pages[m_pdf_page].page_tilecount > 0)              {                  for (int i = 0; i < m_tiff_pages[m_pdf_page].page_tilecount; i++)                  {                      T2P_BOX box = m_tiff_pages[m_pdf_page].tiles_tiles[i].tile_box;                      buffer = string.Format(CultureInfo.InvariantCulture'                           "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7}_{8} Do Q\n"'                           m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                           box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1' i + 1);                        byte[] bytes = Latin1Encoding.GetBytes(buffer);                      written += write_pdf_stream(bytes' bytes.Length);                  }              }              else              {                  T2P_BOX box = m_pdf_imagebox;                  buffer = string.Format(CultureInfo.InvariantCulture'                       "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7} Do Q\n"'                       m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                      box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1);                    byte[] bytes = Latin1Encoding.GetBytes(buffer);                  written += write_pdf_stream(bytes' bytes.Length);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page_content_stream,The following statement contains a magic number: if (m_tiff_pages[m_pdf_page].page_tilecount > 0)              {                  for (int i = 0; i < m_tiff_pages[m_pdf_page].page_tilecount; i++)                  {                      T2P_BOX box = m_tiff_pages[m_pdf_page].tiles_tiles[i].tile_box;                      buffer = string.Format(CultureInfo.InvariantCulture'                           "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7}_{8} Do Q\n"'                           m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                           box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1' i + 1);                        byte[] bytes = Latin1Encoding.GetBytes(buffer);                      written += write_pdf_stream(bytes' bytes.Length);                  }              }              else              {                  T2P_BOX box = m_pdf_imagebox;                  buffer = string.Format(CultureInfo.InvariantCulture'                       "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7} Do Q\n"'                       m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                      box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1);                    byte[] bytes = Latin1Encoding.GetBytes(buffer);                  written += write_pdf_stream(bytes' bytes.Length);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page_content_stream,The following statement contains a magic number: if (m_tiff_pages[m_pdf_page].page_tilecount > 0)              {                  for (int i = 0; i < m_tiff_pages[m_pdf_page].page_tilecount; i++)                  {                      T2P_BOX box = m_tiff_pages[m_pdf_page].tiles_tiles[i].tile_box;                      buffer = string.Format(CultureInfo.InvariantCulture'                           "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7}_{8} Do Q\n"'                           m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                           box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1' i + 1);                        byte[] bytes = Latin1Encoding.GetBytes(buffer);                      written += write_pdf_stream(bytes' bytes.Length);                  }              }              else              {                  T2P_BOX box = m_pdf_imagebox;                  buffer = string.Format(CultureInfo.InvariantCulture'                       "q {0} {1:F4} {2:F4} {3:F4} {4:F4} {5:F4} {6:F4} cm /Im{7} Do Q\n"'                       m_tiff_transferfunctioncount != 0 ? "/GS1 gs " : ""' box.mat[0]' box.mat[1]'                      box.mat[3]' box.mat[4]' box.mat[6]' box.mat[7]' m_pdf_page + 1);                    byte[] bytes = Latin1Encoding.GetBytes(buffer);                  written += write_pdf_stream(bytes' bytes.Length);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,process_jpeg_strip,The following statement contains a magic number: while (i < striplength)              {                  switch (strip[i])                  {                      case 0xd8:                          i += 2;                          break;                        case 0xc0:                      case 0xc1:                      case 0xc3:                      case 0xc9:                      case 0xca:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                                                            short v_samp = 1;                              short h_samp = 1;                              for (int j = 0; j < buffer[bufferoffset + 9]; j++)                              {                                  if ((buffer[bufferoffset + 11 + (2 * j)] >> 4) > h_samp)                                      h_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] >> 4);                                    if ((buffer[bufferoffset + 11 + (2 * j)] & 0x0f) > v_samp)                                      v_samp = (short)(buffer[bufferoffset + 11 + (2 * j)] & 0x0f);                              }                                v_samp *= 8;                              h_samp *= 8;                              short ri = (short)((((buffer[bufferoffset + 5] << 8) | buffer[bufferoffset + 6]) + v_samp - 1) / v_samp);                              ri *= (short)((((buffer[bufferoffset + 7] << 8) | buffer[bufferoffset + 8]) + h_samp - 1) / h_samp);                              buffer[bufferoffset + 5] = (byte)((height >> 8) & 0xff);                              buffer[bufferoffset + 6] = (byte)(height & 0xff);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                                if (stripCount > 1)                              {                                  buffer[bufferoffset++] = 0xff;                                  buffer[bufferoffset++] = 0xdd;                                  buffer[bufferoffset++] = 0x00;                                  buffer[bufferoffset++] = 0x04;                                  buffer[bufferoffset++] = (byte)((ri >> 8) & 0xff);                                  buffer[bufferoffset++] = (byte)(ri & 0xff);                              }                          }                          else                          {                              i += strip[i + 2] + 2;                          }                          break;                        case 0xc4:                      case 0xdb:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                          }                          i += strip[i + 2] + 2;                          break;                        case 0xda:                          if (no == 0)                          {                              Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' strip[i + 2] + 2);                              bufferoffset += strip[i + 2] + 2;                              i += strip[i + 2] + 2;                          }                          else                          {                              buffer[bufferoffset++] = 0xff;                              buffer[bufferoffset++] = (byte)(0xd0 | ((no - 1) % 8));                              i += strip[i + 2] + 2;                          }                            Buffer.BlockCopy(strip' i - 1' buffer' bufferoffset' striplength - i - 1);                          bufferoffset += striplength - i - 1;                          return true;                        default:                          i += strip[i + 2] + 2;                          break;                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)              {                  int sample = data32[i];                  byte alpha = (byte)(255 - ((sample >> 24) & 0xff));                  data[i * 3] = (byte)(((sample >> 16) & 0xff) + alpha);                  data[i * 3 + 1] = (byte)(((sample >> 8) & 0xff) + alpha);                  data[i * 3 + 2] = (byte)((sample & 0xff) + alpha);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)              {                  int sample = data32[i];                  byte alpha = (byte)(255 - ((sample >> 24) & 0xff));                  data[i * 3] = (byte)(((sample >> 16) & 0xff) + alpha);                  data[i * 3 + 1] = (byte)(((sample >> 8) & 0xff) + alpha);                  data[i * 3 + 2] = (byte)((sample & 0xff) + alpha);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)              {                  int sample = data32[i];                  byte alpha = (byte)(255 - ((sample >> 24) & 0xff));                  data[i * 3] = (byte)(((sample >> 16) & 0xff) + alpha);                  data[i * 3 + 1] = (byte)(((sample >> 8) & 0xff) + alpha);                  data[i * 3 + 2] = (byte)((sample & 0xff) + alpha);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)              {                  int sample = data32[i];                  byte alpha = (byte)(255 - ((sample >> 24) & 0xff));                  data[i * 3] = (byte)(((sample >> 16) & 0xff) + alpha);                  data[i * 3 + 1] = (byte)(((sample >> 8) & 0xff) + alpha);                  data[i * 3 + 2] = (byte)((sample & 0xff) + alpha);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)              {                  int sample = data32[i];                  byte alpha = (byte)(255 - ((sample >> 24) & 0xff));                  data[i * 3] = (byte)(((sample >> 16) & 0xff) + alpha);                  data[i * 3 + 1] = (byte)(((sample >> 8) & 0xff) + alpha);                  data[i * 3 + 2] = (byte)((sample & 0xff) + alpha);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)              {                  int sample = data32[i];                  byte alpha = (byte)(255 - ((sample >> 24) & 0xff));                  data[i * 3] = (byte)(((sample >> 16) & 0xff) + alpha);                  data[i * 3 + 1] = (byte)(((sample >> 8) & 0xff) + alpha);                  data[i * 3 + 2] = (byte)((sample & 0xff) + alpha);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)              {                  int sample = data32[i];                  byte alpha = (byte)(255 - ((sample >> 24) & 0xff));                  data[i * 3] = (byte)(((sample >> 16) & 0xff) + alpha);                  data[i * 3 + 1] = (byte)(((sample >> 8) & 0xff) + alpha);                  data[i * 3 + 2] = (byte)((sample & 0xff) + alpha);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)              {                  int sample = data32[i];                  byte alpha = (byte)(255 - ((sample >> 24) & 0xff));                  data[i * 3] = (byte)(((sample >> 16) & 0xff) + alpha);                  data[i * 3 + 1] = (byte)(((sample >> 8) & 0xff) + alpha);                  data[i * 3 + 2] = (byte)((sample & 0xff) + alpha);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgba_to_rgb,The following statement contains a magic number: return (i * 3);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgbaa_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)                  Buffer.BlockCopy(data' i * 4' data' i * 3' 3);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgbaa_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)                  Buffer.BlockCopy(data' i * 4' data' i * 3' 3);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgbaa_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)                  Buffer.BlockCopy(data' i * 4' data' i * 3' 3);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_rgbaa_to_rgb,The following statement contains a magic number: return (i * 3);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_abgr_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)              {                  int sample = data32[i];                  data[i * 3] = (byte)(sample & 0xff);                  data[i * 3 + 1] = (byte)((sample >> 8) & 0xff);                  data[i * 3 + 2] = (byte)((sample >> 16) & 0xff);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_abgr_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)              {                  int sample = data32[i];                  data[i * 3] = (byte)(sample & 0xff);                  data[i * 3 + 1] = (byte)((sample >> 8) & 0xff);                  data[i * 3 + 2] = (byte)((sample >> 16) & 0xff);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_abgr_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)              {                  int sample = data32[i];                  data[i * 3] = (byte)(sample & 0xff);                  data[i * 3 + 1] = (byte)((sample >> 8) & 0xff);                  data[i * 3 + 2] = (byte)((sample >> 16) & 0xff);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_abgr_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)              {                  int sample = data32[i];                  data[i * 3] = (byte)(sample & 0xff);                  data[i * 3 + 1] = (byte)((sample >> 8) & 0xff);                  data[i * 3 + 2] = (byte)((sample >> 16) & 0xff);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_abgr_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)              {                  int sample = data32[i];                  data[i * 3] = (byte)(sample & 0xff);                  data[i * 3 + 1] = (byte)((sample >> 8) & 0xff);                  data[i * 3 + 2] = (byte)((sample >> 16) & 0xff);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_abgr_to_rgb,The following statement contains a magic number: for ( ; i < samplecount; i++)              {                  int sample = data32[i];                  data[i * 3] = (byte)(sample & 0xff);                  data[i * 3 + 1] = (byte)((sample >> 8) & 0xff);                  data[i * 3 + 2] = (byte)((sample >> 16) & 0xff);              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_abgr_to_rgb,The following statement contains a magic number: return (i * 3);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: for (int i = 0; i < samplecount; i++)              {                  if ((buffer[i * 3 + 1] & 0x80) != 0)                      buffer[i * 3 + 1] = (byte)(0x80 + (sbyte)buffer[i * 3 + 1]); // cast to signed int is important                  else                      buffer[i * 3 + 1] |= 0x80;                    if ((buffer[i * 3 + 2] & 0x80) != 0)                      buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);                  else                      buffer[i * 3 + 2] |= 0x80;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: for (int i = 0; i < samplecount; i++)              {                  if ((buffer[i * 3 + 1] & 0x80) != 0)                      buffer[i * 3 + 1] = (byte)(0x80 + (sbyte)buffer[i * 3 + 1]); // cast to signed int is important                  else                      buffer[i * 3 + 1] |= 0x80;                    if ((buffer[i * 3 + 2] & 0x80) != 0)                      buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);                  else                      buffer[i * 3 + 2] |= 0x80;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: for (int i = 0; i < samplecount; i++)              {                  if ((buffer[i * 3 + 1] & 0x80) != 0)                      buffer[i * 3 + 1] = (byte)(0x80 + (sbyte)buffer[i * 3 + 1]); // cast to signed int is important                  else                      buffer[i * 3 + 1] |= 0x80;                    if ((buffer[i * 3 + 2] & 0x80) != 0)                      buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);                  else                      buffer[i * 3 + 2] |= 0x80;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: for (int i = 0; i < samplecount; i++)              {                  if ((buffer[i * 3 + 1] & 0x80) != 0)                      buffer[i * 3 + 1] = (byte)(0x80 + (sbyte)buffer[i * 3 + 1]); // cast to signed int is important                  else                      buffer[i * 3 + 1] |= 0x80;                    if ((buffer[i * 3 + 2] & 0x80) != 0)                      buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);                  else                      buffer[i * 3 + 2] |= 0x80;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: for (int i = 0; i < samplecount; i++)              {                  if ((buffer[i * 3 + 1] & 0x80) != 0)                      buffer[i * 3 + 1] = (byte)(0x80 + (sbyte)buffer[i * 3 + 1]); // cast to signed int is important                  else                      buffer[i * 3 + 1] |= 0x80;                    if ((buffer[i * 3 + 2] & 0x80) != 0)                      buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);                  else                      buffer[i * 3 + 2] |= 0x80;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: for (int i = 0; i < samplecount; i++)              {                  if ((buffer[i * 3 + 1] & 0x80) != 0)                      buffer[i * 3 + 1] = (byte)(0x80 + (sbyte)buffer[i * 3 + 1]); // cast to signed int is important                  else                      buffer[i * 3 + 1] |= 0x80;                    if ((buffer[i * 3 + 2] & 0x80) != 0)                      buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);                  else                      buffer[i * 3 + 2] |= 0x80;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: for (int i = 0; i < samplecount; i++)              {                  if ((buffer[i * 3 + 1] & 0x80) != 0)                      buffer[i * 3 + 1] = (byte)(0x80 + (sbyte)buffer[i * 3 + 1]); // cast to signed int is important                  else                      buffer[i * 3 + 1] |= 0x80;                    if ((buffer[i * 3 + 2] & 0x80) != 0)                      buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);                  else                      buffer[i * 3 + 2] |= 0x80;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: for (int i = 0; i < samplecount; i++)              {                  if ((buffer[i * 3 + 1] & 0x80) != 0)                      buffer[i * 3 + 1] = (byte)(0x80 + (sbyte)buffer[i * 3 + 1]); // cast to signed int is important                  else                      buffer[i * 3 + 1] |= 0x80;                    if ((buffer[i * 3 + 2] & 0x80) != 0)                      buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);                  else                      buffer[i * 3 + 2] |= 0x80;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: for (int i = 0; i < samplecount; i++)              {                  if ((buffer[i * 3 + 1] & 0x80) != 0)                      buffer[i * 3 + 1] = (byte)(0x80 + (sbyte)buffer[i * 3 + 1]); // cast to signed int is important                  else                      buffer[i * 3 + 1] |= 0x80;                    if ((buffer[i * 3 + 2] & 0x80) != 0)                      buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);                  else                      buffer[i * 3 + 2] |= 0x80;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: for (int i = 0; i < samplecount; i++)              {                  if ((buffer[i * 3 + 1] & 0x80) != 0)                      buffer[i * 3 + 1] = (byte)(0x80 + (sbyte)buffer[i * 3 + 1]); // cast to signed int is important                  else                      buffer[i * 3 + 1] |= 0x80;                    if ((buffer[i * 3 + 2] & 0x80) != 0)                      buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);                  else                      buffer[i * 3 + 2] |= 0x80;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: for (int i = 0; i < samplecount; i++)              {                  if ((buffer[i * 3 + 1] & 0x80) != 0)                      buffer[i * 3 + 1] = (byte)(0x80 + (sbyte)buffer[i * 3 + 1]); // cast to signed int is important                  else                      buffer[i * 3 + 1] |= 0x80;                    if ((buffer[i * 3 + 2] & 0x80) != 0)                      buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);                  else                      buffer[i * 3 + 2] |= 0x80;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: for (int i = 0; i < samplecount; i++)              {                  if ((buffer[i * 3 + 1] & 0x80) != 0)                      buffer[i * 3 + 1] = (byte)(0x80 + (sbyte)buffer[i * 3 + 1]); // cast to signed int is important                  else                      buffer[i * 3 + 1] |= 0x80;                    if ((buffer[i * 3 + 2] & 0x80) != 0)                      buffer[i * 3 + 2] = (byte)(0x80 + (sbyte)buffer[i * 3 + 2]);                  else                      buffer[i * 3 + 2] |= 0x80;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,sample_lab_signed_to_unsigned,The following statement contains a magic number: return (samplecount * 3);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,encodeOctalString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' @"\{0}{1}{2}"' (x >> 6) & 7' (x >> 3) & 7' x & 7);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,encodeOctalString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' @"\{0}{1}{2}"' (x >> 6) & 7' (x >> 3) & 7' x & 7);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,encodeOctalString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' @"\{0}{1}{2}"' (x >> 6) & 7' (x >> 3) & 7' x & 7);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,encodeOctalString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' @"\{0}{1}{2}"' (x >> 6) & 7' (x >> 3) & 7' x & 7);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,encodeOctalString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' @"\{0}{1}{2}"' (x >> 6) & 7' (x >> 3) & 7' x & 7);
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_string,The following statement contains a magic number: for (int i = 0; i < len; i++)              {                  if ((pdfstr[i] & 0x80) != 0 || (pdfstr[i] == 127) || (pdfstr[i] < 32))                  {                      string buffer = string.Format(CultureInfo.InvariantCulture'                           "{0}"' encodeOctalString(pdfstr[i]));                      written += writeToFile(buffer);                  }                  else                  {                      switch (pdfstr[i])                      {                          case 0x08:                              written += writeToFile("\\b");                              break;                          case 0x09:                              written += writeToFile("\\t");                              break;                          case 0x0A:                              written += writeToFile("\\n");                              break;                          case 0x0C:                              written += writeToFile("\\f");                              break;                          case 0x0D:                              written += writeToFile("\\r");                              break;                          case 0x28:                              written += writeToFile("\\(");                              break;                          case 0x29:                              written += writeToFile("\\)");                              break;                          case 0x5C:                              written += writeToFile("\\\\");                              break;                          default:                              byte[] b = new byte[1];                              b[0] = pdfstr[i];                              written += writeToFile(b' 1);                              break;                      }                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_string,The following statement contains a magic number: for (int i = 0; i < len; i++)              {                  if ((pdfstr[i] & 0x80) != 0 || (pdfstr[i] == 127) || (pdfstr[i] < 32))                  {                      string buffer = string.Format(CultureInfo.InvariantCulture'                           "{0}"' encodeOctalString(pdfstr[i]));                      written += writeToFile(buffer);                  }                  else                  {                      switch (pdfstr[i])                      {                          case 0x08:                              written += writeToFile("\\b");                              break;                          case 0x09:                              written += writeToFile("\\t");                              break;                          case 0x0A:                              written += writeToFile("\\n");                              break;                          case 0x0C:                              written += writeToFile("\\f");                              break;                          case 0x0D:                              written += writeToFile("\\r");                              break;                          case 0x28:                              written += writeToFile("\\(");                              break;                          case 0x29:                              written += writeToFile("\\)");                              break;                          case 0x5C:                              written += writeToFile("\\\\");                              break;                          default:                              byte[] b = new byte[1];                              b[0] = pdfstr[i];                              written += writeToFile(b' 1);                              break;                      }                  }              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: float[] m1 = new float[9];
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[2] = m1[2] = 0.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[2] = m1[2] = 0.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[3] = m1[3] = 0.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[3] = m1[3] = 0.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[4] = m1[4] = boxp.y2 - boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[4] = m1[4] = boxp.y2 - boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[5] = m1[5] = 0.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[5] = m1[5] = 0.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[6] = m1[6] = boxp.x1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[6] = m1[6] = boxp.x1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[7] = m1[7] = boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[7] = m1[7] = boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[8] = m1[8] = 1.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: boxp.mat[8] = m1[8] = 1.0f;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following statement contains a magic number: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: float[] m1 = new float[9];
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[2] = m1[2] = 0.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[2] = m1[2] = 0.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[3] = m1[3] = 0.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[3] = m1[3] = 0.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[4] = m1[4] = boxp.y2 - boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[4] = m1[4] = boxp.y2 - boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[5] = m1[5] = 0.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[5] = m1[5] = 0.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[6] = m1[6] = boxp.x1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[6] = m1[6] = boxp.x1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[7] = m1[7] = boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[7] = m1[7] = boxp.y1;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[8] = m1[8] = 1.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: boxp.mat[8] = m1[8] = 1.0F;
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following statement contains a magic number: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page,The following statement contains a magic number: if (m_tiff_pages[m_pdf_page].page_tilecount != 0)              {                  written += writeToFile("/XObject <<\n");                  for (int i = 0; i < m_tiff_pages[m_pdf_page].page_tilecount; i++)                  {                      written += writeToFile("/Im");                      buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_page + 1);                      written += writeToFile(buffer);                      written += writeToFile("_");                      buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' i + 1);                      written += writeToFile(buffer);                      written += writeToFile(" ");                      buffer = string.Format(CultureInfo.InvariantCulture'                          "{0}"' obj + 3 + 2 * i + m_tiff_pages[m_pdf_page].page_extra);                      written += writeToFile(buffer);                      written += writeToFile(" 0 R ");                      if (i % 4 == 3)                          written += writeToFile("\n");                  }                                    written += writeToFile(">>\n");              }              else              {                  written += writeToFile("/XObject <<\n");                  written += writeToFile("/Im");                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_page + 1);                  written += writeToFile(buffer);                  written += writeToFile(" ");                  buffer = string.Format(CultureInfo.InvariantCulture'                       "{0}"' obj + 3 + m_tiff_pages[m_pdf_page].page_extra);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                  written += writeToFile(">>\n");              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page,The following statement contains a magic number: if (m_tiff_pages[m_pdf_page].page_tilecount != 0)              {                  written += writeToFile("/XObject <<\n");                  for (int i = 0; i < m_tiff_pages[m_pdf_page].page_tilecount; i++)                  {                      written += writeToFile("/Im");                      buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_page + 1);                      written += writeToFile(buffer);                      written += writeToFile("_");                      buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' i + 1);                      written += writeToFile(buffer);                      written += writeToFile(" ");                      buffer = string.Format(CultureInfo.InvariantCulture'                          "{0}"' obj + 3 + 2 * i + m_tiff_pages[m_pdf_page].page_extra);                      written += writeToFile(buffer);                      written += writeToFile(" 0 R ");                      if (i % 4 == 3)                          written += writeToFile("\n");                  }                                    written += writeToFile(">>\n");              }              else              {                  written += writeToFile("/XObject <<\n");                  written += writeToFile("/Im");                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_page + 1);                  written += writeToFile(buffer);                  written += writeToFile(" ");                  buffer = string.Format(CultureInfo.InvariantCulture'                       "{0}"' obj + 3 + m_tiff_pages[m_pdf_page].page_extra);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                  written += writeToFile(">>\n");              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page,The following statement contains a magic number: if (m_tiff_pages[m_pdf_page].page_tilecount != 0)              {                  written += writeToFile("/XObject <<\n");                  for (int i = 0; i < m_tiff_pages[m_pdf_page].page_tilecount; i++)                  {                      written += writeToFile("/Im");                      buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_page + 1);                      written += writeToFile(buffer);                      written += writeToFile("_");                      buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' i + 1);                      written += writeToFile(buffer);                      written += writeToFile(" ");                      buffer = string.Format(CultureInfo.InvariantCulture'                          "{0}"' obj + 3 + 2 * i + m_tiff_pages[m_pdf_page].page_extra);                      written += writeToFile(buffer);                      written += writeToFile(" 0 R ");                      if (i % 4 == 3)                          written += writeToFile("\n");                  }                                    written += writeToFile(">>\n");              }              else              {                  written += writeToFile("/XObject <<\n");                  written += writeToFile("/Im");                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_page + 1);                  written += writeToFile(buffer);                  written += writeToFile(" ");                  buffer = string.Format(CultureInfo.InvariantCulture'                       "{0}"' obj + 3 + m_tiff_pages[m_pdf_page].page_extra);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                  written += writeToFile(">>\n");              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page,The following statement contains a magic number: if (m_tiff_pages[m_pdf_page].page_tilecount != 0)              {                  written += writeToFile("/XObject <<\n");                  for (int i = 0; i < m_tiff_pages[m_pdf_page].page_tilecount; i++)                  {                      written += writeToFile("/Im");                      buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_page + 1);                      written += writeToFile(buffer);                      written += writeToFile("_");                      buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' i + 1);                      written += writeToFile(buffer);                      written += writeToFile(" ");                      buffer = string.Format(CultureInfo.InvariantCulture'                          "{0}"' obj + 3 + 2 * i + m_tiff_pages[m_pdf_page].page_extra);                      written += writeToFile(buffer);                      written += writeToFile(" 0 R ");                      if (i % 4 == 3)                          written += writeToFile("\n");                  }                                    written += writeToFile(">>\n");              }              else              {                  written += writeToFile("/XObject <<\n");                  written += writeToFile("/Im");                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_page + 1);                  written += writeToFile(buffer);                  written += writeToFile(" ");                  buffer = string.Format(CultureInfo.InvariantCulture'                       "{0}"' obj + 3 + m_tiff_pages[m_pdf_page].page_extra);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                  written += writeToFile(">>\n");              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page,The following statement contains a magic number: if (m_tiff_pages[m_pdf_page].page_tilecount != 0)              {                  written += writeToFile("/XObject <<\n");                  for (int i = 0; i < m_tiff_pages[m_pdf_page].page_tilecount; i++)                  {                      written += writeToFile("/Im");                      buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_page + 1);                      written += writeToFile(buffer);                      written += writeToFile("_");                      buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' i + 1);                      written += writeToFile(buffer);                      written += writeToFile(" ");                      buffer = string.Format(CultureInfo.InvariantCulture'                          "{0}"' obj + 3 + 2 * i + m_tiff_pages[m_pdf_page].page_extra);                      written += writeToFile(buffer);                      written += writeToFile(" 0 R ");                      if (i % 4 == 3)                          written += writeToFile("\n");                  }                                    written += writeToFile(">>\n");              }              else              {                  written += writeToFile("/XObject <<\n");                  written += writeToFile("/Im");                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' m_pdf_page + 1);                  written += writeToFile(buffer);                  written += writeToFile(" ");                  buffer = string.Format(CultureInfo.InvariantCulture'                       "{0}"' obj + 3 + m_tiff_pages[m_pdf_page].page_extra);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                  written += writeToFile(">>\n");              }
Magic Number,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,write_pdf_page,The following statement contains a magic number: if (m_tiff_transferfunctioncount != 0)              {                  written += writeToFile("/ExtGState <<");                  writeToFile("/GS1 ");                  buffer = string.Format(CultureInfo.InvariantCulture' "{0}"' obj + 3);                  written += writeToFile(buffer);                  written += writeToFile(" 0 R ");                  written += writeToFile(">> \n");              }
Missing Default,BitMiracle.Tiff2Pdf,Program,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\Program.cs,Main,The following switch statement is missing a default case: switch (arg[0])                  {                      case 'o':                          outfilename = optarg;                          argn++;                          break;                        case 'j':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_JPEG;                          break;                        case 'z':                            t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_ZIP;                          break;                                            case 'q':                           t2p.m_pdf_defaultcompressionquality = short.Parse(optarg' CultureInfo.InvariantCulture);                          argn++;                          break;                                            case 'n':                           t2p.m_pdf_nopassthrough = true;                          break;                                            case 'd':                           t2p.m_pdf_defaultcompression = t2p_compress_t.T2P_COMPRESS_NONE;                          break;                                            case 'u':                           if (optarg[0] == 'm')                              t2p.m_pdf_centimeters = true;                            argn++;                          break;                        case 'x':                           t2p.m_pdf_defaultxres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'y':                          t2p.m_pdf_defaultyres = float.Parse(optarg' CultureInfo.InvariantCulture) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'w':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagewidth = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'l':                           t2p.m_pdf_overridepagesize = true;                          t2p.m_pdf_defaultpagelength = (float.Parse(optarg' CultureInfo.InvariantCulture) * Tiff2PdfConstants.PS_UNIT_SIZE) / (t2p.m_pdf_centimeters ? 2.54F : 1.0F);                          argn++;                          break;                        case 'r':                           if (optarg[0] == 'o')                              t2p.m_pdf_overrideres = true;                            argn++;                          break;                        case 'p':                           if (tiff2pdf_match_paper_size(out t2p.m_pdf_defaultpagewidth' out t2p.m_pdf_defaultpagelength' optarg))                              t2p.m_pdf_overridepagesize = true;                          else                              Tiff.Warning(Tiff2PdfConstants.TIFF2PDF_MODULE' "Unknown paper size {0}' ignoring option"' optarg);                            argn++;                          break;                        case 'i':                          t2p.m_pdf_colorspace_invert = true;                          break;                        case 'f':                           t2p.m_pdf_fitwindow = true;                          break;                        case 'e':                          t2p.m_pdf_datetime = new byte [17];                          if (optarg.Length == 0)                          {                              t2p.m_pdf_datetime[0] = 0;                          }                          else                          {                              t2p.m_pdf_datetime[0] = (byte)'D';                              t2p.m_pdf_datetime[1] = (byte)':';                                bytes = T2P.Latin1Encoding.GetBytes(optarg);                              Buffer.BlockCopy(bytes' 0' t2p.m_pdf_datetime' 2' Math.Min(bytes.Length' 14));                          }                            argn++;                          break;                        case 'c':                          t2p.m_pdf_creator = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 'a':                          t2p.m_pdf_author = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 't':                          t2p.m_pdf_title = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                                            case 's':                          t2p.m_pdf_subject = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'k':                          t2p.m_pdf_keywords = T2P.Latin1Encoding.GetBytes(optarg);                          argn++;                          break;                        case 'b':                          t2p.m_pdf_image_interpolate = true;                          break;                        case 'h':                       case '?':                           tiff2pdf_usage();                          return;                  }
Missing Default,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient,The following switch statement is missing a default case: switch (orientation)              {                  case 0:                  case Orientation.TOPLEFT:                      break;                    case Orientation.TOPRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[6] += m1[0];                      break;                    case Orientation.BOTRIGHT:                      boxp.mat[0] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.BOTLEFT:                      boxp.mat[4] = 0.0F - m1[4];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[0];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = m1[4];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[0];                      boxp.mat[3] = 0.0F - m1[4];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[4];                      break;              }
Missing Default,BitMiracle.Tiff2Pdf,T2P,C:\repos\BitMiracle_libtiff.net\Tiff2Pdf\T2P.cs,compose_pdf_page_orient_flip,The following switch statement is missing a default case: switch (orientation)              {                  case Orientation.LEFTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTTOP:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = 0.0F - m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[7] += m1[4];                      break;                    case Orientation.RIGHTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = m1[0];                      boxp.mat[4] = 0.0F;                      break;                    case Orientation.LEFTBOT:                      boxp.mat[0] = 0.0F;                      boxp.mat[1] = m1[4];                      boxp.mat[3] = 0.0F - m1[0];                      boxp.mat[4] = 0.0F;                      boxp.mat[6] += m1[0];                      break;              }
