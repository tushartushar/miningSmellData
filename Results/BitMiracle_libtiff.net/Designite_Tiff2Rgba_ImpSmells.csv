Implementation smell,Namespace,Class,File,Method,Description
Complex Method,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_by_tile,Cyclomatic complexity of the method is 8
Complex Method,BitMiracle.Tiff2Rgba,Program,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Program.cs,Main,Cyclomatic complexity of the method is 27
Long Statement,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The length of the statement  "		Tiff.Error (inImage' inImage.FileName ()' "Malformed input file; can't allocate buffer for raster of {0}x{1} size"' width' height); " is 131.
Long Statement,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The length of the statement  "	/* Read the image in one chunk into an RGBA array */if (!inImage.ReadRGBAImageOriented (width' height' raster' Orientation.TOPLEFT' false)) " is 139.
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,tiffcvt,The following statement contains a magic number: outImage.SetField (TiffTag.BITSPERSAMPLE' 8);  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,tiffcvt,The following statement contains a magic number: if (m_noAlpha)  	outImage.SetField (TiffTag.SAMPLESPERPIXEL' 3);  else  	outImage.SetField (TiffTag.SAMPLESPERPIXEL' 4);  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,tiffcvt,The following statement contains a magic number: if (m_noAlpha)  	outImage.SetField (TiffTag.SAMPLESPERPIXEL' 3);  else  	outImage.SetField (TiffTag.SAMPLESPERPIXEL' 4);  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,tiffcvt,The following statement contains a magic number: outImage.SetField (TiffTag.SAMPLESPERPIXEL' 3);  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,tiffcvt,The following statement contains a magic number: outImage.SetField (TiffTag.SAMPLESPERPIXEL' 4);  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_by_tile,The following statement contains a magic number: for (int row = 0; row < height; row += tile_height) {  	for (int col = 0; col < width; col += tile_width) {  		// Read the tile into an RGBA array  		if (!inImage.ReadRGBATile (col' row' raster))  			return false;  		// For some reason the ReadRGBATile() function chooses the lower left corner  		// as the origin. Vertically mirror scanlines.  		for (int i_row = 0; i_row < tile_height / 2; i_row++) {  			int topIndex = tile_width * i_row * sizeof(int);  			int bottomIndex = tile_width * (tile_height - i_row - 1) * sizeof(int);  			Buffer.BlockCopy (raster' topIndex' wrk_line' 0' tile_width * sizeof(int));  			Buffer.BlockCopy (raster' bottomIndex' raster' topIndex' tile_width * sizeof(int));  			Buffer.BlockCopy (wrk_line' 0' raster' bottomIndex' tile_width * sizeof(int));  		}  		// Write out the result in a tile.  		int tile = outImage.ComputeTile (col' row' 0' 0);  		Buffer.BlockCopy (raster' 0' rasterBytes' 0' rasterByteSize);  		if (outImage.WriteEncodedTile (tile' rasterBytes' rasterByteSize) == -1)  			return false;  	}  }  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_by_tile,The following statement contains a magic number: for (int col = 0; col < width; col += tile_width) {  	// Read the tile into an RGBA array  	if (!inImage.ReadRGBATile (col' row' raster))  		return false;  	// For some reason the ReadRGBATile() function chooses the lower left corner  	// as the origin. Vertically mirror scanlines.  	for (int i_row = 0; i_row < tile_height / 2; i_row++) {  		int topIndex = tile_width * i_row * sizeof(int);  		int bottomIndex = tile_width * (tile_height - i_row - 1) * sizeof(int);  		Buffer.BlockCopy (raster' topIndex' wrk_line' 0' tile_width * sizeof(int));  		Buffer.BlockCopy (raster' bottomIndex' raster' topIndex' tile_width * sizeof(int));  		Buffer.BlockCopy (wrk_line' 0' raster' bottomIndex' tile_width * sizeof(int));  	}  	// Write out the result in a tile.  	int tile = outImage.ComputeTile (col' row' 0' 0);  	Buffer.BlockCopy (raster' 0' rasterBytes' 0' rasterByteSize);  	if (outImage.WriteEncodedTile (tile' rasterBytes' rasterByteSize) == -1)  		return false;  }  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_by_tile,The following statement contains a magic number: for (int i_row = 0; i_row < tile_height / 2; i_row++) {  	int topIndex = tile_width * i_row * sizeof(int);  	int bottomIndex = tile_width * (tile_height - i_row - 1) * sizeof(int);  	Buffer.BlockCopy (raster' topIndex' wrk_line' 0' tile_width * sizeof(int));  	Buffer.BlockCopy (raster' bottomIndex' raster' topIndex' tile_width * sizeof(int));  	Buffer.BlockCopy (wrk_line' 0' raster' bottomIndex' tile_width * sizeof(int));  }  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_by_strip,The following statement contains a magic number: for (int row = 0; row < height; row += m_rowsPerStrip) {  	// Read the strip into an RGBA array  	if (!inImage.ReadRGBAStrip (row' raster))  		return false;  	// Figure out the number of scanlines actually in this strip.  	int rows_to_write;  	if (row + m_rowsPerStrip > height)  		rows_to_write = height - row;  	else  		rows_to_write = m_rowsPerStrip;  	// For some reason the TIFFReadRGBAStrip() function chooses the lower left corner  	// as the origin. Vertically mirror scanlines.  	for (int i_row = 0; i_row < rows_to_write / 2; i_row++) {  		int topIndex = width * i_row * sizeof(int);  		int bottomIndex = width * (rows_to_write - i_row - 1) * sizeof(int);  		Buffer.BlockCopy (raster' topIndex' wrk_line' 0' width * sizeof(int));  		Buffer.BlockCopy (raster' bottomIndex' raster' topIndex' width * sizeof(int));  		Buffer.BlockCopy (wrk_line' 0' raster' bottomIndex' width * sizeof(int));  	}  	// Write out the result in a strip  	int bytesToWrite = rows_to_write * width * sizeof(int);  	Buffer.BlockCopy (raster' 0' rasterBytes' 0' bytesToWrite);  	if (outImage.WriteEncodedStrip (row / m_rowsPerStrip' rasterBytes' bytesToWrite) == -1)  		return false;  }  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_by_strip,The following statement contains a magic number: for (int i_row = 0; i_row < rows_to_write / 2; i_row++) {  	int topIndex = width * i_row * sizeof(int);  	int bottomIndex = width * (rows_to_write - i_row - 1) * sizeof(int);  	Buffer.BlockCopy (raster' topIndex' wrk_line' 0' width * sizeof(int));  	Buffer.BlockCopy (raster' bottomIndex' raster' topIndex' width * sizeof(int));  	Buffer.BlockCopy (wrk_line' 0' raster' bottomIndex' width * sizeof(int));  }  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The following statement contains a magic number: if (m_noAlpha) {  	rasterByteSize = pixel_count * 3;  	rasterBytes = new byte[rasterByteSize];  	for (int i = 0' rasterBytesPos = 0; i < pixel_count; i++) {  		byte[] bytes = BitConverter.GetBytes (raster [i]);  		rasterBytes [rasterBytesPos++] = bytes [0];  		rasterBytes [rasterBytesPos++] = bytes [1];  		rasterBytes [rasterBytesPos++] = bytes [2];  	}  } else {  	rasterByteSize = pixel_count * 4;  	rasterBytes = new byte[rasterByteSize];  	Buffer.BlockCopy (raster' 0' rasterBytes' 0' rasterByteSize);  }  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The following statement contains a magic number: if (m_noAlpha) {  	rasterByteSize = pixel_count * 3;  	rasterBytes = new byte[rasterByteSize];  	for (int i = 0' rasterBytesPos = 0; i < pixel_count; i++) {  		byte[] bytes = BitConverter.GetBytes (raster [i]);  		rasterBytes [rasterBytesPos++] = bytes [0];  		rasterBytes [rasterBytesPos++] = bytes [1];  		rasterBytes [rasterBytesPos++] = bytes [2];  	}  } else {  	rasterByteSize = pixel_count * 4;  	rasterBytes = new byte[rasterByteSize];  	Buffer.BlockCopy (raster' 0' rasterBytes' 0' rasterByteSize);  }  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The following statement contains a magic number: if (m_noAlpha) {  	rasterByteSize = pixel_count * 3;  	rasterBytes = new byte[rasterByteSize];  	for (int i = 0' rasterBytesPos = 0; i < pixel_count; i++) {  		byte[] bytes = BitConverter.GetBytes (raster [i]);  		rasterBytes [rasterBytesPos++] = bytes [0];  		rasterBytes [rasterBytesPos++] = bytes [1];  		rasterBytes [rasterBytesPos++] = bytes [2];  	}  } else {  	rasterByteSize = pixel_count * 4;  	rasterBytes = new byte[rasterByteSize];  	Buffer.BlockCopy (raster' 0' rasterBytes' 0' rasterByteSize);  }  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The following statement contains a magic number: rasterByteSize = pixel_count * 3;  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The following statement contains a magic number: for (int i = 0' rasterBytesPos = 0; i < pixel_count; i++) {  	byte[] bytes = BitConverter.GetBytes (raster [i]);  	rasterBytes [rasterBytesPos++] = bytes [0];  	rasterBytes [rasterBytesPos++] = bytes [1];  	rasterBytes [rasterBytesPos++] = bytes [2];  }  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The following statement contains a magic number: rasterBytes [rasterBytesPos++] = bytes [2];  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The following statement contains a magic number: rasterByteSize = pixel_count * 4;  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The following statement contains a magic number: for (int row = 0; row < height; row += m_rowsPerStrip) {  	int bytes_per_pixel;  	if (m_noAlpha)  		bytes_per_pixel = 3;  	else  		bytes_per_pixel = 4;  	int rows_to_write;  	if (row + m_rowsPerStrip > height)  		rows_to_write = height - row;  	else  		rows_to_write = m_rowsPerStrip;  	int offset = bytes_per_pixel * row * width;  	int count = bytes_per_pixel * rows_to_write * width;  	if (outImage.WriteEncodedStrip (row / m_rowsPerStrip' rasterBytes' offset' count) == -1)  		return false;  }  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The following statement contains a magic number: for (int row = 0; row < height; row += m_rowsPerStrip) {  	int bytes_per_pixel;  	if (m_noAlpha)  		bytes_per_pixel = 3;  	else  		bytes_per_pixel = 4;  	int rows_to_write;  	if (row + m_rowsPerStrip > height)  		rows_to_write = height - row;  	else  		rows_to_write = m_rowsPerStrip;  	int offset = bytes_per_pixel * row * width;  	int count = bytes_per_pixel * rows_to_write * width;  	if (outImage.WriteEncodedStrip (row / m_rowsPerStrip' rasterBytes' offset' count) == -1)  		return false;  }  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The following statement contains a magic number: if (m_noAlpha)  	bytes_per_pixel = 3;  else  	bytes_per_pixel = 4;  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The following statement contains a magic number: if (m_noAlpha)  	bytes_per_pixel = 3;  else  	bytes_per_pixel = 4;  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The following statement contains a magic number: bytes_per_pixel = 3;  
Magic Number,BitMiracle.Tiff2Rgba,Converter,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Converter.cs,cvt_whole_image,The following statement contains a magic number: bytes_per_pixel = 4;  
Magic Number,BitMiracle.Tiff2Rgba,Program,F:\newReposMay17\BitMiracle_libtiff.net\Tiff2Rgba\Program.cs,Main,The following statement contains a magic number: if (args.Length - argn < 2) {  	usage ();  	return;  }  
