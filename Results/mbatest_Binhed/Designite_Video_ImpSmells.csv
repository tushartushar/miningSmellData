Implementation smell,Namespace,Class,File,Method,Description
Long Method,VideoFiles,Chunk,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,Chunk,The method has 105 lines of code.
Long Method,VideoFiles,MkvELements,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,MkvELements,The method has 220 lines of code.
Long Method,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The method has 278 lines of code.
Complex Method,VideoFiles,Chunk,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,Chunk,Cyclomatic complexity of the method is 68
Complex Method,VideoFiles,MkvTag,C:\repos\mbatest_Binhed\Mpeg2\Mkv.cs,MkvTag,Cyclomatic complexity of the method is 15
Complex Method,VideoFiles,MkvTag,C:\repos\mbatest_Binhed\Mpeg2\Mkv.cs,IdentifyTag,Cyclomatic complexity of the method is 19
Complex Method,VideoFiles,DataBlock,C:\repos\mbatest_Binhed\Mpeg2\Mkv.cs,DataBlock,Cyclomatic complexity of the method is 11
Complex Method,VideoFiles,Element,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,Element,Cyclomatic complexity of the method is 26
Complex Method,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,Cyclomatic complexity of the method is 19
Complex Method,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,Cyclomatic complexity of the method is 128
Complex Method,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,Cyclomatic complexity of the method is 48
Complex Method,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,Cyclomatic complexity of the method is 12
Complex Method,VideoFiles,Picture,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Picture,Cyclomatic complexity of the method is 12
Complex Method,VideoFiles,VideoAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeVideo,Cyclomatic complexity of the method is 24
Complex Method,VideoFiles,AudioAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeAudio,Cyclomatic complexity of the method is 24
Complex Method,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,Cyclomatic complexity of the method is 9
Complex Method,VideoFiles,IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,IFO,Cyclomatic complexity of the method is 22
Long Statement,VideoFiles,TaggedElement,C:\repos\mbatest_Binhed\Mpeg2\Mkv.cs,ToString,The length of the statement  "	return element.Name + " (" + element.Id.ToString ("x2") + "' " + Element.ElementType.ToString () + ") : " + tags.Count.ToString () + occ; " is 137.
Long Statement,VideoFiles,GOP,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,ToString,The length of the statement  "	return "GOP " + Offset.ToString ("X") + " " + cl + " " + Time + " " + pictures.Count + " images soit " + NumberOfSlices.ToString () + " slices et " + secondes.ToString () + " secondes "; " is 186.
Long Statement,VideoFiles,VideoStream,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodePts_dts,The length of the statement  "	long p = (pts [0] & 0x0E << 29) + ((pts [1] & 0x7F) << 21) + ((pts [2] & 0xFE) << 14) + (pts [3] << 7) + ((pts [4] & 0xFE) >> 1); " is 129.
Long Statement,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,ToString,The length of the statement  "	return base.ToString () + " " + rate_bound.ToString () + " video " + video_bound.ToString () + " audio " + audio_bound.ToString (); " is 131.
Long Statement,VideoFiles,Slice,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,ToString,The length of the statement  "	return base.ToString () + " " + Data.Length.ToString ("X") + " " + sliceExtensionFlag.ToString () + " " + quantiserScaleCode.ToString (); " is 137.
Empty Catch Block,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The method has an empty catch block.
Empty Catch Block,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The method has an empty catch block.
Magic Number,VideoFiles,AVIFile,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,AVIFile,The following statement contains a magic number: Riff = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 4);  
Magic Number,VideoFiles,AVIFile,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,AVIFile,The following statement contains a magic number: FileType = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 4);  
Magic Number,VideoFiles,AVIHEADER,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,AVIHEADER,The following statement contains a magic number: MainAviHeader = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 4);  
Magic Number,VideoFiles,AVISTREAMINFO,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,AVISTREAMINFO,The following statement contains a magic number: fccType = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 4);  
Magic Number,VideoFiles,AVISTREAMINFO,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,AVISTREAMINFO,The following statement contains a magic number: fccHandler = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 4);  
Magic Number,VideoFiles,Chunk,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,Chunk,The following statement contains a magic number: header = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 4);  
Magic Number,VideoFiles,Chunk,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,Chunk,The following statement contains a magic number: switch ((string)header.Value) {  case "idx1":  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	aviIndexEntry = new List<AVIINDEXENTRY> ();  	while (sw.Position < PositionOfStructureInFile + (int)length.Value) {  		AVIINDEXENTRY ev = new AVIINDEXENTRY (sw);  		aviIndexEntry.Add (ev);  	}  	break;  case "dmlh":  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	total = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	break;  case "indx":  case "00db":  case "00dc":  case "ix00":  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	break;  case "ix01":  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	break;  case "00wb":  case "01wb":  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	break;  case "hdrl":  	aviHeader = new AVIHEADER (sw);  	break;  case "INFO":  	info = new List<INFODATA> ();  	long start = sw.Position;  	while (sw.Position < start + l) {  		INFODATA inf = new INFODATA (sw);  		if (sw.Position > start + l) {  			sw.Position = start + l;  			break;  		}  		info.Add (inf);  	}  	break;  case "JUNK":  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	break;  case "LIST":  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	while (sw.Position < PositionOfStructureInFile + (int)length.Value + 8) {  		Chunk ch = new Chunk (sw' (int)length.Value - 4' this);  		content.Add (ch);  	}  	break;  case "vprp":  	break;  case "rec ":  	break;  case "strl":  	Chunk chu = new Chunk (sw' 0' parent);  	content.Add (chu);  	break;  case "strh":  	//(<Stream header>)  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	av = new AVISTREAMINFO (sw);  	break;  case "strf":  	//<Stream format> depends on the stream type  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	switch ((string)parent.Content [0].Content [0].AviStreamInfo.FccType.Value) {  	case "iavs":  		dvInfo = new DVINFO (sw);  		break;  	case "vids":  		bitmapInfo = new BITMAPINFO (sw);  		break;  	case "auds":  		waveFomat = new WAVEFORMATEX (sw);  		break;  	}  	break;  case "strd":  	//<Additional header data>  	break;  case "strn":  	//<Stream name>  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	if ((int)length.Value > 0) {  		strn = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' (int)length.Value);  	}  	break;  case "odml":  	break;  case "movi":  	break;  default:  	break;  }  
Magic Number,VideoFiles,Chunk,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,Chunk,The following statement contains a magic number: switch ((string)header.Value) {  case "idx1":  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	aviIndexEntry = new List<AVIINDEXENTRY> ();  	while (sw.Position < PositionOfStructureInFile + (int)length.Value) {  		AVIINDEXENTRY ev = new AVIINDEXENTRY (sw);  		aviIndexEntry.Add (ev);  	}  	break;  case "dmlh":  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	total = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	break;  case "indx":  case "00db":  case "00dc":  case "ix00":  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	break;  case "ix01":  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	break;  case "00wb":  case "01wb":  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	break;  case "hdrl":  	aviHeader = new AVIHEADER (sw);  	break;  case "INFO":  	info = new List<INFODATA> ();  	long start = sw.Position;  	while (sw.Position < start + l) {  		INFODATA inf = new INFODATA (sw);  		if (sw.Position > start + l) {  			sw.Position = start + l;  			break;  		}  		info.Add (inf);  	}  	break;  case "JUNK":  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	break;  case "LIST":  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	while (sw.Position < PositionOfStructureInFile + (int)length.Value + 8) {  		Chunk ch = new Chunk (sw' (int)length.Value - 4' this);  		content.Add (ch);  	}  	break;  case "vprp":  	break;  case "rec ":  	break;  case "strl":  	Chunk chu = new Chunk (sw' 0' parent);  	content.Add (chu);  	break;  case "strh":  	//(<Stream header>)  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	av = new AVISTREAMINFO (sw);  	break;  case "strf":  	//<Stream format> depends on the stream type  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	switch ((string)parent.Content [0].Content [0].AviStreamInfo.FccType.Value) {  	case "iavs":  		dvInfo = new DVINFO (sw);  		break;  	case "vids":  		bitmapInfo = new BITMAPINFO (sw);  		break;  	case "auds":  		waveFomat = new WAVEFORMATEX (sw);  		break;  	}  	break;  case "strd":  	//<Additional header data>  	break;  case "strn":  	//<Stream name>  	length = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	if ((int)length.Value > 0) {  		strn = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' (int)length.Value);  	}  	break;  case "odml":  	break;  case "movi":  	break;  default:  	break;  }  
Magic Number,VideoFiles,Chunk,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,Chunk,The following statement contains a magic number: while (sw.Position < PositionOfStructureInFile + (int)length.Value + 8) {  	Chunk ch = new Chunk (sw' (int)length.Value - 4' this);  	content.Add (ch);  }  
Magic Number,VideoFiles,Chunk,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,Chunk,The following statement contains a magic number: while (sw.Position < PositionOfStructureInFile + (int)length.Value + 8) {  	Chunk ch = new Chunk (sw' (int)length.Value - 4' this);  	content.Add (ch);  }  
Magic Number,VideoFiles,Chunk,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,Chunk,The following statement contains a magic number: if (length != null)  	sw.Position = PositionOfStructureInFile + (int)length.Value + 8;  
Magic Number,VideoFiles,Chunk,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,Chunk,The following statement contains a magic number: sw.Position = PositionOfStructureInFile + (int)length.Value + 8;  
Magic Number,VideoFiles,Chunk,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,Chunk,The following statement contains a magic number: if (sw.Position % 2 == 1)  	sw.Position++;  
Magic Number,VideoFiles,DVINFO,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,DVINFO,The following statement contains a magic number: dwDVReserved = new ELEMENTARY_TYPE (sw' 0' typeof(int[])' 2);  
Magic Number,VideoFiles,BITMAPINFOHEADER,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,BITMAPINFOHEADER,The following statement contains a magic number: biCompression = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 4);  
Magic Number,VideoFiles,INFODATA,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,INFODATA,The following statement contains a magic number: ckid = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 4);  
Magic Number,VideoFiles,INFODATA,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,INFODATA,The following statement contains a magic number: if ((int)length.Value % 2 == 1)  	sw.Position++;  
Magic Number,VideoFiles,AVIINDEXENTRY,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,AVIINDEXENTRY,The following statement contains a magic number: ckid = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 4);  
Magic Number,VideoFiles,FlvFile,C:\repos\mbatest_Binhed\Mpeg2\FlvFile.cs,FlvFile,The following statement contains a magic number: signature = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 3);  
Magic Number,VideoFiles,PacketHeader,C:\repos\mbatest_Binhed\Mpeg2\FlvFile.cs,PacketHeader,The following statement contains a magic number: payload_size = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  
Magic Number,VideoFiles,PacketHeader,C:\repos\mbatest_Binhed\Mpeg2\FlvFile.cs,PacketHeader,The following statement contains a magic number: timestamp_lower = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  
Magic Number,VideoFiles,PacketHeader,C:\repos\mbatest_Binhed\Mpeg2\FlvFile.cs,PacketHeader,The following statement contains a magic number: stream_ID = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  
Magic Number,VideoFiles,MkvTag,C:\repos\mbatest_Binhed\Mpeg2\Mkv.cs,MkvTag,The following statement contains a magic number: if (tagValue != null) {  	TaggedElement el;  	if (!MkvFile.AllTagsPresents.TryGetValue (tagValue.Id' out el)) {  		TaggedElement tg = new TaggedElement (tagValue);  		tg.Tags.Add (this);  		MkvFile.AllTagsPresents.Add (tagValue.Id' tg);  	}  	else  		el.Tags.Add (this);  	switch (tagValue.ElementType) {  	case EbmlElementType.MASTER:  		DataLength = Vint.ReadEBML (sw' out longueur);  		subtags = new List<MkvTag> ();  		int startA = (int)sw.Position;  		while (sw.Position < startA + longueur) {  			MkvTag t = new MkvTag (sw' PositionOfStructureInFile);  			if (t.tagValue == null)  				return;  			subtags.Add (t);  		}  		LengthInFile = longueur;  		//        if (sw.Position >= sw.Length)                            return;  		break;  	default:  		switch (tagValue.Name) {  		case "SeekPosition":  			data = new DataBlock (sw' tagValue.ElementType);  			subtags = new List<MkvTag> ();  			long start = sw.Position;  			long jump = startAdress + int.Parse (DataValue' System.Globalization.NumberStyles.HexNumber) - 5;  			// ???  			sw.Position = jump;  			//       while (sw.Position<jump +0x1000)  			{  				MkvTag t = new MkvTag (sw' jump);  				subtags.Add (t);  			}  			sw.Position = start;  			break;  		case "SimpleBlock":  			bk = new SimpleBlock (sw' 0);  			//GetLength(sw));  			break;  		default:  			if (tagValue.Name == "DateUTC") {  			}  			data = new DataBlock (sw' tagValue.ElementType);  			break;  		}  		if (data != null)  			LengthInFile = data.Longueur;  		//   else   		LengthInFile = sw.Position - PositionOfStructureInFile;  		break;  	}  }  else  	return;  
Magic Number,VideoFiles,MkvTag,C:\repos\mbatest_Binhed\Mpeg2\Mkv.cs,MkvTag,The following statement contains a magic number: switch (tagValue.ElementType) {  case EbmlElementType.MASTER:  	DataLength = Vint.ReadEBML (sw' out longueur);  	subtags = new List<MkvTag> ();  	int startA = (int)sw.Position;  	while (sw.Position < startA + longueur) {  		MkvTag t = new MkvTag (sw' PositionOfStructureInFile);  		if (t.tagValue == null)  			return;  		subtags.Add (t);  	}  	LengthInFile = longueur;  	//        if (sw.Position >= sw.Length)                            return;  	break;  default:  	switch (tagValue.Name) {  	case "SeekPosition":  		data = new DataBlock (sw' tagValue.ElementType);  		subtags = new List<MkvTag> ();  		long start = sw.Position;  		long jump = startAdress + int.Parse (DataValue' System.Globalization.NumberStyles.HexNumber) - 5;  		// ???  		sw.Position = jump;  		//       while (sw.Position<jump +0x1000)  		{  			MkvTag t = new MkvTag (sw' jump);  			subtags.Add (t);  		}  		sw.Position = start;  		break;  	case "SimpleBlock":  		bk = new SimpleBlock (sw' 0);  		//GetLength(sw));  		break;  	default:  		if (tagValue.Name == "DateUTC") {  		}  		data = new DataBlock (sw' tagValue.ElementType);  		break;  	}  	if (data != null)  		LengthInFile = data.Longueur;  	//   else   	LengthInFile = sw.Position - PositionOfStructureInFile;  	break;  }  
Magic Number,VideoFiles,MkvTag,C:\repos\mbatest_Binhed\Mpeg2\Mkv.cs,MkvTag,The following statement contains a magic number: switch (tagValue.Name) {  case "SeekPosition":  	data = new DataBlock (sw' tagValue.ElementType);  	subtags = new List<MkvTag> ();  	long start = sw.Position;  	long jump = startAdress + int.Parse (DataValue' System.Globalization.NumberStyles.HexNumber) - 5;  	// ???  	sw.Position = jump;  	//       while (sw.Position<jump +0x1000)  	{  		MkvTag t = new MkvTag (sw' jump);  		subtags.Add (t);  	}  	sw.Position = start;  	break;  case "SimpleBlock":  	bk = new SimpleBlock (sw' 0);  	//GetLength(sw));  	break;  default:  	if (tagValue.Name == "DateUTC") {  	}  	data = new DataBlock (sw' tagValue.ElementType);  	break;  }  
Magic Number,VideoFiles,MkvTag,C:\repos\mbatest_Binhed\Mpeg2\Mkv.cs,IdentifyTag,The following statement contains a magic number: switch (tag.Value.GetType ().Name) {  case "Int32":  	MkvFile.tagIds.TryGetValue ((int)tag.Value' out tagValue);  	break;  case "Int16":  	MkvFile.tagIds.TryGetValue ((short)tag.Value' out tagValue);  	break;  case "Byte[]":  	byte[] b = (byte[])tag.Value;  	int val = b [0];  	for (int x = 1; x < b.Length; x++)  		val = (val * 256) + b [x];  	MkvFile.tagIds.TryGetValue (val' out tagValue);  	break;  case "Byte":  	MkvFile.tagIds.TryGetValue ((byte)tag.Value' out tagValue);  	break;  default:  	break;  }  
Magic Number,VideoFiles,MkvTag,C:\repos\mbatest_Binhed\Mpeg2\Mkv.cs,IdentifyTag,The following statement contains a magic number: for (int x = 1; x < b.Length; x++)  	val = (val * 256) + b [x];  
Magic Number,VideoFiles,MkvTag,C:\repos\mbatest_Binhed\Mpeg2\Mkv.cs,IdentifyTag,The following statement contains a magic number: val = (val * 256) + b [x];  
Magic Number,VideoFiles,SimpleBlock,C:\repos\mbatest_Binhed\Mpeg2\Mkv.cs,SimpleBlock,The following statement contains a magic number: data = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' (int)longueur - 4);  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x80) == 0x80)  	actualValue = actualValue & 0x7F;  else if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x80) == 0x80)  	actualValue = actualValue & 0x7F;  else if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x80) == 0x80)  	actualValue = actualValue & 0x7F;  else if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x80) == 0x80)  	actualValue = actualValue & 0x7F;  else if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x80) == 0x80)  	actualValue = actualValue & 0x7F;  else if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x80) == 0x80)  	actualValue = actualValue & 0x7F;  else if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x80) == 0x80)  	actualValue = actualValue & 0x7F;  else if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x80) == 0x80)  	actualValue = actualValue & 0x7F;  else if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x80) == 0x80)  	actualValue = actualValue & 0x7F;  else if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x80) == 0x80)  	actualValue = actualValue & 0x7F;  else if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x40) == 0x40) {  	sw.Position--;  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	actualValue = (short)vint.Value;  	actualValue = actualValue & 0x3FFF;  	return vint;  }  else {  	sw.Position--;  	if ((actualValue & 0x20) == 0x20) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFF;  		return vint;  	}  	if ((actualValue & 0x10) == 0x10) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x08) == 0x08) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x04) == 0x04) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x02) == 0x02) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  		byte[] l = (byte[])vint.Value;  		actualValue = l [0];  		for (int i = 1; i < l.Length; i++)  			actualValue = (actualValue * 256) + l [i];  		actualValue = actualValue & 0x0FFFFFFF;  		return vint;  	}  	if ((actualValue & 0x01) == 0x01) {  		vint = new ELEMENTARY_TYPE (sw' 0' typeof(long));  		actualValue = (long)vint.Value;  		actualValue = actualValue & 0xFFFFFFFFF;  		return vint;  	}  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x20) == 0x20) {  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  	byte[] l = (byte[])vint.Value;  	actualValue = l [0];  	for (int i = 1; i < l.Length; i++)  		actualValue = (actualValue * 256) + l [i];  	actualValue = actualValue & 0x0FFFFF;  	return vint;  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x20) == 0x20) {  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  	byte[] l = (byte[])vint.Value;  	actualValue = l [0];  	for (int i = 1; i < l.Length; i++)  		actualValue = (actualValue * 256) + l [i];  	actualValue = actualValue & 0x0FFFFF;  	return vint;  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 3);  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: for (int i = 1; i < l.Length; i++)  	actualValue = (actualValue * 256) + l [i];  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: actualValue = (actualValue * 256) + l [i];  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x10) == 0x10) {  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  	byte[] l = (byte[])vint.Value;  	actualValue = l [0];  	for (int i = 1; i < l.Length; i++)  		actualValue = (actualValue * 256) + l [i];  	actualValue = actualValue & 0x0FFFFFFF;  	return vint;  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x10) == 0x10) {  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  	byte[] l = (byte[])vint.Value;  	actualValue = l [0];  	for (int i = 1; i < l.Length; i++)  		actualValue = (actualValue * 256) + l [i];  	actualValue = actualValue & 0x0FFFFFFF;  	return vint;  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: for (int i = 1; i < l.Length; i++)  	actualValue = (actualValue * 256) + l [i];  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: actualValue = (actualValue * 256) + l [i];  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x08) == 0x08) {  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  	byte[] l = (byte[])vint.Value;  	actualValue = l [0];  	for (int i = 1; i < l.Length; i++)  		actualValue = (actualValue * 256) + l [i];  	actualValue = actualValue & 0x0FFFFFFF;  	return vint;  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x08) == 0x08) {  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  	byte[] l = (byte[])vint.Value;  	actualValue = l [0];  	for (int i = 1; i < l.Length; i++)  		actualValue = (actualValue * 256) + l [i];  	actualValue = actualValue & 0x0FFFFFFF;  	return vint;  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 5);  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: for (int i = 1; i < l.Length; i++)  	actualValue = (actualValue * 256) + l [i];  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: actualValue = (actualValue * 256) + l [i];  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x04) == 0x04) {  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  	byte[] l = (byte[])vint.Value;  	actualValue = l [0];  	for (int i = 1; i < l.Length; i++)  		actualValue = (actualValue * 256) + l [i];  	actualValue = actualValue & 0x0FFFFFFF;  	return vint;  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x04) == 0x04) {  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  	byte[] l = (byte[])vint.Value;  	actualValue = l [0];  	for (int i = 1; i < l.Length; i++)  		actualValue = (actualValue * 256) + l [i];  	actualValue = actualValue & 0x0FFFFFFF;  	return vint;  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: for (int i = 1; i < l.Length; i++)  	actualValue = (actualValue * 256) + l [i];  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: actualValue = (actualValue * 256) + l [i];  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x02) == 0x02) {  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  	byte[] l = (byte[])vint.Value;  	actualValue = l [0];  	for (int i = 1; i < l.Length; i++)  		actualValue = (actualValue * 256) + l [i];  	actualValue = actualValue & 0x0FFFFFFF;  	return vint;  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: if ((actualValue & 0x02) == 0x02) {  	vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  	byte[] l = (byte[])vint.Value;  	actualValue = l [0];  	for (int i = 1; i < l.Length; i++)  		actualValue = (actualValue * 256) + l [i];  	actualValue = actualValue & 0x0FFFFFFF;  	return vint;  }  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: vint = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 7);  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: for (int i = 1; i < l.Length; i++)  	actualValue = (actualValue * 256) + l [i];  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ReadEBML,The following statement contains a magic number: actualValue = (actualValue * 256) + l [i];  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ToLong,The following statement contains a magic number: for (int i = 1; i < l.Length; i++)  	value = (value * 256) + l [i];  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,ToLong,The following statement contains a magic number: value = (value * 256) + l [i];  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,nanosecondsToSeconds,The following statement contains a magic number: return ((float)nano / 1000000000);  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,BytesToInt,The following statement contains a magic number: for (int x = 0; x < dn.Length; x++)  	val = (val * 256 + dn [x]);  
Magic Number,VideoFiles,Vint,C:\repos\mbatest_Binhed\Mpeg2\MkvElements.cs,BytesToInt,The following statement contains a magic number: val = (val * 256 + dn [x]);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: data [0] = (b [0] & 0x7c) / 4;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: data [1] = (b [0] & 0x03) * 16 + (b [1] & 0xF0) / 16;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: data [1] = (b [0] & 0x03) * 16 + (b [1] & 0xF0) / 16;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: data [2] = (b [1] & 0x07) * 8 + (b [2] & 0xE0) / 0xE0;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: data [2] = (b [1] & 0x07) * 8 + (b [2] & 0xE0) / 0xE0;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: data [2] = (b [1] & 0x07) * 8 + (b [2] & 0xE0) / 0xE0;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: data [3] = (b [2] & 0x1F) * 2 + (b [3] & 0x80) / 0x80;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: data [3] = (b [2] & 0x1F) * 2 + (b [3] & 0x80) / 0x80;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: data [3] = (b [2] & 0x1F) * 2 + (b [3] & 0x80) / 0x80;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: data [3] = (b [2] & 0x1F) * 2 + (b [3] & 0x80) / 0x80;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position <= sw.Length) {  	if (sw.Position > 50000000)  		break;  	#region analyze  	if (sw.Position >= sw.Length)  		break;  	byte[] dat = sw.ReadBytes (4);  	int startExtra = 0;  	while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  		sw.Position -= 3;  		dat = sw.ReadBytes (4);  		startExtra += 1;  	}  	if (startExtra > 0) {  		sw.Position -= startExtra;  		if (CurrentStream != null)  			CurrentStream.unknown = sw.ReadBytes (startExtra);  	}  	IBloc b = new Bloc ();  	b.Offset = sw.Position - 4;  	b.Header = dat;  	try {  		#region Case  		switch (b.HeaderCode) {  		case 0x00:  			#region Picture  			b.Data = sw.ReadBytes (4);  			CurrentPicture = new Picture (b);  			if (CurrentPicture.ImageType != "I") {  				int k = sw.ReadByte ();  			}  			if (CurrentGroup != null) {  				CurrentGroup.Pictures.Add (CurrentPicture);  				CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  			}  			break;  		#endregion  		case 0xb2:  			//user buffer  			blocs.Add (b);  			break;  		case 0xb3:  			#region Sequence header  			b.Data = sw.ReadBytes (8);  			SequenceHeader sq = new SequenceHeader (b);  			seqHead.Add (sq);  			blocs.Add (sq);  			CurrentSequence = sq;  			if (sq.Load_intra_quantiser_matrix) {  			}  			if (sq.Load_non_intra_quantiser_matrix) {  			}  			break;  		#endregion  		case 0xb4:  			break;  		case 0xb5:  			#region extension  			int aa = sw.ReadByte ();  			aa = (aa & 0xF0) / 16;  			sw.Position--;  			switch (aa) {  			case 1:  				buffer = sw.ReadBytes (6);  				b.Data = buffer;  				break;  			case 2:  				buffer = sw.ReadBytes (13);  				// ???  				b.Data = buffer;  				break;  			case 8:  				buffer = sw.ReadBytes (5);  				b.Data = buffer;  				break;  			}  			Extension ex = new Extension (b);  			ex.extensionType = aa;  			int id = ex.detail ();  			if (id > 0) {  				buffer = sw.ReadBytes (id);  			}  			switch (aa) {  			case 1:  				if (CurrentSequence != null)  					CurrentSequence.SequenceExtension = ex;  				break;  			case 4:  				break;  			case 8:  				if (CurrentPicture != null)  					CurrentPicture.pictureExtension = ex;  				break;  			}  			//                           blocs.Add(ex);  			break;  		#endregion  		case 0xb7:  			// end of buffer  			return;  		case 0xb8:  			#region Group of pictures  			b.Data = sw.ReadBytes (4);  			CurrentGroup = new GOP (b);  			if (CurrentSequence != null) {  				CurrentGroup.framerate = CurrentSequence.FrameRate;  				CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  				CurrentGroup.s = CurrentSequence.VideoSize;  			}  			CurrentSequence.gops.Add (CurrentGroup);  			gops.Add (CurrentGroup);  			break;  		#endregion  		case 0xb9:  			break;  		case 0xba:  			#region Pack header length 10  			buffer = sw.ReadBytes (10);  			if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  			 {  				int u = (buffer [9] & 0x7);  				byte[] stuff = sw.ReadBytes (u);  			}  			b.Data = buffer;  			PackHeader p = new PackHeader (b);  			blocs.Add (p);  			break;  		#endregion  		case 0xbb:  			#region System header  			// http://www.mpucoder.com/DVD/sys_hdr.html   			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			SystemHeader sh = new SystemHeader (b);  			blocs.Add (sh);  			break;  		#endregion  		case 0xbc:  			//program stream map  			break;  		case 0xbd:  		//Private stream 1                            		case 0xbf:  		//Private stream 2  		case 0xbe:  			//padding stream  			#region padding stream  			buffer = sw.ReadBytes (sw.ReadShort ());  			b.Data = buffer;  			blocs.Add (b);  			break;  		#endregion  		case 0xc0:  		//Audio  		case 0xe0:  			//video  			#region Data stream  			if (sw.Position >= 0x1200E) {  			}  			int si = sw.ReadShort ();  			byte[] extensionBuffer = sw.ReadBytes (3);  			//extension  			b.Data = buffer;  			CurrentStream = new VideoStream (b' extensionBuffer);  			if (CurrentStream.PTS_DTS_flags != 0) {  				switch (CurrentStream.PTS_DTS_flags) {  				case 0x02:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				case 0x01:  				case 0x03:  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  					break;  				}  				CurrentStream.PTS_DTS_Decode ();  			}  			if (CurrentStream.ESCR_flag) {  				sw.ReadBytes (6);  			}  			if (CurrentStream.ES_rate_flag) {  				sw.ReadBytes (2);  			}  			if (CurrentStream.additional_copy_info_flag)  				sw.ReadBytes (1);  			if (CurrentStream.PES_CRC_flag)  				sw.ReadBytes (2);  			if (CurrentStream.PES_extension_flag) {  				byte ext = (byte)sw.ReadByte ();  				if ((ext & 0x80) == 0x80)//PES private buffer flag  				 {  				}  				if ((ext & 0x40) == 0x40)//pack header field flag  				 {  				}  				if ((ext & 0x20) == 0x20)//program packet sequence counter flag  				 {  					sw.ReadBytes (2);  				}  				if ((ext & 0x10) == 0x10)//P-STD buffer flag  				 {  					byte[] P_STD_buffer = sw.ReadBytes (2);  					bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  					int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  				}  				if ((ext & 0x01) == 0x01)//PES extension flag 2  				 {  				}  			}  			if (CurrentStream.PES_header_data_length > 0) {  				CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  			}  			long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  			CurrentStream.payload = sw.ReadBytes (si);  			sw.Seek (pos' SeekOrigin.Begin);  			videoStream.Add (CurrentStream);  			blocs.Add (CurrentStream);  			break;  		#endregion  		default:  			#region Slice. Ends with new marker  			long start = sw.Position;  			if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  				List<byte> bts = new List<byte> ();  				int endBlock = sw.ReadByte ();  				while (sw.Position < sw.Length) {  					#region Get buffer until 0x00 0x00  					bts.Add ((byte)endBlock);  					endBlock = sw.ReadByte ();  					start = sw.Position;  					if (endBlock == 00) {  						byte[] code = new byte[2];  						sw.Read (code' 0' 2);  						if ((code [0] == 0x00) && (code [1] == 0x01)) {  							sw.Position -= 3;  							break;  						}  						else {  							bts.Add ((byte)endBlock);  							sw.Position -= 2;  						}  					}  					#endregion  				}  				b.Data = bts.ToArray ();  				Slice sl = new Slice (b);  				if (CurrentPicture != null) {  					CurrentPicture.Slices.Add (sl);  					if (sl.HeaderCode != CurrentPicture.Slices.Count) {  					}  				}  			}  			else {  			}  			#endregion  			break;  		}  		#endregion  	}  	catch (Exception e) {  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if (sw.Position > 50000000)  	break;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  	sw.Position -= 3;  	dat = sw.ReadBytes (4);  	startExtra += 1;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  	sw.Position -= 3;  	dat = sw.ReadBytes (4);  	startExtra += 1;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (!((dat [0] == 0x00) && ((dat [1] == 0x00) && (dat [2] == 0x01))) && (sw.Position < sw.Length)) {  	sw.Position -= 3;  	dat = sw.ReadBytes (4);  	startExtra += 1;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: sw.Position -= 3;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: dat = sw.ReadBytes (4);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: b.Offset = sw.Position - 4;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: try {  	#region Case  	switch (b.HeaderCode) {  	case 0x00:  		#region Picture  		b.Data = sw.ReadBytes (4);  		CurrentPicture = new Picture (b);  		if (CurrentPicture.ImageType != "I") {  			int k = sw.ReadByte ();  		}  		if (CurrentGroup != null) {  			CurrentGroup.Pictures.Add (CurrentPicture);  			CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  		}  		break;  	#endregion  	case 0xb2:  		//user buffer  		blocs.Add (b);  		break;  	case 0xb3:  		#region Sequence header  		b.Data = sw.ReadBytes (8);  		SequenceHeader sq = new SequenceHeader (b);  		seqHead.Add (sq);  		blocs.Add (sq);  		CurrentSequence = sq;  		if (sq.Load_intra_quantiser_matrix) {  		}  		if (sq.Load_non_intra_quantiser_matrix) {  		}  		break;  	#endregion  	case 0xb4:  		break;  	case 0xb5:  		#region extension  		int aa = sw.ReadByte ();  		aa = (aa & 0xF0) / 16;  		sw.Position--;  		switch (aa) {  		case 1:  			buffer = sw.ReadBytes (6);  			b.Data = buffer;  			break;  		case 2:  			buffer = sw.ReadBytes (13);  			// ???  			b.Data = buffer;  			break;  		case 8:  			buffer = sw.ReadBytes (5);  			b.Data = buffer;  			break;  		}  		Extension ex = new Extension (b);  		ex.extensionType = aa;  		int id = ex.detail ();  		if (id > 0) {  			buffer = sw.ReadBytes (id);  		}  		switch (aa) {  		case 1:  			if (CurrentSequence != null)  				CurrentSequence.SequenceExtension = ex;  			break;  		case 4:  			break;  		case 8:  			if (CurrentPicture != null)  				CurrentPicture.pictureExtension = ex;  			break;  		}  		//                           blocs.Add(ex);  		break;  	#endregion  	case 0xb7:  		// end of buffer  		return;  	case 0xb8:  		#region Group of pictures  		b.Data = sw.ReadBytes (4);  		CurrentGroup = new GOP (b);  		if (CurrentSequence != null) {  			CurrentGroup.framerate = CurrentSequence.FrameRate;  			CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  			CurrentGroup.s = CurrentSequence.VideoSize;  		}  		CurrentSequence.gops.Add (CurrentGroup);  		gops.Add (CurrentGroup);  		break;  	#endregion  	case 0xb9:  		break;  	case 0xba:  		#region Pack header length 10  		buffer = sw.ReadBytes (10);  		if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  		 {  			int u = (buffer [9] & 0x7);  			byte[] stuff = sw.ReadBytes (u);  		}  		b.Data = buffer;  		PackHeader p = new PackHeader (b);  		blocs.Add (p);  		break;  	#endregion  	case 0xbb:  		#region System header  		// http://www.mpucoder.com/DVD/sys_hdr.html   		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		SystemHeader sh = new SystemHeader (b);  		blocs.Add (sh);  		break;  	#endregion  	case 0xbc:  		//program stream map  		break;  	case 0xbd:  	//Private stream 1                            	case 0xbf:  	//Private stream 2  	case 0xbe:  		//padding stream  		#region padding stream  		buffer = sw.ReadBytes (sw.ReadShort ());  		b.Data = buffer;  		blocs.Add (b);  		break;  	#endregion  	case 0xc0:  	//Audio  	case 0xe0:  		//video  		#region Data stream  		if (sw.Position >= 0x1200E) {  		}  		int si = sw.ReadShort ();  		byte[] extensionBuffer = sw.ReadBytes (3);  		//extension  		b.Data = buffer;  		CurrentStream = new VideoStream (b' extensionBuffer);  		if (CurrentStream.PTS_DTS_flags != 0) {  			switch (CurrentStream.PTS_DTS_flags) {  			case 0x02:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			case 0x01:  			case 0x03:  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  				break;  			}  			CurrentStream.PTS_DTS_Decode ();  		}  		if (CurrentStream.ESCR_flag) {  			sw.ReadBytes (6);  		}  		if (CurrentStream.ES_rate_flag) {  			sw.ReadBytes (2);  		}  		if (CurrentStream.additional_copy_info_flag)  			sw.ReadBytes (1);  		if (CurrentStream.PES_CRC_flag)  			sw.ReadBytes (2);  		if (CurrentStream.PES_extension_flag) {  			byte ext = (byte)sw.ReadByte ();  			if ((ext & 0x80) == 0x80)//PES private buffer flag  			 {  			}  			if ((ext & 0x40) == 0x40)//pack header field flag  			 {  			}  			if ((ext & 0x20) == 0x20)//program packet sequence counter flag  			 {  				sw.ReadBytes (2);  			}  			if ((ext & 0x10) == 0x10)//P-STD buffer flag  			 {  				byte[] P_STD_buffer = sw.ReadBytes (2);  				bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  				int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  			}  			if ((ext & 0x01) == 0x01)//PES extension flag 2  			 {  			}  		}  		if (CurrentStream.PES_header_data_length > 0) {  			CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  		}  		long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  		CurrentStream.payload = sw.ReadBytes (si);  		sw.Seek (pos' SeekOrigin.Begin);  		videoStream.Add (CurrentStream);  		blocs.Add (CurrentStream);  		break;  	#endregion  	default:  		#region Slice. Ends with new marker  		long start = sw.Position;  		if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  			List<byte> bts = new List<byte> ();  			int endBlock = sw.ReadByte ();  			while (sw.Position < sw.Length) {  				#region Get buffer until 0x00 0x00  				bts.Add ((byte)endBlock);  				endBlock = sw.ReadByte ();  				start = sw.Position;  				if (endBlock == 00) {  					byte[] code = new byte[2];  					sw.Read (code' 0' 2);  					if ((code [0] == 0x00) && (code [1] == 0x01)) {  						sw.Position -= 3;  						break;  					}  					else {  						bts.Add ((byte)endBlock);  						sw.Position -= 2;  					}  				}  				#endregion  			}  			b.Data = bts.ToArray ();  			Slice sl = new Slice (b);  			if (CurrentPicture != null) {  				CurrentPicture.Slices.Add (sl);  				if (sl.HeaderCode != CurrentPicture.Slices.Count) {  				}  			}  		}  		else {  		}  		#endregion  		break;  	}  	#endregion  }  catch (Exception e) {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (b.HeaderCode) {  case 0x00:  	#region Picture  	b.Data = sw.ReadBytes (4);  	CurrentPicture = new Picture (b);  	if (CurrentPicture.ImageType != "I") {  		int k = sw.ReadByte ();  	}  	if (CurrentGroup != null) {  		CurrentGroup.Pictures.Add (CurrentPicture);  		CurrentGroup.tempOrder.Add (CurrentPicture.Temporal_sequence_number);  	}  	break;  #endregion  case 0xb2:  	//user buffer  	blocs.Add (b);  	break;  case 0xb3:  	#region Sequence header  	b.Data = sw.ReadBytes (8);  	SequenceHeader sq = new SequenceHeader (b);  	seqHead.Add (sq);  	blocs.Add (sq);  	CurrentSequence = sq;  	if (sq.Load_intra_quantiser_matrix) {  	}  	if (sq.Load_non_intra_quantiser_matrix) {  	}  	break;  #endregion  case 0xb4:  	break;  case 0xb5:  	#region extension  	int aa = sw.ReadByte ();  	aa = (aa & 0xF0) / 16;  	sw.Position--;  	switch (aa) {  	case 1:  		buffer = sw.ReadBytes (6);  		b.Data = buffer;  		break;  	case 2:  		buffer = sw.ReadBytes (13);  		// ???  		b.Data = buffer;  		break;  	case 8:  		buffer = sw.ReadBytes (5);  		b.Data = buffer;  		break;  	}  	Extension ex = new Extension (b);  	ex.extensionType = aa;  	int id = ex.detail ();  	if (id > 0) {  		buffer = sw.ReadBytes (id);  	}  	switch (aa) {  	case 1:  		if (CurrentSequence != null)  			CurrentSequence.SequenceExtension = ex;  		break;  	case 4:  		break;  	case 8:  		if (CurrentPicture != null)  			CurrentPicture.pictureExtension = ex;  		break;  	}  	//                           blocs.Add(ex);  	break;  #endregion  case 0xb7:  	// end of buffer  	return;  case 0xb8:  	#region Group of pictures  	b.Data = sw.ReadBytes (4);  	CurrentGroup = new GOP (b);  	if (CurrentSequence != null) {  		CurrentGroup.framerate = CurrentSequence.FrameRate;  		CurrentGroup.aspectRatio = CurrentSequence.AspectRatio;  		CurrentGroup.s = CurrentSequence.VideoSize;  	}  	CurrentSequence.gops.Add (CurrentGroup);  	gops.Add (CurrentGroup);  	break;  #endregion  case 0xb9:  	break;  case 0xba:  	#region Pack header length 10  	buffer = sw.ReadBytes (10);  	if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.  	 {  		int u = (buffer [9] & 0x7);  		byte[] stuff = sw.ReadBytes (u);  	}  	b.Data = buffer;  	PackHeader p = new PackHeader (b);  	blocs.Add (p);  	break;  #endregion  case 0xbb:  	#region System header  	// http://www.mpucoder.com/DVD/sys_hdr.html   	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	SystemHeader sh = new SystemHeader (b);  	blocs.Add (sh);  	break;  #endregion  case 0xbc:  	//program stream map  	break;  case 0xbd:  //Private stream 1                            case 0xbf:  //Private stream 2  case 0xbe:  	//padding stream  	#region padding stream  	buffer = sw.ReadBytes (sw.ReadShort ());  	b.Data = buffer;  	blocs.Add (b);  	break;  #endregion  case 0xc0:  //Audio  case 0xe0:  	//video  	#region Data stream  	if (sw.Position >= 0x1200E) {  	}  	int si = sw.ReadShort ();  	byte[] extensionBuffer = sw.ReadBytes (3);  	//extension  	b.Data = buffer;  	CurrentStream = new VideoStream (b' extensionBuffer);  	if (CurrentStream.PTS_DTS_flags != 0) {  		switch (CurrentStream.PTS_DTS_flags) {  		case 0x02:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		case 0x01:  		case 0x03:  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  			break;  		}  		CurrentStream.PTS_DTS_Decode ();  	}  	if (CurrentStream.ESCR_flag) {  		sw.ReadBytes (6);  	}  	if (CurrentStream.ES_rate_flag) {  		sw.ReadBytes (2);  	}  	if (CurrentStream.additional_copy_info_flag)  		sw.ReadBytes (1);  	if (CurrentStream.PES_CRC_flag)  		sw.ReadBytes (2);  	if (CurrentStream.PES_extension_flag) {  		byte ext = (byte)sw.ReadByte ();  		if ((ext & 0x80) == 0x80)//PES private buffer flag  		 {  		}  		if ((ext & 0x40) == 0x40)//pack header field flag  		 {  		}  		if ((ext & 0x20) == 0x20)//program packet sequence counter flag  		 {  			sw.ReadBytes (2);  		}  		if ((ext & 0x10) == 0x10)//P-STD buffer flag  		 {  			byte[] P_STD_buffer = sw.ReadBytes (2);  			bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  			int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  		}  		if ((ext & 0x01) == 0x01)//PES extension flag 2  		 {  		}  	}  	if (CurrentStream.PES_header_data_length > 0) {  		CurrentStream.headerData = sw.ReadBytes (CurrentStream.PES_header_data_length);  	}  	long pos = sw.Position - 3 - CurrentStream.PES_header_data_length;  	CurrentStream.payload = sw.ReadBytes (si);  	sw.Seek (pos' SeekOrigin.Begin);  	videoStream.Add (CurrentStream);  	blocs.Add (CurrentStream);  	break;  #endregion  default:  	#region Slice. Ends with new marker  	long start = sw.Position;  	if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  		List<byte> bts = new List<byte> ();  		int endBlock = sw.ReadByte ();  		while (sw.Position < sw.Length) {  			#region Get buffer until 0x00 0x00  			bts.Add ((byte)endBlock);  			endBlock = sw.ReadByte ();  			start = sw.Position;  			if (endBlock == 00) {  				byte[] code = new byte[2];  				sw.Read (code' 0' 2);  				if ((code [0] == 0x00) && (code [1] == 0x01)) {  					sw.Position -= 3;  					break;  				}  				else {  					bts.Add ((byte)endBlock);  					sw.Position -= 2;  				}  			}  			#endregion  		}  		b.Data = bts.ToArray ();  		Slice sl = new Slice (b);  		if (CurrentPicture != null) {  			CurrentPicture.Slices.Add (sl);  			if (sl.HeaderCode != CurrentPicture.Slices.Count) {  			}  		}  	}  	else {  	}  	#endregion  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: b.Data = sw.ReadBytes (4);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: b.Data = sw.ReadBytes (8);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: aa = (aa & 0xF0) / 16;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (aa) {  case 1:  	buffer = sw.ReadBytes (6);  	b.Data = buffer;  	break;  case 2:  	buffer = sw.ReadBytes (13);  	// ???  	b.Data = buffer;  	break;  case 8:  	buffer = sw.ReadBytes (5);  	b.Data = buffer;  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (aa) {  case 1:  	buffer = sw.ReadBytes (6);  	b.Data = buffer;  	break;  case 2:  	buffer = sw.ReadBytes (13);  	// ???  	b.Data = buffer;  	break;  case 8:  	buffer = sw.ReadBytes (5);  	b.Data = buffer;  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (aa) {  case 1:  	buffer = sw.ReadBytes (6);  	b.Data = buffer;  	break;  case 2:  	buffer = sw.ReadBytes (13);  	// ???  	b.Data = buffer;  	break;  case 8:  	buffer = sw.ReadBytes (5);  	b.Data = buffer;  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (aa) {  case 1:  	buffer = sw.ReadBytes (6);  	b.Data = buffer;  	break;  case 2:  	buffer = sw.ReadBytes (13);  	// ???  	b.Data = buffer;  	break;  case 8:  	buffer = sw.ReadBytes (5);  	b.Data = buffer;  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (aa) {  case 1:  	buffer = sw.ReadBytes (6);  	b.Data = buffer;  	break;  case 2:  	buffer = sw.ReadBytes (13);  	// ???  	b.Data = buffer;  	break;  case 8:  	buffer = sw.ReadBytes (5);  	b.Data = buffer;  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: buffer = sw.ReadBytes (6);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: buffer = sw.ReadBytes (13);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: buffer = sw.ReadBytes (5);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (aa) {  case 1:  	if (CurrentSequence != null)  		CurrentSequence.SequenceExtension = ex;  	break;  case 4:  	break;  case 8:  	if (CurrentPicture != null)  		CurrentPicture.pictureExtension = ex;  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (aa) {  case 1:  	if (CurrentSequence != null)  		CurrentSequence.SequenceExtension = ex;  	break;  case 4:  	break;  case 8:  	if (CurrentPicture != null)  		CurrentPicture.pictureExtension = ex;  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: b.Data = sw.ReadBytes (4);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: buffer = sw.ReadBytes (10);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.   {  	int u = (buffer [9] & 0x7);  	byte[] stuff = sw.ReadBytes (u);  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if ((buffer [9] & 0x7) != 0x0)//pack_stuffing_length -- A 3 bit integer specifying the number of stuffing bytes which follow this field.   {  	int u = (buffer [9] & 0x7);  	byte[] stuff = sw.ReadBytes (u);  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if (CurrentStream.PTS_DTS_flags != 0) {  	switch (CurrentStream.PTS_DTS_flags) {  	case 0x02:  		CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  		break;  	case 0x01:  	case 0x03:  		CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  		CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  		break;  	}  	CurrentStream.PTS_DTS_Decode ();  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if (CurrentStream.PTS_DTS_flags != 0) {  	switch (CurrentStream.PTS_DTS_flags) {  	case 0x02:  		CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  		break;  	case 0x01:  	case 0x03:  		CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  		CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  		break;  	}  	CurrentStream.PTS_DTS_Decode ();  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if (CurrentStream.PTS_DTS_flags != 0) {  	switch (CurrentStream.PTS_DTS_flags) {  	case 0x02:  		CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  		break;  	case 0x01:  	case 0x03:  		CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  		CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  		break;  	}  	CurrentStream.PTS_DTS_Decode ();  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (CurrentStream.PTS_DTS_flags) {  case 0x02:  	CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  	break;  case 0x01:  case 0x03:  	CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  	CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (CurrentStream.PTS_DTS_flags) {  case 0x02:  	CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  	break;  case 0x01:  case 0x03:  	CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  	CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: switch (CurrentStream.PTS_DTS_flags) {  case 0x02:  	CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  	break;  case 0x01:  case 0x03:  	CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  	CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  	break;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if (CurrentStream.ESCR_flag) {  	sw.ReadBytes (6);  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: sw.ReadBytes (6);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if (CurrentStream.ES_rate_flag) {  	sw.ReadBytes (2);  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: sw.ReadBytes (2);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if (CurrentStream.PES_CRC_flag)  	sw.ReadBytes (2);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: sw.ReadBytes (2);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if (CurrentStream.PES_extension_flag) {  	byte ext = (byte)sw.ReadByte ();  	if ((ext & 0x80) == 0x80)//PES private buffer flag  	 {  	}  	if ((ext & 0x40) == 0x40)//pack header field flag  	 {  	}  	if ((ext & 0x20) == 0x20)//program packet sequence counter flag  	 {  		sw.ReadBytes (2);  	}  	if ((ext & 0x10) == 0x10)//P-STD buffer flag  	 {  		byte[] P_STD_buffer = sw.ReadBytes (2);  		bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  		int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  	}  	if ((ext & 0x01) == 0x01)//PES extension flag 2  	 {  	}  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if (CurrentStream.PES_extension_flag) {  	byte ext = (byte)sw.ReadByte ();  	if ((ext & 0x80) == 0x80)//PES private buffer flag  	 {  	}  	if ((ext & 0x40) == 0x40)//pack header field flag  	 {  	}  	if ((ext & 0x20) == 0x20)//program packet sequence counter flag  	 {  		sw.ReadBytes (2);  	}  	if ((ext & 0x10) == 0x10)//P-STD buffer flag  	 {  		byte[] P_STD_buffer = sw.ReadBytes (2);  		bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  		int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  	}  	if ((ext & 0x01) == 0x01)//PES extension flag 2  	 {  	}  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if (CurrentStream.PES_extension_flag) {  	byte ext = (byte)sw.ReadByte ();  	if ((ext & 0x80) == 0x80)//PES private buffer flag  	 {  	}  	if ((ext & 0x40) == 0x40)//pack header field flag  	 {  	}  	if ((ext & 0x20) == 0x20)//program packet sequence counter flag  	 {  		sw.ReadBytes (2);  	}  	if ((ext & 0x10) == 0x10)//P-STD buffer flag  	 {  		byte[] P_STD_buffer = sw.ReadBytes (2);  		bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  		int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  	}  	if ((ext & 0x01) == 0x01)//PES extension flag 2  	 {  	}  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if ((ext & 0x20) == 0x20)//program packet sequence counter flag   {  	sw.ReadBytes (2);  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: sw.ReadBytes (2);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if ((ext & 0x10) == 0x10)//P-STD buffer flag   {  	byte[] P_STD_buffer = sw.ReadBytes (2);  	bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  	int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if ((ext & 0x10) == 0x10)//P-STD buffer flag   {  	byte[] P_STD_buffer = sw.ReadBytes (2);  	bool bufScale = (P_STD_buffer [0] & 0x20) == 0x020;  	int bufSize = (P_STD_buffer [0] & 0x1F) * 256 + P_STD_buffer [1];  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  	List<byte> bts = new List<byte> ();  	int endBlock = sw.ReadByte ();  	while (sw.Position < sw.Length) {  		#region Get buffer until 0x00 0x00  		bts.Add ((byte)endBlock);  		endBlock = sw.ReadByte ();  		start = sw.Position;  		if (endBlock == 00) {  			byte[] code = new byte[2];  			sw.Read (code' 0' 2);  			if ((code [0] == 0x00) && (code [1] == 0x01)) {  				sw.Position -= 3;  				break;  			}  			else {  				bts.Add ((byte)endBlock);  				sw.Position -= 2;  			}  		}  		#endregion  	}  	b.Data = bts.ToArray ();  	Slice sl = new Slice (b);  	if (CurrentPicture != null) {  		CurrentPicture.Slices.Add (sl);  		if (sl.HeaderCode != CurrentPicture.Slices.Count) {  		}  	}  }  else {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  	List<byte> bts = new List<byte> ();  	int endBlock = sw.ReadByte ();  	while (sw.Position < sw.Length) {  		#region Get buffer until 0x00 0x00  		bts.Add ((byte)endBlock);  		endBlock = sw.ReadByte ();  		start = sw.Position;  		if (endBlock == 00) {  			byte[] code = new byte[2];  			sw.Read (code' 0' 2);  			if ((code [0] == 0x00) && (code [1] == 0x01)) {  				sw.Position -= 3;  				break;  			}  			else {  				bts.Add ((byte)endBlock);  				sw.Position -= 2;  			}  		}  		#endregion  	}  	b.Data = bts.ToArray ();  	Slice sl = new Slice (b);  	if (CurrentPicture != null) {  		CurrentPicture.Slices.Add (sl);  		if (sl.HeaderCode != CurrentPicture.Slices.Count) {  		}  	}  }  else {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  	List<byte> bts = new List<byte> ();  	int endBlock = sw.ReadByte ();  	while (sw.Position < sw.Length) {  		#region Get buffer until 0x00 0x00  		bts.Add ((byte)endBlock);  		endBlock = sw.ReadByte ();  		start = sw.Position;  		if (endBlock == 00) {  			byte[] code = new byte[2];  			sw.Read (code' 0' 2);  			if ((code [0] == 0x00) && (code [1] == 0x01)) {  				sw.Position -= 3;  				break;  			}  			else {  				bts.Add ((byte)endBlock);  				sw.Position -= 2;  			}  		}  		#endregion  	}  	b.Data = bts.ToArray ();  	Slice sl = new Slice (b);  	if (CurrentPicture != null) {  		CurrentPicture.Slices.Add (sl);  		if (sl.HeaderCode != CurrentPicture.Slices.Count) {  		}  	}  }  else {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if ((b.HeaderCode >= 0x01) && (b.HeaderCode <= 0xAF)) {  	List<byte> bts = new List<byte> ();  	int endBlock = sw.ReadByte ();  	while (sw.Position < sw.Length) {  		#region Get buffer until 0x00 0x00  		bts.Add ((byte)endBlock);  		endBlock = sw.ReadByte ();  		start = sw.Position;  		if (endBlock == 00) {  			byte[] code = new byte[2];  			sw.Read (code' 0' 2);  			if ((code [0] == 0x00) && (code [1] == 0x01)) {  				sw.Position -= 3;  				break;  			}  			else {  				bts.Add ((byte)endBlock);  				sw.Position -= 2;  			}  		}  		#endregion  	}  	b.Data = bts.ToArray ();  	Slice sl = new Slice (b);  	if (CurrentPicture != null) {  		CurrentPicture.Slices.Add (sl);  		if (sl.HeaderCode != CurrentPicture.Slices.Count) {  		}  	}  }  else {  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position < sw.Length) {  	#region Get buffer until 0x00 0x00  	bts.Add ((byte)endBlock);  	endBlock = sw.ReadByte ();  	start = sw.Position;  	if (endBlock == 00) {  		byte[] code = new byte[2];  		sw.Read (code' 0' 2);  		if ((code [0] == 0x00) && (code [1] == 0x01)) {  			sw.Position -= 3;  			break;  		}  		else {  			bts.Add ((byte)endBlock);  			sw.Position -= 2;  		}  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position < sw.Length) {  	#region Get buffer until 0x00 0x00  	bts.Add ((byte)endBlock);  	endBlock = sw.ReadByte ();  	start = sw.Position;  	if (endBlock == 00) {  		byte[] code = new byte[2];  		sw.Read (code' 0' 2);  		if ((code [0] == 0x00) && (code [1] == 0x01)) {  			sw.Position -= 3;  			break;  		}  		else {  			bts.Add ((byte)endBlock);  			sw.Position -= 2;  		}  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position < sw.Length) {  	#region Get buffer until 0x00 0x00  	bts.Add ((byte)endBlock);  	endBlock = sw.ReadByte ();  	start = sw.Position;  	if (endBlock == 00) {  		byte[] code = new byte[2];  		sw.Read (code' 0' 2);  		if ((code [0] == 0x00) && (code [1] == 0x01)) {  			sw.Position -= 3;  			break;  		}  		else {  			bts.Add ((byte)endBlock);  			sw.Position -= 2;  		}  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: while (sw.Position < sw.Length) {  	#region Get buffer until 0x00 0x00  	bts.Add ((byte)endBlock);  	endBlock = sw.ReadByte ();  	start = sw.Position;  	if (endBlock == 00) {  		byte[] code = new byte[2];  		sw.Read (code' 0' 2);  		if ((code [0] == 0x00) && (code [1] == 0x01)) {  			sw.Position -= 3;  			break;  		}  		else {  			bts.Add ((byte)endBlock);  			sw.Position -= 2;  		}  	}  	#endregion  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if (endBlock == 00) {  	byte[] code = new byte[2];  	sw.Read (code' 0' 2);  	if ((code [0] == 0x00) && (code [1] == 0x01)) {  		sw.Position -= 3;  		break;  	}  	else {  		bts.Add ((byte)endBlock);  		sw.Position -= 2;  	}  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if (endBlock == 00) {  	byte[] code = new byte[2];  	sw.Read (code' 0' 2);  	if ((code [0] == 0x00) && (code [1] == 0x01)) {  		sw.Position -= 3;  		break;  	}  	else {  		bts.Add ((byte)endBlock);  		sw.Position -= 2;  	}  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if (endBlock == 00) {  	byte[] code = new byte[2];  	sw.Read (code' 0' 2);  	if ((code [0] == 0x00) && (code [1] == 0x01)) {  		sw.Position -= 3;  		break;  	}  	else {  		bts.Add ((byte)endBlock);  		sw.Position -= 2;  	}  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if (endBlock == 00) {  	byte[] code = new byte[2];  	sw.Read (code' 0' 2);  	if ((code [0] == 0x00) && (code [1] == 0x01)) {  		sw.Position -= 3;  		break;  	}  	else {  		bts.Add ((byte)endBlock);  		sw.Position -= 2;  	}  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: sw.Read (code' 0' 2);  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if ((code [0] == 0x00) && (code [1] == 0x01)) {  	sw.Position -= 3;  	break;  }  else {  	bts.Add ((byte)endBlock);  	sw.Position -= 2;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: if ((code [0] == 0x00) && (code [1] == 0x01)) {  	sw.Position -= 3;  	break;  }  else {  	bts.Add ((byte)endBlock);  	sw.Position -= 2;  }  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: sw.Position -= 3;  
Magic Number,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following statement contains a magic number: sw.Position -= 2;  
Magic Number,VideoFiles,SequenceHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SequenceHeader,The following statement contains a magic number: framerate = FindFrameRate (Data [3]);  
Magic Number,VideoFiles,SequenceHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SequenceHeader,The following statement contains a magic number: aspectRatio = FindAspectRatio (Data [3]);  
Magic Number,VideoFiles,SequenceHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SequenceHeader,The following statement contains a magic number: bitRate = (Data [4] * 256 + Data [5]) * 4 + (Data [6] & 0xC0 / 0xC0);  
Magic Number,VideoFiles,SequenceHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SequenceHeader,The following statement contains a magic number: bitRate = (Data [4] * 256 + Data [5]) * 4 + (Data [6] & 0xC0 / 0xC0);  
Magic Number,VideoFiles,SequenceHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SequenceHeader,The following statement contains a magic number: bitRate = (Data [4] * 256 + Data [5]) * 4 + (Data [6] & 0xC0 / 0xC0);  
Magic Number,VideoFiles,SequenceHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SequenceHeader,The following statement contains a magic number: bitRate = (Data [4] * 256 + Data [5]) * 4 + (Data [6] & 0xC0 / 0xC0);  
Magic Number,VideoFiles,SequenceHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SequenceHeader,The following statement contains a magic number: bitRate = (Data [4] * 256 + Data [5]) * 4 + (Data [6] & 0xC0 / 0xC0);  
Magic Number,VideoFiles,SequenceHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SequenceHeader,The following statement contains a magic number: VBV_buffer_size = ((Data [6] & 0x1F) << 5) + ((Data [7] & 0xF8) >> 3);  
Magic Number,VideoFiles,SequenceHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SequenceHeader,The following statement contains a magic number: VBV_buffer_size = ((Data [6] & 0x1F) << 5) + ((Data [7] & 0xF8) >> 3);  
Magic Number,VideoFiles,SequenceHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SequenceHeader,The following statement contains a magic number: VBV_buffer_size = ((Data [6] & 0x1F) << 5) + ((Data [7] & 0xF8) >> 3);  
Magic Number,VideoFiles,SequenceHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SequenceHeader,The following statement contains a magic number: VBV_buffer_size = ((Data [6] & 0x1F) << 5) + ((Data [7] & 0xF8) >> 3);  
Magic Number,VideoFiles,SequenceHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SequenceHeader,The following statement contains a magic number: constrained_parameters_flag = ((Data [7] & 0x04) == 0x04);  
Magic Number,VideoFiles,SequenceHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SequenceHeader,The following statement contains a magic number: load_intra_quantiser_matrix = ((Data [7] & 0x02) == 0x02);  
Magic Number,VideoFiles,SequenceHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SequenceHeader,The following statement contains a magic number: load_non_intra_quantiser_matrix = ((Data [7] & 0x01) == 0x01);  
Magic Number,VideoFiles,GOP,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: hour = (b [0] & 0x7c) / 4;  
Magic Number,VideoFiles,GOP,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: minute = (b [0] & 0x03) * 16 + (b [1] & 0xF0) / 16;  
Magic Number,VideoFiles,GOP,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: minute = (b [0] & 0x03) * 16 + (b [1] & 0xF0) / 16;  
Magic Number,VideoFiles,GOP,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: second = (b [1] & 0x07) * 8 + (b [2] & 0xE0) / 0x20;  
Magic Number,VideoFiles,GOP,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: second = (b [1] & 0x07) * 8 + (b [2] & 0xE0) / 0x20;  
Magic Number,VideoFiles,GOP,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: frame = (b [2] & 0x1F) * 2 + (b [3] & 0x80) / 0x80;  
Magic Number,VideoFiles,GOP,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: frame = (b [2] & 0x1F) * 2 + (b [3] & 0x80) / 0x80;  
Magic Number,VideoFiles,GOP,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodeGop,The following statement contains a magic number: frame = (b [2] & 0x1F) * 2 + (b [3] & 0x80) / 0x80;  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: try {  	switch (extensionType) {  	case 1:  		extT = "Sequence_Extension";  		int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  		bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  		int chroma_format = (Data [1] & 0x06) / 2;  		int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  		int vertical_size_extension = (Data [2] & 0x60) / 0x60;  		int bit_rate_extension;  		int vbv_buffer_size_extension;  		int low_delay;  		int frame_rate_extension_n;  		int frame_rate_extension_d;  		break;  	case 2:  		extT = "Sequence_Display_Extension";  		int video_format;  		bool color_description_flag = false;  		if (color_description_flag)  			toRead = 3;  		int color_primaries;  		int transfer_characteristics;  		int matrix_coefficients;  		int display_horizontal_size;  		int display_vertical_size;  		break;  	case 8:  		extT = "Picture_Coding_Extension";  		int intra_DC_precision = (Data [2] & 0x0C) >> 2;  		int picture_structure = (Data [2] & 0x03);  		bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  		bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  		bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  		bool q_scale_type = ((Data [3] & 0x10) == 0x10);  		bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  		bool alternate_scan = ((Data [3] & 0x04) == 0x04);  		bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  		bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  		bool progressive_frame = ((Data [4] & 0x80) == 0x80);  		bool composite_display = ((Data [4] & 0x40) == 0x40);  		if (composite_display) {  			toRead = 2;  			bool v_axis = ((Data [4] & 0x20) == 0x20);  			int field_sequence;  			bool sub_carrier;  			int burst_amplitude;  			int sub_carrier_phase;  		}  		int['] f_code = new int[2' 2];  		f_code [0' 0] = Data [0] & 0x0F;  		// forward horizontal  		f_code [0' 1] = (Data [1] & 0xF0) >> 4;  		//forward vertical  		f_code [1' 0] = Data [1] & 0x0F;  		//backward horizontal  		f_code [1' 1] = (Data [2] & 0x0F) >> 4;  		//backward vertical  		break;  	}  }  catch {  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: if (color_description_flag)  	toRead = 3;  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: toRead = 3;  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: if (composite_display) {  	toRead = 2;  	bool v_axis = ((Data [4] & 0x20) == 0x20);  	int field_sequence;  	bool sub_carrier;  	int burst_amplitude;  	int sub_carrier_phase;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: if (composite_display) {  	toRead = 2;  	bool v_axis = ((Data [4] & 0x20) == 0x20);  	int field_sequence;  	bool sub_carrier;  	int burst_amplitude;  	int sub_carrier_phase;  }  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: toRead = 2;  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: f_code [0' 1] = (Data [1] & 0xF0) >> 4;  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: f_code [1' 1] = (Data [2] & 0x0F) >> 4;  
Magic Number,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following statement contains a magic number: f_code [1' 1] = (Data [2] & 0x0F) >> 4;  
Magic Number,VideoFiles,VideoStream,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,PTS_DTS_Decode,The following statement contains a magic number: if (PTS_DTS_Buffer.Count == 2) {  	DTS = DecodePts_dts (PTS_DTS_Buffer [1]);  }  
Magic Number,VideoFiles,VideoStream,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,DecodePts_dts,The following statement contains a magic number: return p / 90;  
Magic Number,VideoFiles,VideoStream,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,VideoStream,The following statement contains a magic number: PES_scrambling_control = (extensionData [0] & 0x30) >> 4;  
Magic Number,VideoFiles,VideoStream,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,VideoStream,The following statement contains a magic number: PTS_DTS_flags = (extensionData [1] & 0xc0) >> 6;  
Magic Number,VideoFiles,VideoStream,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,VideoStream,The following statement contains a magic number: PES_header_data_length = extensionData [2];  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: rate_bound = c + (b + a * 256) * 256;  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: rate_bound = c + (b + a * 256) * 256;  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: audio_bound = (Data [3] & 0xFC) >> 2;  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: audio_bound = (Data [3] & 0xFC) >> 2;  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: fixed_flag = ((Data [3] & 0x02) == 0x02);  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: CSPS_flag = ((Data [3] & 0x01) == 0x01);  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: system_audio_lock_flag = ((Data [4] & 0x80) == 0x80);  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: system_video_lock_flag = ((Data [4] & 0x40) == 0x40);  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: video_bound = Data [4] & 0x1F;  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: packet_rate_restriction_flag = ((Data [5] & 0x80) == 0x80);  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: if (Data.Length > 6) {  	int i = 6;  	while (i < Data.Length) {  		Stream_bound_Entry ste = new Stream_bound_Entry ();  		ste.code = Data [i];  		ste.P_STD_buffer_bound_scale = ((Data [i + 1] & 0x20) == 0x20);  		ste.P_STD_buffer_size_bound = Data [i + 2] + (Data [i + 1] & 0x1F) * 256;  		stes.Add (ste);  		switch (Data [i]) {  		case 0xB9:  			break;  		case 0xB8:  			break;  		case 0xBD:  			break;  		case 0xBF:  			break;  		default:  			break;  		}  		i += 3;  	}  }  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: if (Data.Length > 6) {  	int i = 6;  	while (i < Data.Length) {  		Stream_bound_Entry ste = new Stream_bound_Entry ();  		ste.code = Data [i];  		ste.P_STD_buffer_bound_scale = ((Data [i + 1] & 0x20) == 0x20);  		ste.P_STD_buffer_size_bound = Data [i + 2] + (Data [i + 1] & 0x1F) * 256;  		stes.Add (ste);  		switch (Data [i]) {  		case 0xB9:  			break;  		case 0xB8:  			break;  		case 0xBD:  			break;  		case 0xBF:  			break;  		default:  			break;  		}  		i += 3;  	}  }  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: if (Data.Length > 6) {  	int i = 6;  	while (i < Data.Length) {  		Stream_bound_Entry ste = new Stream_bound_Entry ();  		ste.code = Data [i];  		ste.P_STD_buffer_bound_scale = ((Data [i + 1] & 0x20) == 0x20);  		ste.P_STD_buffer_size_bound = Data [i + 2] + (Data [i + 1] & 0x1F) * 256;  		stes.Add (ste);  		switch (Data [i]) {  		case 0xB9:  			break;  		case 0xB8:  			break;  		case 0xBD:  			break;  		case 0xBF:  			break;  		default:  			break;  		}  		i += 3;  	}  }  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: if (Data.Length > 6) {  	int i = 6;  	while (i < Data.Length) {  		Stream_bound_Entry ste = new Stream_bound_Entry ();  		ste.code = Data [i];  		ste.P_STD_buffer_bound_scale = ((Data [i + 1] & 0x20) == 0x20);  		ste.P_STD_buffer_size_bound = Data [i + 2] + (Data [i + 1] & 0x1F) * 256;  		stes.Add (ste);  		switch (Data [i]) {  		case 0xB9:  			break;  		case 0xB8:  			break;  		case 0xBD:  			break;  		case 0xBF:  			break;  		default:  			break;  		}  		i += 3;  	}  }  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: if (Data.Length > 6) {  	int i = 6;  	while (i < Data.Length) {  		Stream_bound_Entry ste = new Stream_bound_Entry ();  		ste.code = Data [i];  		ste.P_STD_buffer_bound_scale = ((Data [i + 1] & 0x20) == 0x20);  		ste.P_STD_buffer_size_bound = Data [i + 2] + (Data [i + 1] & 0x1F) * 256;  		stes.Add (ste);  		switch (Data [i]) {  		case 0xB9:  			break;  		case 0xB8:  			break;  		case 0xBD:  			break;  		case 0xBF:  			break;  		default:  			break;  		}  		i += 3;  	}  }  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: while (i < Data.Length) {  	Stream_bound_Entry ste = new Stream_bound_Entry ();  	ste.code = Data [i];  	ste.P_STD_buffer_bound_scale = ((Data [i + 1] & 0x20) == 0x20);  	ste.P_STD_buffer_size_bound = Data [i + 2] + (Data [i + 1] & 0x1F) * 256;  	stes.Add (ste);  	switch (Data [i]) {  	case 0xB9:  		break;  	case 0xB8:  		break;  	case 0xBD:  		break;  	case 0xBF:  		break;  	default:  		break;  	}  	i += 3;  }  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: while (i < Data.Length) {  	Stream_bound_Entry ste = new Stream_bound_Entry ();  	ste.code = Data [i];  	ste.P_STD_buffer_bound_scale = ((Data [i + 1] & 0x20) == 0x20);  	ste.P_STD_buffer_size_bound = Data [i + 2] + (Data [i + 1] & 0x1F) * 256;  	stes.Add (ste);  	switch (Data [i]) {  	case 0xB9:  		break;  	case 0xB8:  		break;  	case 0xBD:  		break;  	case 0xBF:  		break;  	default:  		break;  	}  	i += 3;  }  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: while (i < Data.Length) {  	Stream_bound_Entry ste = new Stream_bound_Entry ();  	ste.code = Data [i];  	ste.P_STD_buffer_bound_scale = ((Data [i + 1] & 0x20) == 0x20);  	ste.P_STD_buffer_size_bound = Data [i + 2] + (Data [i + 1] & 0x1F) * 256;  	stes.Add (ste);  	switch (Data [i]) {  	case 0xB9:  		break;  	case 0xB8:  		break;  	case 0xBD:  		break;  	case 0xBF:  		break;  	default:  		break;  	}  	i += 3;  }  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: ste.P_STD_buffer_size_bound = Data [i + 2] + (Data [i + 1] & 0x1F) * 256;  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: ste.P_STD_buffer_size_bound = Data [i + 2] + (Data [i + 1] & 0x1F) * 256;  
Magic Number,VideoFiles,SystemHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,SystemHeader,The following statement contains a magic number: i += 3;  
Magic Number,VideoFiles,PackHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,PackHeader,The following statement contains a magic number: src *= 300;  
Magic Number,VideoFiles,PackHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,PackHeader,The following statement contains a magic number: src = src / 27000.0;  
Magic Number,VideoFiles,PackHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,PackHeader,The following statement contains a magic number: program_Mux_Rate = ((Data [6] * 256 + Data [7]) << 6) + ((Data [8] & 0xFC) >> 2);  
Magic Number,VideoFiles,PackHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,PackHeader,The following statement contains a magic number: program_Mux_Rate = ((Data [6] * 256 + Data [7]) << 6) + ((Data [8] & 0xFC) >> 2);  
Magic Number,VideoFiles,PackHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,PackHeader,The following statement contains a magic number: program_Mux_Rate = ((Data [6] * 256 + Data [7]) << 6) + ((Data [8] & 0xFC) >> 2);  
Magic Number,VideoFiles,PackHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,PackHeader,The following statement contains a magic number: program_Mux_Rate = ((Data [6] * 256 + Data [7]) << 6) + ((Data [8] & 0xFC) >> 2);  
Magic Number,VideoFiles,PackHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,PackHeader,The following statement contains a magic number: program_Mux_Rate = ((Data [6] * 256 + Data [7]) << 6) + ((Data [8] & 0xFC) >> 2);  
Magic Number,VideoFiles,PackHeader,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,PackHeader,The following statement contains a magic number: program_Mux_Rate = ((Data [6] * 256 + Data [7]) << 6) + ((Data [8] & 0xFC) >> 2);  
Magic Number,VideoFiles,Picture,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Picture,The following statement contains a magic number: switch (ai) {  case 1:  	imageType = "I";  	break;  case 2:  	imageType = "P";  	break;  case 3:  	imageType = "B";  	break;  case 4:  	imageType = "D";  	break;  }  
Magic Number,VideoFiles,Picture,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Picture,The following statement contains a magic number: switch (ai) {  case 1:  	imageType = "I";  	break;  case 2:  	imageType = "P";  	break;  case 3:  	imageType = "B";  	break;  case 4:  	imageType = "D";  	break;  }  
Magic Number,VideoFiles,Picture,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Picture,The following statement contains a magic number: switch (ai) {  case 1:  	imageType = "I";  	break;  case 2:  	imageType = "P";  	break;  case 3:  	imageType = "B";  	break;  case 4:  	imageType = "D";  	break;  }  
Magic Number,VideoFiles,Picture,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Picture,The following statement contains a magic number: temperal_sequence_number = (Data [0] << 2) + ((Data [1] & 0xC0) >> 6);  
Magic Number,VideoFiles,Picture,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Picture,The following statement contains a magic number: temperal_sequence_number = (Data [0] << 2) + ((Data [1] & 0xC0) >> 6);  
Magic Number,VideoFiles,Picture,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Picture,The following statement contains a magic number: VBV_delay = ((Data [1] & 0x07) * 256 + Data [2]) * 8 + (Data [3] & 0xF8) / 8;  
Magic Number,VideoFiles,Picture,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Picture,The following statement contains a magic number: VBV_delay = ((Data [1] & 0x07) * 256 + Data [2]) * 8 + (Data [3] & 0xF8) / 8;  
Magic Number,VideoFiles,Picture,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Picture,The following statement contains a magic number: VBV_delay = ((Data [1] & 0x07) * 256 + Data [2]) * 8 + (Data [3] & 0xF8) / 8;  
Magic Number,VideoFiles,Picture,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Picture,The following statement contains a magic number: VBV_delay = ((Data [1] & 0x07) * 256 + Data [2]) * 8 + (Data [3] & 0xF8) / 8;  
Magic Number,VideoFiles,Picture,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Picture,The following statement contains a magic number: VBV_delay = ((Data [1] & 0x07) * 256 + Data [2]) * 8 + (Data [3] & 0xF8) / 8;  
Magic Number,VideoFiles,Picture,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,ToString,The following statement contains a magic number: temperal_sequence_number = (Data [0] << 2) + ((Data [1] & 0xC0) >> 6);  
Magic Number,VideoFiles,Picture,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,ToString,The following statement contains a magic number: temperal_sequence_number = (Data [0] << 2) + ((Data [1] & 0xC0) >> 6);  
Magic Number,VideoFiles,Slice,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Slice,The following statement contains a magic number: quantiserScaleCode = (Data [0] & 0xF8) / 8;  
Magic Number,VideoFiles,Slice,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Slice,The following statement contains a magic number: sliceExtensionFlag = ((Data [0] & 0x04) / 4 == 1);  
Magic Number,VideoFiles,VideoAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeVideo,The following statement contains a magic number: switch ((buf [0] & 0xc0) >> 6) {  case 0:  	coding_Mode = "Mpeg-1";  	break;  case 1:  	coding_Mode = "Mpeg-2";  	break;  }  
Magic Number,VideoFiles,VideoAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeVideo,The following statement contains a magic number: switch ((buf [0] & 0x30) >> 4) {  case 0:  	standard = "NTSC";  	break;  case 1:  	standard = "PAL";  	break;  }  
Magic Number,VideoFiles,VideoAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeVideo,The following statement contains a magic number: switch ((buf [0] & 0x0c) >> 2) {  case 0:  	aspect = "4:3";  	break;  case 3:  	aspect = "16:9";  	break;  }  
Magic Number,VideoFiles,VideoAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeVideo,The following statement contains a magic number: switch ((buf [0] & 0x0c) >> 2) {  case 0:  	aspect = "4:3";  	break;  case 3:  	aspect = "16:9";  	break;  }  
Magic Number,VideoFiles,AudioAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeAudio,The following statement contains a magic number: switch ((buf [0] & 0xE) >> 1) {  case 0:  	coding_Mode = "AC3";  	break;  case 2:  	coding_Mode = "Mpeg-1";  	break;  case 3:  	coding_Mode = "Mpeg-2ext";  	break;  case 4:  	coding_Mode = "LPCM";  	break;  case 6:  	coding_Mode = " DTS";  	break;  }  
Magic Number,VideoFiles,AudioAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeAudio,The following statement contains a magic number: switch ((buf [0] & 0xE) >> 1) {  case 0:  	coding_Mode = "AC3";  	break;  case 2:  	coding_Mode = "Mpeg-1";  	break;  case 3:  	coding_Mode = "Mpeg-2ext";  	break;  case 4:  	coding_Mode = "LPCM";  	break;  case 6:  	coding_Mode = " DTS";  	break;  }  
Magic Number,VideoFiles,AudioAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeAudio,The following statement contains a magic number: switch ((buf [0] & 0xE) >> 1) {  case 0:  	coding_Mode = "AC3";  	break;  case 2:  	coding_Mode = "Mpeg-1";  	break;  case 3:  	coding_Mode = "Mpeg-2ext";  	break;  case 4:  	coding_Mode = "LPCM";  	break;  case 6:  	coding_Mode = " DTS";  	break;  }  
Magic Number,VideoFiles,AudioAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeAudio,The following statement contains a magic number: switch ((buf [0] & 0xE) >> 1) {  case 0:  	coding_Mode = "AC3";  	break;  case 2:  	coding_Mode = "Mpeg-1";  	break;  case 3:  	coding_Mode = "Mpeg-2ext";  	break;  case 4:  	coding_Mode = "LPCM";  	break;  case 6:  	coding_Mode = " DTS";  	break;  }  
Magic Number,VideoFiles,AudioAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeAudio,The following statement contains a magic number: if (((buf [0] & 0x0C) >> 2) == 0)  	lg = false;  
Magic Number,VideoFiles,AudioAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeAudio,The following statement contains a magic number: switch ((buf [1] & 0x30) >> 2) {  case 0:  	sample_rate = "48 kbps";  	break;  case 1:  	sample_rate = "96 kbps";  	break;  }  
Magic Number,VideoFiles,AudioAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeAudio,The following statement contains a magic number: if (lg) {  	byte[] b = new byte[2];  	Buffer.BlockCopy (buf' 2' b' 0' 2);  	language_code = Encoding.Default.GetString (b);  }  
Magic Number,VideoFiles,AudioAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeAudio,The following statement contains a magic number: if (lg) {  	byte[] b = new byte[2];  	Buffer.BlockCopy (buf' 2' b' 0' 2);  	language_code = Encoding.Default.GetString (b);  }  
Magic Number,VideoFiles,AudioAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeAudio,The following statement contains a magic number: if (lg) {  	byte[] b = new byte[2];  	Buffer.BlockCopy (buf' 2' b' 0' 2);  	language_code = Encoding.Default.GetString (b);  }  
Magic Number,VideoFiles,AudioAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeAudio,The following statement contains a magic number: Buffer.BlockCopy (buf' 2' b' 0' 2);  
Magic Number,VideoFiles,AudioAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeAudio,The following statement contains a magic number: Buffer.BlockCopy (buf' 2' b' 0' 2);  
Magic Number,VideoFiles,VMG_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMG_IFO,The following statement contains a magic number: header = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 12);  
Magic Number,VideoFiles,VMG_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMG_IFO,The following statement contains a magic number: versionnumber = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 2);  
Magic Number,VideoFiles,VMG_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMG_IFO,The following statement contains a magic number: Vmg_category = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  
Magic Number,VideoFiles,VMG_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMG_IFO,The following statement contains a magic number: Provider_ID = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 32);  
Magic Number,VideoFiles,VMG_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMG_IFO,The following statement contains a magic number: vmg_POS = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 8);  
Magic Number,VideoFiles,VMG_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMG_IFO,The following statement contains a magic number: video_attributes_of_VMGM_VOBS = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 2);  
Magic Number,VideoFiles,VMG_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMG_IFO,The following statement contains a magic number: audio_attributes_of_VMGM_VOBS = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 8 * 8);  
Magic Number,VideoFiles,VMG_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMG_IFO,The following statement contains a magic number: audio_attributes_of_VMGM_VOBS = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 8 * 8);  
Magic Number,VideoFiles,VMG_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMG_IFO,The following statement contains a magic number: subpicture_attributes_of_VMGM_VOBS = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 6);  
Magic Number,VideoFiles,TS_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,TS_IFO,The following statement contains a magic number: header = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 12);  
Magic Number,VideoFiles,TS_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,TS_IFO,The following statement contains a magic number: version_number_TS = sw.ReadBytes (2);  
Magic Number,VideoFiles,TS_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,TS_IFO,The following statement contains a magic number: video_attributes_of_VTSM_VOBS = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 2);  
Magic Number,VideoFiles,TS_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,TS_IFO,The following statement contains a magic number: audio_attributes_of_VTSM_VOBS = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 8 * 8);  
Magic Number,VideoFiles,TS_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,TS_IFO,The following statement contains a magic number: audio_attributes_of_VTSM_VOBS = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 8 * 8);  
Magic Number,VideoFiles,TS_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,TS_IFO,The following statement contains a magic number: subpicture_attributes_of_VTSM_VOBS = sw.ReadBytes (6);  
Magic Number,VideoFiles,TS_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,TS_IFO,The following statement contains a magic number: video_attributes_of_VTS_VOBS = sw.ReadBytes (2);  
Magic Number,VideoFiles,TS_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,TS_IFO,The following statement contains a magic number: audio_attributes_of_VTS_VOBS = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 8 * 8);  
Magic Number,VideoFiles,TS_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,TS_IFO,The following statement contains a magic number: audio_attributes_of_VTS_VOBS = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 8 * 8);  
Magic Number,VideoFiles,TS_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,TS_IFO,The following statement contains a magic number: subpicture_attributes_of_VTS_VOBS = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 32 * 6);  
Magic Number,VideoFiles,TS_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,TS_IFO,The following statement contains a magic number: subpicture_attributes_of_VTS_VOBS = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 32 * 6);  
Magic Number,VideoFiles,TS_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,TS_IFO,The following statement contains a magic number: multichannel_extension = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 8 * 24);  
Magic Number,VideoFiles,TS_IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,TS_IFO,The following statement contains a magic number: multichannel_extension = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 8 * 24);  
Magic Number,VideoFiles,VMGM_LU,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_LU,The following statement contains a magic number: sw.Position += 2;  
Magic Number,VideoFiles,VMGM_PGCI_UT,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGCI_UT,The following statement contains a magic number: sw.Position += 2;  
Magic Number,VideoFiles,VMGM_PGCI_UT,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGCI_UT,The following statement contains a magic number: IsoLanguage = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 2);  
Magic Number,VideoFiles,PGC_SPST_CTL,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,PGC_SPST_CTL,The following statement contains a magic number: b = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  
Magic Number,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,The following statement contains a magic number: sw.Position += 2;  
Magic Number,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,The following statement contains a magic number: Playback = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4);  
Magic Number,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,The following statement contains a magic number: sw.Position += 4;  
Magic Number,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	pgc_ast_ctrl.Add (new PGC_AST_CTL (sw));  
Magic Number,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,The following statement contains a magic number: for (int i = 0; i < 32; i++)  	pgc_spst_ctrl.Add (new PGC_SPST_CTL (sw));  
Magic Number,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,The following statement contains a magic number: sw.Position += 8;  
Magic Number,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,The following statement contains a magic number: palettes = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4 * 16);  
Magic Number,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,The following statement contains a magic number: palettes = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 4 * 16);  
Magic Number,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,The following statement contains a magic number: if ((short)offsetToCommands.Value != 0) {  	sw.Position = (int)PositionOfStructureInFile + (short)offsetToCommands.Value;  	nb_pre_commands = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	nb_post_commands = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	nb_cell_commands = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	end_adress = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	pre_commands = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' (short)nb_pre_commands.Value * 8);  	post_commands = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' (short)nb_post_commands.Value * 8);  	cell_commands = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' (short)nb_cell_commands.Value * 8);  	sw.Position += (int)PositionOfStructureInFile + (short)end_adress.Value;  }  
Magic Number,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,The following statement contains a magic number: if ((short)offsetToCommands.Value != 0) {  	sw.Position = (int)PositionOfStructureInFile + (short)offsetToCommands.Value;  	nb_pre_commands = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	nb_post_commands = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	nb_cell_commands = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	end_adress = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	pre_commands = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' (short)nb_pre_commands.Value * 8);  	post_commands = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' (short)nb_post_commands.Value * 8);  	cell_commands = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' (short)nb_cell_commands.Value * 8);  	sw.Position += (int)PositionOfStructureInFile + (short)end_adress.Value;  }  
Magic Number,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,The following statement contains a magic number: if ((short)offsetToCommands.Value != 0) {  	sw.Position = (int)PositionOfStructureInFile + (short)offsetToCommands.Value;  	nb_pre_commands = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	nb_post_commands = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	nb_cell_commands = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	end_adress = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	pre_commands = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' (short)nb_pre_commands.Value * 8);  	post_commands = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' (short)nb_post_commands.Value * 8);  	cell_commands = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' (short)nb_cell_commands.Value * 8);  	sw.Position += (int)PositionOfStructureInFile + (short)end_adress.Value;  }  
Magic Number,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,The following statement contains a magic number: pre_commands = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' (short)nb_pre_commands.Value * 8);  
Magic Number,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,The following statement contains a magic number: post_commands = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' (short)nb_post_commands.Value * 8);  
Magic Number,VideoFiles,VMGM_PGC,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_PGC,The following statement contains a magic number: cell_commands = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' (short)nb_cell_commands.Value * 8);  
Magic Number,VideoFiles,VMGM_C_ADT,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,VMGM_C_ADT,The following statement contains a magic number: sw.Position += 6;  
Magic Number,VideoFiles,IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,IFO,The following statement contains a magic number: switch ((string)header.Value) {  case "DVDVIDEO-VMG_IFO":  //in VIDEO_TS.IFO  case "DVDVIDEO-VMG":  	#region  	vmg = new VMG_IFO (sw);  	version = ((((byte[])vmg.Versionnumber.Value) [1] & 0xF0) >> 4).ToString () + "." + ((((byte[])vmg.Versionnumber.Value) [1] & 0x0F).ToString ());  	regionCode = ((byte[])vmg.Vmg_category.Value) [1];  	video.Add (new VideoAttributes ("VMGM_VOBS"' (byte[])vmg.Video_attributes_of_VMGM_VOBS.Value));  	AddAudio ((short)vmg.Number_of_audio_streams_in_VMGM_VOBS.Value' (byte[])vmg.Audio_attributes_of_VMGM_VOBS.Value' "VMGM_VOBS");  	ParseTableOfTitles ();  	sw.Position = (int)vmg.Start_address_of_First_Play_program_chain.Value;  	First_pgc = new VMGM_PGC (sw);  	ReadMenu (((int)vmg.Sector_pointer_to_Menu_Program_Chain_table.Value));  	//   the region code is stored in the file "VIDEO_TS.IFO" (table "VMGM_MAT")' byte offsets 34 and 35.[12]  	sw.Position = (int)vmg.Sector_pointer_to_VMGM_C_ADT.Value * 0x800;  	vmgm_c_adt = new VMGM_C_ADT (sw);  	#endregion  	break;  case "DVDVIDEO-VTS":  	ts_ifo = new TS_IFO (sw);  	video.Add (new VideoAttributes ("VTSM_VOBS"' (byte[])ts_ifo.Video_attributes_of_VTSM_VOBS.Value));  	video.Add (new VideoAttributes ("VTS_VOBS"' (byte[])ts_ifo.Video_attributes_of_VTS_VOBS));  	AddAudio ((short)ts_ifo.Number_of_audio_streams_in_VTSM_VOBS.Value' (byte[])ts_ifo.Audio_attributes_of_VTSM_VOBS.Value' "VTSM_VOBS");  	AddAudio ((short)ts_ifo.Number_of_audio_streams_in_VTS_VOBS.Value' (byte[])ts_ifo.Audio_attributes_of_VTS_VOBS.Value' "VTS_VOBS");  	ReadMenu (((int)ts_ifo.Sector_pointer_to_VTSM_PGCI_UT.Value));  	break;  }  
Magic Number,VideoFiles,IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,IFO,The following statement contains a magic number: version = ((((byte[])vmg.Versionnumber.Value) [1] & 0xF0) >> 4).ToString () + "." + ((((byte[])vmg.Versionnumber.Value) [1] & 0x0F).ToString ());  
Magic Number,VideoFiles,IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,ParseTableOfTitles,The following statement contains a magic number: sw.Position += 6;  
Magic Number,VideoFiles,IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,AddAudio,The following statement contains a magic number: for (int i = 0; i < number_of_audio_streams; i++) {  	byte[] b = new byte[8];  	if (i * 8 < audio_attributes.Length) {  		Buffer.BlockCopy (audio_attributes' i * 8' b' 0' 8);  		audio.Add (new AudioAttributes (name' b));  	}  }  
Magic Number,VideoFiles,IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,AddAudio,The following statement contains a magic number: for (int i = 0; i < number_of_audio_streams; i++) {  	byte[] b = new byte[8];  	if (i * 8 < audio_attributes.Length) {  		Buffer.BlockCopy (audio_attributes' i * 8' b' 0' 8);  		audio.Add (new AudioAttributes (name' b));  	}  }  
Magic Number,VideoFiles,IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,AddAudio,The following statement contains a magic number: for (int i = 0; i < number_of_audio_streams; i++) {  	byte[] b = new byte[8];  	if (i * 8 < audio_attributes.Length) {  		Buffer.BlockCopy (audio_attributes' i * 8' b' 0' 8);  		audio.Add (new AudioAttributes (name' b));  	}  }  
Magic Number,VideoFiles,IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,AddAudio,The following statement contains a magic number: for (int i = 0; i < number_of_audio_streams; i++) {  	byte[] b = new byte[8];  	if (i * 8 < audio_attributes.Length) {  		Buffer.BlockCopy (audio_attributes' i * 8' b' 0' 8);  		audio.Add (new AudioAttributes (name' b));  	}  }  
Magic Number,VideoFiles,IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,AddAudio,The following statement contains a magic number: if (i * 8 < audio_attributes.Length) {  	Buffer.BlockCopy (audio_attributes' i * 8' b' 0' 8);  	audio.Add (new AudioAttributes (name' b));  }  
Magic Number,VideoFiles,IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,AddAudio,The following statement contains a magic number: if (i * 8 < audio_attributes.Length) {  	Buffer.BlockCopy (audio_attributes' i * 8' b' 0' 8);  	audio.Add (new AudioAttributes (name' b));  }  
Magic Number,VideoFiles,IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,AddAudio,The following statement contains a magic number: if (i * 8 < audio_attributes.Length) {  	Buffer.BlockCopy (audio_attributes' i * 8' b' 0' 8);  	audio.Add (new AudioAttributes (name' b));  }  
Magic Number,VideoFiles,IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,AddAudio,The following statement contains a magic number: Buffer.BlockCopy (audio_attributes' i * 8' b' 0' 8);  
Magic Number,VideoFiles,IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,AddAudio,The following statement contains a magic number: Buffer.BlockCopy (audio_attributes' i * 8' b' 0' 8);  
Missing Default,VideoFiles,Chunk,C:\repos\mbatest_Binhed\Mpeg2\AVIFile.cs,Chunk,The following switch statement is missing a default case: switch ((string)parent.Content [0].Content [0].AviStreamInfo.FccType.Value) {  case "iavs":  	dvInfo = new DVINFO (sw);  	break;  case "vids":  	bitmapInfo = new BITMAPINFO (sw);  	break;  case "auds":  	waveFomat = new WAVEFORMATEX (sw);  	break;  }  
Missing Default,VideoFiles,DataBlock,C:\repos\mbatest_Binhed\Mpeg2\Mkv.cs,DataBlock,The following switch statement is missing a default case: switch (el_type) {  case EbmlElementType.TEXTA:  	formattedValue = Encoding.Default.GetString ((byte[])value.Value);  	break;  case EbmlElementType.TEXTU:  	formattedValue = Encoding.UTF8.GetString ((byte[])value.Value);  	break;  case EbmlElementType.DATE:  	break;  case EbmlElementType.SIGNED:  case EbmlElementType.UNSIGNED:  	break;  }  
Missing Default,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following switch statement is missing a default case: switch (aa) {  case 1:  	buffer = sw.ReadBytes (6);  	b.Data = buffer;  	break;  case 2:  	buffer = sw.ReadBytes (13);  	// ???  	b.Data = buffer;  	break;  case 8:  	buffer = sw.ReadBytes (5);  	b.Data = buffer;  	break;  }  
Missing Default,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following switch statement is missing a default case: switch (aa) {  case 1:  	if (CurrentSequence != null)  		CurrentSequence.SequenceExtension = ex;  	break;  case 4:  	break;  case 8:  	if (CurrentPicture != null)  		CurrentPicture.pictureExtension = ex;  	break;  }  
Missing Default,VideoFiles,Mpeg2,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Mpeg2,The following switch statement is missing a default case: switch (CurrentStream.PTS_DTS_flags) {  case 0x02:  	CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  	break;  case 0x01:  case 0x03:  	CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  	CurrentStream.PTS_DTS_Buffer.Add (sw.ReadBytes (5));  	break;  }  
Missing Default,VideoFiles,Extension,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,detail,The following switch statement is missing a default case: switch (extensionType) {  case 1:  	extT = "Sequence_Extension";  	int profileAndLevel = ((Data [0] & 0x0F) << 4) + ((Data [1] & 0xF0) >> 4);  	bool progressive_sequence = ((Data [1] & 0x08) == 0x08);  	int chroma_format = (Data [1] & 0x06) / 2;  	int horizontal_size_extension = (Data [1] & 0x01) * 2 + (Data [2] & 0x0C) / 0x0C;  	int vertical_size_extension = (Data [2] & 0x60) / 0x60;  	int bit_rate_extension;  	int vbv_buffer_size_extension;  	int low_delay;  	int frame_rate_extension_n;  	int frame_rate_extension_d;  	break;  case 2:  	extT = "Sequence_Display_Extension";  	int video_format;  	bool color_description_flag = false;  	if (color_description_flag)  		toRead = 3;  	int color_primaries;  	int transfer_characteristics;  	int matrix_coefficients;  	int display_horizontal_size;  	int display_vertical_size;  	break;  case 8:  	extT = "Picture_Coding_Extension";  	int intra_DC_precision = (Data [2] & 0x0C) >> 2;  	int picture_structure = (Data [2] & 0x03);  	bool Top_Field_First = ((Data [3] & 0x80) == 0x80);  	bool frame_pred_frame_dct = ((Data [3] & 0x40) == 0x40);  	bool concealment_motion_vectors = ((Data [3] & 0x20) == 0x20);  	bool q_scale_type = ((Data [3] & 0x10) == 0x10);  	bool intra_vlc_format = ((Data [3] & 0x08) == 0x08);  	bool alternate_scan = ((Data [3] & 0x04) == 0x04);  	bool Repeat_First_Field = ((Data [3] & 0x02) == 0x02);  	bool chroma_420_type = ((Data [3] & 0x01) == 0x01);  	bool progressive_frame = ((Data [4] & 0x80) == 0x80);  	bool composite_display = ((Data [4] & 0x40) == 0x40);  	if (composite_display) {  		toRead = 2;  		bool v_axis = ((Data [4] & 0x20) == 0x20);  		int field_sequence;  		bool sub_carrier;  		int burst_amplitude;  		int sub_carrier_phase;  	}  	int['] f_code = new int[2' 2];  	f_code [0' 0] = Data [0] & 0x0F;  	// forward horizontal  	f_code [0' 1] = (Data [1] & 0xF0) >> 4;  	//forward vertical  	f_code [1' 0] = Data [1] & 0x0F;  	//backward horizontal  	f_code [1' 1] = (Data [2] & 0x0F) >> 4;  	//backward vertical  	break;  }  
Missing Default,VideoFiles,Picture,C:\repos\mbatest_Binhed\Mpeg2\Mpeg.cs,Picture,The following switch statement is missing a default case: switch (ai) {  case 1:  	imageType = "I";  	break;  case 2:  	imageType = "P";  	break;  case 3:  	imageType = "B";  	break;  case 4:  	imageType = "D";  	break;  }  
Missing Default,VideoFiles,VideoAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeVideo,The following switch statement is missing a default case: switch ((buf [0] & 0xc0) >> 6) {  case 0:  	coding_Mode = "Mpeg-1";  	break;  case 1:  	coding_Mode = "Mpeg-2";  	break;  }  
Missing Default,VideoFiles,VideoAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeVideo,The following switch statement is missing a default case: switch ((buf [0] & 0x30) >> 4) {  case 0:  	standard = "NTSC";  	break;  case 1:  	standard = "PAL";  	break;  }  
Missing Default,VideoFiles,VideoAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeVideo,The following switch statement is missing a default case: switch ((buf [0] & 0x0c) >> 2) {  case 0:  	aspect = "4:3";  	break;  case 3:  	aspect = "16:9";  	break;  }  
Missing Default,VideoFiles,VideoAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeVideo,The following switch statement is missing a default case: switch (buf [1] & 0x30) {  case 0:  	resolution = "720x576";  	if (standard == "NTSC")  		resolution = "720x480";  	break;  case 1:  	resolution = "704x576";  	break;  }  
Missing Default,VideoFiles,AudioAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeAudio,The following switch statement is missing a default case: switch ((buf [0] & 0xE) >> 1) {  case 0:  	coding_Mode = "AC3";  	break;  case 2:  	coding_Mode = "Mpeg-1";  	break;  case 3:  	coding_Mode = "Mpeg-2ext";  	break;  case 4:  	coding_Mode = "LPCM";  	break;  case 6:  	coding_Mode = " DTS";  	break;  }  
Missing Default,VideoFiles,AudioAttributes,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,DecodeAudio,The following switch statement is missing a default case: switch ((buf [1] & 0x30) >> 2) {  case 0:  	sample_rate = "48 kbps";  	break;  case 1:  	sample_rate = "96 kbps";  	break;  }  
Missing Default,VideoFiles,IFO,C:\repos\mbatest_Binhed\Mpeg2\Ifo.cs,IFO,The following switch statement is missing a default case: switch ((string)header.Value) {  case "DVDVIDEO-VMG_IFO":  //in VIDEO_TS.IFO  case "DVDVIDEO-VMG":  	#region  	vmg = new VMG_IFO (sw);  	version = ((((byte[])vmg.Versionnumber.Value) [1] & 0xF0) >> 4).ToString () + "." + ((((byte[])vmg.Versionnumber.Value) [1] & 0x0F).ToString ());  	regionCode = ((byte[])vmg.Vmg_category.Value) [1];  	video.Add (new VideoAttributes ("VMGM_VOBS"' (byte[])vmg.Video_attributes_of_VMGM_VOBS.Value));  	AddAudio ((short)vmg.Number_of_audio_streams_in_VMGM_VOBS.Value' (byte[])vmg.Audio_attributes_of_VMGM_VOBS.Value' "VMGM_VOBS");  	ParseTableOfTitles ();  	sw.Position = (int)vmg.Start_address_of_First_Play_program_chain.Value;  	First_pgc = new VMGM_PGC (sw);  	ReadMenu (((int)vmg.Sector_pointer_to_Menu_Program_Chain_table.Value));  	//   the region code is stored in the file "VIDEO_TS.IFO" (table "VMGM_MAT")' byte offsets 34 and 35.[12]  	sw.Position = (int)vmg.Sector_pointer_to_VMGM_C_ADT.Value * 0x800;  	vmgm_c_adt = new VMGM_C_ADT (sw);  	#endregion  	break;  case "DVDVIDEO-VTS":  	ts_ifo = new TS_IFO (sw);  	video.Add (new VideoAttributes ("VTSM_VOBS"' (byte[])ts_ifo.Video_attributes_of_VTSM_VOBS.Value));  	video.Add (new VideoAttributes ("VTS_VOBS"' (byte[])ts_ifo.Video_attributes_of_VTS_VOBS));  	AddAudio ((short)ts_ifo.Number_of_audio_streams_in_VTSM_VOBS.Value' (byte[])ts_ifo.Audio_attributes_of_VTSM_VOBS.Value' "VTSM_VOBS");  	AddAudio ((short)ts_ifo.Number_of_audio_streams_in_VTS_VOBS.Value' (byte[])ts_ifo.Audio_attributes_of_VTS_VOBS.Value' "VTS_VOBS");  	ReadMenu (((int)ts_ifo.Sector_pointer_to_VTSM_PGCI_UT.Value));  	break;  }  
