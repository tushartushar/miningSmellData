Implementation smell,Namespace,Class,File,Method,Description
Long Method,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The method has 416 lines of code.
Long Method,BinHed,FileViewer,C:\repos\mbatest_Binhed\BinHed\FileViewer.cs,FillTreeNode,The method has 189 lines of code.
Long Method,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The method has 168 lines of code.
Long Method,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The method has 133 lines of code.
Complex Method,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,BinDecoder,Cyclomatic complexity of the method is 9
Complex Method,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,Cyclomatic complexity of the method is 15
Complex Method,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,Cyclomatic complexity of the method is 196
Complex Method,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,hexa_Click,Cyclomatic complexity of the method is 12
Complex Method,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,hexToolStripMenuItem_Click,Cyclomatic complexity of the method is 20
Complex Method,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,textBoxPath_TextChanged,Cyclomatic complexity of the method is 11
Complex Method,BinHed,FileViewer,C:\repos\mbatest_Binhed\BinHed\FileViewer.cs,FillTreeNode,Cyclomatic complexity of the method is 80
Complex Method,BinHed,FileViewer,C:\repos\mbatest_Binhed\BinHed\FileViewer.cs,treeView1_AfterSelect,Cyclomatic complexity of the method is 14
Complex Method,BinHed,Helpers,C:\repos\mbatest_Binhed\BinHed\Helpers.cs,IsUserInAdminGroup,Cyclomatic complexity of the method is 10
Complex Method,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,AviHeaders,Cyclomatic complexity of the method is 8
Complex Method,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,Cyclomatic complexity of the method is 97
Complex Method,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,Cyclomatic complexity of the method is 11
Complex Method,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,Cyclomatic complexity of the method is 13
Complex Method,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,Cyclomatic complexity of the method is 16
Long Parameter List,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,SetWindowPos,The method has 7 parameters.
Long Parameter List,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,MoveWindow,The method has 6 parameters.
Long Parameter List,BinHed,NativeMethods,C:\repos\mbatest_Binhed\BinHed\NativeMethods.cs,GetTokenInformation,The method has 5 parameters.
Long Parameter List,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,SetWindowPos,The method has 7 parameters.
Long Parameter List,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,MoveWindow,The method has 6 parameters.
Long Statement,BinHed,DataSet1,C:\repos\mbatest_Binhed\BinHed\DataSet1.Designer.cs,GetTypedDataSetSchema,The length of the statement  "			for (global::System.Collections.IEnumerator schemas = xs.Schemas (dsSchema.TargetNamespace).GetEnumerator (); schemas.MoveNext ();) { " is 133.
Long Statement,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The length of the statement  "                        object dummy = null;*/document = wd.Workbooks.Open ((string)fileName' 0' true' 5' ""' ""' true' XlPlatform.xlWindows' "\t"' false' false' 0' true' 1' 0); " is 153.
Long Statement,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The length of the statement  "			SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME); " is 145.
Long Statement,BinHed,Helpers,C:\repos\mbatest_Binhed\BinHed\Helpers.cs,IsUserInAdminGroup,The length of the statement  "		if (!NativeMethods.OpenProcessToken (Process.GetCurrentProcess ().Handle' NativeMethods.TOKEN_QUERY | NativeMethods.TOKEN_DUPLICATE' out hToken)) { " is 147.
Long Statement,BinHed,Helpers,C:\repos\mbatest_Binhed\BinHed\Helpers.cs,IsUserInAdminGroup,The length of the statement  "			if (!NativeMethods.GetTokenInformation (hToken' TOKEN_INFORMATION_CLASS.TokenElevationType' pElevationType' cbSize' out cbSize)) { " is 130.
Long Statement,BinHed,Helpers,C:\repos\mbatest_Binhed\BinHed\Helpers.cs,IsUserInAdminGroup,The length of the statement  "				if (!NativeMethods.GetTokenInformation (hToken' TOKEN_INFORMATION_CLASS.TokenLinkedToken' pLinkedToken' cbSize' out cbSize)) { " is 126.
Long Statement,BinHed,Helpers,C:\repos\mbatest_Binhed\BinHed\Helpers.cs,IsProcessElevated,The length of the statement  "		if (!NativeMethods.GetTokenInformation (hToken' TOKEN_INFORMATION_CLASS.TokenElevation' pTokenElevation' cbTokenElevation' out cbTokenElevation)) { " is 147.
Long Statement,BinHed,Helpers,C:\repos\mbatest_Binhed\BinHed\Helpers.cs,GetProcessIntegrityLevel,The length of the statement  "		if (!NativeMethods.GetTokenInformation (hToken' TOKEN_INFORMATION_CLASS.TokenIntegrityLevel' IntPtr.Zero' 0' out cbTokenIL)) { " is 126.
Long Statement,BinHed,Helpers,C:\repos\mbatest_Binhed\BinHed\Helpers.cs,GetProcessIntegrityLevel,The length of the statement  "		if (!NativeMethods.GetTokenInformation (hToken' TOKEN_INFORMATION_CLASS.TokenIntegrityLevel' pTokenIL' cbTokenIL' out cbTokenIL)) { " is 131.
Long Statement,BinHed,Helpers,C:\repos\mbatest_Binhed\BinHed\Helpers.cs,GetProcessIntegrityLevel,The length of the statement  "		TOKEN_MANDATORY_LABEL tokenIL = (TOKEN_MANDATORY_LABEL)Marshal.PtrToStructure (pTokenIL' typeof(TOKEN_MANDATORY_LABEL)); " is 120.
Long Statement,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The length of the statement  "	EndOfFile (this' new SequenceEventArgs (CurrentFrameDate' CurrentTimeCode' (int)fileHdr.NbTotalFrames' SequenceNumber)); " is 120.
Long Statement,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The length of the statement  "						if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) { " is 147.
Long Statement,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The length of the statement  "				NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber)); " is 122.
Long Statement,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The length of the statement  "				//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString()); " is 273.
Long Statement,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The length of the statement  "				if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) { " is 206.
Long Statement,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The length of the statement  "					//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx"); " is 139.
Long Statement,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The length of the statement  "		//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString()); " is 282.
Long Statement,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The length of the statement  "			SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME); " is 145.
Complex Conditional,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The conditional expression  "(frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)"  is complex.
Complex Conditional,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The conditional expression  "(ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")"  is complex.
Complex Conditional,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The conditional expression  "(currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)"  is complex.
Empty Catch Block,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,CloseControl,The method has an empty catch block.
Empty Catch Block,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The method has an empty catch block.
Empty Catch Block,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The method has an empty catch block.
Empty Catch Block,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The method has an empty catch block.
Empty Catch Block,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The method has an empty catch block.
Empty Catch Block,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,RestoreWord,The method has an empty catch block.
Empty Catch Block,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,RestoreWord,The method has an empty catch block.
Empty Catch Block,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Dump_Click,The method has an empty catch block.
Empty Catch Block,BinHed,FileViewer,C:\repos\mbatest_Binhed\BinHed\FileViewer.cs,FillTreeNode,The method has an empty catch block.
Empty Catch Block,BinHed,FileViewer,C:\repos\mbatest_Binhed\BinHed\FileViewer.cs,treeView1_AfterSelect,The method has an empty catch block.
Empty Catch Block,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,CloseControl,The method has an empty catch block.
Empty Catch Block,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The method has an empty catch block.
Empty Catch Block,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The method has an empty catch block.
Empty Catch Block,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The method has an empty catch block.
Empty Catch Block,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The method has an empty catch block.
Empty Catch Block,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The method has an empty catch block.
Empty Catch Block,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,RestoreWord,The method has an empty catch block.
Empty Catch Block,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,RestoreWord,The method has an empty catch block.
Magic Number,BinHed,DataInspector,C:\repos\mbatest_Binhed\BinHed\DataInspector.cs,ShowData,The following statement contains a magic number: if (b.Length < 2)  	return;  
Magic Number,BinHed,DataInspector,C:\repos\mbatest_Binhed\BinHed\DataInspector.cs,ShowData,The following statement contains a magic number: if (b.Length < 4)  	return;  
Magic Number,BinHed,DataInspector,C:\repos\mbatest_Binhed\BinHed\DataInspector.cs,ShowData,The following statement contains a magic number: if (b.Length < 8)  	return;  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeBMP,The following statement contains a magic number: FS.Read (buffer' 0' 55);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeBMP,The following statement contains a magic number: Buffer.BlockCopy (buffer' 2' c' 0' 4);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeBMP,The following statement contains a magic number: Buffer.BlockCopy (buffer' 2' c' 0' 4);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeBMP,The following statement contains a magic number: Buffer.BlockCopy (buffer' 10' c' 0' 4);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeBMP,The following statement contains a magic number: Buffer.BlockCopy (buffer' 10' c' 0' 4);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeBMP,The following statement contains a magic number: Buffer.BlockCopy (buffer' 18' c' 0' 4);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeBMP,The following statement contains a magic number: Buffer.BlockCopy (buffer' 18' c' 0' 4);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeBMP,The following statement contains a magic number: Buffer.BlockCopy (buffer' 22' c' 0' 4);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeBMP,The following statement contains a magic number: Buffer.BlockCopy (buffer' 22' c' 0' 4);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeBMP,The following statement contains a magic number: c = new byte[2];  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeBMP,The following statement contains a magic number: Buffer.BlockCopy (buffer' 28' c' 0' 2);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeBMP,The following statement contains a magic number: Buffer.BlockCopy (buffer' 28' c' 0' 2);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodePNG,The following statement contains a magic number: FS.Read (buffer' 0' 8);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeCHM,The following statement contains a magic number: Buffer.BlockCopy (buffer' 4' c' 0' 4);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeCHM,The following statement contains a magic number: Buffer.BlockCopy (buffer' 4' c' 0' 4);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeCHM,The following statement contains a magic number: Buffer.BlockCopy (buffer' 8' c' 0' 4);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeCHM,The following statement contains a magic number: Buffer.BlockCopy (buffer' 8' c' 0' 4);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeCHM,The following statement contains a magic number: Buffer.BlockCopy (buffer' 0x10' c' 0' 4);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,DecodeCHM,The following statement contains a magic number: Buffer.BlockCopy (buffer' 0x14' c' 0' 4);  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,ConvertToInt,The following statement contains a magic number: for (int w = 0; w < c.Length; w++) {  	t = 256 * t + (int)c [c.Length - 1 - w];  }  
Magic Number,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,ConvertToInt,The following statement contains a magic number: t = 256 * t + (int)c [c.Length - 1 - w];  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size (440' 336);  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size (440' 336);  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: if (wordWnd != 0) {  	SetParent (wordWnd' this.Handle.ToInt32 ());  	object fileName = filename;  	object newTemplate = false;  	object docType = 0;  	object readOnly = true;  	object isVisible = true;  	object missing = System.Reflection.Missing.Value;  	try {  		if (wd == null) {  			throw new WordInstanceException ();  		}  		if (wd.Workbooks == null) {  			throw new DocumentInstanceException ();  		}  		if (wd != null && wd.Workbooks != null) {  			/*               Object UpdateLinks;                          Object ReadOnly;                         Object Format;                         Object Password;                         Object WriteResPassword;                         Object IgnoreReadOnlyRecommended;                         Object Origin;                         Object Delimiter;                         Object Editable;                         Object Notify;                         Object Converter;                         Object AddToMru;                          Object Local;                         Object CorruptLoad;                         object dummy = null;*/document = wd.Workbooks.Open ((string)fileName' 0' true' 5' ""' ""' true' XlPlatform.xlWindows' "\t"' false' false' 0' true' 1' 0);  		}  		if (document == null) {  			throw new ValidDocumentException ();  		}  	}  	catch {  	}  	int counter = 0;  	// wd.ActiveWindow.Application.CommandBars.Count;  	for (int i = 0; i < counter; i++) {  		try {  			//             wd.ActiveWindow.Application.CommandBars[i].Enabled = false;  		}  		catch {  		}  	}  	try {  		wd.Visible = true;  		//                   wd.Activate();  		SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  		MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  	}  	catch {  		MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  	}  	this.Parent.Focus ();  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: if (wordWnd != 0) {  	SetParent (wordWnd' this.Handle.ToInt32 ());  	object fileName = filename;  	object newTemplate = false;  	object docType = 0;  	object readOnly = true;  	object isVisible = true;  	object missing = System.Reflection.Missing.Value;  	try {  		if (wd == null) {  			throw new WordInstanceException ();  		}  		if (wd.Workbooks == null) {  			throw new DocumentInstanceException ();  		}  		if (wd != null && wd.Workbooks != null) {  			/*               Object UpdateLinks;                          Object ReadOnly;                         Object Format;                         Object Password;                         Object WriteResPassword;                         Object IgnoreReadOnlyRecommended;                         Object Origin;                         Object Delimiter;                         Object Editable;                         Object Notify;                         Object Converter;                         Object AddToMru;                          Object Local;                         Object CorruptLoad;                         object dummy = null;*/document = wd.Workbooks.Open ((string)fileName' 0' true' 5' ""' ""' true' XlPlatform.xlWindows' "\t"' false' false' 0' true' 1' 0);  		}  		if (document == null) {  			throw new ValidDocumentException ();  		}  	}  	catch {  	}  	int counter = 0;  	// wd.ActiveWindow.Application.CommandBars.Count;  	for (int i = 0; i < counter; i++) {  		try {  			//             wd.ActiveWindow.Application.CommandBars[i].Enabled = false;  		}  		catch {  		}  	}  	try {  		wd.Visible = true;  		//                   wd.Activate();  		SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  		MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  	}  	catch {  		MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  	}  	this.Parent.Focus ();  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: if (wordWnd != 0) {  	SetParent (wordWnd' this.Handle.ToInt32 ());  	object fileName = filename;  	object newTemplate = false;  	object docType = 0;  	object readOnly = true;  	object isVisible = true;  	object missing = System.Reflection.Missing.Value;  	try {  		if (wd == null) {  			throw new WordInstanceException ();  		}  		if (wd.Workbooks == null) {  			throw new DocumentInstanceException ();  		}  		if (wd != null && wd.Workbooks != null) {  			/*               Object UpdateLinks;                          Object ReadOnly;                         Object Format;                         Object Password;                         Object WriteResPassword;                         Object IgnoreReadOnlyRecommended;                         Object Origin;                         Object Delimiter;                         Object Editable;                         Object Notify;                         Object Converter;                         Object AddToMru;                          Object Local;                         Object CorruptLoad;                         object dummy = null;*/document = wd.Workbooks.Open ((string)fileName' 0' true' 5' ""' ""' true' XlPlatform.xlWindows' "\t"' false' false' 0' true' 1' 0);  		}  		if (document == null) {  			throw new ValidDocumentException ();  		}  	}  	catch {  	}  	int counter = 0;  	// wd.ActiveWindow.Application.CommandBars.Count;  	for (int i = 0; i < counter; i++) {  		try {  			//             wd.ActiveWindow.Application.CommandBars[i].Enabled = false;  		}  		catch {  		}  	}  	try {  		wd.Visible = true;  		//                   wd.Activate();  		SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  		MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  	}  	catch {  		MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  	}  	this.Parent.Focus ();  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: if (wordWnd != 0) {  	SetParent (wordWnd' this.Handle.ToInt32 ());  	object fileName = filename;  	object newTemplate = false;  	object docType = 0;  	object readOnly = true;  	object isVisible = true;  	object missing = System.Reflection.Missing.Value;  	try {  		if (wd == null) {  			throw new WordInstanceException ();  		}  		if (wd.Workbooks == null) {  			throw new DocumentInstanceException ();  		}  		if (wd != null && wd.Workbooks != null) {  			/*               Object UpdateLinks;                          Object ReadOnly;                         Object Format;                         Object Password;                         Object WriteResPassword;                         Object IgnoreReadOnlyRecommended;                         Object Origin;                         Object Delimiter;                         Object Editable;                         Object Notify;                         Object Converter;                         Object AddToMru;                          Object Local;                         Object CorruptLoad;                         object dummy = null;*/document = wd.Workbooks.Open ((string)fileName' 0' true' 5' ""' ""' true' XlPlatform.xlWindows' "\t"' false' false' 0' true' 1' 0);  		}  		if (document == null) {  			throw new ValidDocumentException ();  		}  	}  	catch {  	}  	int counter = 0;  	// wd.ActiveWindow.Application.CommandBars.Count;  	for (int i = 0; i < counter; i++) {  		try {  			//             wd.ActiveWindow.Application.CommandBars[i].Enabled = false;  		}  		catch {  		}  	}  	try {  		wd.Visible = true;  		//                   wd.Activate();  		SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  		MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  	}  	catch {  		MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  	}  	this.Parent.Focus ();  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: if (wordWnd != 0) {  	SetParent (wordWnd' this.Handle.ToInt32 ());  	object fileName = filename;  	object newTemplate = false;  	object docType = 0;  	object readOnly = true;  	object isVisible = true;  	object missing = System.Reflection.Missing.Value;  	try {  		if (wd == null) {  			throw new WordInstanceException ();  		}  		if (wd.Workbooks == null) {  			throw new DocumentInstanceException ();  		}  		if (wd != null && wd.Workbooks != null) {  			/*               Object UpdateLinks;                          Object ReadOnly;                         Object Format;                         Object Password;                         Object WriteResPassword;                         Object IgnoreReadOnlyRecommended;                         Object Origin;                         Object Delimiter;                         Object Editable;                         Object Notify;                         Object Converter;                         Object AddToMru;                          Object Local;                         Object CorruptLoad;                         object dummy = null;*/document = wd.Workbooks.Open ((string)fileName' 0' true' 5' ""' ""' true' XlPlatform.xlWindows' "\t"' false' false' 0' true' 1' 0);  		}  		if (document == null) {  			throw new ValidDocumentException ();  		}  	}  	catch {  	}  	int counter = 0;  	// wd.ActiveWindow.Application.CommandBars.Count;  	for (int i = 0; i < counter; i++) {  		try {  			//             wd.ActiveWindow.Application.CommandBars[i].Enabled = false;  		}  		catch {  		}  	}  	try {  		wd.Visible = true;  		//                   wd.Activate();  		SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  		MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  	}  	catch {  		MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  	}  	this.Parent.Focus ();  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: if (wordWnd != 0) {  	SetParent (wordWnd' this.Handle.ToInt32 ());  	object fileName = filename;  	object newTemplate = false;  	object docType = 0;  	object readOnly = true;  	object isVisible = true;  	object missing = System.Reflection.Missing.Value;  	try {  		if (wd == null) {  			throw new WordInstanceException ();  		}  		if (wd.Workbooks == null) {  			throw new DocumentInstanceException ();  		}  		if (wd != null && wd.Workbooks != null) {  			/*               Object UpdateLinks;                          Object ReadOnly;                         Object Format;                         Object Password;                         Object WriteResPassword;                         Object IgnoreReadOnlyRecommended;                         Object Origin;                         Object Delimiter;                         Object Editable;                         Object Notify;                         Object Converter;                         Object AddToMru;                          Object Local;                         Object CorruptLoad;                         object dummy = null;*/document = wd.Workbooks.Open ((string)fileName' 0' true' 5' ""' ""' true' XlPlatform.xlWindows' "\t"' false' false' 0' true' 1' 0);  		}  		if (document == null) {  			throw new ValidDocumentException ();  		}  	}  	catch {  	}  	int counter = 0;  	// wd.ActiveWindow.Application.CommandBars.Count;  	for (int i = 0; i < counter; i++) {  		try {  			//             wd.ActiveWindow.Application.CommandBars[i].Enabled = false;  		}  		catch {  		}  	}  	try {  		wd.Visible = true;  		//                   wd.Activate();  		SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  		MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  	}  	catch {  		MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  	}  	this.Parent.Focus ();  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: if (wordWnd != 0) {  	SetParent (wordWnd' this.Handle.ToInt32 ());  	object fileName = filename;  	object newTemplate = false;  	object docType = 0;  	object readOnly = true;  	object isVisible = true;  	object missing = System.Reflection.Missing.Value;  	try {  		if (wd == null) {  			throw new WordInstanceException ();  		}  		if (wd.Workbooks == null) {  			throw new DocumentInstanceException ();  		}  		if (wd != null && wd.Workbooks != null) {  			/*               Object UpdateLinks;                          Object ReadOnly;                         Object Format;                         Object Password;                         Object WriteResPassword;                         Object IgnoreReadOnlyRecommended;                         Object Origin;                         Object Delimiter;                         Object Editable;                         Object Notify;                         Object Converter;                         Object AddToMru;                          Object Local;                         Object CorruptLoad;                         object dummy = null;*/document = wd.Workbooks.Open ((string)fileName' 0' true' 5' ""' ""' true' XlPlatform.xlWindows' "\t"' false' false' 0' true' 1' 0);  		}  		if (document == null) {  			throw new ValidDocumentException ();  		}  	}  	catch {  	}  	int counter = 0;  	// wd.ActiveWindow.Application.CommandBars.Count;  	for (int i = 0; i < counter; i++) {  		try {  			//             wd.ActiveWindow.Application.CommandBars[i].Enabled = false;  		}  		catch {  		}  	}  	try {  		wd.Visible = true;  		//                   wd.Activate();  		SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  		MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  	}  	catch {  		MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  	}  	this.Parent.Focus ();  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: try {  	if (wd == null) {  		throw new WordInstanceException ();  	}  	if (wd.Workbooks == null) {  		throw new DocumentInstanceException ();  	}  	if (wd != null && wd.Workbooks != null) {  		/*               Object UpdateLinks;                          Object ReadOnly;                         Object Format;                         Object Password;                         Object WriteResPassword;                         Object IgnoreReadOnlyRecommended;                         Object Origin;                         Object Delimiter;                         Object Editable;                         Object Notify;                         Object Converter;                         Object AddToMru;                          Object Local;                         Object CorruptLoad;                         object dummy = null;*/document = wd.Workbooks.Open ((string)fileName' 0' true' 5' ""' ""' true' XlPlatform.xlWindows' "\t"' false' false' 0' true' 1' 0);  	}  	if (document == null) {  		throw new ValidDocumentException ();  	}  }  catch {  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: if (wd != null && wd.Workbooks != null) {  	/*               Object UpdateLinks;                          Object ReadOnly;                         Object Format;                         Object Password;                         Object WriteResPassword;                         Object IgnoreReadOnlyRecommended;                         Object Origin;                         Object Delimiter;                         Object Editable;                         Object Notify;                         Object Converter;                         Object AddToMru;                          Object Local;                         Object CorruptLoad;                         object dummy = null;*/document = wd.Workbooks.Open ((string)fileName' 0' true' 5' ""' ""' true' XlPlatform.xlWindows' "\t"' false' false' 0' true' 1' 0);  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: document = wd.Workbooks.Open ((string)fileName' 0' true' 5' ""' ""' true' XlPlatform.xlWindows' "\t"' false' false' 0' true' 1' 0);  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: try {  	wd.Visible = true;  	//                   wd.Activate();  	SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  	MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  }  catch {  	MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: try {  	wd.Visible = true;  	//                   wd.Activate();  	SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  	MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  }  catch {  	MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: try {  	wd.Visible = true;  	//                   wd.Activate();  	SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  	MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  }  catch {  	MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: try {  	wd.Visible = true;  	//                   wd.Activate();  	SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  	MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  }  catch {  	MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: try {  	wd.Visible = true;  	//                   wd.Activate();  	SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  	MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  }  catch {  	MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: try {  	wd.Visible = true;  	//                   wd.Activate();  	SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  	MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  }  catch {  	MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  }  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,LoadDocument,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,OnResize,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,OnResize,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,OnResize,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,ExcelControl,C:\repos\mbatest_Binhed\BinHed\ExcelCont.cs,OnResize,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: hdr = new FileHeader (fs.ReadBytes (20)' Path.GetExtension (FileName));  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: if (Utils.Utils.types.TryGetValue (ext' out ft)) {  	switch (ext) {  	#region Web  	case ".htm":  	case ".html":  	case ".xml":  		webBrowser1.Url = new Uri (FileName);  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (webBrowser1);  		splitContainer3.Panel2Collapsed = false;  		webBrowser1.Dock = DockStyle.Fill;  		break;  	#endregion  	#region Microsoft Office  	case ".xls":  	case ".xslx":  		#region Excel  		if (Path.GetExtension (FileName).ToLower () == ".xslx") {  			Zip zx = new Zip (FileName);  			exv.Init (zx);  		}  		/*                  ExcelControl xls = new ExcelControl();                                              xls.LoadDocument(FileName);                                             xls.Dock = DockStyle.Fill;                                             tabControl1.TabPages[2].Controls.Add(xls);                                             xls.Visible = true;*/break;  	#endregion  	case ".doc":  	case ".docx":  		#region Word  		if (Path.GetExtension (FileName).ToLower () == ".docx") {  			Zip zx = new Zip (FileName);  			exv.Init (zx);  		}  		/*                  WinWordControl winWordControl1 = new WinWordControl();                                           splitContainer3.Panel2.Controls.Clear();                                           splitContainer3.Panel2.Controls.Add(winWordControl1);                                           splitContainer3.Panel2Collapsed = false;                                           winWordControl1.Dock = DockStyle.Fill;                                           winWordControl1.Visible = true;                                           winWordControl1.LoadDocument(FileName);*/break;  	#endregion  	#endregion  	#region ebooks  	case ".prc":  		MobiFileReader mob = new MobiFileReader (FileName);  		exv.Init (mob);  		webBrowser1.Visible = true;  		webBrowser1.DocumentText = mob.text;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (webBrowser1);  		splitContainer3.Panel2Collapsed = false;  		webBrowser1.Dock = DockStyle.Fill;  		prcButton.Visible = true;  		nextPage.Visible = true;  		break;  	case ".lrf":  		LRFFileReader vr = new LRFFileReader (FileName);  		exv.Init (vr);  		break;  	#endregion  	#region Images  	case ".jpg":  		JPGFileData jpg = new JPGFileData (FileName);  		exv.Init (jpg);  		PictureBox p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".png":  		PNGFile png = new PNGFile (FileName);  		exv.Init (png);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".bmp":  		BMPFile bind = new BMPFile (FileName);  		exv.Init (bind);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".gif":  		GIFFile gif = new GIFFile (FileName);  		exv.Init (gif);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".tif":  	case ".tiff":  		TiFFile tif = new TiFFile (FileName);  		exv.Init (tif);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	#endregion  	#region Audio  	case ".mp3":  	case ".wma":  		MusicFileClass mf = new MusicFileClass (FileName);  		exv.Init (mf);  		break;  	#endregion  	case ".zip":  		Zip z = new Zip (FileName);  		exv.Init (z);  		break;  	case ".ttf":  		// Font file  		break;  	#region Video  	case ".divx":  	case ".avi":  		AVIFile avi = new AVIFile (FileName);  		exv.Init (avi);  		break;  	case ".mkv":  		MkvFile mkv = new MkvFile (FileName);  		exv.Init (mkv);  		break;  	case ".flv":  		FlvFile flv = new FlvFile (FileName);  		exv.Init (flv);  		break;  	case ".mp4":  		Mp4File mp4 = new Mp4File (FileName);  		exv.Init (mp4);  		break;  	#endregion  	#region Mpeg2 endCode video  	case ".mpg":  	case ".mpeg":  	case ".vob":  		Mpeg2 mpg = new Mpeg2 (FileName);  		exv.Init (mpg);  		break;  	case ".ifo":  	case ".bup":  		IFO ifo = new IFO (FileName);  		exv.Init (ifo);  		break;  	#endregion  	#region BD video  	case ".m2ts":  	/*               M2TS mts = new M2TS(FileName);                         exv.Init(mts);                         break;*/case ".ts":  		TS_File ts = new TS_File (FileName);  		exv.Init (ts);  		break;  	case ".mpls":  		MPLS mp = new MPLS (FileName);  		exv.Init ((ILOCALIZED_DATA)mp);  		break;  	case ".clpi":  		CLPI cp = new CLPI (FileName);  		exv.Init ((ILOCALIZED_DATA)cp);  		break;  	case ".bdmv":  		if (FileName.IndexOf ("index") >= 0) {  			exv.Visible = false;  			INDEX_BDMV bd = new INDEX_BDMV (FileName);  			BDViewer bdv = new BDViewer ();  			bdv.tabSelected += new TabSelectedEventHandler (bdv_tabSelected);  			bdv.Init (bd);  			splitContainer3.Panel1.Controls.Add (bdv);  			bdv.Dock = DockStyle.Fill;  			bdv.dataSelected += new DataSelectedEventHandler (exv_dataSelected);  			TabPage tp = new TabPage (Path.GetFileName (bd.MovieObject.fileName));  			tabControl1.TabPages.Add (tp);  			BinaryView bn = new BinaryView ();  			bn.Init (bd.MovieObject.fileName);  			tp.Controls.Add (bn);  			bn.Dock = DockStyle.Fill;  			foreach (MPLS mpl in bd.MplsList) {  				tp = new TabPage (Path.GetFileName (mpl.LongName));  				tabControl1.TabPages.Add (tp);  				bn = new BinaryView ();  				bn.Init (mpl.LongName);  				tp.Controls.Add (bn);  				bn.Dock = DockStyle.Fill;  			}  		}  		else if (FileName.IndexOf ("Movie") >= 0) {  			MOBJ_BDMV mo = new MOBJ_BDMV (FileName);  			exv.Init ((ILOCALIZED_DATA)mo);  		}  		break;  	#endregion  	#region Text like files  	case ".ps":  		PostScriptReader ps = new PostScriptReader (FileName);  		exv.Init (ps);  		break;  	case ".pdf":  		PdfViewer pdf = new PdfViewer ();  		pdf.Init (FileName);  		exv.Visible = false;  		splitContainer3.Panel1.Controls.Add (pdf);  		pdf.Dock = DockStyle.Fill;  		break;  	case ".log":  	case ".ini":  	case ".cs":  	case ".txt":  	case ".bat":  		exv.Visible = false;  		TextBox t = new TextBox ();  		t.Multiline = true;  		t.ScrollBars = ScrollBars.Both;  		StreamReader sr = new StreamReader (FileName);  		t.Text = sr.ReadToEnd ();  		sr.Close ();  		splitContainer3.Panel1.Controls.Add (t);  		t.Dock = DockStyle.Fill;  		break;  	#endregion  	#region PE files  	case ".exe":  	case ".dll":  		exv.Visible = false;  		Executable ex = new Executable (FileName);  		ExeViewer exeViewer = new ExeViewer ();  		exeViewer.Init (ex);  		exeViewer.dataSelected += exv_dataSelected;  		splitContainer3.Panel1.Controls.Add (exeViewer);  		exeViewer.Dock = DockStyle.Fill;  		/*                                          exv.Init(ex);                        */break;  	#endregion  	case ".chm":  		//chm : http://www.russotto.net/chm/chmformat.html  		break;  	default:  		#region Analyse header and try to identify file type  		switch (hdr.HeaderBinarySt) {  		case "5346504B":  			//SFKP Sound Forge (Peak Data File)   			break;  		case "44564456":  			//DVD IFO (or BUP)  			ifo = new IFO (FileName);  			break;  		case "47494638":  			//Gif  			break;  		case "89504e47":  			//PNG  			break;  		case "4d534346":  			//CAB  			break;  		case "49545346":  			//ITSF chm  			break;  		case "31be0000":  			//wri ?  			break;  		case "00010000":  			//ttf' mdb  			break;  		case "00000100":  			// ico  			break;  		case "504b0304":  			Zip zi = new Zip (FileName);  			exv.Init (zi);  			break;  		case "52617221":  			break;  		case "ffd8ffe0":  			//Jpg  			break;  		case "d0cf11e0":  			//office  			break;  		case "3f5f0300":  			//help  			break;  		case "000001ba":  			mpg = new Mpeg2 (FileName);  			exv.Init (mpg);  			break;  		default:  			if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  				//gz file  				MessageBox.Show ("gz file' to do");  				byte compressionMethods = hdr.header [2];  				if (compressionMethods == 0x08) {  					//deflate  				}  				byte flags = hdr.header [3];  				if (flags != 0x00) {  				}  				Gzip gz = new Gzip (FileName);  				exv.Init (gz);  			}  			#region binary header  			switch (hdr.ShortHeaderString) {  			case "BM":  				// BMP  				BinDecoder bi = new BinDecoder (FileName);  				exv.Init (bi);  				break;  			case "MK":  				break;  			case "PK":  				//Zip' jar  				break;  			case "MZ":  				//exe' dll  				break;  			default:  				#region text header  				switch (hdr.HeaderString) {  				case "DVDV":  					//DVD IFO (or BUP)  					ifo = new IFO (FileName);  					break;  				case "ITSF":  					BinDecoder bid = new BinDecoder (FileName);  					//Microsoft Compiled HTML Help File : Info-Tech Storage Format  					break;  				case "GIF8":  					break;  				case "MSCF":  					//Microsoft cabinet file  					break;  				case "Rar!":  					break;  				case "RIFF":  					//avi  					AviAnalyze av = new AviAnalyze (FileName);  					exv.Init (av);  					break;  				case "%PDF":  					break;  				case "PNG":  					break;  				case "<?xm":  					//xml  					break;  				case "ID3":  					//mp3  					break;  				case "L\0R\0":  					//lrf  					break;  				case "":  					//office  					break;  				case "BZh9":  					//tar.gz  					break;  				case "\0 \0\0":  					break;  				default:  					break;  				}  				#endregion  				break;  			}  			#endregion  			break;  		}  		#endregion  		break;  	}  }  else {  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: if (Utils.Utils.types.TryGetValue (ext' out ft)) {  	switch (ext) {  	#region Web  	case ".htm":  	case ".html":  	case ".xml":  		webBrowser1.Url = new Uri (FileName);  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (webBrowser1);  		splitContainer3.Panel2Collapsed = false;  		webBrowser1.Dock = DockStyle.Fill;  		break;  	#endregion  	#region Microsoft Office  	case ".xls":  	case ".xslx":  		#region Excel  		if (Path.GetExtension (FileName).ToLower () == ".xslx") {  			Zip zx = new Zip (FileName);  			exv.Init (zx);  		}  		/*                  ExcelControl xls = new ExcelControl();                                              xls.LoadDocument(FileName);                                             xls.Dock = DockStyle.Fill;                                             tabControl1.TabPages[2].Controls.Add(xls);                                             xls.Visible = true;*/break;  	#endregion  	case ".doc":  	case ".docx":  		#region Word  		if (Path.GetExtension (FileName).ToLower () == ".docx") {  			Zip zx = new Zip (FileName);  			exv.Init (zx);  		}  		/*                  WinWordControl winWordControl1 = new WinWordControl();                                           splitContainer3.Panel2.Controls.Clear();                                           splitContainer3.Panel2.Controls.Add(winWordControl1);                                           splitContainer3.Panel2Collapsed = false;                                           winWordControl1.Dock = DockStyle.Fill;                                           winWordControl1.Visible = true;                                           winWordControl1.LoadDocument(FileName);*/break;  	#endregion  	#endregion  	#region ebooks  	case ".prc":  		MobiFileReader mob = new MobiFileReader (FileName);  		exv.Init (mob);  		webBrowser1.Visible = true;  		webBrowser1.DocumentText = mob.text;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (webBrowser1);  		splitContainer3.Panel2Collapsed = false;  		webBrowser1.Dock = DockStyle.Fill;  		prcButton.Visible = true;  		nextPage.Visible = true;  		break;  	case ".lrf":  		LRFFileReader vr = new LRFFileReader (FileName);  		exv.Init (vr);  		break;  	#endregion  	#region Images  	case ".jpg":  		JPGFileData jpg = new JPGFileData (FileName);  		exv.Init (jpg);  		PictureBox p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".png":  		PNGFile png = new PNGFile (FileName);  		exv.Init (png);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".bmp":  		BMPFile bind = new BMPFile (FileName);  		exv.Init (bind);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".gif":  		GIFFile gif = new GIFFile (FileName);  		exv.Init (gif);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".tif":  	case ".tiff":  		TiFFile tif = new TiFFile (FileName);  		exv.Init (tif);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	#endregion  	#region Audio  	case ".mp3":  	case ".wma":  		MusicFileClass mf = new MusicFileClass (FileName);  		exv.Init (mf);  		break;  	#endregion  	case ".zip":  		Zip z = new Zip (FileName);  		exv.Init (z);  		break;  	case ".ttf":  		// Font file  		break;  	#region Video  	case ".divx":  	case ".avi":  		AVIFile avi = new AVIFile (FileName);  		exv.Init (avi);  		break;  	case ".mkv":  		MkvFile mkv = new MkvFile (FileName);  		exv.Init (mkv);  		break;  	case ".flv":  		FlvFile flv = new FlvFile (FileName);  		exv.Init (flv);  		break;  	case ".mp4":  		Mp4File mp4 = new Mp4File (FileName);  		exv.Init (mp4);  		break;  	#endregion  	#region Mpeg2 endCode video  	case ".mpg":  	case ".mpeg":  	case ".vob":  		Mpeg2 mpg = new Mpeg2 (FileName);  		exv.Init (mpg);  		break;  	case ".ifo":  	case ".bup":  		IFO ifo = new IFO (FileName);  		exv.Init (ifo);  		break;  	#endregion  	#region BD video  	case ".m2ts":  	/*               M2TS mts = new M2TS(FileName);                         exv.Init(mts);                         break;*/case ".ts":  		TS_File ts = new TS_File (FileName);  		exv.Init (ts);  		break;  	case ".mpls":  		MPLS mp = new MPLS (FileName);  		exv.Init ((ILOCALIZED_DATA)mp);  		break;  	case ".clpi":  		CLPI cp = new CLPI (FileName);  		exv.Init ((ILOCALIZED_DATA)cp);  		break;  	case ".bdmv":  		if (FileName.IndexOf ("index") >= 0) {  			exv.Visible = false;  			INDEX_BDMV bd = new INDEX_BDMV (FileName);  			BDViewer bdv = new BDViewer ();  			bdv.tabSelected += new TabSelectedEventHandler (bdv_tabSelected);  			bdv.Init (bd);  			splitContainer3.Panel1.Controls.Add (bdv);  			bdv.Dock = DockStyle.Fill;  			bdv.dataSelected += new DataSelectedEventHandler (exv_dataSelected);  			TabPage tp = new TabPage (Path.GetFileName (bd.MovieObject.fileName));  			tabControl1.TabPages.Add (tp);  			BinaryView bn = new BinaryView ();  			bn.Init (bd.MovieObject.fileName);  			tp.Controls.Add (bn);  			bn.Dock = DockStyle.Fill;  			foreach (MPLS mpl in bd.MplsList) {  				tp = new TabPage (Path.GetFileName (mpl.LongName));  				tabControl1.TabPages.Add (tp);  				bn = new BinaryView ();  				bn.Init (mpl.LongName);  				tp.Controls.Add (bn);  				bn.Dock = DockStyle.Fill;  			}  		}  		else if (FileName.IndexOf ("Movie") >= 0) {  			MOBJ_BDMV mo = new MOBJ_BDMV (FileName);  			exv.Init ((ILOCALIZED_DATA)mo);  		}  		break;  	#endregion  	#region Text like files  	case ".ps":  		PostScriptReader ps = new PostScriptReader (FileName);  		exv.Init (ps);  		break;  	case ".pdf":  		PdfViewer pdf = new PdfViewer ();  		pdf.Init (FileName);  		exv.Visible = false;  		splitContainer3.Panel1.Controls.Add (pdf);  		pdf.Dock = DockStyle.Fill;  		break;  	case ".log":  	case ".ini":  	case ".cs":  	case ".txt":  	case ".bat":  		exv.Visible = false;  		TextBox t = new TextBox ();  		t.Multiline = true;  		t.ScrollBars = ScrollBars.Both;  		StreamReader sr = new StreamReader (FileName);  		t.Text = sr.ReadToEnd ();  		sr.Close ();  		splitContainer3.Panel1.Controls.Add (t);  		t.Dock = DockStyle.Fill;  		break;  	#endregion  	#region PE files  	case ".exe":  	case ".dll":  		exv.Visible = false;  		Executable ex = new Executable (FileName);  		ExeViewer exeViewer = new ExeViewer ();  		exeViewer.Init (ex);  		exeViewer.dataSelected += exv_dataSelected;  		splitContainer3.Panel1.Controls.Add (exeViewer);  		exeViewer.Dock = DockStyle.Fill;  		/*                                          exv.Init(ex);                        */break;  	#endregion  	case ".chm":  		//chm : http://www.russotto.net/chm/chmformat.html  		break;  	default:  		#region Analyse header and try to identify file type  		switch (hdr.HeaderBinarySt) {  		case "5346504B":  			//SFKP Sound Forge (Peak Data File)   			break;  		case "44564456":  			//DVD IFO (or BUP)  			ifo = new IFO (FileName);  			break;  		case "47494638":  			//Gif  			break;  		case "89504e47":  			//PNG  			break;  		case "4d534346":  			//CAB  			break;  		case "49545346":  			//ITSF chm  			break;  		case "31be0000":  			//wri ?  			break;  		case "00010000":  			//ttf' mdb  			break;  		case "00000100":  			// ico  			break;  		case "504b0304":  			Zip zi = new Zip (FileName);  			exv.Init (zi);  			break;  		case "52617221":  			break;  		case "ffd8ffe0":  			//Jpg  			break;  		case "d0cf11e0":  			//office  			break;  		case "3f5f0300":  			//help  			break;  		case "000001ba":  			mpg = new Mpeg2 (FileName);  			exv.Init (mpg);  			break;  		default:  			if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  				//gz file  				MessageBox.Show ("gz file' to do");  				byte compressionMethods = hdr.header [2];  				if (compressionMethods == 0x08) {  					//deflate  				}  				byte flags = hdr.header [3];  				if (flags != 0x00) {  				}  				Gzip gz = new Gzip (FileName);  				exv.Init (gz);  			}  			#region binary header  			switch (hdr.ShortHeaderString) {  			case "BM":  				// BMP  				BinDecoder bi = new BinDecoder (FileName);  				exv.Init (bi);  				break;  			case "MK":  				break;  			case "PK":  				//Zip' jar  				break;  			case "MZ":  				//exe' dll  				break;  			default:  				#region text header  				switch (hdr.HeaderString) {  				case "DVDV":  					//DVD IFO (or BUP)  					ifo = new IFO (FileName);  					break;  				case "ITSF":  					BinDecoder bid = new BinDecoder (FileName);  					//Microsoft Compiled HTML Help File : Info-Tech Storage Format  					break;  				case "GIF8":  					break;  				case "MSCF":  					//Microsoft cabinet file  					break;  				case "Rar!":  					break;  				case "RIFF":  					//avi  					AviAnalyze av = new AviAnalyze (FileName);  					exv.Init (av);  					break;  				case "%PDF":  					break;  				case "PNG":  					break;  				case "<?xm":  					//xml  					break;  				case "ID3":  					//mp3  					break;  				case "L\0R\0":  					//lrf  					break;  				case "":  					//office  					break;  				case "BZh9":  					//tar.gz  					break;  				case "\0 \0\0":  					break;  				default:  					break;  				}  				#endregion  				break;  			}  			#endregion  			break;  		}  		#endregion  		break;  	}  }  else {  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: if (Utils.Utils.types.TryGetValue (ext' out ft)) {  	switch (ext) {  	#region Web  	case ".htm":  	case ".html":  	case ".xml":  		webBrowser1.Url = new Uri (FileName);  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (webBrowser1);  		splitContainer3.Panel2Collapsed = false;  		webBrowser1.Dock = DockStyle.Fill;  		break;  	#endregion  	#region Microsoft Office  	case ".xls":  	case ".xslx":  		#region Excel  		if (Path.GetExtension (FileName).ToLower () == ".xslx") {  			Zip zx = new Zip (FileName);  			exv.Init (zx);  		}  		/*                  ExcelControl xls = new ExcelControl();                                              xls.LoadDocument(FileName);                                             xls.Dock = DockStyle.Fill;                                             tabControl1.TabPages[2].Controls.Add(xls);                                             xls.Visible = true;*/break;  	#endregion  	case ".doc":  	case ".docx":  		#region Word  		if (Path.GetExtension (FileName).ToLower () == ".docx") {  			Zip zx = new Zip (FileName);  			exv.Init (zx);  		}  		/*                  WinWordControl winWordControl1 = new WinWordControl();                                           splitContainer3.Panel2.Controls.Clear();                                           splitContainer3.Panel2.Controls.Add(winWordControl1);                                           splitContainer3.Panel2Collapsed = false;                                           winWordControl1.Dock = DockStyle.Fill;                                           winWordControl1.Visible = true;                                           winWordControl1.LoadDocument(FileName);*/break;  	#endregion  	#endregion  	#region ebooks  	case ".prc":  		MobiFileReader mob = new MobiFileReader (FileName);  		exv.Init (mob);  		webBrowser1.Visible = true;  		webBrowser1.DocumentText = mob.text;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (webBrowser1);  		splitContainer3.Panel2Collapsed = false;  		webBrowser1.Dock = DockStyle.Fill;  		prcButton.Visible = true;  		nextPage.Visible = true;  		break;  	case ".lrf":  		LRFFileReader vr = new LRFFileReader (FileName);  		exv.Init (vr);  		break;  	#endregion  	#region Images  	case ".jpg":  		JPGFileData jpg = new JPGFileData (FileName);  		exv.Init (jpg);  		PictureBox p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".png":  		PNGFile png = new PNGFile (FileName);  		exv.Init (png);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".bmp":  		BMPFile bind = new BMPFile (FileName);  		exv.Init (bind);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".gif":  		GIFFile gif = new GIFFile (FileName);  		exv.Init (gif);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".tif":  	case ".tiff":  		TiFFile tif = new TiFFile (FileName);  		exv.Init (tif);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	#endregion  	#region Audio  	case ".mp3":  	case ".wma":  		MusicFileClass mf = new MusicFileClass (FileName);  		exv.Init (mf);  		break;  	#endregion  	case ".zip":  		Zip z = new Zip (FileName);  		exv.Init (z);  		break;  	case ".ttf":  		// Font file  		break;  	#region Video  	case ".divx":  	case ".avi":  		AVIFile avi = new AVIFile (FileName);  		exv.Init (avi);  		break;  	case ".mkv":  		MkvFile mkv = new MkvFile (FileName);  		exv.Init (mkv);  		break;  	case ".flv":  		FlvFile flv = new FlvFile (FileName);  		exv.Init (flv);  		break;  	case ".mp4":  		Mp4File mp4 = new Mp4File (FileName);  		exv.Init (mp4);  		break;  	#endregion  	#region Mpeg2 endCode video  	case ".mpg":  	case ".mpeg":  	case ".vob":  		Mpeg2 mpg = new Mpeg2 (FileName);  		exv.Init (mpg);  		break;  	case ".ifo":  	case ".bup":  		IFO ifo = new IFO (FileName);  		exv.Init (ifo);  		break;  	#endregion  	#region BD video  	case ".m2ts":  	/*               M2TS mts = new M2TS(FileName);                         exv.Init(mts);                         break;*/case ".ts":  		TS_File ts = new TS_File (FileName);  		exv.Init (ts);  		break;  	case ".mpls":  		MPLS mp = new MPLS (FileName);  		exv.Init ((ILOCALIZED_DATA)mp);  		break;  	case ".clpi":  		CLPI cp = new CLPI (FileName);  		exv.Init ((ILOCALIZED_DATA)cp);  		break;  	case ".bdmv":  		if (FileName.IndexOf ("index") >= 0) {  			exv.Visible = false;  			INDEX_BDMV bd = new INDEX_BDMV (FileName);  			BDViewer bdv = new BDViewer ();  			bdv.tabSelected += new TabSelectedEventHandler (bdv_tabSelected);  			bdv.Init (bd);  			splitContainer3.Panel1.Controls.Add (bdv);  			bdv.Dock = DockStyle.Fill;  			bdv.dataSelected += new DataSelectedEventHandler (exv_dataSelected);  			TabPage tp = new TabPage (Path.GetFileName (bd.MovieObject.fileName));  			tabControl1.TabPages.Add (tp);  			BinaryView bn = new BinaryView ();  			bn.Init (bd.MovieObject.fileName);  			tp.Controls.Add (bn);  			bn.Dock = DockStyle.Fill;  			foreach (MPLS mpl in bd.MplsList) {  				tp = new TabPage (Path.GetFileName (mpl.LongName));  				tabControl1.TabPages.Add (tp);  				bn = new BinaryView ();  				bn.Init (mpl.LongName);  				tp.Controls.Add (bn);  				bn.Dock = DockStyle.Fill;  			}  		}  		else if (FileName.IndexOf ("Movie") >= 0) {  			MOBJ_BDMV mo = new MOBJ_BDMV (FileName);  			exv.Init ((ILOCALIZED_DATA)mo);  		}  		break;  	#endregion  	#region Text like files  	case ".ps":  		PostScriptReader ps = new PostScriptReader (FileName);  		exv.Init (ps);  		break;  	case ".pdf":  		PdfViewer pdf = new PdfViewer ();  		pdf.Init (FileName);  		exv.Visible = false;  		splitContainer3.Panel1.Controls.Add (pdf);  		pdf.Dock = DockStyle.Fill;  		break;  	case ".log":  	case ".ini":  	case ".cs":  	case ".txt":  	case ".bat":  		exv.Visible = false;  		TextBox t = new TextBox ();  		t.Multiline = true;  		t.ScrollBars = ScrollBars.Both;  		StreamReader sr = new StreamReader (FileName);  		t.Text = sr.ReadToEnd ();  		sr.Close ();  		splitContainer3.Panel1.Controls.Add (t);  		t.Dock = DockStyle.Fill;  		break;  	#endregion  	#region PE files  	case ".exe":  	case ".dll":  		exv.Visible = false;  		Executable ex = new Executable (FileName);  		ExeViewer exeViewer = new ExeViewer ();  		exeViewer.Init (ex);  		exeViewer.dataSelected += exv_dataSelected;  		splitContainer3.Panel1.Controls.Add (exeViewer);  		exeViewer.Dock = DockStyle.Fill;  		/*                                          exv.Init(ex);                        */break;  	#endregion  	case ".chm":  		//chm : http://www.russotto.net/chm/chmformat.html  		break;  	default:  		#region Analyse header and try to identify file type  		switch (hdr.HeaderBinarySt) {  		case "5346504B":  			//SFKP Sound Forge (Peak Data File)   			break;  		case "44564456":  			//DVD IFO (or BUP)  			ifo = new IFO (FileName);  			break;  		case "47494638":  			//Gif  			break;  		case "89504e47":  			//PNG  			break;  		case "4d534346":  			//CAB  			break;  		case "49545346":  			//ITSF chm  			break;  		case "31be0000":  			//wri ?  			break;  		case "00010000":  			//ttf' mdb  			break;  		case "00000100":  			// ico  			break;  		case "504b0304":  			Zip zi = new Zip (FileName);  			exv.Init (zi);  			break;  		case "52617221":  			break;  		case "ffd8ffe0":  			//Jpg  			break;  		case "d0cf11e0":  			//office  			break;  		case "3f5f0300":  			//help  			break;  		case "000001ba":  			mpg = new Mpeg2 (FileName);  			exv.Init (mpg);  			break;  		default:  			if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  				//gz file  				MessageBox.Show ("gz file' to do");  				byte compressionMethods = hdr.header [2];  				if (compressionMethods == 0x08) {  					//deflate  				}  				byte flags = hdr.header [3];  				if (flags != 0x00) {  				}  				Gzip gz = new Gzip (FileName);  				exv.Init (gz);  			}  			#region binary header  			switch (hdr.ShortHeaderString) {  			case "BM":  				// BMP  				BinDecoder bi = new BinDecoder (FileName);  				exv.Init (bi);  				break;  			case "MK":  				break;  			case "PK":  				//Zip' jar  				break;  			case "MZ":  				//exe' dll  				break;  			default:  				#region text header  				switch (hdr.HeaderString) {  				case "DVDV":  					//DVD IFO (or BUP)  					ifo = new IFO (FileName);  					break;  				case "ITSF":  					BinDecoder bid = new BinDecoder (FileName);  					//Microsoft Compiled HTML Help File : Info-Tech Storage Format  					break;  				case "GIF8":  					break;  				case "MSCF":  					//Microsoft cabinet file  					break;  				case "Rar!":  					break;  				case "RIFF":  					//avi  					AviAnalyze av = new AviAnalyze (FileName);  					exv.Init (av);  					break;  				case "%PDF":  					break;  				case "PNG":  					break;  				case "<?xm":  					//xml  					break;  				case "ID3":  					//mp3  					break;  				case "L\0R\0":  					//lrf  					break;  				case "":  					//office  					break;  				case "BZh9":  					//tar.gz  					break;  				case "\0 \0\0":  					break;  				default:  					break;  				}  				#endregion  				break;  			}  			#endregion  			break;  		}  		#endregion  		break;  	}  }  else {  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: if (Utils.Utils.types.TryGetValue (ext' out ft)) {  	switch (ext) {  	#region Web  	case ".htm":  	case ".html":  	case ".xml":  		webBrowser1.Url = new Uri (FileName);  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (webBrowser1);  		splitContainer3.Panel2Collapsed = false;  		webBrowser1.Dock = DockStyle.Fill;  		break;  	#endregion  	#region Microsoft Office  	case ".xls":  	case ".xslx":  		#region Excel  		if (Path.GetExtension (FileName).ToLower () == ".xslx") {  			Zip zx = new Zip (FileName);  			exv.Init (zx);  		}  		/*                  ExcelControl xls = new ExcelControl();                                              xls.LoadDocument(FileName);                                             xls.Dock = DockStyle.Fill;                                             tabControl1.TabPages[2].Controls.Add(xls);                                             xls.Visible = true;*/break;  	#endregion  	case ".doc":  	case ".docx":  		#region Word  		if (Path.GetExtension (FileName).ToLower () == ".docx") {  			Zip zx = new Zip (FileName);  			exv.Init (zx);  		}  		/*                  WinWordControl winWordControl1 = new WinWordControl();                                           splitContainer3.Panel2.Controls.Clear();                                           splitContainer3.Panel2.Controls.Add(winWordControl1);                                           splitContainer3.Panel2Collapsed = false;                                           winWordControl1.Dock = DockStyle.Fill;                                           winWordControl1.Visible = true;                                           winWordControl1.LoadDocument(FileName);*/break;  	#endregion  	#endregion  	#region ebooks  	case ".prc":  		MobiFileReader mob = new MobiFileReader (FileName);  		exv.Init (mob);  		webBrowser1.Visible = true;  		webBrowser1.DocumentText = mob.text;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (webBrowser1);  		splitContainer3.Panel2Collapsed = false;  		webBrowser1.Dock = DockStyle.Fill;  		prcButton.Visible = true;  		nextPage.Visible = true;  		break;  	case ".lrf":  		LRFFileReader vr = new LRFFileReader (FileName);  		exv.Init (vr);  		break;  	#endregion  	#region Images  	case ".jpg":  		JPGFileData jpg = new JPGFileData (FileName);  		exv.Init (jpg);  		PictureBox p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".png":  		PNGFile png = new PNGFile (FileName);  		exv.Init (png);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".bmp":  		BMPFile bind = new BMPFile (FileName);  		exv.Init (bind);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".gif":  		GIFFile gif = new GIFFile (FileName);  		exv.Init (gif);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".tif":  	case ".tiff":  		TiFFile tif = new TiFFile (FileName);  		exv.Init (tif);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	#endregion  	#region Audio  	case ".mp3":  	case ".wma":  		MusicFileClass mf = new MusicFileClass (FileName);  		exv.Init (mf);  		break;  	#endregion  	case ".zip":  		Zip z = new Zip (FileName);  		exv.Init (z);  		break;  	case ".ttf":  		// Font file  		break;  	#region Video  	case ".divx":  	case ".avi":  		AVIFile avi = new AVIFile (FileName);  		exv.Init (avi);  		break;  	case ".mkv":  		MkvFile mkv = new MkvFile (FileName);  		exv.Init (mkv);  		break;  	case ".flv":  		FlvFile flv = new FlvFile (FileName);  		exv.Init (flv);  		break;  	case ".mp4":  		Mp4File mp4 = new Mp4File (FileName);  		exv.Init (mp4);  		break;  	#endregion  	#region Mpeg2 endCode video  	case ".mpg":  	case ".mpeg":  	case ".vob":  		Mpeg2 mpg = new Mpeg2 (FileName);  		exv.Init (mpg);  		break;  	case ".ifo":  	case ".bup":  		IFO ifo = new IFO (FileName);  		exv.Init (ifo);  		break;  	#endregion  	#region BD video  	case ".m2ts":  	/*               M2TS mts = new M2TS(FileName);                         exv.Init(mts);                         break;*/case ".ts":  		TS_File ts = new TS_File (FileName);  		exv.Init (ts);  		break;  	case ".mpls":  		MPLS mp = new MPLS (FileName);  		exv.Init ((ILOCALIZED_DATA)mp);  		break;  	case ".clpi":  		CLPI cp = new CLPI (FileName);  		exv.Init ((ILOCALIZED_DATA)cp);  		break;  	case ".bdmv":  		if (FileName.IndexOf ("index") >= 0) {  			exv.Visible = false;  			INDEX_BDMV bd = new INDEX_BDMV (FileName);  			BDViewer bdv = new BDViewer ();  			bdv.tabSelected += new TabSelectedEventHandler (bdv_tabSelected);  			bdv.Init (bd);  			splitContainer3.Panel1.Controls.Add (bdv);  			bdv.Dock = DockStyle.Fill;  			bdv.dataSelected += new DataSelectedEventHandler (exv_dataSelected);  			TabPage tp = new TabPage (Path.GetFileName (bd.MovieObject.fileName));  			tabControl1.TabPages.Add (tp);  			BinaryView bn = new BinaryView ();  			bn.Init (bd.MovieObject.fileName);  			tp.Controls.Add (bn);  			bn.Dock = DockStyle.Fill;  			foreach (MPLS mpl in bd.MplsList) {  				tp = new TabPage (Path.GetFileName (mpl.LongName));  				tabControl1.TabPages.Add (tp);  				bn = new BinaryView ();  				bn.Init (mpl.LongName);  				tp.Controls.Add (bn);  				bn.Dock = DockStyle.Fill;  			}  		}  		else if (FileName.IndexOf ("Movie") >= 0) {  			MOBJ_BDMV mo = new MOBJ_BDMV (FileName);  			exv.Init ((ILOCALIZED_DATA)mo);  		}  		break;  	#endregion  	#region Text like files  	case ".ps":  		PostScriptReader ps = new PostScriptReader (FileName);  		exv.Init (ps);  		break;  	case ".pdf":  		PdfViewer pdf = new PdfViewer ();  		pdf.Init (FileName);  		exv.Visible = false;  		splitContainer3.Panel1.Controls.Add (pdf);  		pdf.Dock = DockStyle.Fill;  		break;  	case ".log":  	case ".ini":  	case ".cs":  	case ".txt":  	case ".bat":  		exv.Visible = false;  		TextBox t = new TextBox ();  		t.Multiline = true;  		t.ScrollBars = ScrollBars.Both;  		StreamReader sr = new StreamReader (FileName);  		t.Text = sr.ReadToEnd ();  		sr.Close ();  		splitContainer3.Panel1.Controls.Add (t);  		t.Dock = DockStyle.Fill;  		break;  	#endregion  	#region PE files  	case ".exe":  	case ".dll":  		exv.Visible = false;  		Executable ex = new Executable (FileName);  		ExeViewer exeViewer = new ExeViewer ();  		exeViewer.Init (ex);  		exeViewer.dataSelected += exv_dataSelected;  		splitContainer3.Panel1.Controls.Add (exeViewer);  		exeViewer.Dock = DockStyle.Fill;  		/*                                          exv.Init(ex);                        */break;  	#endregion  	case ".chm":  		//chm : http://www.russotto.net/chm/chmformat.html  		break;  	default:  		#region Analyse header and try to identify file type  		switch (hdr.HeaderBinarySt) {  		case "5346504B":  			//SFKP Sound Forge (Peak Data File)   			break;  		case "44564456":  			//DVD IFO (or BUP)  			ifo = new IFO (FileName);  			break;  		case "47494638":  			//Gif  			break;  		case "89504e47":  			//PNG  			break;  		case "4d534346":  			//CAB  			break;  		case "49545346":  			//ITSF chm  			break;  		case "31be0000":  			//wri ?  			break;  		case "00010000":  			//ttf' mdb  			break;  		case "00000100":  			// ico  			break;  		case "504b0304":  			Zip zi = new Zip (FileName);  			exv.Init (zi);  			break;  		case "52617221":  			break;  		case "ffd8ffe0":  			//Jpg  			break;  		case "d0cf11e0":  			//office  			break;  		case "3f5f0300":  			//help  			break;  		case "000001ba":  			mpg = new Mpeg2 (FileName);  			exv.Init (mpg);  			break;  		default:  			if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  				//gz file  				MessageBox.Show ("gz file' to do");  				byte compressionMethods = hdr.header [2];  				if (compressionMethods == 0x08) {  					//deflate  				}  				byte flags = hdr.header [3];  				if (flags != 0x00) {  				}  				Gzip gz = new Gzip (FileName);  				exv.Init (gz);  			}  			#region binary header  			switch (hdr.ShortHeaderString) {  			case "BM":  				// BMP  				BinDecoder bi = new BinDecoder (FileName);  				exv.Init (bi);  				break;  			case "MK":  				break;  			case "PK":  				//Zip' jar  				break;  			case "MZ":  				//exe' dll  				break;  			default:  				#region text header  				switch (hdr.HeaderString) {  				case "DVDV":  					//DVD IFO (or BUP)  					ifo = new IFO (FileName);  					break;  				case "ITSF":  					BinDecoder bid = new BinDecoder (FileName);  					//Microsoft Compiled HTML Help File : Info-Tech Storage Format  					break;  				case "GIF8":  					break;  				case "MSCF":  					//Microsoft cabinet file  					break;  				case "Rar!":  					break;  				case "RIFF":  					//avi  					AviAnalyze av = new AviAnalyze (FileName);  					exv.Init (av);  					break;  				case "%PDF":  					break;  				case "PNG":  					break;  				case "<?xm":  					//xml  					break;  				case "ID3":  					//mp3  					break;  				case "L\0R\0":  					//lrf  					break;  				case "":  					//office  					break;  				case "BZh9":  					//tar.gz  					break;  				case "\0 \0\0":  					break;  				default:  					break;  				}  				#endregion  				break;  			}  			#endregion  			break;  		}  		#endregion  		break;  	}  }  else {  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: if (Utils.Utils.types.TryGetValue (ext' out ft)) {  	switch (ext) {  	#region Web  	case ".htm":  	case ".html":  	case ".xml":  		webBrowser1.Url = new Uri (FileName);  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (webBrowser1);  		splitContainer3.Panel2Collapsed = false;  		webBrowser1.Dock = DockStyle.Fill;  		break;  	#endregion  	#region Microsoft Office  	case ".xls":  	case ".xslx":  		#region Excel  		if (Path.GetExtension (FileName).ToLower () == ".xslx") {  			Zip zx = new Zip (FileName);  			exv.Init (zx);  		}  		/*                  ExcelControl xls = new ExcelControl();                                              xls.LoadDocument(FileName);                                             xls.Dock = DockStyle.Fill;                                             tabControl1.TabPages[2].Controls.Add(xls);                                             xls.Visible = true;*/break;  	#endregion  	case ".doc":  	case ".docx":  		#region Word  		if (Path.GetExtension (FileName).ToLower () == ".docx") {  			Zip zx = new Zip (FileName);  			exv.Init (zx);  		}  		/*                  WinWordControl winWordControl1 = new WinWordControl();                                           splitContainer3.Panel2.Controls.Clear();                                           splitContainer3.Panel2.Controls.Add(winWordControl1);                                           splitContainer3.Panel2Collapsed = false;                                           winWordControl1.Dock = DockStyle.Fill;                                           winWordControl1.Visible = true;                                           winWordControl1.LoadDocument(FileName);*/break;  	#endregion  	#endregion  	#region ebooks  	case ".prc":  		MobiFileReader mob = new MobiFileReader (FileName);  		exv.Init (mob);  		webBrowser1.Visible = true;  		webBrowser1.DocumentText = mob.text;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (webBrowser1);  		splitContainer3.Panel2Collapsed = false;  		webBrowser1.Dock = DockStyle.Fill;  		prcButton.Visible = true;  		nextPage.Visible = true;  		break;  	case ".lrf":  		LRFFileReader vr = new LRFFileReader (FileName);  		exv.Init (vr);  		break;  	#endregion  	#region Images  	case ".jpg":  		JPGFileData jpg = new JPGFileData (FileName);  		exv.Init (jpg);  		PictureBox p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".png":  		PNGFile png = new PNGFile (FileName);  		exv.Init (png);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".bmp":  		BMPFile bind = new BMPFile (FileName);  		exv.Init (bind);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".gif":  		GIFFile gif = new GIFFile (FileName);  		exv.Init (gif);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".tif":  	case ".tiff":  		TiFFile tif = new TiFFile (FileName);  		exv.Init (tif);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	#endregion  	#region Audio  	case ".mp3":  	case ".wma":  		MusicFileClass mf = new MusicFileClass (FileName);  		exv.Init (mf);  		break;  	#endregion  	case ".zip":  		Zip z = new Zip (FileName);  		exv.Init (z);  		break;  	case ".ttf":  		// Font file  		break;  	#region Video  	case ".divx":  	case ".avi":  		AVIFile avi = new AVIFile (FileName);  		exv.Init (avi);  		break;  	case ".mkv":  		MkvFile mkv = new MkvFile (FileName);  		exv.Init (mkv);  		break;  	case ".flv":  		FlvFile flv = new FlvFile (FileName);  		exv.Init (flv);  		break;  	case ".mp4":  		Mp4File mp4 = new Mp4File (FileName);  		exv.Init (mp4);  		break;  	#endregion  	#region Mpeg2 endCode video  	case ".mpg":  	case ".mpeg":  	case ".vob":  		Mpeg2 mpg = new Mpeg2 (FileName);  		exv.Init (mpg);  		break;  	case ".ifo":  	case ".bup":  		IFO ifo = new IFO (FileName);  		exv.Init (ifo);  		break;  	#endregion  	#region BD video  	case ".m2ts":  	/*               M2TS mts = new M2TS(FileName);                         exv.Init(mts);                         break;*/case ".ts":  		TS_File ts = new TS_File (FileName);  		exv.Init (ts);  		break;  	case ".mpls":  		MPLS mp = new MPLS (FileName);  		exv.Init ((ILOCALIZED_DATA)mp);  		break;  	case ".clpi":  		CLPI cp = new CLPI (FileName);  		exv.Init ((ILOCALIZED_DATA)cp);  		break;  	case ".bdmv":  		if (FileName.IndexOf ("index") >= 0) {  			exv.Visible = false;  			INDEX_BDMV bd = new INDEX_BDMV (FileName);  			BDViewer bdv = new BDViewer ();  			bdv.tabSelected += new TabSelectedEventHandler (bdv_tabSelected);  			bdv.Init (bd);  			splitContainer3.Panel1.Controls.Add (bdv);  			bdv.Dock = DockStyle.Fill;  			bdv.dataSelected += new DataSelectedEventHandler (exv_dataSelected);  			TabPage tp = new TabPage (Path.GetFileName (bd.MovieObject.fileName));  			tabControl1.TabPages.Add (tp);  			BinaryView bn = new BinaryView ();  			bn.Init (bd.MovieObject.fileName);  			tp.Controls.Add (bn);  			bn.Dock = DockStyle.Fill;  			foreach (MPLS mpl in bd.MplsList) {  				tp = new TabPage (Path.GetFileName (mpl.LongName));  				tabControl1.TabPages.Add (tp);  				bn = new BinaryView ();  				bn.Init (mpl.LongName);  				tp.Controls.Add (bn);  				bn.Dock = DockStyle.Fill;  			}  		}  		else if (FileName.IndexOf ("Movie") >= 0) {  			MOBJ_BDMV mo = new MOBJ_BDMV (FileName);  			exv.Init ((ILOCALIZED_DATA)mo);  		}  		break;  	#endregion  	#region Text like files  	case ".ps":  		PostScriptReader ps = new PostScriptReader (FileName);  		exv.Init (ps);  		break;  	case ".pdf":  		PdfViewer pdf = new PdfViewer ();  		pdf.Init (FileName);  		exv.Visible = false;  		splitContainer3.Panel1.Controls.Add (pdf);  		pdf.Dock = DockStyle.Fill;  		break;  	case ".log":  	case ".ini":  	case ".cs":  	case ".txt":  	case ".bat":  		exv.Visible = false;  		TextBox t = new TextBox ();  		t.Multiline = true;  		t.ScrollBars = ScrollBars.Both;  		StreamReader sr = new StreamReader (FileName);  		t.Text = sr.ReadToEnd ();  		sr.Close ();  		splitContainer3.Panel1.Controls.Add (t);  		t.Dock = DockStyle.Fill;  		break;  	#endregion  	#region PE files  	case ".exe":  	case ".dll":  		exv.Visible = false;  		Executable ex = new Executable (FileName);  		ExeViewer exeViewer = new ExeViewer ();  		exeViewer.Init (ex);  		exeViewer.dataSelected += exv_dataSelected;  		splitContainer3.Panel1.Controls.Add (exeViewer);  		exeViewer.Dock = DockStyle.Fill;  		/*                                          exv.Init(ex);                        */break;  	#endregion  	case ".chm":  		//chm : http://www.russotto.net/chm/chmformat.html  		break;  	default:  		#region Analyse header and try to identify file type  		switch (hdr.HeaderBinarySt) {  		case "5346504B":  			//SFKP Sound Forge (Peak Data File)   			break;  		case "44564456":  			//DVD IFO (or BUP)  			ifo = new IFO (FileName);  			break;  		case "47494638":  			//Gif  			break;  		case "89504e47":  			//PNG  			break;  		case "4d534346":  			//CAB  			break;  		case "49545346":  			//ITSF chm  			break;  		case "31be0000":  			//wri ?  			break;  		case "00010000":  			//ttf' mdb  			break;  		case "00000100":  			// ico  			break;  		case "504b0304":  			Zip zi = new Zip (FileName);  			exv.Init (zi);  			break;  		case "52617221":  			break;  		case "ffd8ffe0":  			//Jpg  			break;  		case "d0cf11e0":  			//office  			break;  		case "3f5f0300":  			//help  			break;  		case "000001ba":  			mpg = new Mpeg2 (FileName);  			exv.Init (mpg);  			break;  		default:  			if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  				//gz file  				MessageBox.Show ("gz file' to do");  				byte compressionMethods = hdr.header [2];  				if (compressionMethods == 0x08) {  					//deflate  				}  				byte flags = hdr.header [3];  				if (flags != 0x00) {  				}  				Gzip gz = new Gzip (FileName);  				exv.Init (gz);  			}  			#region binary header  			switch (hdr.ShortHeaderString) {  			case "BM":  				// BMP  				BinDecoder bi = new BinDecoder (FileName);  				exv.Init (bi);  				break;  			case "MK":  				break;  			case "PK":  				//Zip' jar  				break;  			case "MZ":  				//exe' dll  				break;  			default:  				#region text header  				switch (hdr.HeaderString) {  				case "DVDV":  					//DVD IFO (or BUP)  					ifo = new IFO (FileName);  					break;  				case "ITSF":  					BinDecoder bid = new BinDecoder (FileName);  					//Microsoft Compiled HTML Help File : Info-Tech Storage Format  					break;  				case "GIF8":  					break;  				case "MSCF":  					//Microsoft cabinet file  					break;  				case "Rar!":  					break;  				case "RIFF":  					//avi  					AviAnalyze av = new AviAnalyze (FileName);  					exv.Init (av);  					break;  				case "%PDF":  					break;  				case "PNG":  					break;  				case "<?xm":  					//xml  					break;  				case "ID3":  					//mp3  					break;  				case "L\0R\0":  					//lrf  					break;  				case "":  					//office  					break;  				case "BZh9":  					//tar.gz  					break;  				case "\0 \0\0":  					break;  				default:  					break;  				}  				#endregion  				break;  			}  			#endregion  			break;  		}  		#endregion  		break;  	}  }  else {  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: if (Utils.Utils.types.TryGetValue (ext' out ft)) {  	switch (ext) {  	#region Web  	case ".htm":  	case ".html":  	case ".xml":  		webBrowser1.Url = new Uri (FileName);  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (webBrowser1);  		splitContainer3.Panel2Collapsed = false;  		webBrowser1.Dock = DockStyle.Fill;  		break;  	#endregion  	#region Microsoft Office  	case ".xls":  	case ".xslx":  		#region Excel  		if (Path.GetExtension (FileName).ToLower () == ".xslx") {  			Zip zx = new Zip (FileName);  			exv.Init (zx);  		}  		/*                  ExcelControl xls = new ExcelControl();                                              xls.LoadDocument(FileName);                                             xls.Dock = DockStyle.Fill;                                             tabControl1.TabPages[2].Controls.Add(xls);                                             xls.Visible = true;*/break;  	#endregion  	case ".doc":  	case ".docx":  		#region Word  		if (Path.GetExtension (FileName).ToLower () == ".docx") {  			Zip zx = new Zip (FileName);  			exv.Init (zx);  		}  		/*                  WinWordControl winWordControl1 = new WinWordControl();                                           splitContainer3.Panel2.Controls.Clear();                                           splitContainer3.Panel2.Controls.Add(winWordControl1);                                           splitContainer3.Panel2Collapsed = false;                                           winWordControl1.Dock = DockStyle.Fill;                                           winWordControl1.Visible = true;                                           winWordControl1.LoadDocument(FileName);*/break;  	#endregion  	#endregion  	#region ebooks  	case ".prc":  		MobiFileReader mob = new MobiFileReader (FileName);  		exv.Init (mob);  		webBrowser1.Visible = true;  		webBrowser1.DocumentText = mob.text;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (webBrowser1);  		splitContainer3.Panel2Collapsed = false;  		webBrowser1.Dock = DockStyle.Fill;  		prcButton.Visible = true;  		nextPage.Visible = true;  		break;  	case ".lrf":  		LRFFileReader vr = new LRFFileReader (FileName);  		exv.Init (vr);  		break;  	#endregion  	#region Images  	case ".jpg":  		JPGFileData jpg = new JPGFileData (FileName);  		exv.Init (jpg);  		PictureBox p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".png":  		PNGFile png = new PNGFile (FileName);  		exv.Init (png);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".bmp":  		BMPFile bind = new BMPFile (FileName);  		exv.Init (bind);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".gif":  		GIFFile gif = new GIFFile (FileName);  		exv.Init (gif);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".tif":  	case ".tiff":  		TiFFile tif = new TiFFile (FileName);  		exv.Init (tif);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	#endregion  	#region Audio  	case ".mp3":  	case ".wma":  		MusicFileClass mf = new MusicFileClass (FileName);  		exv.Init (mf);  		break;  	#endregion  	case ".zip":  		Zip z = new Zip (FileName);  		exv.Init (z);  		break;  	case ".ttf":  		// Font file  		break;  	#region Video  	case ".divx":  	case ".avi":  		AVIFile avi = new AVIFile (FileName);  		exv.Init (avi);  		break;  	case ".mkv":  		MkvFile mkv = new MkvFile (FileName);  		exv.Init (mkv);  		break;  	case ".flv":  		FlvFile flv = new FlvFile (FileName);  		exv.Init (flv);  		break;  	case ".mp4":  		Mp4File mp4 = new Mp4File (FileName);  		exv.Init (mp4);  		break;  	#endregion  	#region Mpeg2 endCode video  	case ".mpg":  	case ".mpeg":  	case ".vob":  		Mpeg2 mpg = new Mpeg2 (FileName);  		exv.Init (mpg);  		break;  	case ".ifo":  	case ".bup":  		IFO ifo = new IFO (FileName);  		exv.Init (ifo);  		break;  	#endregion  	#region BD video  	case ".m2ts":  	/*               M2TS mts = new M2TS(FileName);                         exv.Init(mts);                         break;*/case ".ts":  		TS_File ts = new TS_File (FileName);  		exv.Init (ts);  		break;  	case ".mpls":  		MPLS mp = new MPLS (FileName);  		exv.Init ((ILOCALIZED_DATA)mp);  		break;  	case ".clpi":  		CLPI cp = new CLPI (FileName);  		exv.Init ((ILOCALIZED_DATA)cp);  		break;  	case ".bdmv":  		if (FileName.IndexOf ("index") >= 0) {  			exv.Visible = false;  			INDEX_BDMV bd = new INDEX_BDMV (FileName);  			BDViewer bdv = new BDViewer ();  			bdv.tabSelected += new TabSelectedEventHandler (bdv_tabSelected);  			bdv.Init (bd);  			splitContainer3.Panel1.Controls.Add (bdv);  			bdv.Dock = DockStyle.Fill;  			bdv.dataSelected += new DataSelectedEventHandler (exv_dataSelected);  			TabPage tp = new TabPage (Path.GetFileName (bd.MovieObject.fileName));  			tabControl1.TabPages.Add (tp);  			BinaryView bn = new BinaryView ();  			bn.Init (bd.MovieObject.fileName);  			tp.Controls.Add (bn);  			bn.Dock = DockStyle.Fill;  			foreach (MPLS mpl in bd.MplsList) {  				tp = new TabPage (Path.GetFileName (mpl.LongName));  				tabControl1.TabPages.Add (tp);  				bn = new BinaryView ();  				bn.Init (mpl.LongName);  				tp.Controls.Add (bn);  				bn.Dock = DockStyle.Fill;  			}  		}  		else if (FileName.IndexOf ("Movie") >= 0) {  			MOBJ_BDMV mo = new MOBJ_BDMV (FileName);  			exv.Init ((ILOCALIZED_DATA)mo);  		}  		break;  	#endregion  	#region Text like files  	case ".ps":  		PostScriptReader ps = new PostScriptReader (FileName);  		exv.Init (ps);  		break;  	case ".pdf":  		PdfViewer pdf = new PdfViewer ();  		pdf.Init (FileName);  		exv.Visible = false;  		splitContainer3.Panel1.Controls.Add (pdf);  		pdf.Dock = DockStyle.Fill;  		break;  	case ".log":  	case ".ini":  	case ".cs":  	case ".txt":  	case ".bat":  		exv.Visible = false;  		TextBox t = new TextBox ();  		t.Multiline = true;  		t.ScrollBars = ScrollBars.Both;  		StreamReader sr = new StreamReader (FileName);  		t.Text = sr.ReadToEnd ();  		sr.Close ();  		splitContainer3.Panel1.Controls.Add (t);  		t.Dock = DockStyle.Fill;  		break;  	#endregion  	#region PE files  	case ".exe":  	case ".dll":  		exv.Visible = false;  		Executable ex = new Executable (FileName);  		ExeViewer exeViewer = new ExeViewer ();  		exeViewer.Init (ex);  		exeViewer.dataSelected += exv_dataSelected;  		splitContainer3.Panel1.Controls.Add (exeViewer);  		exeViewer.Dock = DockStyle.Fill;  		/*                                          exv.Init(ex);                        */break;  	#endregion  	case ".chm":  		//chm : http://www.russotto.net/chm/chmformat.html  		break;  	default:  		#region Analyse header and try to identify file type  		switch (hdr.HeaderBinarySt) {  		case "5346504B":  			//SFKP Sound Forge (Peak Data File)   			break;  		case "44564456":  			//DVD IFO (or BUP)  			ifo = new IFO (FileName);  			break;  		case "47494638":  			//Gif  			break;  		case "89504e47":  			//PNG  			break;  		case "4d534346":  			//CAB  			break;  		case "49545346":  			//ITSF chm  			break;  		case "31be0000":  			//wri ?  			break;  		case "00010000":  			//ttf' mdb  			break;  		case "00000100":  			// ico  			break;  		case "504b0304":  			Zip zi = new Zip (FileName);  			exv.Init (zi);  			break;  		case "52617221":  			break;  		case "ffd8ffe0":  			//Jpg  			break;  		case "d0cf11e0":  			//office  			break;  		case "3f5f0300":  			//help  			break;  		case "000001ba":  			mpg = new Mpeg2 (FileName);  			exv.Init (mpg);  			break;  		default:  			if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  				//gz file  				MessageBox.Show ("gz file' to do");  				byte compressionMethods = hdr.header [2];  				if (compressionMethods == 0x08) {  					//deflate  				}  				byte flags = hdr.header [3];  				if (flags != 0x00) {  				}  				Gzip gz = new Gzip (FileName);  				exv.Init (gz);  			}  			#region binary header  			switch (hdr.ShortHeaderString) {  			case "BM":  				// BMP  				BinDecoder bi = new BinDecoder (FileName);  				exv.Init (bi);  				break;  			case "MK":  				break;  			case "PK":  				//Zip' jar  				break;  			case "MZ":  				//exe' dll  				break;  			default:  				#region text header  				switch (hdr.HeaderString) {  				case "DVDV":  					//DVD IFO (or BUP)  					ifo = new IFO (FileName);  					break;  				case "ITSF":  					BinDecoder bid = new BinDecoder (FileName);  					//Microsoft Compiled HTML Help File : Info-Tech Storage Format  					break;  				case "GIF8":  					break;  				case "MSCF":  					//Microsoft cabinet file  					break;  				case "Rar!":  					break;  				case "RIFF":  					//avi  					AviAnalyze av = new AviAnalyze (FileName);  					exv.Init (av);  					break;  				case "%PDF":  					break;  				case "PNG":  					break;  				case "<?xm":  					//xml  					break;  				case "ID3":  					//mp3  					break;  				case "L\0R\0":  					//lrf  					break;  				case "":  					//office  					break;  				case "BZh9":  					//tar.gz  					break;  				case "\0 \0\0":  					break;  				default:  					break;  				}  				#endregion  				break;  			}  			#endregion  			break;  		}  		#endregion  		break;  	}  }  else {  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: if (Utils.Utils.types.TryGetValue (ext' out ft)) {  	switch (ext) {  	#region Web  	case ".htm":  	case ".html":  	case ".xml":  		webBrowser1.Url = new Uri (FileName);  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (webBrowser1);  		splitContainer3.Panel2Collapsed = false;  		webBrowser1.Dock = DockStyle.Fill;  		break;  	#endregion  	#region Microsoft Office  	case ".xls":  	case ".xslx":  		#region Excel  		if (Path.GetExtension (FileName).ToLower () == ".xslx") {  			Zip zx = new Zip (FileName);  			exv.Init (zx);  		}  		/*                  ExcelControl xls = new ExcelControl();                                              xls.LoadDocument(FileName);                                             xls.Dock = DockStyle.Fill;                                             tabControl1.TabPages[2].Controls.Add(xls);                                             xls.Visible = true;*/break;  	#endregion  	case ".doc":  	case ".docx":  		#region Word  		if (Path.GetExtension (FileName).ToLower () == ".docx") {  			Zip zx = new Zip (FileName);  			exv.Init (zx);  		}  		/*                  WinWordControl winWordControl1 = new WinWordControl();                                           splitContainer3.Panel2.Controls.Clear();                                           splitContainer3.Panel2.Controls.Add(winWordControl1);                                           splitContainer3.Panel2Collapsed = false;                                           winWordControl1.Dock = DockStyle.Fill;                                           winWordControl1.Visible = true;                                           winWordControl1.LoadDocument(FileName);*/break;  	#endregion  	#endregion  	#region ebooks  	case ".prc":  		MobiFileReader mob = new MobiFileReader (FileName);  		exv.Init (mob);  		webBrowser1.Visible = true;  		webBrowser1.DocumentText = mob.text;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (webBrowser1);  		splitContainer3.Panel2Collapsed = false;  		webBrowser1.Dock = DockStyle.Fill;  		prcButton.Visible = true;  		nextPage.Visible = true;  		break;  	case ".lrf":  		LRFFileReader vr = new LRFFileReader (FileName);  		exv.Init (vr);  		break;  	#endregion  	#region Images  	case ".jpg":  		JPGFileData jpg = new JPGFileData (FileName);  		exv.Init (jpg);  		PictureBox p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".png":  		PNGFile png = new PNGFile (FileName);  		exv.Init (png);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".bmp":  		BMPFile bind = new BMPFile (FileName);  		exv.Init (bind);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".gif":  		GIFFile gif = new GIFFile (FileName);  		exv.Init (gif);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	case ".tif":  	case ".tiff":  		TiFFile tif = new TiFFile (FileName);  		exv.Init (tif);  		p = new PictureBox ();  		p.SizeMode = PictureBoxSizeMode.StretchImage;  		p.Width = 400;  		// splitContainer1.Panel2.Width;  		p.Image = Image.FromFile (FileName);  		p.Height = p.Width * p.Image.Height / p.Image.Width;  		splitContainer3.Panel2.Controls.Clear ();  		splitContainer3.Panel2.Controls.Add (p);  		splitContainer3.Panel2Collapsed = false;  		break;  	#endregion  	#region Audio  	case ".mp3":  	case ".wma":  		MusicFileClass mf = new MusicFileClass (FileName);  		exv.Init (mf);  		break;  	#endregion  	case ".zip":  		Zip z = new Zip (FileName);  		exv.Init (z);  		break;  	case ".ttf":  		// Font file  		break;  	#region Video  	case ".divx":  	case ".avi":  		AVIFile avi = new AVIFile (FileName);  		exv.Init (avi);  		break;  	case ".mkv":  		MkvFile mkv = new MkvFile (FileName);  		exv.Init (mkv);  		break;  	case ".flv":  		FlvFile flv = new FlvFile (FileName);  		exv.Init (flv);  		break;  	case ".mp4":  		Mp4File mp4 = new Mp4File (FileName);  		exv.Init (mp4);  		break;  	#endregion  	#region Mpeg2 endCode video  	case ".mpg":  	case ".mpeg":  	case ".vob":  		Mpeg2 mpg = new Mpeg2 (FileName);  		exv.Init (mpg);  		break;  	case ".ifo":  	case ".bup":  		IFO ifo = new IFO (FileName);  		exv.Init (ifo);  		break;  	#endregion  	#region BD video  	case ".m2ts":  	/*               M2TS mts = new M2TS(FileName);                         exv.Init(mts);                         break;*/case ".ts":  		TS_File ts = new TS_File (FileName);  		exv.Init (ts);  		break;  	case ".mpls":  		MPLS mp = new MPLS (FileName);  		exv.Init ((ILOCALIZED_DATA)mp);  		break;  	case ".clpi":  		CLPI cp = new CLPI (FileName);  		exv.Init ((ILOCALIZED_DATA)cp);  		break;  	case ".bdmv":  		if (FileName.IndexOf ("index") >= 0) {  			exv.Visible = false;  			INDEX_BDMV bd = new INDEX_BDMV (FileName);  			BDViewer bdv = new BDViewer ();  			bdv.tabSelected += new TabSelectedEventHandler (bdv_tabSelected);  			bdv.Init (bd);  			splitContainer3.Panel1.Controls.Add (bdv);  			bdv.Dock = DockStyle.Fill;  			bdv.dataSelected += new DataSelectedEventHandler (exv_dataSelected);  			TabPage tp = new TabPage (Path.GetFileName (bd.MovieObject.fileName));  			tabControl1.TabPages.Add (tp);  			BinaryView bn = new BinaryView ();  			bn.Init (bd.MovieObject.fileName);  			tp.Controls.Add (bn);  			bn.Dock = DockStyle.Fill;  			foreach (MPLS mpl in bd.MplsList) {  				tp = new TabPage (Path.GetFileName (mpl.LongName));  				tabControl1.TabPages.Add (tp);  				bn = new BinaryView ();  				bn.Init (mpl.LongName);  				tp.Controls.Add (bn);  				bn.Dock = DockStyle.Fill;  			}  		}  		else if (FileName.IndexOf ("Movie") >= 0) {  			MOBJ_BDMV mo = new MOBJ_BDMV (FileName);  			exv.Init ((ILOCALIZED_DATA)mo);  		}  		break;  	#endregion  	#region Text like files  	case ".ps":  		PostScriptReader ps = new PostScriptReader (FileName);  		exv.Init (ps);  		break;  	case ".pdf":  		PdfViewer pdf = new PdfViewer ();  		pdf.Init (FileName);  		exv.Visible = false;  		splitContainer3.Panel1.Controls.Add (pdf);  		pdf.Dock = DockStyle.Fill;  		break;  	case ".log":  	case ".ini":  	case ".cs":  	case ".txt":  	case ".bat":  		exv.Visible = false;  		TextBox t = new TextBox ();  		t.Multiline = true;  		t.ScrollBars = ScrollBars.Both;  		StreamReader sr = new StreamReader (FileName);  		t.Text = sr.ReadToEnd ();  		sr.Close ();  		splitContainer3.Panel1.Controls.Add (t);  		t.Dock = DockStyle.Fill;  		break;  	#endregion  	#region PE files  	case ".exe":  	case ".dll":  		exv.Visible = false;  		Executable ex = new Executable (FileName);  		ExeViewer exeViewer = new ExeViewer ();  		exeViewer.Init (ex);  		exeViewer.dataSelected += exv_dataSelected;  		splitContainer3.Panel1.Controls.Add (exeViewer);  		exeViewer.Dock = DockStyle.Fill;  		/*                                          exv.Init(ex);                        */break;  	#endregion  	case ".chm":  		//chm : http://www.russotto.net/chm/chmformat.html  		break;  	default:  		#region Analyse header and try to identify file type  		switch (hdr.HeaderBinarySt) {  		case "5346504B":  			//SFKP Sound Forge (Peak Data File)   			break;  		case "44564456":  			//DVD IFO (or BUP)  			ifo = new IFO (FileName);  			break;  		case "47494638":  			//Gif  			break;  		case "89504e47":  			//PNG  			break;  		case "4d534346":  			//CAB  			break;  		case "49545346":  			//ITSF chm  			break;  		case "31be0000":  			//wri ?  			break;  		case "00010000":  			//ttf' mdb  			break;  		case "00000100":  			// ico  			break;  		case "504b0304":  			Zip zi = new Zip (FileName);  			exv.Init (zi);  			break;  		case "52617221":  			break;  		case "ffd8ffe0":  			//Jpg  			break;  		case "d0cf11e0":  			//office  			break;  		case "3f5f0300":  			//help  			break;  		case "000001ba":  			mpg = new Mpeg2 (FileName);  			exv.Init (mpg);  			break;  		default:  			if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  				//gz file  				MessageBox.Show ("gz file' to do");  				byte compressionMethods = hdr.header [2];  				if (compressionMethods == 0x08) {  					//deflate  				}  				byte flags = hdr.header [3];  				if (flags != 0x00) {  				}  				Gzip gz = new Gzip (FileName);  				exv.Init (gz);  			}  			#region binary header  			switch (hdr.ShortHeaderString) {  			case "BM":  				// BMP  				BinDecoder bi = new BinDecoder (FileName);  				exv.Init (bi);  				break;  			case "MK":  				break;  			case "PK":  				//Zip' jar  				break;  			case "MZ":  				//exe' dll  				break;  			default:  				#region text header  				switch (hdr.HeaderString) {  				case "DVDV":  					//DVD IFO (or BUP)  					ifo = new IFO (FileName);  					break;  				case "ITSF":  					BinDecoder bid = new BinDecoder (FileName);  					//Microsoft Compiled HTML Help File : Info-Tech Storage Format  					break;  				case "GIF8":  					break;  				case "MSCF":  					//Microsoft cabinet file  					break;  				case "Rar!":  					break;  				case "RIFF":  					//avi  					AviAnalyze av = new AviAnalyze (FileName);  					exv.Init (av);  					break;  				case "%PDF":  					break;  				case "PNG":  					break;  				case "<?xm":  					//xml  					break;  				case "ID3":  					//mp3  					break;  				case "L\0R\0":  					//lrf  					break;  				case "":  					//office  					break;  				case "BZh9":  					//tar.gz  					break;  				case "\0 \0\0":  					break;  				default:  					break;  				}  				#endregion  				break;  			}  			#endregion  			break;  		}  		#endregion  		break;  	}  }  else {  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: switch (ext) {  #region Web  case ".htm":  case ".html":  case ".xml":  	webBrowser1.Url = new Uri (FileName);  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (webBrowser1);  	splitContainer3.Panel2Collapsed = false;  	webBrowser1.Dock = DockStyle.Fill;  	break;  #endregion  #region Microsoft Office  case ".xls":  case ".xslx":  	#region Excel  	if (Path.GetExtension (FileName).ToLower () == ".xslx") {  		Zip zx = new Zip (FileName);  		exv.Init (zx);  	}  	/*                  ExcelControl xls = new ExcelControl();                                              xls.LoadDocument(FileName);                                             xls.Dock = DockStyle.Fill;                                             tabControl1.TabPages[2].Controls.Add(xls);                                             xls.Visible = true;*/break;  #endregion  case ".doc":  case ".docx":  	#region Word  	if (Path.GetExtension (FileName).ToLower () == ".docx") {  		Zip zx = new Zip (FileName);  		exv.Init (zx);  	}  	/*                  WinWordControl winWordControl1 = new WinWordControl();                                           splitContainer3.Panel2.Controls.Clear();                                           splitContainer3.Panel2.Controls.Add(winWordControl1);                                           splitContainer3.Panel2Collapsed = false;                                           winWordControl1.Dock = DockStyle.Fill;                                           winWordControl1.Visible = true;                                           winWordControl1.LoadDocument(FileName);*/break;  #endregion  #endregion  #region ebooks  case ".prc":  	MobiFileReader mob = new MobiFileReader (FileName);  	exv.Init (mob);  	webBrowser1.Visible = true;  	webBrowser1.DocumentText = mob.text;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (webBrowser1);  	splitContainer3.Panel2Collapsed = false;  	webBrowser1.Dock = DockStyle.Fill;  	prcButton.Visible = true;  	nextPage.Visible = true;  	break;  case ".lrf":  	LRFFileReader vr = new LRFFileReader (FileName);  	exv.Init (vr);  	break;  #endregion  #region Images  case ".jpg":  	JPGFileData jpg = new JPGFileData (FileName);  	exv.Init (jpg);  	PictureBox p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".png":  	PNGFile png = new PNGFile (FileName);  	exv.Init (png);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".bmp":  	BMPFile bind = new BMPFile (FileName);  	exv.Init (bind);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".gif":  	GIFFile gif = new GIFFile (FileName);  	exv.Init (gif);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".tif":  case ".tiff":  	TiFFile tif = new TiFFile (FileName);  	exv.Init (tif);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  #endregion  #region Audio  case ".mp3":  case ".wma":  	MusicFileClass mf = new MusicFileClass (FileName);  	exv.Init (mf);  	break;  #endregion  case ".zip":  	Zip z = new Zip (FileName);  	exv.Init (z);  	break;  case ".ttf":  	// Font file  	break;  #region Video  case ".divx":  case ".avi":  	AVIFile avi = new AVIFile (FileName);  	exv.Init (avi);  	break;  case ".mkv":  	MkvFile mkv = new MkvFile (FileName);  	exv.Init (mkv);  	break;  case ".flv":  	FlvFile flv = new FlvFile (FileName);  	exv.Init (flv);  	break;  case ".mp4":  	Mp4File mp4 = new Mp4File (FileName);  	exv.Init (mp4);  	break;  #endregion  #region Mpeg2 endCode video  case ".mpg":  case ".mpeg":  case ".vob":  	Mpeg2 mpg = new Mpeg2 (FileName);  	exv.Init (mpg);  	break;  case ".ifo":  case ".bup":  	IFO ifo = new IFO (FileName);  	exv.Init (ifo);  	break;  #endregion  #region BD video  case ".m2ts":  /*               M2TS mts = new M2TS(FileName);                         exv.Init(mts);                         break;*/case ".ts":  	TS_File ts = new TS_File (FileName);  	exv.Init (ts);  	break;  case ".mpls":  	MPLS mp = new MPLS (FileName);  	exv.Init ((ILOCALIZED_DATA)mp);  	break;  case ".clpi":  	CLPI cp = new CLPI (FileName);  	exv.Init ((ILOCALIZED_DATA)cp);  	break;  case ".bdmv":  	if (FileName.IndexOf ("index") >= 0) {  		exv.Visible = false;  		INDEX_BDMV bd = new INDEX_BDMV (FileName);  		BDViewer bdv = new BDViewer ();  		bdv.tabSelected += new TabSelectedEventHandler (bdv_tabSelected);  		bdv.Init (bd);  		splitContainer3.Panel1.Controls.Add (bdv);  		bdv.Dock = DockStyle.Fill;  		bdv.dataSelected += new DataSelectedEventHandler (exv_dataSelected);  		TabPage tp = new TabPage (Path.GetFileName (bd.MovieObject.fileName));  		tabControl1.TabPages.Add (tp);  		BinaryView bn = new BinaryView ();  		bn.Init (bd.MovieObject.fileName);  		tp.Controls.Add (bn);  		bn.Dock = DockStyle.Fill;  		foreach (MPLS mpl in bd.MplsList) {  			tp = new TabPage (Path.GetFileName (mpl.LongName));  			tabControl1.TabPages.Add (tp);  			bn = new BinaryView ();  			bn.Init (mpl.LongName);  			tp.Controls.Add (bn);  			bn.Dock = DockStyle.Fill;  		}  	}  	else if (FileName.IndexOf ("Movie") >= 0) {  		MOBJ_BDMV mo = new MOBJ_BDMV (FileName);  		exv.Init ((ILOCALIZED_DATA)mo);  	}  	break;  #endregion  #region Text like files  case ".ps":  	PostScriptReader ps = new PostScriptReader (FileName);  	exv.Init (ps);  	break;  case ".pdf":  	PdfViewer pdf = new PdfViewer ();  	pdf.Init (FileName);  	exv.Visible = false;  	splitContainer3.Panel1.Controls.Add (pdf);  	pdf.Dock = DockStyle.Fill;  	break;  case ".log":  case ".ini":  case ".cs":  case ".txt":  case ".bat":  	exv.Visible = false;  	TextBox t = new TextBox ();  	t.Multiline = true;  	t.ScrollBars = ScrollBars.Both;  	StreamReader sr = new StreamReader (FileName);  	t.Text = sr.ReadToEnd ();  	sr.Close ();  	splitContainer3.Panel1.Controls.Add (t);  	t.Dock = DockStyle.Fill;  	break;  #endregion  #region PE files  case ".exe":  case ".dll":  	exv.Visible = false;  	Executable ex = new Executable (FileName);  	ExeViewer exeViewer = new ExeViewer ();  	exeViewer.Init (ex);  	exeViewer.dataSelected += exv_dataSelected;  	splitContainer3.Panel1.Controls.Add (exeViewer);  	exeViewer.Dock = DockStyle.Fill;  	/*                                          exv.Init(ex);                        */break;  #endregion  case ".chm":  	//chm : http://www.russotto.net/chm/chmformat.html  	break;  default:  	#region Analyse header and try to identify file type  	switch (hdr.HeaderBinarySt) {  	case "5346504B":  		//SFKP Sound Forge (Peak Data File)   		break;  	case "44564456":  		//DVD IFO (or BUP)  		ifo = new IFO (FileName);  		break;  	case "47494638":  		//Gif  		break;  	case "89504e47":  		//PNG  		break;  	case "4d534346":  		//CAB  		break;  	case "49545346":  		//ITSF chm  		break;  	case "31be0000":  		//wri ?  		break;  	case "00010000":  		//ttf' mdb  		break;  	case "00000100":  		// ico  		break;  	case "504b0304":  		Zip zi = new Zip (FileName);  		exv.Init (zi);  		break;  	case "52617221":  		break;  	case "ffd8ffe0":  		//Jpg  		break;  	case "d0cf11e0":  		//office  		break;  	case "3f5f0300":  		//help  		break;  	case "000001ba":  		mpg = new Mpeg2 (FileName);  		exv.Init (mpg);  		break;  	default:  		if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  			//gz file  			MessageBox.Show ("gz file' to do");  			byte compressionMethods = hdr.header [2];  			if (compressionMethods == 0x08) {  				//deflate  			}  			byte flags = hdr.header [3];  			if (flags != 0x00) {  			}  			Gzip gz = new Gzip (FileName);  			exv.Init (gz);  		}  		#region binary header  		switch (hdr.ShortHeaderString) {  		case "BM":  			// BMP  			BinDecoder bi = new BinDecoder (FileName);  			exv.Init (bi);  			break;  		case "MK":  			break;  		case "PK":  			//Zip' jar  			break;  		case "MZ":  			//exe' dll  			break;  		default:  			#region text header  			switch (hdr.HeaderString) {  			case "DVDV":  				//DVD IFO (or BUP)  				ifo = new IFO (FileName);  				break;  			case "ITSF":  				BinDecoder bid = new BinDecoder (FileName);  				//Microsoft Compiled HTML Help File : Info-Tech Storage Format  				break;  			case "GIF8":  				break;  			case "MSCF":  				//Microsoft cabinet file  				break;  			case "Rar!":  				break;  			case "RIFF":  				//avi  				AviAnalyze av = new AviAnalyze (FileName);  				exv.Init (av);  				break;  			case "%PDF":  				break;  			case "PNG":  				break;  			case "<?xm":  				//xml  				break;  			case "ID3":  				//mp3  				break;  			case "L\0R\0":  				//lrf  				break;  			case "":  				//office  				break;  			case "BZh9":  				//tar.gz  				break;  			case "\0 \0\0":  				break;  			default:  				break;  			}  			#endregion  			break;  		}  		#endregion  		break;  	}  	#endregion  	break;  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: switch (ext) {  #region Web  case ".htm":  case ".html":  case ".xml":  	webBrowser1.Url = new Uri (FileName);  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (webBrowser1);  	splitContainer3.Panel2Collapsed = false;  	webBrowser1.Dock = DockStyle.Fill;  	break;  #endregion  #region Microsoft Office  case ".xls":  case ".xslx":  	#region Excel  	if (Path.GetExtension (FileName).ToLower () == ".xslx") {  		Zip zx = new Zip (FileName);  		exv.Init (zx);  	}  	/*                  ExcelControl xls = new ExcelControl();                                              xls.LoadDocument(FileName);                                             xls.Dock = DockStyle.Fill;                                             tabControl1.TabPages[2].Controls.Add(xls);                                             xls.Visible = true;*/break;  #endregion  case ".doc":  case ".docx":  	#region Word  	if (Path.GetExtension (FileName).ToLower () == ".docx") {  		Zip zx = new Zip (FileName);  		exv.Init (zx);  	}  	/*                  WinWordControl winWordControl1 = new WinWordControl();                                           splitContainer3.Panel2.Controls.Clear();                                           splitContainer3.Panel2.Controls.Add(winWordControl1);                                           splitContainer3.Panel2Collapsed = false;                                           winWordControl1.Dock = DockStyle.Fill;                                           winWordControl1.Visible = true;                                           winWordControl1.LoadDocument(FileName);*/break;  #endregion  #endregion  #region ebooks  case ".prc":  	MobiFileReader mob = new MobiFileReader (FileName);  	exv.Init (mob);  	webBrowser1.Visible = true;  	webBrowser1.DocumentText = mob.text;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (webBrowser1);  	splitContainer3.Panel2Collapsed = false;  	webBrowser1.Dock = DockStyle.Fill;  	prcButton.Visible = true;  	nextPage.Visible = true;  	break;  case ".lrf":  	LRFFileReader vr = new LRFFileReader (FileName);  	exv.Init (vr);  	break;  #endregion  #region Images  case ".jpg":  	JPGFileData jpg = new JPGFileData (FileName);  	exv.Init (jpg);  	PictureBox p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".png":  	PNGFile png = new PNGFile (FileName);  	exv.Init (png);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".bmp":  	BMPFile bind = new BMPFile (FileName);  	exv.Init (bind);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".gif":  	GIFFile gif = new GIFFile (FileName);  	exv.Init (gif);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".tif":  case ".tiff":  	TiFFile tif = new TiFFile (FileName);  	exv.Init (tif);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  #endregion  #region Audio  case ".mp3":  case ".wma":  	MusicFileClass mf = new MusicFileClass (FileName);  	exv.Init (mf);  	break;  #endregion  case ".zip":  	Zip z = new Zip (FileName);  	exv.Init (z);  	break;  case ".ttf":  	// Font file  	break;  #region Video  case ".divx":  case ".avi":  	AVIFile avi = new AVIFile (FileName);  	exv.Init (avi);  	break;  case ".mkv":  	MkvFile mkv = new MkvFile (FileName);  	exv.Init (mkv);  	break;  case ".flv":  	FlvFile flv = new FlvFile (FileName);  	exv.Init (flv);  	break;  case ".mp4":  	Mp4File mp4 = new Mp4File (FileName);  	exv.Init (mp4);  	break;  #endregion  #region Mpeg2 endCode video  case ".mpg":  case ".mpeg":  case ".vob":  	Mpeg2 mpg = new Mpeg2 (FileName);  	exv.Init (mpg);  	break;  case ".ifo":  case ".bup":  	IFO ifo = new IFO (FileName);  	exv.Init (ifo);  	break;  #endregion  #region BD video  case ".m2ts":  /*               M2TS mts = new M2TS(FileName);                         exv.Init(mts);                         break;*/case ".ts":  	TS_File ts = new TS_File (FileName);  	exv.Init (ts);  	break;  case ".mpls":  	MPLS mp = new MPLS (FileName);  	exv.Init ((ILOCALIZED_DATA)mp);  	break;  case ".clpi":  	CLPI cp = new CLPI (FileName);  	exv.Init ((ILOCALIZED_DATA)cp);  	break;  case ".bdmv":  	if (FileName.IndexOf ("index") >= 0) {  		exv.Visible = false;  		INDEX_BDMV bd = new INDEX_BDMV (FileName);  		BDViewer bdv = new BDViewer ();  		bdv.tabSelected += new TabSelectedEventHandler (bdv_tabSelected);  		bdv.Init (bd);  		splitContainer3.Panel1.Controls.Add (bdv);  		bdv.Dock = DockStyle.Fill;  		bdv.dataSelected += new DataSelectedEventHandler (exv_dataSelected);  		TabPage tp = new TabPage (Path.GetFileName (bd.MovieObject.fileName));  		tabControl1.TabPages.Add (tp);  		BinaryView bn = new BinaryView ();  		bn.Init (bd.MovieObject.fileName);  		tp.Controls.Add (bn);  		bn.Dock = DockStyle.Fill;  		foreach (MPLS mpl in bd.MplsList) {  			tp = new TabPage (Path.GetFileName (mpl.LongName));  			tabControl1.TabPages.Add (tp);  			bn = new BinaryView ();  			bn.Init (mpl.LongName);  			tp.Controls.Add (bn);  			bn.Dock = DockStyle.Fill;  		}  	}  	else if (FileName.IndexOf ("Movie") >= 0) {  		MOBJ_BDMV mo = new MOBJ_BDMV (FileName);  		exv.Init ((ILOCALIZED_DATA)mo);  	}  	break;  #endregion  #region Text like files  case ".ps":  	PostScriptReader ps = new PostScriptReader (FileName);  	exv.Init (ps);  	break;  case ".pdf":  	PdfViewer pdf = new PdfViewer ();  	pdf.Init (FileName);  	exv.Visible = false;  	splitContainer3.Panel1.Controls.Add (pdf);  	pdf.Dock = DockStyle.Fill;  	break;  case ".log":  case ".ini":  case ".cs":  case ".txt":  case ".bat":  	exv.Visible = false;  	TextBox t = new TextBox ();  	t.Multiline = true;  	t.ScrollBars = ScrollBars.Both;  	StreamReader sr = new StreamReader (FileName);  	t.Text = sr.ReadToEnd ();  	sr.Close ();  	splitContainer3.Panel1.Controls.Add (t);  	t.Dock = DockStyle.Fill;  	break;  #endregion  #region PE files  case ".exe":  case ".dll":  	exv.Visible = false;  	Executable ex = new Executable (FileName);  	ExeViewer exeViewer = new ExeViewer ();  	exeViewer.Init (ex);  	exeViewer.dataSelected += exv_dataSelected;  	splitContainer3.Panel1.Controls.Add (exeViewer);  	exeViewer.Dock = DockStyle.Fill;  	/*                                          exv.Init(ex);                        */break;  #endregion  case ".chm":  	//chm : http://www.russotto.net/chm/chmformat.html  	break;  default:  	#region Analyse header and try to identify file type  	switch (hdr.HeaderBinarySt) {  	case "5346504B":  		//SFKP Sound Forge (Peak Data File)   		break;  	case "44564456":  		//DVD IFO (or BUP)  		ifo = new IFO (FileName);  		break;  	case "47494638":  		//Gif  		break;  	case "89504e47":  		//PNG  		break;  	case "4d534346":  		//CAB  		break;  	case "49545346":  		//ITSF chm  		break;  	case "31be0000":  		//wri ?  		break;  	case "00010000":  		//ttf' mdb  		break;  	case "00000100":  		// ico  		break;  	case "504b0304":  		Zip zi = new Zip (FileName);  		exv.Init (zi);  		break;  	case "52617221":  		break;  	case "ffd8ffe0":  		//Jpg  		break;  	case "d0cf11e0":  		//office  		break;  	case "3f5f0300":  		//help  		break;  	case "000001ba":  		mpg = new Mpeg2 (FileName);  		exv.Init (mpg);  		break;  	default:  		if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  			//gz file  			MessageBox.Show ("gz file' to do");  			byte compressionMethods = hdr.header [2];  			if (compressionMethods == 0x08) {  				//deflate  			}  			byte flags = hdr.header [3];  			if (flags != 0x00) {  			}  			Gzip gz = new Gzip (FileName);  			exv.Init (gz);  		}  		#region binary header  		switch (hdr.ShortHeaderString) {  		case "BM":  			// BMP  			BinDecoder bi = new BinDecoder (FileName);  			exv.Init (bi);  			break;  		case "MK":  			break;  		case "PK":  			//Zip' jar  			break;  		case "MZ":  			//exe' dll  			break;  		default:  			#region text header  			switch (hdr.HeaderString) {  			case "DVDV":  				//DVD IFO (or BUP)  				ifo = new IFO (FileName);  				break;  			case "ITSF":  				BinDecoder bid = new BinDecoder (FileName);  				//Microsoft Compiled HTML Help File : Info-Tech Storage Format  				break;  			case "GIF8":  				break;  			case "MSCF":  				//Microsoft cabinet file  				break;  			case "Rar!":  				break;  			case "RIFF":  				//avi  				AviAnalyze av = new AviAnalyze (FileName);  				exv.Init (av);  				break;  			case "%PDF":  				break;  			case "PNG":  				break;  			case "<?xm":  				//xml  				break;  			case "ID3":  				//mp3  				break;  			case "L\0R\0":  				//lrf  				break;  			case "":  				//office  				break;  			case "BZh9":  				//tar.gz  				break;  			case "\0 \0\0":  				break;  			default:  				break;  			}  			#endregion  			break;  		}  		#endregion  		break;  	}  	#endregion  	break;  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: switch (ext) {  #region Web  case ".htm":  case ".html":  case ".xml":  	webBrowser1.Url = new Uri (FileName);  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (webBrowser1);  	splitContainer3.Panel2Collapsed = false;  	webBrowser1.Dock = DockStyle.Fill;  	break;  #endregion  #region Microsoft Office  case ".xls":  case ".xslx":  	#region Excel  	if (Path.GetExtension (FileName).ToLower () == ".xslx") {  		Zip zx = new Zip (FileName);  		exv.Init (zx);  	}  	/*                  ExcelControl xls = new ExcelControl();                                              xls.LoadDocument(FileName);                                             xls.Dock = DockStyle.Fill;                                             tabControl1.TabPages[2].Controls.Add(xls);                                             xls.Visible = true;*/break;  #endregion  case ".doc":  case ".docx":  	#region Word  	if (Path.GetExtension (FileName).ToLower () == ".docx") {  		Zip zx = new Zip (FileName);  		exv.Init (zx);  	}  	/*                  WinWordControl winWordControl1 = new WinWordControl();                                           splitContainer3.Panel2.Controls.Clear();                                           splitContainer3.Panel2.Controls.Add(winWordControl1);                                           splitContainer3.Panel2Collapsed = false;                                           winWordControl1.Dock = DockStyle.Fill;                                           winWordControl1.Visible = true;                                           winWordControl1.LoadDocument(FileName);*/break;  #endregion  #endregion  #region ebooks  case ".prc":  	MobiFileReader mob = new MobiFileReader (FileName);  	exv.Init (mob);  	webBrowser1.Visible = true;  	webBrowser1.DocumentText = mob.text;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (webBrowser1);  	splitContainer3.Panel2Collapsed = false;  	webBrowser1.Dock = DockStyle.Fill;  	prcButton.Visible = true;  	nextPage.Visible = true;  	break;  case ".lrf":  	LRFFileReader vr = new LRFFileReader (FileName);  	exv.Init (vr);  	break;  #endregion  #region Images  case ".jpg":  	JPGFileData jpg = new JPGFileData (FileName);  	exv.Init (jpg);  	PictureBox p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".png":  	PNGFile png = new PNGFile (FileName);  	exv.Init (png);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".bmp":  	BMPFile bind = new BMPFile (FileName);  	exv.Init (bind);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".gif":  	GIFFile gif = new GIFFile (FileName);  	exv.Init (gif);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".tif":  case ".tiff":  	TiFFile tif = new TiFFile (FileName);  	exv.Init (tif);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  #endregion  #region Audio  case ".mp3":  case ".wma":  	MusicFileClass mf = new MusicFileClass (FileName);  	exv.Init (mf);  	break;  #endregion  case ".zip":  	Zip z = new Zip (FileName);  	exv.Init (z);  	break;  case ".ttf":  	// Font file  	break;  #region Video  case ".divx":  case ".avi":  	AVIFile avi = new AVIFile (FileName);  	exv.Init (avi);  	break;  case ".mkv":  	MkvFile mkv = new MkvFile (FileName);  	exv.Init (mkv);  	break;  case ".flv":  	FlvFile flv = new FlvFile (FileName);  	exv.Init (flv);  	break;  case ".mp4":  	Mp4File mp4 = new Mp4File (FileName);  	exv.Init (mp4);  	break;  #endregion  #region Mpeg2 endCode video  case ".mpg":  case ".mpeg":  case ".vob":  	Mpeg2 mpg = new Mpeg2 (FileName);  	exv.Init (mpg);  	break;  case ".ifo":  case ".bup":  	IFO ifo = new IFO (FileName);  	exv.Init (ifo);  	break;  #endregion  #region BD video  case ".m2ts":  /*               M2TS mts = new M2TS(FileName);                         exv.Init(mts);                         break;*/case ".ts":  	TS_File ts = new TS_File (FileName);  	exv.Init (ts);  	break;  case ".mpls":  	MPLS mp = new MPLS (FileName);  	exv.Init ((ILOCALIZED_DATA)mp);  	break;  case ".clpi":  	CLPI cp = new CLPI (FileName);  	exv.Init ((ILOCALIZED_DATA)cp);  	break;  case ".bdmv":  	if (FileName.IndexOf ("index") >= 0) {  		exv.Visible = false;  		INDEX_BDMV bd = new INDEX_BDMV (FileName);  		BDViewer bdv = new BDViewer ();  		bdv.tabSelected += new TabSelectedEventHandler (bdv_tabSelected);  		bdv.Init (bd);  		splitContainer3.Panel1.Controls.Add (bdv);  		bdv.Dock = DockStyle.Fill;  		bdv.dataSelected += new DataSelectedEventHandler (exv_dataSelected);  		TabPage tp = new TabPage (Path.GetFileName (bd.MovieObject.fileName));  		tabControl1.TabPages.Add (tp);  		BinaryView bn = new BinaryView ();  		bn.Init (bd.MovieObject.fileName);  		tp.Controls.Add (bn);  		bn.Dock = DockStyle.Fill;  		foreach (MPLS mpl in bd.MplsList) {  			tp = new TabPage (Path.GetFileName (mpl.LongName));  			tabControl1.TabPages.Add (tp);  			bn = new BinaryView ();  			bn.Init (mpl.LongName);  			tp.Controls.Add (bn);  			bn.Dock = DockStyle.Fill;  		}  	}  	else if (FileName.IndexOf ("Movie") >= 0) {  		MOBJ_BDMV mo = new MOBJ_BDMV (FileName);  		exv.Init ((ILOCALIZED_DATA)mo);  	}  	break;  #endregion  #region Text like files  case ".ps":  	PostScriptReader ps = new PostScriptReader (FileName);  	exv.Init (ps);  	break;  case ".pdf":  	PdfViewer pdf = new PdfViewer ();  	pdf.Init (FileName);  	exv.Visible = false;  	splitContainer3.Panel1.Controls.Add (pdf);  	pdf.Dock = DockStyle.Fill;  	break;  case ".log":  case ".ini":  case ".cs":  case ".txt":  case ".bat":  	exv.Visible = false;  	TextBox t = new TextBox ();  	t.Multiline = true;  	t.ScrollBars = ScrollBars.Both;  	StreamReader sr = new StreamReader (FileName);  	t.Text = sr.ReadToEnd ();  	sr.Close ();  	splitContainer3.Panel1.Controls.Add (t);  	t.Dock = DockStyle.Fill;  	break;  #endregion  #region PE files  case ".exe":  case ".dll":  	exv.Visible = false;  	Executable ex = new Executable (FileName);  	ExeViewer exeViewer = new ExeViewer ();  	exeViewer.Init (ex);  	exeViewer.dataSelected += exv_dataSelected;  	splitContainer3.Panel1.Controls.Add (exeViewer);  	exeViewer.Dock = DockStyle.Fill;  	/*                                          exv.Init(ex);                        */break;  #endregion  case ".chm":  	//chm : http://www.russotto.net/chm/chmformat.html  	break;  default:  	#region Analyse header and try to identify file type  	switch (hdr.HeaderBinarySt) {  	case "5346504B":  		//SFKP Sound Forge (Peak Data File)   		break;  	case "44564456":  		//DVD IFO (or BUP)  		ifo = new IFO (FileName);  		break;  	case "47494638":  		//Gif  		break;  	case "89504e47":  		//PNG  		break;  	case "4d534346":  		//CAB  		break;  	case "49545346":  		//ITSF chm  		break;  	case "31be0000":  		//wri ?  		break;  	case "00010000":  		//ttf' mdb  		break;  	case "00000100":  		// ico  		break;  	case "504b0304":  		Zip zi = new Zip (FileName);  		exv.Init (zi);  		break;  	case "52617221":  		break;  	case "ffd8ffe0":  		//Jpg  		break;  	case "d0cf11e0":  		//office  		break;  	case "3f5f0300":  		//help  		break;  	case "000001ba":  		mpg = new Mpeg2 (FileName);  		exv.Init (mpg);  		break;  	default:  		if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  			//gz file  			MessageBox.Show ("gz file' to do");  			byte compressionMethods = hdr.header [2];  			if (compressionMethods == 0x08) {  				//deflate  			}  			byte flags = hdr.header [3];  			if (flags != 0x00) {  			}  			Gzip gz = new Gzip (FileName);  			exv.Init (gz);  		}  		#region binary header  		switch (hdr.ShortHeaderString) {  		case "BM":  			// BMP  			BinDecoder bi = new BinDecoder (FileName);  			exv.Init (bi);  			break;  		case "MK":  			break;  		case "PK":  			//Zip' jar  			break;  		case "MZ":  			//exe' dll  			break;  		default:  			#region text header  			switch (hdr.HeaderString) {  			case "DVDV":  				//DVD IFO (or BUP)  				ifo = new IFO (FileName);  				break;  			case "ITSF":  				BinDecoder bid = new BinDecoder (FileName);  				//Microsoft Compiled HTML Help File : Info-Tech Storage Format  				break;  			case "GIF8":  				break;  			case "MSCF":  				//Microsoft cabinet file  				break;  			case "Rar!":  				break;  			case "RIFF":  				//avi  				AviAnalyze av = new AviAnalyze (FileName);  				exv.Init (av);  				break;  			case "%PDF":  				break;  			case "PNG":  				break;  			case "<?xm":  				//xml  				break;  			case "ID3":  				//mp3  				break;  			case "L\0R\0":  				//lrf  				break;  			case "":  				//office  				break;  			case "BZh9":  				//tar.gz  				break;  			case "\0 \0\0":  				break;  			default:  				break;  			}  			#endregion  			break;  		}  		#endregion  		break;  	}  	#endregion  	break;  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: switch (ext) {  #region Web  case ".htm":  case ".html":  case ".xml":  	webBrowser1.Url = new Uri (FileName);  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (webBrowser1);  	splitContainer3.Panel2Collapsed = false;  	webBrowser1.Dock = DockStyle.Fill;  	break;  #endregion  #region Microsoft Office  case ".xls":  case ".xslx":  	#region Excel  	if (Path.GetExtension (FileName).ToLower () == ".xslx") {  		Zip zx = new Zip (FileName);  		exv.Init (zx);  	}  	/*                  ExcelControl xls = new ExcelControl();                                              xls.LoadDocument(FileName);                                             xls.Dock = DockStyle.Fill;                                             tabControl1.TabPages[2].Controls.Add(xls);                                             xls.Visible = true;*/break;  #endregion  case ".doc":  case ".docx":  	#region Word  	if (Path.GetExtension (FileName).ToLower () == ".docx") {  		Zip zx = new Zip (FileName);  		exv.Init (zx);  	}  	/*                  WinWordControl winWordControl1 = new WinWordControl();                                           splitContainer3.Panel2.Controls.Clear();                                           splitContainer3.Panel2.Controls.Add(winWordControl1);                                           splitContainer3.Panel2Collapsed = false;                                           winWordControl1.Dock = DockStyle.Fill;                                           winWordControl1.Visible = true;                                           winWordControl1.LoadDocument(FileName);*/break;  #endregion  #endregion  #region ebooks  case ".prc":  	MobiFileReader mob = new MobiFileReader (FileName);  	exv.Init (mob);  	webBrowser1.Visible = true;  	webBrowser1.DocumentText = mob.text;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (webBrowser1);  	splitContainer3.Panel2Collapsed = false;  	webBrowser1.Dock = DockStyle.Fill;  	prcButton.Visible = true;  	nextPage.Visible = true;  	break;  case ".lrf":  	LRFFileReader vr = new LRFFileReader (FileName);  	exv.Init (vr);  	break;  #endregion  #region Images  case ".jpg":  	JPGFileData jpg = new JPGFileData (FileName);  	exv.Init (jpg);  	PictureBox p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".png":  	PNGFile png = new PNGFile (FileName);  	exv.Init (png);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".bmp":  	BMPFile bind = new BMPFile (FileName);  	exv.Init (bind);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".gif":  	GIFFile gif = new GIFFile (FileName);  	exv.Init (gif);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".tif":  case ".tiff":  	TiFFile tif = new TiFFile (FileName);  	exv.Init (tif);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  #endregion  #region Audio  case ".mp3":  case ".wma":  	MusicFileClass mf = new MusicFileClass (FileName);  	exv.Init (mf);  	break;  #endregion  case ".zip":  	Zip z = new Zip (FileName);  	exv.Init (z);  	break;  case ".ttf":  	// Font file  	break;  #region Video  case ".divx":  case ".avi":  	AVIFile avi = new AVIFile (FileName);  	exv.Init (avi);  	break;  case ".mkv":  	MkvFile mkv = new MkvFile (FileName);  	exv.Init (mkv);  	break;  case ".flv":  	FlvFile flv = new FlvFile (FileName);  	exv.Init (flv);  	break;  case ".mp4":  	Mp4File mp4 = new Mp4File (FileName);  	exv.Init (mp4);  	break;  #endregion  #region Mpeg2 endCode video  case ".mpg":  case ".mpeg":  case ".vob":  	Mpeg2 mpg = new Mpeg2 (FileName);  	exv.Init (mpg);  	break;  case ".ifo":  case ".bup":  	IFO ifo = new IFO (FileName);  	exv.Init (ifo);  	break;  #endregion  #region BD video  case ".m2ts":  /*               M2TS mts = new M2TS(FileName);                         exv.Init(mts);                         break;*/case ".ts":  	TS_File ts = new TS_File (FileName);  	exv.Init (ts);  	break;  case ".mpls":  	MPLS mp = new MPLS (FileName);  	exv.Init ((ILOCALIZED_DATA)mp);  	break;  case ".clpi":  	CLPI cp = new CLPI (FileName);  	exv.Init ((ILOCALIZED_DATA)cp);  	break;  case ".bdmv":  	if (FileName.IndexOf ("index") >= 0) {  		exv.Visible = false;  		INDEX_BDMV bd = new INDEX_BDMV (FileName);  		BDViewer bdv = new BDViewer ();  		bdv.tabSelected += new TabSelectedEventHandler (bdv_tabSelected);  		bdv.Init (bd);  		splitContainer3.Panel1.Controls.Add (bdv);  		bdv.Dock = DockStyle.Fill;  		bdv.dataSelected += new DataSelectedEventHandler (exv_dataSelected);  		TabPage tp = new TabPage (Path.GetFileName (bd.MovieObject.fileName));  		tabControl1.TabPages.Add (tp);  		BinaryView bn = new BinaryView ();  		bn.Init (bd.MovieObject.fileName);  		tp.Controls.Add (bn);  		bn.Dock = DockStyle.Fill;  		foreach (MPLS mpl in bd.MplsList) {  			tp = new TabPage (Path.GetFileName (mpl.LongName));  			tabControl1.TabPages.Add (tp);  			bn = new BinaryView ();  			bn.Init (mpl.LongName);  			tp.Controls.Add (bn);  			bn.Dock = DockStyle.Fill;  		}  	}  	else if (FileName.IndexOf ("Movie") >= 0) {  		MOBJ_BDMV mo = new MOBJ_BDMV (FileName);  		exv.Init ((ILOCALIZED_DATA)mo);  	}  	break;  #endregion  #region Text like files  case ".ps":  	PostScriptReader ps = new PostScriptReader (FileName);  	exv.Init (ps);  	break;  case ".pdf":  	PdfViewer pdf = new PdfViewer ();  	pdf.Init (FileName);  	exv.Visible = false;  	splitContainer3.Panel1.Controls.Add (pdf);  	pdf.Dock = DockStyle.Fill;  	break;  case ".log":  case ".ini":  case ".cs":  case ".txt":  case ".bat":  	exv.Visible = false;  	TextBox t = new TextBox ();  	t.Multiline = true;  	t.ScrollBars = ScrollBars.Both;  	StreamReader sr = new StreamReader (FileName);  	t.Text = sr.ReadToEnd ();  	sr.Close ();  	splitContainer3.Panel1.Controls.Add (t);  	t.Dock = DockStyle.Fill;  	break;  #endregion  #region PE files  case ".exe":  case ".dll":  	exv.Visible = false;  	Executable ex = new Executable (FileName);  	ExeViewer exeViewer = new ExeViewer ();  	exeViewer.Init (ex);  	exeViewer.dataSelected += exv_dataSelected;  	splitContainer3.Panel1.Controls.Add (exeViewer);  	exeViewer.Dock = DockStyle.Fill;  	/*                                          exv.Init(ex);                        */break;  #endregion  case ".chm":  	//chm : http://www.russotto.net/chm/chmformat.html  	break;  default:  	#region Analyse header and try to identify file type  	switch (hdr.HeaderBinarySt) {  	case "5346504B":  		//SFKP Sound Forge (Peak Data File)   		break;  	case "44564456":  		//DVD IFO (or BUP)  		ifo = new IFO (FileName);  		break;  	case "47494638":  		//Gif  		break;  	case "89504e47":  		//PNG  		break;  	case "4d534346":  		//CAB  		break;  	case "49545346":  		//ITSF chm  		break;  	case "31be0000":  		//wri ?  		break;  	case "00010000":  		//ttf' mdb  		break;  	case "00000100":  		// ico  		break;  	case "504b0304":  		Zip zi = new Zip (FileName);  		exv.Init (zi);  		break;  	case "52617221":  		break;  	case "ffd8ffe0":  		//Jpg  		break;  	case "d0cf11e0":  		//office  		break;  	case "3f5f0300":  		//help  		break;  	case "000001ba":  		mpg = new Mpeg2 (FileName);  		exv.Init (mpg);  		break;  	default:  		if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  			//gz file  			MessageBox.Show ("gz file' to do");  			byte compressionMethods = hdr.header [2];  			if (compressionMethods == 0x08) {  				//deflate  			}  			byte flags = hdr.header [3];  			if (flags != 0x00) {  			}  			Gzip gz = new Gzip (FileName);  			exv.Init (gz);  		}  		#region binary header  		switch (hdr.ShortHeaderString) {  		case "BM":  			// BMP  			BinDecoder bi = new BinDecoder (FileName);  			exv.Init (bi);  			break;  		case "MK":  			break;  		case "PK":  			//Zip' jar  			break;  		case "MZ":  			//exe' dll  			break;  		default:  			#region text header  			switch (hdr.HeaderString) {  			case "DVDV":  				//DVD IFO (or BUP)  				ifo = new IFO (FileName);  				break;  			case "ITSF":  				BinDecoder bid = new BinDecoder (FileName);  				//Microsoft Compiled HTML Help File : Info-Tech Storage Format  				break;  			case "GIF8":  				break;  			case "MSCF":  				//Microsoft cabinet file  				break;  			case "Rar!":  				break;  			case "RIFF":  				//avi  				AviAnalyze av = new AviAnalyze (FileName);  				exv.Init (av);  				break;  			case "%PDF":  				break;  			case "PNG":  				break;  			case "<?xm":  				//xml  				break;  			case "ID3":  				//mp3  				break;  			case "L\0R\0":  				//lrf  				break;  			case "":  				//office  				break;  			case "BZh9":  				//tar.gz  				break;  			case "\0 \0\0":  				break;  			default:  				break;  			}  			#endregion  			break;  		}  		#endregion  		break;  	}  	#endregion  	break;  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: switch (ext) {  #region Web  case ".htm":  case ".html":  case ".xml":  	webBrowser1.Url = new Uri (FileName);  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (webBrowser1);  	splitContainer3.Panel2Collapsed = false;  	webBrowser1.Dock = DockStyle.Fill;  	break;  #endregion  #region Microsoft Office  case ".xls":  case ".xslx":  	#region Excel  	if (Path.GetExtension (FileName).ToLower () == ".xslx") {  		Zip zx = new Zip (FileName);  		exv.Init (zx);  	}  	/*                  ExcelControl xls = new ExcelControl();                                              xls.LoadDocument(FileName);                                             xls.Dock = DockStyle.Fill;                                             tabControl1.TabPages[2].Controls.Add(xls);                                             xls.Visible = true;*/break;  #endregion  case ".doc":  case ".docx":  	#region Word  	if (Path.GetExtension (FileName).ToLower () == ".docx") {  		Zip zx = new Zip (FileName);  		exv.Init (zx);  	}  	/*                  WinWordControl winWordControl1 = new WinWordControl();                                           splitContainer3.Panel2.Controls.Clear();                                           splitContainer3.Panel2.Controls.Add(winWordControl1);                                           splitContainer3.Panel2Collapsed = false;                                           winWordControl1.Dock = DockStyle.Fill;                                           winWordControl1.Visible = true;                                           winWordControl1.LoadDocument(FileName);*/break;  #endregion  #endregion  #region ebooks  case ".prc":  	MobiFileReader mob = new MobiFileReader (FileName);  	exv.Init (mob);  	webBrowser1.Visible = true;  	webBrowser1.DocumentText = mob.text;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (webBrowser1);  	splitContainer3.Panel2Collapsed = false;  	webBrowser1.Dock = DockStyle.Fill;  	prcButton.Visible = true;  	nextPage.Visible = true;  	break;  case ".lrf":  	LRFFileReader vr = new LRFFileReader (FileName);  	exv.Init (vr);  	break;  #endregion  #region Images  case ".jpg":  	JPGFileData jpg = new JPGFileData (FileName);  	exv.Init (jpg);  	PictureBox p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".png":  	PNGFile png = new PNGFile (FileName);  	exv.Init (png);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".bmp":  	BMPFile bind = new BMPFile (FileName);  	exv.Init (bind);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".gif":  	GIFFile gif = new GIFFile (FileName);  	exv.Init (gif);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".tif":  case ".tiff":  	TiFFile tif = new TiFFile (FileName);  	exv.Init (tif);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  #endregion  #region Audio  case ".mp3":  case ".wma":  	MusicFileClass mf = new MusicFileClass (FileName);  	exv.Init (mf);  	break;  #endregion  case ".zip":  	Zip z = new Zip (FileName);  	exv.Init (z);  	break;  case ".ttf":  	// Font file  	break;  #region Video  case ".divx":  case ".avi":  	AVIFile avi = new AVIFile (FileName);  	exv.Init (avi);  	break;  case ".mkv":  	MkvFile mkv = new MkvFile (FileName);  	exv.Init (mkv);  	break;  case ".flv":  	FlvFile flv = new FlvFile (FileName);  	exv.Init (flv);  	break;  case ".mp4":  	Mp4File mp4 = new Mp4File (FileName);  	exv.Init (mp4);  	break;  #endregion  #region Mpeg2 endCode video  case ".mpg":  case ".mpeg":  case ".vob":  	Mpeg2 mpg = new Mpeg2 (FileName);  	exv.Init (mpg);  	break;  case ".ifo":  case ".bup":  	IFO ifo = new IFO (FileName);  	exv.Init (ifo);  	break;  #endregion  #region BD video  case ".m2ts":  /*               M2TS mts = new M2TS(FileName);                         exv.Init(mts);                         break;*/case ".ts":  	TS_File ts = new TS_File (FileName);  	exv.Init (ts);  	break;  case ".mpls":  	MPLS mp = new MPLS (FileName);  	exv.Init ((ILOCALIZED_DATA)mp);  	break;  case ".clpi":  	CLPI cp = new CLPI (FileName);  	exv.Init ((ILOCALIZED_DATA)cp);  	break;  case ".bdmv":  	if (FileName.IndexOf ("index") >= 0) {  		exv.Visible = false;  		INDEX_BDMV bd = new INDEX_BDMV (FileName);  		BDViewer bdv = new BDViewer ();  		bdv.tabSelected += new TabSelectedEventHandler (bdv_tabSelected);  		bdv.Init (bd);  		splitContainer3.Panel1.Controls.Add (bdv);  		bdv.Dock = DockStyle.Fill;  		bdv.dataSelected += new DataSelectedEventHandler (exv_dataSelected);  		TabPage tp = new TabPage (Path.GetFileName (bd.MovieObject.fileName));  		tabControl1.TabPages.Add (tp);  		BinaryView bn = new BinaryView ();  		bn.Init (bd.MovieObject.fileName);  		tp.Controls.Add (bn);  		bn.Dock = DockStyle.Fill;  		foreach (MPLS mpl in bd.MplsList) {  			tp = new TabPage (Path.GetFileName (mpl.LongName));  			tabControl1.TabPages.Add (tp);  			bn = new BinaryView ();  			bn.Init (mpl.LongName);  			tp.Controls.Add (bn);  			bn.Dock = DockStyle.Fill;  		}  	}  	else if (FileName.IndexOf ("Movie") >= 0) {  		MOBJ_BDMV mo = new MOBJ_BDMV (FileName);  		exv.Init ((ILOCALIZED_DATA)mo);  	}  	break;  #endregion  #region Text like files  case ".ps":  	PostScriptReader ps = new PostScriptReader (FileName);  	exv.Init (ps);  	break;  case ".pdf":  	PdfViewer pdf = new PdfViewer ();  	pdf.Init (FileName);  	exv.Visible = false;  	splitContainer3.Panel1.Controls.Add (pdf);  	pdf.Dock = DockStyle.Fill;  	break;  case ".log":  case ".ini":  case ".cs":  case ".txt":  case ".bat":  	exv.Visible = false;  	TextBox t = new TextBox ();  	t.Multiline = true;  	t.ScrollBars = ScrollBars.Both;  	StreamReader sr = new StreamReader (FileName);  	t.Text = sr.ReadToEnd ();  	sr.Close ();  	splitContainer3.Panel1.Controls.Add (t);  	t.Dock = DockStyle.Fill;  	break;  #endregion  #region PE files  case ".exe":  case ".dll":  	exv.Visible = false;  	Executable ex = new Executable (FileName);  	ExeViewer exeViewer = new ExeViewer ();  	exeViewer.Init (ex);  	exeViewer.dataSelected += exv_dataSelected;  	splitContainer3.Panel1.Controls.Add (exeViewer);  	exeViewer.Dock = DockStyle.Fill;  	/*                                          exv.Init(ex);                        */break;  #endregion  case ".chm":  	//chm : http://www.russotto.net/chm/chmformat.html  	break;  default:  	#region Analyse header and try to identify file type  	switch (hdr.HeaderBinarySt) {  	case "5346504B":  		//SFKP Sound Forge (Peak Data File)   		break;  	case "44564456":  		//DVD IFO (or BUP)  		ifo = new IFO (FileName);  		break;  	case "47494638":  		//Gif  		break;  	case "89504e47":  		//PNG  		break;  	case "4d534346":  		//CAB  		break;  	case "49545346":  		//ITSF chm  		break;  	case "31be0000":  		//wri ?  		break;  	case "00010000":  		//ttf' mdb  		break;  	case "00000100":  		// ico  		break;  	case "504b0304":  		Zip zi = new Zip (FileName);  		exv.Init (zi);  		break;  	case "52617221":  		break;  	case "ffd8ffe0":  		//Jpg  		break;  	case "d0cf11e0":  		//office  		break;  	case "3f5f0300":  		//help  		break;  	case "000001ba":  		mpg = new Mpeg2 (FileName);  		exv.Init (mpg);  		break;  	default:  		if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  			//gz file  			MessageBox.Show ("gz file' to do");  			byte compressionMethods = hdr.header [2];  			if (compressionMethods == 0x08) {  				//deflate  			}  			byte flags = hdr.header [3];  			if (flags != 0x00) {  			}  			Gzip gz = new Gzip (FileName);  			exv.Init (gz);  		}  		#region binary header  		switch (hdr.ShortHeaderString) {  		case "BM":  			// BMP  			BinDecoder bi = new BinDecoder (FileName);  			exv.Init (bi);  			break;  		case "MK":  			break;  		case "PK":  			//Zip' jar  			break;  		case "MZ":  			//exe' dll  			break;  		default:  			#region text header  			switch (hdr.HeaderString) {  			case "DVDV":  				//DVD IFO (or BUP)  				ifo = new IFO (FileName);  				break;  			case "ITSF":  				BinDecoder bid = new BinDecoder (FileName);  				//Microsoft Compiled HTML Help File : Info-Tech Storage Format  				break;  			case "GIF8":  				break;  			case "MSCF":  				//Microsoft cabinet file  				break;  			case "Rar!":  				break;  			case "RIFF":  				//avi  				AviAnalyze av = new AviAnalyze (FileName);  				exv.Init (av);  				break;  			case "%PDF":  				break;  			case "PNG":  				break;  			case "<?xm":  				//xml  				break;  			case "ID3":  				//mp3  				break;  			case "L\0R\0":  				//lrf  				break;  			case "":  				//office  				break;  			case "BZh9":  				//tar.gz  				break;  			case "\0 \0\0":  				break;  			default:  				break;  			}  			#endregion  			break;  		}  		#endregion  		break;  	}  	#endregion  	break;  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: switch (ext) {  #region Web  case ".htm":  case ".html":  case ".xml":  	webBrowser1.Url = new Uri (FileName);  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (webBrowser1);  	splitContainer3.Panel2Collapsed = false;  	webBrowser1.Dock = DockStyle.Fill;  	break;  #endregion  #region Microsoft Office  case ".xls":  case ".xslx":  	#region Excel  	if (Path.GetExtension (FileName).ToLower () == ".xslx") {  		Zip zx = new Zip (FileName);  		exv.Init (zx);  	}  	/*                  ExcelControl xls = new ExcelControl();                                              xls.LoadDocument(FileName);                                             xls.Dock = DockStyle.Fill;                                             tabControl1.TabPages[2].Controls.Add(xls);                                             xls.Visible = true;*/break;  #endregion  case ".doc":  case ".docx":  	#region Word  	if (Path.GetExtension (FileName).ToLower () == ".docx") {  		Zip zx = new Zip (FileName);  		exv.Init (zx);  	}  	/*                  WinWordControl winWordControl1 = new WinWordControl();                                           splitContainer3.Panel2.Controls.Clear();                                           splitContainer3.Panel2.Controls.Add(winWordControl1);                                           splitContainer3.Panel2Collapsed = false;                                           winWordControl1.Dock = DockStyle.Fill;                                           winWordControl1.Visible = true;                                           winWordControl1.LoadDocument(FileName);*/break;  #endregion  #endregion  #region ebooks  case ".prc":  	MobiFileReader mob = new MobiFileReader (FileName);  	exv.Init (mob);  	webBrowser1.Visible = true;  	webBrowser1.DocumentText = mob.text;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (webBrowser1);  	splitContainer3.Panel2Collapsed = false;  	webBrowser1.Dock = DockStyle.Fill;  	prcButton.Visible = true;  	nextPage.Visible = true;  	break;  case ".lrf":  	LRFFileReader vr = new LRFFileReader (FileName);  	exv.Init (vr);  	break;  #endregion  #region Images  case ".jpg":  	JPGFileData jpg = new JPGFileData (FileName);  	exv.Init (jpg);  	PictureBox p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".png":  	PNGFile png = new PNGFile (FileName);  	exv.Init (png);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".bmp":  	BMPFile bind = new BMPFile (FileName);  	exv.Init (bind);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".gif":  	GIFFile gif = new GIFFile (FileName);  	exv.Init (gif);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".tif":  case ".tiff":  	TiFFile tif = new TiFFile (FileName);  	exv.Init (tif);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  #endregion  #region Audio  case ".mp3":  case ".wma":  	MusicFileClass mf = new MusicFileClass (FileName);  	exv.Init (mf);  	break;  #endregion  case ".zip":  	Zip z = new Zip (FileName);  	exv.Init (z);  	break;  case ".ttf":  	// Font file  	break;  #region Video  case ".divx":  case ".avi":  	AVIFile avi = new AVIFile (FileName);  	exv.Init (avi);  	break;  case ".mkv":  	MkvFile mkv = new MkvFile (FileName);  	exv.Init (mkv);  	break;  case ".flv":  	FlvFile flv = new FlvFile (FileName);  	exv.Init (flv);  	break;  case ".mp4":  	Mp4File mp4 = new Mp4File (FileName);  	exv.Init (mp4);  	break;  #endregion  #region Mpeg2 endCode video  case ".mpg":  case ".mpeg":  case ".vob":  	Mpeg2 mpg = new Mpeg2 (FileName);  	exv.Init (mpg);  	break;  case ".ifo":  case ".bup":  	IFO ifo = new IFO (FileName);  	exv.Init (ifo);  	break;  #endregion  #region BD video  case ".m2ts":  /*               M2TS mts = new M2TS(FileName);                         exv.Init(mts);                         break;*/case ".ts":  	TS_File ts = new TS_File (FileName);  	exv.Init (ts);  	break;  case ".mpls":  	MPLS mp = new MPLS (FileName);  	exv.Init ((ILOCALIZED_DATA)mp);  	break;  case ".clpi":  	CLPI cp = new CLPI (FileName);  	exv.Init ((ILOCALIZED_DATA)cp);  	break;  case ".bdmv":  	if (FileName.IndexOf ("index") >= 0) {  		exv.Visible = false;  		INDEX_BDMV bd = new INDEX_BDMV (FileName);  		BDViewer bdv = new BDViewer ();  		bdv.tabSelected += new TabSelectedEventHandler (bdv_tabSelected);  		bdv.Init (bd);  		splitContainer3.Panel1.Controls.Add (bdv);  		bdv.Dock = DockStyle.Fill;  		bdv.dataSelected += new DataSelectedEventHandler (exv_dataSelected);  		TabPage tp = new TabPage (Path.GetFileName (bd.MovieObject.fileName));  		tabControl1.TabPages.Add (tp);  		BinaryView bn = new BinaryView ();  		bn.Init (bd.MovieObject.fileName);  		tp.Controls.Add (bn);  		bn.Dock = DockStyle.Fill;  		foreach (MPLS mpl in bd.MplsList) {  			tp = new TabPage (Path.GetFileName (mpl.LongName));  			tabControl1.TabPages.Add (tp);  			bn = new BinaryView ();  			bn.Init (mpl.LongName);  			tp.Controls.Add (bn);  			bn.Dock = DockStyle.Fill;  		}  	}  	else if (FileName.IndexOf ("Movie") >= 0) {  		MOBJ_BDMV mo = new MOBJ_BDMV (FileName);  		exv.Init ((ILOCALIZED_DATA)mo);  	}  	break;  #endregion  #region Text like files  case ".ps":  	PostScriptReader ps = new PostScriptReader (FileName);  	exv.Init (ps);  	break;  case ".pdf":  	PdfViewer pdf = new PdfViewer ();  	pdf.Init (FileName);  	exv.Visible = false;  	splitContainer3.Panel1.Controls.Add (pdf);  	pdf.Dock = DockStyle.Fill;  	break;  case ".log":  case ".ini":  case ".cs":  case ".txt":  case ".bat":  	exv.Visible = false;  	TextBox t = new TextBox ();  	t.Multiline = true;  	t.ScrollBars = ScrollBars.Both;  	StreamReader sr = new StreamReader (FileName);  	t.Text = sr.ReadToEnd ();  	sr.Close ();  	splitContainer3.Panel1.Controls.Add (t);  	t.Dock = DockStyle.Fill;  	break;  #endregion  #region PE files  case ".exe":  case ".dll":  	exv.Visible = false;  	Executable ex = new Executable (FileName);  	ExeViewer exeViewer = new ExeViewer ();  	exeViewer.Init (ex);  	exeViewer.dataSelected += exv_dataSelected;  	splitContainer3.Panel1.Controls.Add (exeViewer);  	exeViewer.Dock = DockStyle.Fill;  	/*                                          exv.Init(ex);                        */break;  #endregion  case ".chm":  	//chm : http://www.russotto.net/chm/chmformat.html  	break;  default:  	#region Analyse header and try to identify file type  	switch (hdr.HeaderBinarySt) {  	case "5346504B":  		//SFKP Sound Forge (Peak Data File)   		break;  	case "44564456":  		//DVD IFO (or BUP)  		ifo = new IFO (FileName);  		break;  	case "47494638":  		//Gif  		break;  	case "89504e47":  		//PNG  		break;  	case "4d534346":  		//CAB  		break;  	case "49545346":  		//ITSF chm  		break;  	case "31be0000":  		//wri ?  		break;  	case "00010000":  		//ttf' mdb  		break;  	case "00000100":  		// ico  		break;  	case "504b0304":  		Zip zi = new Zip (FileName);  		exv.Init (zi);  		break;  	case "52617221":  		break;  	case "ffd8ffe0":  		//Jpg  		break;  	case "d0cf11e0":  		//office  		break;  	case "3f5f0300":  		//help  		break;  	case "000001ba":  		mpg = new Mpeg2 (FileName);  		exv.Init (mpg);  		break;  	default:  		if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  			//gz file  			MessageBox.Show ("gz file' to do");  			byte compressionMethods = hdr.header [2];  			if (compressionMethods == 0x08) {  				//deflate  			}  			byte flags = hdr.header [3];  			if (flags != 0x00) {  			}  			Gzip gz = new Gzip (FileName);  			exv.Init (gz);  		}  		#region binary header  		switch (hdr.ShortHeaderString) {  		case "BM":  			// BMP  			BinDecoder bi = new BinDecoder (FileName);  			exv.Init (bi);  			break;  		case "MK":  			break;  		case "PK":  			//Zip' jar  			break;  		case "MZ":  			//exe' dll  			break;  		default:  			#region text header  			switch (hdr.HeaderString) {  			case "DVDV":  				//DVD IFO (or BUP)  				ifo = new IFO (FileName);  				break;  			case "ITSF":  				BinDecoder bid = new BinDecoder (FileName);  				//Microsoft Compiled HTML Help File : Info-Tech Storage Format  				break;  			case "GIF8":  				break;  			case "MSCF":  				//Microsoft cabinet file  				break;  			case "Rar!":  				break;  			case "RIFF":  				//avi  				AviAnalyze av = new AviAnalyze (FileName);  				exv.Init (av);  				break;  			case "%PDF":  				break;  			case "PNG":  				break;  			case "<?xm":  				//xml  				break;  			case "ID3":  				//mp3  				break;  			case "L\0R\0":  				//lrf  				break;  			case "":  				//office  				break;  			case "BZh9":  				//tar.gz  				break;  			case "\0 \0\0":  				break;  			default:  				break;  			}  			#endregion  			break;  		}  		#endregion  		break;  	}  	#endregion  	break;  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: switch (ext) {  #region Web  case ".htm":  case ".html":  case ".xml":  	webBrowser1.Url = new Uri (FileName);  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (webBrowser1);  	splitContainer3.Panel2Collapsed = false;  	webBrowser1.Dock = DockStyle.Fill;  	break;  #endregion  #region Microsoft Office  case ".xls":  case ".xslx":  	#region Excel  	if (Path.GetExtension (FileName).ToLower () == ".xslx") {  		Zip zx = new Zip (FileName);  		exv.Init (zx);  	}  	/*                  ExcelControl xls = new ExcelControl();                                              xls.LoadDocument(FileName);                                             xls.Dock = DockStyle.Fill;                                             tabControl1.TabPages[2].Controls.Add(xls);                                             xls.Visible = true;*/break;  #endregion  case ".doc":  case ".docx":  	#region Word  	if (Path.GetExtension (FileName).ToLower () == ".docx") {  		Zip zx = new Zip (FileName);  		exv.Init (zx);  	}  	/*                  WinWordControl winWordControl1 = new WinWordControl();                                           splitContainer3.Panel2.Controls.Clear();                                           splitContainer3.Panel2.Controls.Add(winWordControl1);                                           splitContainer3.Panel2Collapsed = false;                                           winWordControl1.Dock = DockStyle.Fill;                                           winWordControl1.Visible = true;                                           winWordControl1.LoadDocument(FileName);*/break;  #endregion  #endregion  #region ebooks  case ".prc":  	MobiFileReader mob = new MobiFileReader (FileName);  	exv.Init (mob);  	webBrowser1.Visible = true;  	webBrowser1.DocumentText = mob.text;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (webBrowser1);  	splitContainer3.Panel2Collapsed = false;  	webBrowser1.Dock = DockStyle.Fill;  	prcButton.Visible = true;  	nextPage.Visible = true;  	break;  case ".lrf":  	LRFFileReader vr = new LRFFileReader (FileName);  	exv.Init (vr);  	break;  #endregion  #region Images  case ".jpg":  	JPGFileData jpg = new JPGFileData (FileName);  	exv.Init (jpg);  	PictureBox p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".png":  	PNGFile png = new PNGFile (FileName);  	exv.Init (png);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".bmp":  	BMPFile bind = new BMPFile (FileName);  	exv.Init (bind);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".gif":  	GIFFile gif = new GIFFile (FileName);  	exv.Init (gif);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  case ".tif":  case ".tiff":  	TiFFile tif = new TiFFile (FileName);  	exv.Init (tif);  	p = new PictureBox ();  	p.SizeMode = PictureBoxSizeMode.StretchImage;  	p.Width = 400;  	// splitContainer1.Panel2.Width;  	p.Image = Image.FromFile (FileName);  	p.Height = p.Width * p.Image.Height / p.Image.Width;  	splitContainer3.Panel2.Controls.Clear ();  	splitContainer3.Panel2.Controls.Add (p);  	splitContainer3.Panel2Collapsed = false;  	break;  #endregion  #region Audio  case ".mp3":  case ".wma":  	MusicFileClass mf = new MusicFileClass (FileName);  	exv.Init (mf);  	break;  #endregion  case ".zip":  	Zip z = new Zip (FileName);  	exv.Init (z);  	break;  case ".ttf":  	// Font file  	break;  #region Video  case ".divx":  case ".avi":  	AVIFile avi = new AVIFile (FileName);  	exv.Init (avi);  	break;  case ".mkv":  	MkvFile mkv = new MkvFile (FileName);  	exv.Init (mkv);  	break;  case ".flv":  	FlvFile flv = new FlvFile (FileName);  	exv.Init (flv);  	break;  case ".mp4":  	Mp4File mp4 = new Mp4File (FileName);  	exv.Init (mp4);  	break;  #endregion  #region Mpeg2 endCode video  case ".mpg":  case ".mpeg":  case ".vob":  	Mpeg2 mpg = new Mpeg2 (FileName);  	exv.Init (mpg);  	break;  case ".ifo":  case ".bup":  	IFO ifo = new IFO (FileName);  	exv.Init (ifo);  	break;  #endregion  #region BD video  case ".m2ts":  /*               M2TS mts = new M2TS(FileName);                         exv.Init(mts);                         break;*/case ".ts":  	TS_File ts = new TS_File (FileName);  	exv.Init (ts);  	break;  case ".mpls":  	MPLS mp = new MPLS (FileName);  	exv.Init ((ILOCALIZED_DATA)mp);  	break;  case ".clpi":  	CLPI cp = new CLPI (FileName);  	exv.Init ((ILOCALIZED_DATA)cp);  	break;  case ".bdmv":  	if (FileName.IndexOf ("index") >= 0) {  		exv.Visible = false;  		INDEX_BDMV bd = new INDEX_BDMV (FileName);  		BDViewer bdv = new BDViewer ();  		bdv.tabSelected += new TabSelectedEventHandler (bdv_tabSelected);  		bdv.Init (bd);  		splitContainer3.Panel1.Controls.Add (bdv);  		bdv.Dock = DockStyle.Fill;  		bdv.dataSelected += new DataSelectedEventHandler (exv_dataSelected);  		TabPage tp = new TabPage (Path.GetFileName (bd.MovieObject.fileName));  		tabControl1.TabPages.Add (tp);  		BinaryView bn = new BinaryView ();  		bn.Init (bd.MovieObject.fileName);  		tp.Controls.Add (bn);  		bn.Dock = DockStyle.Fill;  		foreach (MPLS mpl in bd.MplsList) {  			tp = new TabPage (Path.GetFileName (mpl.LongName));  			tabControl1.TabPages.Add (tp);  			bn = new BinaryView ();  			bn.Init (mpl.LongName);  			tp.Controls.Add (bn);  			bn.Dock = DockStyle.Fill;  		}  	}  	else if (FileName.IndexOf ("Movie") >= 0) {  		MOBJ_BDMV mo = new MOBJ_BDMV (FileName);  		exv.Init ((ILOCALIZED_DATA)mo);  	}  	break;  #endregion  #region Text like files  case ".ps":  	PostScriptReader ps = new PostScriptReader (FileName);  	exv.Init (ps);  	break;  case ".pdf":  	PdfViewer pdf = new PdfViewer ();  	pdf.Init (FileName);  	exv.Visible = false;  	splitContainer3.Panel1.Controls.Add (pdf);  	pdf.Dock = DockStyle.Fill;  	break;  case ".log":  case ".ini":  case ".cs":  case ".txt":  case ".bat":  	exv.Visible = false;  	TextBox t = new TextBox ();  	t.Multiline = true;  	t.ScrollBars = ScrollBars.Both;  	StreamReader sr = new StreamReader (FileName);  	t.Text = sr.ReadToEnd ();  	sr.Close ();  	splitContainer3.Panel1.Controls.Add (t);  	t.Dock = DockStyle.Fill;  	break;  #endregion  #region PE files  case ".exe":  case ".dll":  	exv.Visible = false;  	Executable ex = new Executable (FileName);  	ExeViewer exeViewer = new ExeViewer ();  	exeViewer.Init (ex);  	exeViewer.dataSelected += exv_dataSelected;  	splitContainer3.Panel1.Controls.Add (exeViewer);  	exeViewer.Dock = DockStyle.Fill;  	/*                                          exv.Init(ex);                        */break;  #endregion  case ".chm":  	//chm : http://www.russotto.net/chm/chmformat.html  	break;  default:  	#region Analyse header and try to identify file type  	switch (hdr.HeaderBinarySt) {  	case "5346504B":  		//SFKP Sound Forge (Peak Data File)   		break;  	case "44564456":  		//DVD IFO (or BUP)  		ifo = new IFO (FileName);  		break;  	case "47494638":  		//Gif  		break;  	case "89504e47":  		//PNG  		break;  	case "4d534346":  		//CAB  		break;  	case "49545346":  		//ITSF chm  		break;  	case "31be0000":  		//wri ?  		break;  	case "00010000":  		//ttf' mdb  		break;  	case "00000100":  		// ico  		break;  	case "504b0304":  		Zip zi = new Zip (FileName);  		exv.Init (zi);  		break;  	case "52617221":  		break;  	case "ffd8ffe0":  		//Jpg  		break;  	case "d0cf11e0":  		//office  		break;  	case "3f5f0300":  		//help  		break;  	case "000001ba":  		mpg = new Mpeg2 (FileName);  		exv.Init (mpg);  		break;  	default:  		if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  			//gz file  			MessageBox.Show ("gz file' to do");  			byte compressionMethods = hdr.header [2];  			if (compressionMethods == 0x08) {  				//deflate  			}  			byte flags = hdr.header [3];  			if (flags != 0x00) {  			}  			Gzip gz = new Gzip (FileName);  			exv.Init (gz);  		}  		#region binary header  		switch (hdr.ShortHeaderString) {  		case "BM":  			// BMP  			BinDecoder bi = new BinDecoder (FileName);  			exv.Init (bi);  			break;  		case "MK":  			break;  		case "PK":  			//Zip' jar  			break;  		case "MZ":  			//exe' dll  			break;  		default:  			#region text header  			switch (hdr.HeaderString) {  			case "DVDV":  				//DVD IFO (or BUP)  				ifo = new IFO (FileName);  				break;  			case "ITSF":  				BinDecoder bid = new BinDecoder (FileName);  				//Microsoft Compiled HTML Help File : Info-Tech Storage Format  				break;  			case "GIF8":  				break;  			case "MSCF":  				//Microsoft cabinet file  				break;  			case "Rar!":  				break;  			case "RIFF":  				//avi  				AviAnalyze av = new AviAnalyze (FileName);  				exv.Init (av);  				break;  			case "%PDF":  				break;  			case "PNG":  				break;  			case "<?xm":  				//xml  				break;  			case "ID3":  				//mp3  				break;  			case "L\0R\0":  				//lrf  				break;  			case "":  				//office  				break;  			case "BZh9":  				//tar.gz  				break;  			case "\0 \0\0":  				break;  			default:  				break;  			}  			#endregion  			break;  		}  		#endregion  		break;  	}  	#endregion  	break;  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: p.Width = 400;  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: p.Width = 400;  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: p.Width = 400;  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: p.Width = 400;  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: p.Width = 400;  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: switch (hdr.HeaderBinarySt) {  case "5346504B":  	//SFKP Sound Forge (Peak Data File)   	break;  case "44564456":  	//DVD IFO (or BUP)  	ifo = new IFO (FileName);  	break;  case "47494638":  	//Gif  	break;  case "89504e47":  	//PNG  	break;  case "4d534346":  	//CAB  	break;  case "49545346":  	//ITSF chm  	break;  case "31be0000":  	//wri ?  	break;  case "00010000":  	//ttf' mdb  	break;  case "00000100":  	// ico  	break;  case "504b0304":  	Zip zi = new Zip (FileName);  	exv.Init (zi);  	break;  case "52617221":  	break;  case "ffd8ffe0":  	//Jpg  	break;  case "d0cf11e0":  	//office  	break;  case "3f5f0300":  	//help  	break;  case "000001ba":  	mpg = new Mpeg2 (FileName);  	exv.Init (mpg);  	break;  default:  	if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  		//gz file  		MessageBox.Show ("gz file' to do");  		byte compressionMethods = hdr.header [2];  		if (compressionMethods == 0x08) {  			//deflate  		}  		byte flags = hdr.header [3];  		if (flags != 0x00) {  		}  		Gzip gz = new Gzip (FileName);  		exv.Init (gz);  	}  	#region binary header  	switch (hdr.ShortHeaderString) {  	case "BM":  		// BMP  		BinDecoder bi = new BinDecoder (FileName);  		exv.Init (bi);  		break;  	case "MK":  		break;  	case "PK":  		//Zip' jar  		break;  	case "MZ":  		//exe' dll  		break;  	default:  		#region text header  		switch (hdr.HeaderString) {  		case "DVDV":  			//DVD IFO (or BUP)  			ifo = new IFO (FileName);  			break;  		case "ITSF":  			BinDecoder bid = new BinDecoder (FileName);  			//Microsoft Compiled HTML Help File : Info-Tech Storage Format  			break;  		case "GIF8":  			break;  		case "MSCF":  			//Microsoft cabinet file  			break;  		case "Rar!":  			break;  		case "RIFF":  			//avi  			AviAnalyze av = new AviAnalyze (FileName);  			exv.Init (av);  			break;  		case "%PDF":  			break;  		case "PNG":  			break;  		case "<?xm":  			//xml  			break;  		case "ID3":  			//mp3  			break;  		case "L\0R\0":  			//lrf  			break;  		case "":  			//office  			break;  		case "BZh9":  			//tar.gz  			break;  		case "\0 \0\0":  			break;  		default:  			break;  		}  		#endregion  		break;  	}  	#endregion  	break;  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: switch (hdr.HeaderBinarySt) {  case "5346504B":  	//SFKP Sound Forge (Peak Data File)   	break;  case "44564456":  	//DVD IFO (or BUP)  	ifo = new IFO (FileName);  	break;  case "47494638":  	//Gif  	break;  case "89504e47":  	//PNG  	break;  case "4d534346":  	//CAB  	break;  case "49545346":  	//ITSF chm  	break;  case "31be0000":  	//wri ?  	break;  case "00010000":  	//ttf' mdb  	break;  case "00000100":  	// ico  	break;  case "504b0304":  	Zip zi = new Zip (FileName);  	exv.Init (zi);  	break;  case "52617221":  	break;  case "ffd8ffe0":  	//Jpg  	break;  case "d0cf11e0":  	//office  	break;  case "3f5f0300":  	//help  	break;  case "000001ba":  	mpg = new Mpeg2 (FileName);  	exv.Init (mpg);  	break;  default:  	if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  		//gz file  		MessageBox.Show ("gz file' to do");  		byte compressionMethods = hdr.header [2];  		if (compressionMethods == 0x08) {  			//deflate  		}  		byte flags = hdr.header [3];  		if (flags != 0x00) {  		}  		Gzip gz = new Gzip (FileName);  		exv.Init (gz);  	}  	#region binary header  	switch (hdr.ShortHeaderString) {  	case "BM":  		// BMP  		BinDecoder bi = new BinDecoder (FileName);  		exv.Init (bi);  		break;  	case "MK":  		break;  	case "PK":  		//Zip' jar  		break;  	case "MZ":  		//exe' dll  		break;  	default:  		#region text header  		switch (hdr.HeaderString) {  		case "DVDV":  			//DVD IFO (or BUP)  			ifo = new IFO (FileName);  			break;  		case "ITSF":  			BinDecoder bid = new BinDecoder (FileName);  			//Microsoft Compiled HTML Help File : Info-Tech Storage Format  			break;  		case "GIF8":  			break;  		case "MSCF":  			//Microsoft cabinet file  			break;  		case "Rar!":  			break;  		case "RIFF":  			//avi  			AviAnalyze av = new AviAnalyze (FileName);  			exv.Init (av);  			break;  		case "%PDF":  			break;  		case "PNG":  			break;  		case "<?xm":  			//xml  			break;  		case "ID3":  			//mp3  			break;  		case "L\0R\0":  			//lrf  			break;  		case "":  			//office  			break;  		case "BZh9":  			//tar.gz  			break;  		case "\0 \0\0":  			break;  		default:  			break;  		}  		#endregion  		break;  	}  	#endregion  	break;  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  	//gz file  	MessageBox.Show ("gz file' to do");  	byte compressionMethods = hdr.header [2];  	if (compressionMethods == 0x08) {  		//deflate  	}  	byte flags = hdr.header [3];  	if (flags != 0x00) {  	}  	Gzip gz = new Gzip (FileName);  	exv.Init (gz);  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,Analyse,The following statement contains a magic number: if (hdr.HeaderBinarySt.StartsWith ("1f8b")) {  	//gz file  	MessageBox.Show ("gz file' to do");  	byte compressionMethods = hdr.header [2];  	if (compressionMethods == 0x08) {  		//deflate  	}  	byte flags = hdr.header [3];  	if (flags != 0x00) {  	}  	Gzip gz = new Gzip (FileName);  	exv.Init (gz);  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,prcButton_Click,The following statement contains a magic number: if (Path.GetExtension (FileName) == ".lrf") {  	LRFView view = new LRFView (FileName);  	tabControl1.TabPages [2].Controls.Add (view);  	view.Dock = DockStyle.Fill;  }  
Magic Number,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,prcButton_Click,The following statement contains a magic number: tabControl1.TabPages [2].Controls.Add (view);  
Magic Number,BinHed,FileHeader,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,FileHeader,The following statement contains a magic number: for (int u = 0; u < 4; u++)  	HeaderBinarySt += header [u].ToString ("x2");  
Magic Number,BinHed,FileHeader,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,FileHeader,The following statement contains a magic number: Buffer.BlockCopy (header' 0' c' 0' 2);  
Magic Number,BinHed,FileViewer,C:\repos\mbatest_Binhed\BinHed\FileViewer.cs,Init,The following statement contains a magic number: iml.ImageSize = new System.Drawing.Size (20' 20);  
Magic Number,BinHed,FileViewer,C:\repos\mbatest_Binhed\BinHed\FileViewer.cs,Init,The following statement contains a magic number: iml.ImageSize = new System.Drawing.Size (20' 20);  
Magic Number,BinHed,FileViewer,C:\repos\mbatest_Binhed\BinHed\FileViewer.cs,treeView1_AfterSelect,The following statement contains a magic number: if (tn.Tag != null) {  	Type t = tn.Tag.GetType ();  	if ((tn.Text.Contains ("Data Start Sector")) || (tn.Text.Contains ("DataStartSector")))  		if (dataSelected != null)  			dataSelected (this' new DataSelectedEventArgs ((long)tn.Tag * 0x200' 0x200' null));  	if (tn.Text.Contains ("StartCluster"))  		if (dataSelected != null)  			dataSelected (this' new DataSelectedEventArgs ((long)tn.Tag * 0x200 * 8' 0x200' null));  	try {  		Type[] ts = tn.Tag.GetType ().GetInterfaces ();  		if (ts.Length > 0) {  			if (ts [0].Name == "ILOCALIZED_DATA") {  				ILOCALIZED_DATA im = (ILOCALIZED_DATA)tn.Tag;  				FillTreeNode (tn' im);  				if (dataSelected != null)  					dataSelected (this' new DataSelectedEventArgs (im.PositionOfStructureInFile' im.LengthInFile));  				if (dataRequested != null)  					dataRequested (this' new DataRequestArgs (tn' tn.Tag));  			}  		}  		else {  			if (tn.Nodes.Count == 0) {  				System.Reflection.PropertyInfo[] properties = t.GetProperties ();  				foreach (System.Reflection.PropertyInfo pr in properties) {  					var x = t.GetProperty (pr.Name).GetValue (tn.Tag' null).ToString ();  					TreeNode tn1 = new TreeNode (pr.Name + " " + x.ToString ());  					tn1.Tag = x;  					tn.Nodes.Add (tn1);  				}  			}  		}  	}  	catch {  	}  	if (autoExpand)  		tn.Expand ();  }  
Magic Number,BinHed,FileViewer,C:\repos\mbatest_Binhed\BinHed\FileViewer.cs,treeView1_AfterSelect,The following statement contains a magic number: if (tn.Text.Contains ("StartCluster"))  	if (dataSelected != null)  		dataSelected (this' new DataSelectedEventArgs ((long)tn.Tag * 0x200 * 8' 0x200' null));  
Magic Number,BinHed,FileViewer,C:\repos\mbatest_Binhed\BinHed\FileViewer.cs,treeView1_AfterSelect,The following statement contains a magic number: if (dataSelected != null)  	dataSelected (this' new DataSelectedEventArgs ((long)tn.Tag * 0x200 * 8' 0x200' null));  
Magic Number,BinHed,FileViewer,C:\repos\mbatest_Binhed\BinHed\FileViewer.cs,treeView1_AfterSelect,The following statement contains a magic number: dataSelected (this' new DataSelectedEventArgs ((long)tn.Tag * 0x200 * 8' 0x200' null));  
Magic Number,BinHed,Helpers,C:\repos\mbatest_Binhed\BinHed\Helpers.cs,IsUserInAdminGroup,The following statement contains a magic number: try {  	// Open the access token of the current process for query and duplicate.  	if (!NativeMethods.OpenProcessToken (Process.GetCurrentProcess ().Handle' NativeMethods.TOKEN_QUERY | NativeMethods.TOKEN_DUPLICATE' out hToken)) {  		throw new Win32Exception ();  	}  	// Determine whether system is running Windows Vista or later operating   	// systems (major version >= 6) because they support linked tokens' but   	// previous versions (major version < 6) do not.  	if (Environment.OSVersion.Version.Major >= 6) {  		// Running Windows Vista or later (major version >= 6).   		// Determine token type: limited' elevated' or default.   		// Allocate a buffer for the elevation type information.  		cbSize = sizeof(TOKEN_ELEVATION_TYPE);  		pElevationType = Marshal.AllocHGlobal (cbSize);  		if (pElevationType == IntPtr.Zero) {  			throw new Win32Exception ();  		}  		// Retrieve token elevation type information.  		if (!NativeMethods.GetTokenInformation (hToken' TOKEN_INFORMATION_CLASS.TokenElevationType' pElevationType' cbSize' out cbSize)) {  			throw new Win32Exception ();  		}  		// Marshal the TOKEN_ELEVATION_TYPE enum from native to .NET.  		TOKEN_ELEVATION_TYPE elevType = (TOKEN_ELEVATION_TYPE)Marshal.ReadInt32 (pElevationType);  		// If limited' get the linked elevated token for further check.  		if (elevType == TOKEN_ELEVATION_TYPE.TokenElevationTypeLimited) {  			// Allocate a buffer for the linked token.  			cbSize = IntPtr.Size;  			pLinkedToken = Marshal.AllocHGlobal (cbSize);  			if (pLinkedToken == IntPtr.Zero) {  				throw new Win32Exception ();  			}  			// Get the linked token.  			if (!NativeMethods.GetTokenInformation (hToken' TOKEN_INFORMATION_CLASS.TokenLinkedToken' pLinkedToken' cbSize' out cbSize)) {  				throw new Win32Exception ();  			}  			// Marshal the linked token value from native to .NET.  			IntPtr hLinkedToken = Marshal.ReadIntPtr (pLinkedToken);  			hTokenToCheck = new SafeTokenHandle (hLinkedToken);  		}  	}  	// CheckTokenMembership requires an impersonation token. If we just got   	// a linked token' it already is an impersonation token.  If we did not   	// get a linked token' duplicate the original into an impersonation   	// token for CheckTokenMembership.  	if (hTokenToCheck == null) {  		if (!NativeMethods.DuplicateToken (hToken' SECURITY_IMPERSONATION_LEVEL.SecurityIdentification' out hTokenToCheck)) {  			throw new Win32Exception ();  		}  	}  	// Check if the token to be checked contains admin SID.  	WindowsIdentity id = new WindowsIdentity (hTokenToCheck.DangerousGetHandle ());  	WindowsPrincipal principal = new WindowsPrincipal (id);  	fInAdminGroup = principal.IsInRole (WindowsBuiltInRole.Administrator);  }  finally {  	// Centralized cleanup for all allocated resources.   	if (hToken != null) {  		hToken.Close ();  		hToken = null;  	}  	if (hTokenToCheck != null) {  		hTokenToCheck.Close ();  		hTokenToCheck = null;  	}  	if (pElevationType != IntPtr.Zero) {  		Marshal.FreeHGlobal (pElevationType);  		pElevationType = IntPtr.Zero;  	}  	if (pLinkedToken != IntPtr.Zero) {  		Marshal.FreeHGlobal (pLinkedToken);  		pLinkedToken = IntPtr.Zero;  	}  }  
Magic Number,BinHed,Helpers,C:\repos\mbatest_Binhed\BinHed\Helpers.cs,IsUserInAdminGroup,The following statement contains a magic number: if (Environment.OSVersion.Version.Major >= 6) {  	// Running Windows Vista or later (major version >= 6).   	// Determine token type: limited' elevated' or default.   	// Allocate a buffer for the elevation type information.  	cbSize = sizeof(TOKEN_ELEVATION_TYPE);  	pElevationType = Marshal.AllocHGlobal (cbSize);  	if (pElevationType == IntPtr.Zero) {  		throw new Win32Exception ();  	}  	// Retrieve token elevation type information.  	if (!NativeMethods.GetTokenInformation (hToken' TOKEN_INFORMATION_CLASS.TokenElevationType' pElevationType' cbSize' out cbSize)) {  		throw new Win32Exception ();  	}  	// Marshal the TOKEN_ELEVATION_TYPE enum from native to .NET.  	TOKEN_ELEVATION_TYPE elevType = (TOKEN_ELEVATION_TYPE)Marshal.ReadInt32 (pElevationType);  	// If limited' get the linked elevated token for further check.  	if (elevType == TOKEN_ELEVATION_TYPE.TokenElevationTypeLimited) {  		// Allocate a buffer for the linked token.  		cbSize = IntPtr.Size;  		pLinkedToken = Marshal.AllocHGlobal (cbSize);  		if (pLinkedToken == IntPtr.Zero) {  			throw new Win32Exception ();  		}  		// Get the linked token.  		if (!NativeMethods.GetTokenInformation (hToken' TOKEN_INFORMATION_CLASS.TokenLinkedToken' pLinkedToken' cbSize' out cbSize)) {  			throw new Win32Exception ();  		}  		// Marshal the linked token value from native to .NET.  		IntPtr hLinkedToken = Marshal.ReadIntPtr (pLinkedToken);  		hTokenToCheck = new SafeTokenHandle (hLinkedToken);  	}  }  
Magic Number,BinHed,Editor,C:\repos\mbatest_Binhed\BinHed\MainForm.cs,Editor,The following statement contains a magic number: foreach (string s in keyNames) {  	if ((s.StartsWith (".")) && (s.Length < 7)) {  		RegistryKey rkFileType = rkRoot.OpenSubKey (s);  		object defaultValue = rkFileType.GetValue ("");  		extensions.Add (s + ":" + (string)defaultValue);  	}  }  
Magic Number,BinHed,Editor,C:\repos\mbatest_Binhed\BinHed\MainForm.cs,Editor,The following statement contains a magic number: if ((s.StartsWith (".")) && (s.Length < 7)) {  	RegistryKey rkFileType = rkRoot.OpenSubKey (s);  	object defaultValue = rkFileType.GetValue ("");  	extensions.Add (s + ":" + (string)defaultValue);  }  
Magic Number,BinHed,TabControlEx,C:\repos\mbatest_Binhed\BinHed\TabControlEx.cs,OnDrawItem,The following statement contains a magic number: r.Offset (2' 2);  
Magic Number,BinHed,TabControlEx,C:\repos\mbatest_Binhed\BinHed\TabControlEx.cs,OnDrawItem,The following statement contains a magic number: r.Offset (2' 2);  
Magic Number,BinHed,TabControlEx,C:\repos\mbatest_Binhed\BinHed\TabControlEx.cs,OnDrawItem,The following statement contains a magic number: r.Width = 5;  
Magic Number,BinHed,TabControlEx,C:\repos\mbatest_Binhed\BinHed\TabControlEx.cs,OnDrawItem,The following statement contains a magic number: r.Height = 5;  
Magic Number,BinHed,TabControlEx,C:\repos\mbatest_Binhed\BinHed\TabControlEx.cs,OnDrawItem,The following statement contains a magic number: e.Graphics.DrawString (Title' f' b' new PointF (r.X + 5' r.Y));  
Magic Number,BinHed,TabControlEx,C:\repos\mbatest_Binhed\BinHed\TabControlEx.cs,OnMouseClick,The following statement contains a magic number: for (int i = 0; i < TabCount; i++) {  	Rectangle r = GetTabRect (i);  	r.Offset (2' 2);  	r.Width = 5;  	r.Height = 5;  	if (r.Contains (p)) {  		CloseTab (i);  	}  }  
Magic Number,BinHed,TabControlEx,C:\repos\mbatest_Binhed\BinHed\TabControlEx.cs,OnMouseClick,The following statement contains a magic number: for (int i = 0; i < TabCount; i++) {  	Rectangle r = GetTabRect (i);  	r.Offset (2' 2);  	r.Width = 5;  	r.Height = 5;  	if (r.Contains (p)) {  		CloseTab (i);  	}  }  
Magic Number,BinHed,TabControlEx,C:\repos\mbatest_Binhed\BinHed\TabControlEx.cs,OnMouseClick,The following statement contains a magic number: for (int i = 0; i < TabCount; i++) {  	Rectangle r = GetTabRect (i);  	r.Offset (2' 2);  	r.Width = 5;  	r.Height = 5;  	if (r.Contains (p)) {  		CloseTab (i);  	}  }  
Magic Number,BinHed,TabControlEx,C:\repos\mbatest_Binhed\BinHed\TabControlEx.cs,OnMouseClick,The following statement contains a magic number: for (int i = 0; i < TabCount; i++) {  	Rectangle r = GetTabRect (i);  	r.Offset (2' 2);  	r.Width = 5;  	r.Height = 5;  	if (r.Contains (p)) {  		CloseTab (i);  	}  }  
Magic Number,BinHed,TabControlEx,C:\repos\mbatest_Binhed\BinHed\TabControlEx.cs,OnMouseClick,The following statement contains a magic number: r.Offset (2' 2);  
Magic Number,BinHed,TabControlEx,C:\repos\mbatest_Binhed\BinHed\TabControlEx.cs,OnMouseClick,The following statement contains a magic number: r.Offset (2' 2);  
Magic Number,BinHed,TabControlEx,C:\repos\mbatest_Binhed\BinHed\TabControlEx.cs,OnMouseClick,The following statement contains a magic number: r.Width = 5;  
Magic Number,BinHed,TabControlEx,C:\repos\mbatest_Binhed\BinHed\TabControlEx.cs,OnMouseClick,The following statement contains a magic number: r.Height = 5;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,AviHeaders,The following statement contains a magic number: if (fileStruc [0].fccType == "iavs") {  	while (ch != vidstr) {  		aviFile.Read (ckid' 0' len);  		ch = ByteTos (ckid);  		Interpret (0);  	}  }  else {  	//On recherche le premier frame qui commence  	//par object_length'indicateur vidstr  	do {  		aviFile.Read (ckid' 0' len);  		ch = ByteTos (ckid);  		Interpret (0);  	}  	while ((ch != vidstr) && (aviFile.Position < aviFile.Length / 10));  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,AviHeaders,The following statement contains a magic number: do {  	aviFile.Read (ckid' 0' len);  	ch = ByteTos (ckid);  	Interpret (0);  }  while ((ch != vidstr) && (aviFile.Position < aviFile.Length / 10));  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (ch) {  case "ix00":  	entriesInUse = UpdateIndex ();  	break;  case "ix01":  	UpdateIndexAud ();  	break;  case "01wb":  	aviFile.Read (ckid' 0' len);  	long u = ByteToi (ckid);  	aviFile.Seek (u' SeekOrigin.Current);  	break;  case "JUNK":  	aviFile.Read (ckid' 0' len);  	long lh = ByteToi (ckid);  	analyseList.Add (aviFile.Position.ToString ("x8") + ch + " " + lh.ToString ());  	aviFile.Seek ((int)lh' SeekOrigin.Current);  	break;  case "LIST":  	analyseList.Add (aviFile.Position.ToString ("x8") + " List : " + ch);  	AddLong ("Size");  	break;  case "vprp":  	break;  case "dmlh":  	analyseList.Add (aviFile.Position.ToString ("x8") + ch);  	break;  case "strl":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Flux n " + streamNumber.ToString () + " " + ch);  	break;  case "strh":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Header : " + ch);  	stSize = AddLong ("Size");  	fileStruc [streamNumber].fccType = AddString ("Type de flux");  	stSize -= 4;  	fileStruc [streamNumber].fccHandler = AddString ("Gestionnaire");  	stSize -= 4;  	if (fileStruc [streamNumber].fccHandler == "RLE ")  		vidstr = "00db";  	fileStruc [streamNumber].dwFlags = AddLong ("Flags");  	stSize -= 4;  	fileStruc [streamNumber].wPriority = AddShort ("Priority");  	stSize -= 2;  	fileStruc [streamNumber].wLanguage = AddShort ("Language");  	stSize -= 2;  	fileStruc [streamNumber].dwInitialFrames = AddLong ("Initial Frame");  	stSize -= 4;  	fileStruc [streamNumber].dwScale = AddLong ("Scale");  	stSize -= 4;  	fileStruc [streamNumber].dwRate = AddLong ("Rate");  	stSize -= 4;  	fileStruc [streamNumber].dwStart = AddLong ("Start");  	stSize -= 4;  	fileStruc [streamNumber].dwLength = AddLong ("Length");  	stSize -= 4;  	fileStruc [streamNumber].dwSuggestedBufferSize = AddLong ("Suggested Buffer Size");  	stSize -= 4;  	if (fileStruc [streamNumber].fccType == "vids")  		buf = (int)fileStruc [streamNumber].dwSuggestedBufferSize;  	fileStruc [streamNumber].dwQuality = AddLong ("Quality");  	stSize -= 4;  	fileStruc [streamNumber].dwSampleSize = AddLong ("Sample Size");  	stSize -= 4;  	AddShort ("Left");  	stSize -= 2;  	AddShort ("Top");  	stSize -= 2;  	AddShort ("Right");  	stSize -= 2;  	AddShort ("Bottom");  	stSize -= 2;  	break;  case "strf":  	analyseList.Add (aviFile.Position.ToString ("x8") + "Format " + ch);  	AddLong ("Taille");  	switch (fileStruc [streamNumber].fccType) {  	case "iavs":  		AddLong ("DVAAuxSrc");  		AddLong ("DVAAuxCtl");  		AddLong ("DVAAuxSrc1");  		AddLong ("DVAAuxCtl1");  		AddLong ("DVVAuxSrc");  		AddLong ("DVVAuxCtl");  		AddLong ("Reserved");  		AddLong ("Reserved");  		break;  	case "vids":  		stSize = AddLong ("Size");  		AddLong ("Width");  		stSize -= 4;  		AddLong ("Height");  		stSize -= 4;  		AddShort ("Planes");  		stSize -= 2;  		AddShort ("BitCount");  		stSize -= 2;  		AddString ("Compression");  		stSize -= 4;  		int buf2 = (int)AddLong ("ImageSize");  		stSize -= 4;  		if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  			buf = buf2;  		AddLong ("xPelsPerMeter");  		stSize -= 4;  		AddLong ("yPelsPerMeter");  		stSize -= 4;  		AddLong ("Color_Table");  		stSize -= 4;  		AddLong ("Important Color_Table");  		stSize -= 4;  		streamNumber++;  		break;  	case "auds":  		AddShort ("Format");  		stSize -= 2;  		AddShort ("nChannels");  		stSize -= 2;  		AddLong ("SamplesPerRec");  		stSize -= 4;  		AddLong ("AvgBytesPerRec");  		stSize -= 4;  		AddShort ("BlockAlign");  		stSize -= 2;  		AddShort ("BitsPerSample");  		stSize -= 2;  		streamNumber++;  		break;  	}  	break;  case "strd":  	long a = AddLong ("");  	for (int uu = 0; uu < (a / 4); uu++)  		AddLong ("");  	break;  case "odml":  	analyseList.Add (aviFile.Position.ToString ("x8") + " Open DML List " + ch);  	AddString ("");  	long length = AddLong ("Length");  	long dw = AddLong ("Real Frame Number");  	length -= 4;  	aviFile.Seek (length' SeekOrigin.Current);  	break;  case "indx":  	//Type 1 DV dv file  	analyseList.Add (aviFile.Position.ToString ("x8") + " " + ch);  	long lhn = AddLong ("Size");  	aviFile.Seek (lhn' SeekOrigin.Current);  	/*                   AddShort("LongPerEntry");                                        AddByte("SubType");                                        AddByte("Type");                                        int entryInUse = (int)AddLong("Index in use");                                        string ss = AddString("Frame marker");                    //                    if (streamNumber == 0) vidstr = ss;                                        int[] ent = new int[entryInUse];                                        for (int ux = 0; ux < entryInUse; ux++)                                        {                                            aviFile.Read(ckid' 0' strLen);                                            ent[ux] = (int)ByteToi(ckid);                                            debListeMFiles += strLen;                                         }*/break;  default:  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 2;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 2;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 2;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 2;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 2;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 2;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 2;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 2;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 2;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 2;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 2;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: stSize -= 2;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: for (int uu = 0; uu < (a / 4); uu++)  	AddLong ("");  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following statement contains a magic number: length -= 4;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: if (indexFrame.Count > 0) {  	DateTime oldFrame = DateTime.MinValue;  	DateTime newFrame = DateTime.MinValue;  	int prevFrame = 0;  	IndexData inx = (IndexData)indexFrameStart [0];  	aviFile.Seek ((long)inx.startOffset' SeekOrigin.Begin);  	int debut = 0;  	UInt64 movieOffset = inx.startOffset;  	buf = (int)fileStruc [0].dwSuggestedBufferSize;  	vauxdata = new byte[buf];  	currentFrameNumber = 0;  	// First frame handling  	FrameData fr = (FrameData)indexFrame [0];  	long offSet = (long)movieOffset + fr.offset;  	aviFile.Seek (offSet - 8' SeekOrigin.Begin);  	if (fr.size <= buf) {  		aviFile.Read (vauxdata' 0' 1000);  		int start = 0x1D2;  		if (vauxdata [start] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  			currentFrameDate = timeData [0];  			currentTimeCode = timeData [1];  			currentSequenceNumber = sequenceNumber;  			NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  			sequenceNumber += 1;  		}  	}  	oldFrame = fr.timeStamp;  	currentFrameNumber += 1;  	int numIndex = 0;  	TimeSpan tsLength = new TimeSpan (0' 0' 1);  	while (currentFrameNumber < fileHdr.NbTotalFrames) {  		int fin = (int)Math.Min (debut + entriesInUse' fileHdr.NbTotalFrames) - 1;  		while (currentFrameNumber <= fin) {  			if (stop)  				return;  			fr = (FrameData)indexFrame [currentFrameNumber];  			offSet = (long)movieOffset + fr.offset;  			aviFile.Seek (offSet - 8' SeekOrigin.Begin);  			if (fr.size <= buf) {  				aviFile.Read (vauxdata' 0' 1000);  				int start = 0x1D2;  				if (vauxdata [start] == 0x62) {  					DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  					currentFrameDate = timeData [0];  					currentTimeCode = timeData [1];  					//Test : la premire vrification vite des choses tranges  					// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  					if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  						//new sequence  						NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  						currentSequenceNumber = sequenceNumber;  						sequenceNumber += 1;  						prevFrame = currentFrameNumber;  						frameSequenceLength = 0;  					}  					oldFrame = currentFrameDate;  				}  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' currentFrameDate' currentTimeCode));  			if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  				DateTime endComp = DateTime.Now;  				TimeSpan ts = endComp - startComp;  				int sec = ts.Minutes * 60 + ts.Seconds;  				int speed = (int)fileHdr.NbTotalFrames / sec;  				return;  			}  			currentFrameNumber += 1;  			NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber));  			frameSequenceLength += 1;  		}  		while (ch != "ix00") {  			aviFile.Read (ckid' 0' len);  			ch = ByteTos (ckid);  		}  		entriesInUse = UpdateIndex ();  		ch = "";  		debut = debut + inx.startFrame;  		numIndex += 1;  		inx = (IndexData)indexFrameStart [numIndex];  		movieOffset = inx.startOffset;  	}  }  else {  	FrameAnalysisAlter (startFrame' endFrame);  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: if (indexFrame.Count > 0) {  	DateTime oldFrame = DateTime.MinValue;  	DateTime newFrame = DateTime.MinValue;  	int prevFrame = 0;  	IndexData inx = (IndexData)indexFrameStart [0];  	aviFile.Seek ((long)inx.startOffset' SeekOrigin.Begin);  	int debut = 0;  	UInt64 movieOffset = inx.startOffset;  	buf = (int)fileStruc [0].dwSuggestedBufferSize;  	vauxdata = new byte[buf];  	currentFrameNumber = 0;  	// First frame handling  	FrameData fr = (FrameData)indexFrame [0];  	long offSet = (long)movieOffset + fr.offset;  	aviFile.Seek (offSet - 8' SeekOrigin.Begin);  	if (fr.size <= buf) {  		aviFile.Read (vauxdata' 0' 1000);  		int start = 0x1D2;  		if (vauxdata [start] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  			currentFrameDate = timeData [0];  			currentTimeCode = timeData [1];  			currentSequenceNumber = sequenceNumber;  			NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  			sequenceNumber += 1;  		}  	}  	oldFrame = fr.timeStamp;  	currentFrameNumber += 1;  	int numIndex = 0;  	TimeSpan tsLength = new TimeSpan (0' 0' 1);  	while (currentFrameNumber < fileHdr.NbTotalFrames) {  		int fin = (int)Math.Min (debut + entriesInUse' fileHdr.NbTotalFrames) - 1;  		while (currentFrameNumber <= fin) {  			if (stop)  				return;  			fr = (FrameData)indexFrame [currentFrameNumber];  			offSet = (long)movieOffset + fr.offset;  			aviFile.Seek (offSet - 8' SeekOrigin.Begin);  			if (fr.size <= buf) {  				aviFile.Read (vauxdata' 0' 1000);  				int start = 0x1D2;  				if (vauxdata [start] == 0x62) {  					DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  					currentFrameDate = timeData [0];  					currentTimeCode = timeData [1];  					//Test : la premire vrification vite des choses tranges  					// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  					if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  						//new sequence  						NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  						currentSequenceNumber = sequenceNumber;  						sequenceNumber += 1;  						prevFrame = currentFrameNumber;  						frameSequenceLength = 0;  					}  					oldFrame = currentFrameDate;  				}  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' currentFrameDate' currentTimeCode));  			if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  				DateTime endComp = DateTime.Now;  				TimeSpan ts = endComp - startComp;  				int sec = ts.Minutes * 60 + ts.Seconds;  				int speed = (int)fileHdr.NbTotalFrames / sec;  				return;  			}  			currentFrameNumber += 1;  			NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber));  			frameSequenceLength += 1;  		}  		while (ch != "ix00") {  			aviFile.Read (ckid' 0' len);  			ch = ByteTos (ckid);  		}  		entriesInUse = UpdateIndex ();  		ch = "";  		debut = debut + inx.startFrame;  		numIndex += 1;  		inx = (IndexData)indexFrameStart [numIndex];  		movieOffset = inx.startOffset;  	}  }  else {  	FrameAnalysisAlter (startFrame' endFrame);  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: if (indexFrame.Count > 0) {  	DateTime oldFrame = DateTime.MinValue;  	DateTime newFrame = DateTime.MinValue;  	int prevFrame = 0;  	IndexData inx = (IndexData)indexFrameStart [0];  	aviFile.Seek ((long)inx.startOffset' SeekOrigin.Begin);  	int debut = 0;  	UInt64 movieOffset = inx.startOffset;  	buf = (int)fileStruc [0].dwSuggestedBufferSize;  	vauxdata = new byte[buf];  	currentFrameNumber = 0;  	// First frame handling  	FrameData fr = (FrameData)indexFrame [0];  	long offSet = (long)movieOffset + fr.offset;  	aviFile.Seek (offSet - 8' SeekOrigin.Begin);  	if (fr.size <= buf) {  		aviFile.Read (vauxdata' 0' 1000);  		int start = 0x1D2;  		if (vauxdata [start] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  			currentFrameDate = timeData [0];  			currentTimeCode = timeData [1];  			currentSequenceNumber = sequenceNumber;  			NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  			sequenceNumber += 1;  		}  	}  	oldFrame = fr.timeStamp;  	currentFrameNumber += 1;  	int numIndex = 0;  	TimeSpan tsLength = new TimeSpan (0' 0' 1);  	while (currentFrameNumber < fileHdr.NbTotalFrames) {  		int fin = (int)Math.Min (debut + entriesInUse' fileHdr.NbTotalFrames) - 1;  		while (currentFrameNumber <= fin) {  			if (stop)  				return;  			fr = (FrameData)indexFrame [currentFrameNumber];  			offSet = (long)movieOffset + fr.offset;  			aviFile.Seek (offSet - 8' SeekOrigin.Begin);  			if (fr.size <= buf) {  				aviFile.Read (vauxdata' 0' 1000);  				int start = 0x1D2;  				if (vauxdata [start] == 0x62) {  					DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  					currentFrameDate = timeData [0];  					currentTimeCode = timeData [1];  					//Test : la premire vrification vite des choses tranges  					// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  					if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  						//new sequence  						NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  						currentSequenceNumber = sequenceNumber;  						sequenceNumber += 1;  						prevFrame = currentFrameNumber;  						frameSequenceLength = 0;  					}  					oldFrame = currentFrameDate;  				}  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' currentFrameDate' currentTimeCode));  			if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  				DateTime endComp = DateTime.Now;  				TimeSpan ts = endComp - startComp;  				int sec = ts.Minutes * 60 + ts.Seconds;  				int speed = (int)fileHdr.NbTotalFrames / sec;  				return;  			}  			currentFrameNumber += 1;  			NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber));  			frameSequenceLength += 1;  		}  		while (ch != "ix00") {  			aviFile.Read (ckid' 0' len);  			ch = ByteTos (ckid);  		}  		entriesInUse = UpdateIndex ();  		ch = "";  		debut = debut + inx.startFrame;  		numIndex += 1;  		inx = (IndexData)indexFrameStart [numIndex];  		movieOffset = inx.startOffset;  	}  }  else {  	FrameAnalysisAlter (startFrame' endFrame);  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: if (indexFrame.Count > 0) {  	DateTime oldFrame = DateTime.MinValue;  	DateTime newFrame = DateTime.MinValue;  	int prevFrame = 0;  	IndexData inx = (IndexData)indexFrameStart [0];  	aviFile.Seek ((long)inx.startOffset' SeekOrigin.Begin);  	int debut = 0;  	UInt64 movieOffset = inx.startOffset;  	buf = (int)fileStruc [0].dwSuggestedBufferSize;  	vauxdata = new byte[buf];  	currentFrameNumber = 0;  	// First frame handling  	FrameData fr = (FrameData)indexFrame [0];  	long offSet = (long)movieOffset + fr.offset;  	aviFile.Seek (offSet - 8' SeekOrigin.Begin);  	if (fr.size <= buf) {  		aviFile.Read (vauxdata' 0' 1000);  		int start = 0x1D2;  		if (vauxdata [start] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  			currentFrameDate = timeData [0];  			currentTimeCode = timeData [1];  			currentSequenceNumber = sequenceNumber;  			NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  			sequenceNumber += 1;  		}  	}  	oldFrame = fr.timeStamp;  	currentFrameNumber += 1;  	int numIndex = 0;  	TimeSpan tsLength = new TimeSpan (0' 0' 1);  	while (currentFrameNumber < fileHdr.NbTotalFrames) {  		int fin = (int)Math.Min (debut + entriesInUse' fileHdr.NbTotalFrames) - 1;  		while (currentFrameNumber <= fin) {  			if (stop)  				return;  			fr = (FrameData)indexFrame [currentFrameNumber];  			offSet = (long)movieOffset + fr.offset;  			aviFile.Seek (offSet - 8' SeekOrigin.Begin);  			if (fr.size <= buf) {  				aviFile.Read (vauxdata' 0' 1000);  				int start = 0x1D2;  				if (vauxdata [start] == 0x62) {  					DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  					currentFrameDate = timeData [0];  					currentTimeCode = timeData [1];  					//Test : la premire vrification vite des choses tranges  					// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  					if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  						//new sequence  						NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  						currentSequenceNumber = sequenceNumber;  						sequenceNumber += 1;  						prevFrame = currentFrameNumber;  						frameSequenceLength = 0;  					}  					oldFrame = currentFrameDate;  				}  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' currentFrameDate' currentTimeCode));  			if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  				DateTime endComp = DateTime.Now;  				TimeSpan ts = endComp - startComp;  				int sec = ts.Minutes * 60 + ts.Seconds;  				int speed = (int)fileHdr.NbTotalFrames / sec;  				return;  			}  			currentFrameNumber += 1;  			NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber));  			frameSequenceLength += 1;  		}  		while (ch != "ix00") {  			aviFile.Read (ckid' 0' len);  			ch = ByteTos (ckid);  		}  		entriesInUse = UpdateIndex ();  		ch = "";  		debut = debut + inx.startFrame;  		numIndex += 1;  		inx = (IndexData)indexFrameStart [numIndex];  		movieOffset = inx.startOffset;  	}  }  else {  	FrameAnalysisAlter (startFrame' endFrame);  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: if (indexFrame.Count > 0) {  	DateTime oldFrame = DateTime.MinValue;  	DateTime newFrame = DateTime.MinValue;  	int prevFrame = 0;  	IndexData inx = (IndexData)indexFrameStart [0];  	aviFile.Seek ((long)inx.startOffset' SeekOrigin.Begin);  	int debut = 0;  	UInt64 movieOffset = inx.startOffset;  	buf = (int)fileStruc [0].dwSuggestedBufferSize;  	vauxdata = new byte[buf];  	currentFrameNumber = 0;  	// First frame handling  	FrameData fr = (FrameData)indexFrame [0];  	long offSet = (long)movieOffset + fr.offset;  	aviFile.Seek (offSet - 8' SeekOrigin.Begin);  	if (fr.size <= buf) {  		aviFile.Read (vauxdata' 0' 1000);  		int start = 0x1D2;  		if (vauxdata [start] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  			currentFrameDate = timeData [0];  			currentTimeCode = timeData [1];  			currentSequenceNumber = sequenceNumber;  			NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  			sequenceNumber += 1;  		}  	}  	oldFrame = fr.timeStamp;  	currentFrameNumber += 1;  	int numIndex = 0;  	TimeSpan tsLength = new TimeSpan (0' 0' 1);  	while (currentFrameNumber < fileHdr.NbTotalFrames) {  		int fin = (int)Math.Min (debut + entriesInUse' fileHdr.NbTotalFrames) - 1;  		while (currentFrameNumber <= fin) {  			if (stop)  				return;  			fr = (FrameData)indexFrame [currentFrameNumber];  			offSet = (long)movieOffset + fr.offset;  			aviFile.Seek (offSet - 8' SeekOrigin.Begin);  			if (fr.size <= buf) {  				aviFile.Read (vauxdata' 0' 1000);  				int start = 0x1D2;  				if (vauxdata [start] == 0x62) {  					DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  					currentFrameDate = timeData [0];  					currentTimeCode = timeData [1];  					//Test : la premire vrification vite des choses tranges  					// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  					if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  						//new sequence  						NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  						currentSequenceNumber = sequenceNumber;  						sequenceNumber += 1;  						prevFrame = currentFrameNumber;  						frameSequenceLength = 0;  					}  					oldFrame = currentFrameDate;  				}  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' currentFrameDate' currentTimeCode));  			if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  				DateTime endComp = DateTime.Now;  				TimeSpan ts = endComp - startComp;  				int sec = ts.Minutes * 60 + ts.Seconds;  				int speed = (int)fileHdr.NbTotalFrames / sec;  				return;  			}  			currentFrameNumber += 1;  			NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber));  			frameSequenceLength += 1;  		}  		while (ch != "ix00") {  			aviFile.Read (ckid' 0' len);  			ch = ByteTos (ckid);  		}  		entriesInUse = UpdateIndex ();  		ch = "";  		debut = debut + inx.startFrame;  		numIndex += 1;  		inx = (IndexData)indexFrameStart [numIndex];  		movieOffset = inx.startOffset;  	}  }  else {  	FrameAnalysisAlter (startFrame' endFrame);  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: if (indexFrame.Count > 0) {  	DateTime oldFrame = DateTime.MinValue;  	DateTime newFrame = DateTime.MinValue;  	int prevFrame = 0;  	IndexData inx = (IndexData)indexFrameStart [0];  	aviFile.Seek ((long)inx.startOffset' SeekOrigin.Begin);  	int debut = 0;  	UInt64 movieOffset = inx.startOffset;  	buf = (int)fileStruc [0].dwSuggestedBufferSize;  	vauxdata = new byte[buf];  	currentFrameNumber = 0;  	// First frame handling  	FrameData fr = (FrameData)indexFrame [0];  	long offSet = (long)movieOffset + fr.offset;  	aviFile.Seek (offSet - 8' SeekOrigin.Begin);  	if (fr.size <= buf) {  		aviFile.Read (vauxdata' 0' 1000);  		int start = 0x1D2;  		if (vauxdata [start] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  			currentFrameDate = timeData [0];  			currentTimeCode = timeData [1];  			currentSequenceNumber = sequenceNumber;  			NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  			sequenceNumber += 1;  		}  	}  	oldFrame = fr.timeStamp;  	currentFrameNumber += 1;  	int numIndex = 0;  	TimeSpan tsLength = new TimeSpan (0' 0' 1);  	while (currentFrameNumber < fileHdr.NbTotalFrames) {  		int fin = (int)Math.Min (debut + entriesInUse' fileHdr.NbTotalFrames) - 1;  		while (currentFrameNumber <= fin) {  			if (stop)  				return;  			fr = (FrameData)indexFrame [currentFrameNumber];  			offSet = (long)movieOffset + fr.offset;  			aviFile.Seek (offSet - 8' SeekOrigin.Begin);  			if (fr.size <= buf) {  				aviFile.Read (vauxdata' 0' 1000);  				int start = 0x1D2;  				if (vauxdata [start] == 0x62) {  					DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  					currentFrameDate = timeData [0];  					currentTimeCode = timeData [1];  					//Test : la premire vrification vite des choses tranges  					// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  					if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  						//new sequence  						NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  						currentSequenceNumber = sequenceNumber;  						sequenceNumber += 1;  						prevFrame = currentFrameNumber;  						frameSequenceLength = 0;  					}  					oldFrame = currentFrameDate;  				}  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' currentFrameDate' currentTimeCode));  			if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  				DateTime endComp = DateTime.Now;  				TimeSpan ts = endComp - startComp;  				int sec = ts.Minutes * 60 + ts.Seconds;  				int speed = (int)fileHdr.NbTotalFrames / sec;  				return;  			}  			currentFrameNumber += 1;  			NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber));  			frameSequenceLength += 1;  		}  		while (ch != "ix00") {  			aviFile.Read (ckid' 0' len);  			ch = ByteTos (ckid);  		}  		entriesInUse = UpdateIndex ();  		ch = "";  		debut = debut + inx.startFrame;  		numIndex += 1;  		inx = (IndexData)indexFrameStart [numIndex];  		movieOffset = inx.startOffset;  	}  }  else {  	FrameAnalysisAlter (startFrame' endFrame);  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: aviFile.Seek (offSet - 8' SeekOrigin.Begin);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: if (fr.size <= buf) {  	aviFile.Read (vauxdata' 0' 1000);  	int start = 0x1D2;  	if (vauxdata [start] == 0x62) {  		DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  		currentFrameDate = timeData [0];  		currentTimeCode = timeData [1];  		currentSequenceNumber = sequenceNumber;  		NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  		sequenceNumber += 1;  	}  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: aviFile.Read (vauxdata' 0' 1000);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: while (currentFrameNumber < fileHdr.NbTotalFrames) {  	int fin = (int)Math.Min (debut + entriesInUse' fileHdr.NbTotalFrames) - 1;  	while (currentFrameNumber <= fin) {  		if (stop)  			return;  		fr = (FrameData)indexFrame [currentFrameNumber];  		offSet = (long)movieOffset + fr.offset;  		aviFile.Seek (offSet - 8' SeekOrigin.Begin);  		if (fr.size <= buf) {  			aviFile.Read (vauxdata' 0' 1000);  			int start = 0x1D2;  			if (vauxdata [start] == 0x62) {  				DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  				currentFrameDate = timeData [0];  				currentTimeCode = timeData [1];  				//Test : la premire vrification vite des choses tranges  				// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  				if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  					//new sequence  					NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  					currentSequenceNumber = sequenceNumber;  					sequenceNumber += 1;  					prevFrame = currentFrameNumber;  					frameSequenceLength = 0;  				}  				oldFrame = currentFrameDate;  			}  		}  		frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' currentFrameDate' currentTimeCode));  		if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  			DateTime endComp = DateTime.Now;  			TimeSpan ts = endComp - startComp;  			int sec = ts.Minutes * 60 + ts.Seconds;  			int speed = (int)fileHdr.NbTotalFrames / sec;  			return;  		}  		currentFrameNumber += 1;  		NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber));  		frameSequenceLength += 1;  	}  	while (ch != "ix00") {  		aviFile.Read (ckid' 0' len);  		ch = ByteTos (ckid);  	}  	entriesInUse = UpdateIndex ();  	ch = "";  	debut = debut + inx.startFrame;  	numIndex += 1;  	inx = (IndexData)indexFrameStart [numIndex];  	movieOffset = inx.startOffset;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: while (currentFrameNumber < fileHdr.NbTotalFrames) {  	int fin = (int)Math.Min (debut + entriesInUse' fileHdr.NbTotalFrames) - 1;  	while (currentFrameNumber <= fin) {  		if (stop)  			return;  		fr = (FrameData)indexFrame [currentFrameNumber];  		offSet = (long)movieOffset + fr.offset;  		aviFile.Seek (offSet - 8' SeekOrigin.Begin);  		if (fr.size <= buf) {  			aviFile.Read (vauxdata' 0' 1000);  			int start = 0x1D2;  			if (vauxdata [start] == 0x62) {  				DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  				currentFrameDate = timeData [0];  				currentTimeCode = timeData [1];  				//Test : la premire vrification vite des choses tranges  				// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  				if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  					//new sequence  					NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  					currentSequenceNumber = sequenceNumber;  					sequenceNumber += 1;  					prevFrame = currentFrameNumber;  					frameSequenceLength = 0;  				}  				oldFrame = currentFrameDate;  			}  		}  		frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' currentFrameDate' currentTimeCode));  		if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  			DateTime endComp = DateTime.Now;  			TimeSpan ts = endComp - startComp;  			int sec = ts.Minutes * 60 + ts.Seconds;  			int speed = (int)fileHdr.NbTotalFrames / sec;  			return;  		}  		currentFrameNumber += 1;  		NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber));  		frameSequenceLength += 1;  	}  	while (ch != "ix00") {  		aviFile.Read (ckid' 0' len);  		ch = ByteTos (ckid);  	}  	entriesInUse = UpdateIndex ();  	ch = "";  	debut = debut + inx.startFrame;  	numIndex += 1;  	inx = (IndexData)indexFrameStart [numIndex];  	movieOffset = inx.startOffset;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: while (currentFrameNumber < fileHdr.NbTotalFrames) {  	int fin = (int)Math.Min (debut + entriesInUse' fileHdr.NbTotalFrames) - 1;  	while (currentFrameNumber <= fin) {  		if (stop)  			return;  		fr = (FrameData)indexFrame [currentFrameNumber];  		offSet = (long)movieOffset + fr.offset;  		aviFile.Seek (offSet - 8' SeekOrigin.Begin);  		if (fr.size <= buf) {  			aviFile.Read (vauxdata' 0' 1000);  			int start = 0x1D2;  			if (vauxdata [start] == 0x62) {  				DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  				currentFrameDate = timeData [0];  				currentTimeCode = timeData [1];  				//Test : la premire vrification vite des choses tranges  				// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  				if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  					//new sequence  					NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  					currentSequenceNumber = sequenceNumber;  					sequenceNumber += 1;  					prevFrame = currentFrameNumber;  					frameSequenceLength = 0;  				}  				oldFrame = currentFrameDate;  			}  		}  		frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' currentFrameDate' currentTimeCode));  		if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  			DateTime endComp = DateTime.Now;  			TimeSpan ts = endComp - startComp;  			int sec = ts.Minutes * 60 + ts.Seconds;  			int speed = (int)fileHdr.NbTotalFrames / sec;  			return;  		}  		currentFrameNumber += 1;  		NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber));  		frameSequenceLength += 1;  	}  	while (ch != "ix00") {  		aviFile.Read (ckid' 0' len);  		ch = ByteTos (ckid);  	}  	entriesInUse = UpdateIndex ();  	ch = "";  	debut = debut + inx.startFrame;  	numIndex += 1;  	inx = (IndexData)indexFrameStart [numIndex];  	movieOffset = inx.startOffset;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: while (currentFrameNumber < fileHdr.NbTotalFrames) {  	int fin = (int)Math.Min (debut + entriesInUse' fileHdr.NbTotalFrames) - 1;  	while (currentFrameNumber <= fin) {  		if (stop)  			return;  		fr = (FrameData)indexFrame [currentFrameNumber];  		offSet = (long)movieOffset + fr.offset;  		aviFile.Seek (offSet - 8' SeekOrigin.Begin);  		if (fr.size <= buf) {  			aviFile.Read (vauxdata' 0' 1000);  			int start = 0x1D2;  			if (vauxdata [start] == 0x62) {  				DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  				currentFrameDate = timeData [0];  				currentTimeCode = timeData [1];  				//Test : la premire vrification vite des choses tranges  				// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  				if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  					//new sequence  					NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  					currentSequenceNumber = sequenceNumber;  					sequenceNumber += 1;  					prevFrame = currentFrameNumber;  					frameSequenceLength = 0;  				}  				oldFrame = currentFrameDate;  			}  		}  		frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' currentFrameDate' currentTimeCode));  		if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  			DateTime endComp = DateTime.Now;  			TimeSpan ts = endComp - startComp;  			int sec = ts.Minutes * 60 + ts.Seconds;  			int speed = (int)fileHdr.NbTotalFrames / sec;  			return;  		}  		currentFrameNumber += 1;  		NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber));  		frameSequenceLength += 1;  	}  	while (ch != "ix00") {  		aviFile.Read (ckid' 0' len);  		ch = ByteTos (ckid);  	}  	entriesInUse = UpdateIndex ();  	ch = "";  	debut = debut + inx.startFrame;  	numIndex += 1;  	inx = (IndexData)indexFrameStart [numIndex];  	movieOffset = inx.startOffset;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: while (currentFrameNumber <= fin) {  	if (stop)  		return;  	fr = (FrameData)indexFrame [currentFrameNumber];  	offSet = (long)movieOffset + fr.offset;  	aviFile.Seek (offSet - 8' SeekOrigin.Begin);  	if (fr.size <= buf) {  		aviFile.Read (vauxdata' 0' 1000);  		int start = 0x1D2;  		if (vauxdata [start] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  			currentFrameDate = timeData [0];  			currentTimeCode = timeData [1];  			//Test : la premire vrification vite des choses tranges  			// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  			if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  				//new sequence  				NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  				currentSequenceNumber = sequenceNumber;  				sequenceNumber += 1;  				prevFrame = currentFrameNumber;  				frameSequenceLength = 0;  			}  			oldFrame = currentFrameDate;  		}  	}  	frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' currentFrameDate' currentTimeCode));  	if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  		DateTime endComp = DateTime.Now;  		TimeSpan ts = endComp - startComp;  		int sec = ts.Minutes * 60 + ts.Seconds;  		int speed = (int)fileHdr.NbTotalFrames / sec;  		return;  	}  	currentFrameNumber += 1;  	NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber));  	frameSequenceLength += 1;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: while (currentFrameNumber <= fin) {  	if (stop)  		return;  	fr = (FrameData)indexFrame [currentFrameNumber];  	offSet = (long)movieOffset + fr.offset;  	aviFile.Seek (offSet - 8' SeekOrigin.Begin);  	if (fr.size <= buf) {  		aviFile.Read (vauxdata' 0' 1000);  		int start = 0x1D2;  		if (vauxdata [start] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  			currentFrameDate = timeData [0];  			currentTimeCode = timeData [1];  			//Test : la premire vrification vite des choses tranges  			// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  			if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  				//new sequence  				NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  				currentSequenceNumber = sequenceNumber;  				sequenceNumber += 1;  				prevFrame = currentFrameNumber;  				frameSequenceLength = 0;  			}  			oldFrame = currentFrameDate;  		}  	}  	frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' currentFrameDate' currentTimeCode));  	if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  		DateTime endComp = DateTime.Now;  		TimeSpan ts = endComp - startComp;  		int sec = ts.Minutes * 60 + ts.Seconds;  		int speed = (int)fileHdr.NbTotalFrames / sec;  		return;  	}  	currentFrameNumber += 1;  	NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber));  	frameSequenceLength += 1;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: while (currentFrameNumber <= fin) {  	if (stop)  		return;  	fr = (FrameData)indexFrame [currentFrameNumber];  	offSet = (long)movieOffset + fr.offset;  	aviFile.Seek (offSet - 8' SeekOrigin.Begin);  	if (fr.size <= buf) {  		aviFile.Read (vauxdata' 0' 1000);  		int start = 0x1D2;  		if (vauxdata [start] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  			currentFrameDate = timeData [0];  			currentTimeCode = timeData [1];  			//Test : la premire vrification vite des choses tranges  			// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  			if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  				//new sequence  				NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  				currentSequenceNumber = sequenceNumber;  				sequenceNumber += 1;  				prevFrame = currentFrameNumber;  				frameSequenceLength = 0;  			}  			oldFrame = currentFrameDate;  		}  	}  	frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' currentFrameDate' currentTimeCode));  	if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  		DateTime endComp = DateTime.Now;  		TimeSpan ts = endComp - startComp;  		int sec = ts.Minutes * 60 + ts.Seconds;  		int speed = (int)fileHdr.NbTotalFrames / sec;  		return;  	}  	currentFrameNumber += 1;  	NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber));  	frameSequenceLength += 1;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: while (currentFrameNumber <= fin) {  	if (stop)  		return;  	fr = (FrameData)indexFrame [currentFrameNumber];  	offSet = (long)movieOffset + fr.offset;  	aviFile.Seek (offSet - 8' SeekOrigin.Begin);  	if (fr.size <= buf) {  		aviFile.Read (vauxdata' 0' 1000);  		int start = 0x1D2;  		if (vauxdata [start] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  			currentFrameDate = timeData [0];  			currentTimeCode = timeData [1];  			//Test : la premire vrification vite des choses tranges  			// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  			if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  				//new sequence  				NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  				currentSequenceNumber = sequenceNumber;  				sequenceNumber += 1;  				prevFrame = currentFrameNumber;  				frameSequenceLength = 0;  			}  			oldFrame = currentFrameDate;  		}  	}  	frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' currentFrameDate' currentTimeCode));  	if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  		DateTime endComp = DateTime.Now;  		TimeSpan ts = endComp - startComp;  		int sec = ts.Minutes * 60 + ts.Seconds;  		int speed = (int)fileHdr.NbTotalFrames / sec;  		return;  	}  	currentFrameNumber += 1;  	NewFrameRead (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' currentSequenceNumber));  	frameSequenceLength += 1;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: aviFile.Seek (offSet - 8' SeekOrigin.Begin);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: if (fr.size <= buf) {  	aviFile.Read (vauxdata' 0' 1000);  	int start = 0x1D2;  	if (vauxdata [start] == 0x62) {  		DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  		currentFrameDate = timeData [0];  		currentTimeCode = timeData [1];  		//Test : la premire vrification vite des choses tranges  		// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  		if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  			//new sequence  			NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  			currentSequenceNumber = sequenceNumber;  			sequenceNumber += 1;  			prevFrame = currentFrameNumber;  			frameSequenceLength = 0;  		}  		oldFrame = currentFrameDate;  	}  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: if (fr.size <= buf) {  	aviFile.Read (vauxdata' 0' 1000);  	int start = 0x1D2;  	if (vauxdata [start] == 0x62) {  		DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  		currentFrameDate = timeData [0];  		currentTimeCode = timeData [1];  		//Test : la premire vrification vite des choses tranges  		// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  		if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  			//new sequence  			NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  			currentSequenceNumber = sequenceNumber;  			sequenceNumber += 1;  			prevFrame = currentFrameNumber;  			frameSequenceLength = 0;  		}  		oldFrame = currentFrameDate;  	}  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: aviFile.Read (vauxdata' 0' 1000);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: if (vauxdata [start] == 0x62) {  	DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' start);  	currentFrameDate = timeData [0];  	currentTimeCode = timeData [1];  	//Test : la premire vrification vite des choses tranges  	// et repose sur object_length'hypothse raisonnable de squences directionBit'au moins 5 frames' ie 1/5 de secondes  	if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  		//new sequence  		NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  		currentSequenceNumber = sequenceNumber;  		sequenceNumber += 1;  		prevFrame = currentFrameNumber;  		frameSequenceLength = 0;  	}  	oldFrame = currentFrameDate;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: if ((frameSequenceLength > 5) && (currentFrameDate != oldFrame) && ((currentFrameDate > oldFrame.Add (tsLength)) || currentFrameDate < oldFrame)) {  	//new sequence  	NewSequence (this' new SequenceEventArgs (currentFrameDate' currentTimeCode' currentFrameNumber' sequenceNumber));  	currentSequenceNumber = sequenceNumber;  	sequenceNumber += 1;  	prevFrame = currentFrameNumber;  	frameSequenceLength = 0;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysis,The following statement contains a magic number: if (currentFrameNumber == fileHdr.NbTotalFrames - 1) {  	DateTime endComp = DateTime.Now;  	TimeSpan ts = endComp - startComp;  	int sec = ts.Minutes * 60 + ts.Seconds;  	int speed = (int)fileHdr.NbTotalFrames / sec;  	return;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: buf = 144000;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: do {  	while (ch != vidstr) {  		if (numtr >= endFrame)  			break;  		if (ch == "01wb") {  			aviFile.Read (ckid' 0' len);  			audLen = ByteToi (ckid);  			aviFile.Seek (audLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  			if ((framCount < 24) && (numtr > 24)) {  				// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  				// manque trois frames entre deux audios au frame 15046  				numtr += (25 - framCount);  			}  			framCount = 0;  		}  		if (ch == "RIFF") {  		}  		if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  			//skipping index codeBuffer  			aviFile.Read (ckid' 0' len);  			long indLen = ByteToi (ckid);  			aviFile.Seek (indLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  		}  		if (aviFile.Read (ckid' 0' len) < 0)  			return;  		ch = ByteTos (ckid);  		if (aviFile.Position >= aviFile.Length)  			break;  	}  	startOldFrame = startNewFrame;  	startNewFrame = aviFile.Position;  	ch = "";  	//One more frame has been found and can be analyzed  	sizeFrame = startNewFrame - startOldFrame;  	aviFile.Read (ckid' 0' len);  	vidLen = (int)ByteToi (ckid);  	if (vidLen == 144000) {  		aviFile.Read (vauxdata' 0' 500);  		if (vauxdata [0x1CA] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  			newFrame = timeData [0];  			frameLoc = timeData [1];  			//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  			// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  			if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  				//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  				//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  				int secd = frameSequence / 25;  				int mn = secd / 60;  				secd = frameSequence / 25 - 60 * mn;  				int fr = frameSequence - 25 * secd;  				s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  				///Saving the current sequence  				s.endFrame = (int)numtr - 1;  				s.validDate = correct;  				sequences.Add (s);  				//new sequence  				numSequence += 1;  				s = new SEQUENCE ();  				s.seqNumber = numSequence;  				s.startFrame = (int)numtr;  				s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  				prevFrame = currentFrameNumber;  				frameSequence = 0;  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  			frameSequence += 1;  			beforeFrame = oldFrame;  			oldFrame = newFrame;  			oldFrameLoc = frameLoc;  			currentFrameNumber += 1;  			// Correction  		}  		// Jump to Change candidate frame  		aviFile.Seek (buf - 500' SeekOrigin.Current);  		frameStart += 1;  		framCount += 1;  		numtr++;  	}  	// Prepare Change frame  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  }  while (numtr < endFrame);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: do {  	while (ch != vidstr) {  		if (numtr >= endFrame)  			break;  		if (ch == "01wb") {  			aviFile.Read (ckid' 0' len);  			audLen = ByteToi (ckid);  			aviFile.Seek (audLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  			if ((framCount < 24) && (numtr > 24)) {  				// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  				// manque trois frames entre deux audios au frame 15046  				numtr += (25 - framCount);  			}  			framCount = 0;  		}  		if (ch == "RIFF") {  		}  		if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  			//skipping index codeBuffer  			aviFile.Read (ckid' 0' len);  			long indLen = ByteToi (ckid);  			aviFile.Seek (indLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  		}  		if (aviFile.Read (ckid' 0' len) < 0)  			return;  		ch = ByteTos (ckid);  		if (aviFile.Position >= aviFile.Length)  			break;  	}  	startOldFrame = startNewFrame;  	startNewFrame = aviFile.Position;  	ch = "";  	//One more frame has been found and can be analyzed  	sizeFrame = startNewFrame - startOldFrame;  	aviFile.Read (ckid' 0' len);  	vidLen = (int)ByteToi (ckid);  	if (vidLen == 144000) {  		aviFile.Read (vauxdata' 0' 500);  		if (vauxdata [0x1CA] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  			newFrame = timeData [0];  			frameLoc = timeData [1];  			//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  			// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  			if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  				//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  				//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  				int secd = frameSequence / 25;  				int mn = secd / 60;  				secd = frameSequence / 25 - 60 * mn;  				int fr = frameSequence - 25 * secd;  				s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  				///Saving the current sequence  				s.endFrame = (int)numtr - 1;  				s.validDate = correct;  				sequences.Add (s);  				//new sequence  				numSequence += 1;  				s = new SEQUENCE ();  				s.seqNumber = numSequence;  				s.startFrame = (int)numtr;  				s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  				prevFrame = currentFrameNumber;  				frameSequence = 0;  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  			frameSequence += 1;  			beforeFrame = oldFrame;  			oldFrame = newFrame;  			oldFrameLoc = frameLoc;  			currentFrameNumber += 1;  			// Correction  		}  		// Jump to Change candidate frame  		aviFile.Seek (buf - 500' SeekOrigin.Current);  		frameStart += 1;  		framCount += 1;  		numtr++;  	}  	// Prepare Change frame  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  }  while (numtr < endFrame);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: do {  	while (ch != vidstr) {  		if (numtr >= endFrame)  			break;  		if (ch == "01wb") {  			aviFile.Read (ckid' 0' len);  			audLen = ByteToi (ckid);  			aviFile.Seek (audLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  			if ((framCount < 24) && (numtr > 24)) {  				// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  				// manque trois frames entre deux audios au frame 15046  				numtr += (25 - framCount);  			}  			framCount = 0;  		}  		if (ch == "RIFF") {  		}  		if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  			//skipping index codeBuffer  			aviFile.Read (ckid' 0' len);  			long indLen = ByteToi (ckid);  			aviFile.Seek (indLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  		}  		if (aviFile.Read (ckid' 0' len) < 0)  			return;  		ch = ByteTos (ckid);  		if (aviFile.Position >= aviFile.Length)  			break;  	}  	startOldFrame = startNewFrame;  	startNewFrame = aviFile.Position;  	ch = "";  	//One more frame has been found and can be analyzed  	sizeFrame = startNewFrame - startOldFrame;  	aviFile.Read (ckid' 0' len);  	vidLen = (int)ByteToi (ckid);  	if (vidLen == 144000) {  		aviFile.Read (vauxdata' 0' 500);  		if (vauxdata [0x1CA] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  			newFrame = timeData [0];  			frameLoc = timeData [1];  			//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  			// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  			if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  				//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  				//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  				int secd = frameSequence / 25;  				int mn = secd / 60;  				secd = frameSequence / 25 - 60 * mn;  				int fr = frameSequence - 25 * secd;  				s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  				///Saving the current sequence  				s.endFrame = (int)numtr - 1;  				s.validDate = correct;  				sequences.Add (s);  				//new sequence  				numSequence += 1;  				s = new SEQUENCE ();  				s.seqNumber = numSequence;  				s.startFrame = (int)numtr;  				s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  				prevFrame = currentFrameNumber;  				frameSequence = 0;  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  			frameSequence += 1;  			beforeFrame = oldFrame;  			oldFrame = newFrame;  			oldFrameLoc = frameLoc;  			currentFrameNumber += 1;  			// Correction  		}  		// Jump to Change candidate frame  		aviFile.Seek (buf - 500' SeekOrigin.Current);  		frameStart += 1;  		framCount += 1;  		numtr++;  	}  	// Prepare Change frame  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  }  while (numtr < endFrame);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: do {  	while (ch != vidstr) {  		if (numtr >= endFrame)  			break;  		if (ch == "01wb") {  			aviFile.Read (ckid' 0' len);  			audLen = ByteToi (ckid);  			aviFile.Seek (audLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  			if ((framCount < 24) && (numtr > 24)) {  				// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  				// manque trois frames entre deux audios au frame 15046  				numtr += (25 - framCount);  			}  			framCount = 0;  		}  		if (ch == "RIFF") {  		}  		if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  			//skipping index codeBuffer  			aviFile.Read (ckid' 0' len);  			long indLen = ByteToi (ckid);  			aviFile.Seek (indLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  		}  		if (aviFile.Read (ckid' 0' len) < 0)  			return;  		ch = ByteTos (ckid);  		if (aviFile.Position >= aviFile.Length)  			break;  	}  	startOldFrame = startNewFrame;  	startNewFrame = aviFile.Position;  	ch = "";  	//One more frame has been found and can be analyzed  	sizeFrame = startNewFrame - startOldFrame;  	aviFile.Read (ckid' 0' len);  	vidLen = (int)ByteToi (ckid);  	if (vidLen == 144000) {  		aviFile.Read (vauxdata' 0' 500);  		if (vauxdata [0x1CA] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  			newFrame = timeData [0];  			frameLoc = timeData [1];  			//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  			// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  			if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  				//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  				//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  				int secd = frameSequence / 25;  				int mn = secd / 60;  				secd = frameSequence / 25 - 60 * mn;  				int fr = frameSequence - 25 * secd;  				s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  				///Saving the current sequence  				s.endFrame = (int)numtr - 1;  				s.validDate = correct;  				sequences.Add (s);  				//new sequence  				numSequence += 1;  				s = new SEQUENCE ();  				s.seqNumber = numSequence;  				s.startFrame = (int)numtr;  				s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  				prevFrame = currentFrameNumber;  				frameSequence = 0;  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  			frameSequence += 1;  			beforeFrame = oldFrame;  			oldFrame = newFrame;  			oldFrameLoc = frameLoc;  			currentFrameNumber += 1;  			// Correction  		}  		// Jump to Change candidate frame  		aviFile.Seek (buf - 500' SeekOrigin.Current);  		frameStart += 1;  		framCount += 1;  		numtr++;  	}  	// Prepare Change frame  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  }  while (numtr < endFrame);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: do {  	while (ch != vidstr) {  		if (numtr >= endFrame)  			break;  		if (ch == "01wb") {  			aviFile.Read (ckid' 0' len);  			audLen = ByteToi (ckid);  			aviFile.Seek (audLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  			if ((framCount < 24) && (numtr > 24)) {  				// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  				// manque trois frames entre deux audios au frame 15046  				numtr += (25 - framCount);  			}  			framCount = 0;  		}  		if (ch == "RIFF") {  		}  		if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  			//skipping index codeBuffer  			aviFile.Read (ckid' 0' len);  			long indLen = ByteToi (ckid);  			aviFile.Seek (indLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  		}  		if (aviFile.Read (ckid' 0' len) < 0)  			return;  		ch = ByteTos (ckid);  		if (aviFile.Position >= aviFile.Length)  			break;  	}  	startOldFrame = startNewFrame;  	startNewFrame = aviFile.Position;  	ch = "";  	//One more frame has been found and can be analyzed  	sizeFrame = startNewFrame - startOldFrame;  	aviFile.Read (ckid' 0' len);  	vidLen = (int)ByteToi (ckid);  	if (vidLen == 144000) {  		aviFile.Read (vauxdata' 0' 500);  		if (vauxdata [0x1CA] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  			newFrame = timeData [0];  			frameLoc = timeData [1];  			//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  			// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  			if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  				//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  				//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  				int secd = frameSequence / 25;  				int mn = secd / 60;  				secd = frameSequence / 25 - 60 * mn;  				int fr = frameSequence - 25 * secd;  				s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  				///Saving the current sequence  				s.endFrame = (int)numtr - 1;  				s.validDate = correct;  				sequences.Add (s);  				//new sequence  				numSequence += 1;  				s = new SEQUENCE ();  				s.seqNumber = numSequence;  				s.startFrame = (int)numtr;  				s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  				prevFrame = currentFrameNumber;  				frameSequence = 0;  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  			frameSequence += 1;  			beforeFrame = oldFrame;  			oldFrame = newFrame;  			oldFrameLoc = frameLoc;  			currentFrameNumber += 1;  			// Correction  		}  		// Jump to Change candidate frame  		aviFile.Seek (buf - 500' SeekOrigin.Current);  		frameStart += 1;  		framCount += 1;  		numtr++;  	}  	// Prepare Change frame  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  }  while (numtr < endFrame);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: do {  	while (ch != vidstr) {  		if (numtr >= endFrame)  			break;  		if (ch == "01wb") {  			aviFile.Read (ckid' 0' len);  			audLen = ByteToi (ckid);  			aviFile.Seek (audLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  			if ((framCount < 24) && (numtr > 24)) {  				// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  				// manque trois frames entre deux audios au frame 15046  				numtr += (25 - framCount);  			}  			framCount = 0;  		}  		if (ch == "RIFF") {  		}  		if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  			//skipping index codeBuffer  			aviFile.Read (ckid' 0' len);  			long indLen = ByteToi (ckid);  			aviFile.Seek (indLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  		}  		if (aviFile.Read (ckid' 0' len) < 0)  			return;  		ch = ByteTos (ckid);  		if (aviFile.Position >= aviFile.Length)  			break;  	}  	startOldFrame = startNewFrame;  	startNewFrame = aviFile.Position;  	ch = "";  	//One more frame has been found and can be analyzed  	sizeFrame = startNewFrame - startOldFrame;  	aviFile.Read (ckid' 0' len);  	vidLen = (int)ByteToi (ckid);  	if (vidLen == 144000) {  		aviFile.Read (vauxdata' 0' 500);  		if (vauxdata [0x1CA] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  			newFrame = timeData [0];  			frameLoc = timeData [1];  			//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  			// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  			if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  				//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  				//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  				int secd = frameSequence / 25;  				int mn = secd / 60;  				secd = frameSequence / 25 - 60 * mn;  				int fr = frameSequence - 25 * secd;  				s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  				///Saving the current sequence  				s.endFrame = (int)numtr - 1;  				s.validDate = correct;  				sequences.Add (s);  				//new sequence  				numSequence += 1;  				s = new SEQUENCE ();  				s.seqNumber = numSequence;  				s.startFrame = (int)numtr;  				s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  				prevFrame = currentFrameNumber;  				frameSequence = 0;  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  			frameSequence += 1;  			beforeFrame = oldFrame;  			oldFrame = newFrame;  			oldFrameLoc = frameLoc;  			currentFrameNumber += 1;  			// Correction  		}  		// Jump to Change candidate frame  		aviFile.Seek (buf - 500' SeekOrigin.Current);  		frameStart += 1;  		framCount += 1;  		numtr++;  	}  	// Prepare Change frame  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  }  while (numtr < endFrame);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: do {  	while (ch != vidstr) {  		if (numtr >= endFrame)  			break;  		if (ch == "01wb") {  			aviFile.Read (ckid' 0' len);  			audLen = ByteToi (ckid);  			aviFile.Seek (audLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  			if ((framCount < 24) && (numtr > 24)) {  				// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  				// manque trois frames entre deux audios au frame 15046  				numtr += (25 - framCount);  			}  			framCount = 0;  		}  		if (ch == "RIFF") {  		}  		if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  			//skipping index codeBuffer  			aviFile.Read (ckid' 0' len);  			long indLen = ByteToi (ckid);  			aviFile.Seek (indLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  		}  		if (aviFile.Read (ckid' 0' len) < 0)  			return;  		ch = ByteTos (ckid);  		if (aviFile.Position >= aviFile.Length)  			break;  	}  	startOldFrame = startNewFrame;  	startNewFrame = aviFile.Position;  	ch = "";  	//One more frame has been found and can be analyzed  	sizeFrame = startNewFrame - startOldFrame;  	aviFile.Read (ckid' 0' len);  	vidLen = (int)ByteToi (ckid);  	if (vidLen == 144000) {  		aviFile.Read (vauxdata' 0' 500);  		if (vauxdata [0x1CA] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  			newFrame = timeData [0];  			frameLoc = timeData [1];  			//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  			// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  			if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  				//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  				//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  				int secd = frameSequence / 25;  				int mn = secd / 60;  				secd = frameSequence / 25 - 60 * mn;  				int fr = frameSequence - 25 * secd;  				s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  				///Saving the current sequence  				s.endFrame = (int)numtr - 1;  				s.validDate = correct;  				sequences.Add (s);  				//new sequence  				numSequence += 1;  				s = new SEQUENCE ();  				s.seqNumber = numSequence;  				s.startFrame = (int)numtr;  				s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  				prevFrame = currentFrameNumber;  				frameSequence = 0;  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  			frameSequence += 1;  			beforeFrame = oldFrame;  			oldFrame = newFrame;  			oldFrameLoc = frameLoc;  			currentFrameNumber += 1;  			// Correction  		}  		// Jump to Change candidate frame  		aviFile.Seek (buf - 500' SeekOrigin.Current);  		frameStart += 1;  		framCount += 1;  		numtr++;  	}  	// Prepare Change frame  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  }  while (numtr < endFrame);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: do {  	while (ch != vidstr) {  		if (numtr >= endFrame)  			break;  		if (ch == "01wb") {  			aviFile.Read (ckid' 0' len);  			audLen = ByteToi (ckid);  			aviFile.Seek (audLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  			if ((framCount < 24) && (numtr > 24)) {  				// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  				// manque trois frames entre deux audios au frame 15046  				numtr += (25 - framCount);  			}  			framCount = 0;  		}  		if (ch == "RIFF") {  		}  		if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  			//skipping index codeBuffer  			aviFile.Read (ckid' 0' len);  			long indLen = ByteToi (ckid);  			aviFile.Seek (indLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  		}  		if (aviFile.Read (ckid' 0' len) < 0)  			return;  		ch = ByteTos (ckid);  		if (aviFile.Position >= aviFile.Length)  			break;  	}  	startOldFrame = startNewFrame;  	startNewFrame = aviFile.Position;  	ch = "";  	//One more frame has been found and can be analyzed  	sizeFrame = startNewFrame - startOldFrame;  	aviFile.Read (ckid' 0' len);  	vidLen = (int)ByteToi (ckid);  	if (vidLen == 144000) {  		aviFile.Read (vauxdata' 0' 500);  		if (vauxdata [0x1CA] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  			newFrame = timeData [0];  			frameLoc = timeData [1];  			//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  			// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  			if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  				//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  				//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  				int secd = frameSequence / 25;  				int mn = secd / 60;  				secd = frameSequence / 25 - 60 * mn;  				int fr = frameSequence - 25 * secd;  				s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  				///Saving the current sequence  				s.endFrame = (int)numtr - 1;  				s.validDate = correct;  				sequences.Add (s);  				//new sequence  				numSequence += 1;  				s = new SEQUENCE ();  				s.seqNumber = numSequence;  				s.startFrame = (int)numtr;  				s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  				prevFrame = currentFrameNumber;  				frameSequence = 0;  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  			frameSequence += 1;  			beforeFrame = oldFrame;  			oldFrame = newFrame;  			oldFrameLoc = frameLoc;  			currentFrameNumber += 1;  			// Correction  		}  		// Jump to Change candidate frame  		aviFile.Seek (buf - 500' SeekOrigin.Current);  		frameStart += 1;  		framCount += 1;  		numtr++;  	}  	// Prepare Change frame  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  }  while (numtr < endFrame);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: do {  	while (ch != vidstr) {  		if (numtr >= endFrame)  			break;  		if (ch == "01wb") {  			aviFile.Read (ckid' 0' len);  			audLen = ByteToi (ckid);  			aviFile.Seek (audLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  			if ((framCount < 24) && (numtr > 24)) {  				// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  				// manque trois frames entre deux audios au frame 15046  				numtr += (25 - framCount);  			}  			framCount = 0;  		}  		if (ch == "RIFF") {  		}  		if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  			//skipping index codeBuffer  			aviFile.Read (ckid' 0' len);  			long indLen = ByteToi (ckid);  			aviFile.Seek (indLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  		}  		if (aviFile.Read (ckid' 0' len) < 0)  			return;  		ch = ByteTos (ckid);  		if (aviFile.Position >= aviFile.Length)  			break;  	}  	startOldFrame = startNewFrame;  	startNewFrame = aviFile.Position;  	ch = "";  	//One more frame has been found and can be analyzed  	sizeFrame = startNewFrame - startOldFrame;  	aviFile.Read (ckid' 0' len);  	vidLen = (int)ByteToi (ckid);  	if (vidLen == 144000) {  		aviFile.Read (vauxdata' 0' 500);  		if (vauxdata [0x1CA] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  			newFrame = timeData [0];  			frameLoc = timeData [1];  			//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  			// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  			if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  				//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  				//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  				int secd = frameSequence / 25;  				int mn = secd / 60;  				secd = frameSequence / 25 - 60 * mn;  				int fr = frameSequence - 25 * secd;  				s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  				///Saving the current sequence  				s.endFrame = (int)numtr - 1;  				s.validDate = correct;  				sequences.Add (s);  				//new sequence  				numSequence += 1;  				s = new SEQUENCE ();  				s.seqNumber = numSequence;  				s.startFrame = (int)numtr;  				s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  				prevFrame = currentFrameNumber;  				frameSequence = 0;  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  			frameSequence += 1;  			beforeFrame = oldFrame;  			oldFrame = newFrame;  			oldFrameLoc = frameLoc;  			currentFrameNumber += 1;  			// Correction  		}  		// Jump to Change candidate frame  		aviFile.Seek (buf - 500' SeekOrigin.Current);  		frameStart += 1;  		framCount += 1;  		numtr++;  	}  	// Prepare Change frame  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  }  while (numtr < endFrame);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: do {  	while (ch != vidstr) {  		if (numtr >= endFrame)  			break;  		if (ch == "01wb") {  			aviFile.Read (ckid' 0' len);  			audLen = ByteToi (ckid);  			aviFile.Seek (audLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  			if ((framCount < 24) && (numtr > 24)) {  				// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  				// manque trois frames entre deux audios au frame 15046  				numtr += (25 - framCount);  			}  			framCount = 0;  		}  		if (ch == "RIFF") {  		}  		if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  			//skipping index codeBuffer  			aviFile.Read (ckid' 0' len);  			long indLen = ByteToi (ckid);  			aviFile.Seek (indLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  		}  		if (aviFile.Read (ckid' 0' len) < 0)  			return;  		ch = ByteTos (ckid);  		if (aviFile.Position >= aviFile.Length)  			break;  	}  	startOldFrame = startNewFrame;  	startNewFrame = aviFile.Position;  	ch = "";  	//One more frame has been found and can be analyzed  	sizeFrame = startNewFrame - startOldFrame;  	aviFile.Read (ckid' 0' len);  	vidLen = (int)ByteToi (ckid);  	if (vidLen == 144000) {  		aviFile.Read (vauxdata' 0' 500);  		if (vauxdata [0x1CA] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  			newFrame = timeData [0];  			frameLoc = timeData [1];  			//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  			// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  			if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  				//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  				//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  				int secd = frameSequence / 25;  				int mn = secd / 60;  				secd = frameSequence / 25 - 60 * mn;  				int fr = frameSequence - 25 * secd;  				s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  				///Saving the current sequence  				s.endFrame = (int)numtr - 1;  				s.validDate = correct;  				sequences.Add (s);  				//new sequence  				numSequence += 1;  				s = new SEQUENCE ();  				s.seqNumber = numSequence;  				s.startFrame = (int)numtr;  				s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  				prevFrame = currentFrameNumber;  				frameSequence = 0;  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  			frameSequence += 1;  			beforeFrame = oldFrame;  			oldFrame = newFrame;  			oldFrameLoc = frameLoc;  			currentFrameNumber += 1;  			// Correction  		}  		// Jump to Change candidate frame  		aviFile.Seek (buf - 500' SeekOrigin.Current);  		frameStart += 1;  		framCount += 1;  		numtr++;  	}  	// Prepare Change frame  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  }  while (numtr < endFrame);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: do {  	while (ch != vidstr) {  		if (numtr >= endFrame)  			break;  		if (ch == "01wb") {  			aviFile.Read (ckid' 0' len);  			audLen = ByteToi (ckid);  			aviFile.Seek (audLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  			if ((framCount < 24) && (numtr > 24)) {  				// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  				// manque trois frames entre deux audios au frame 15046  				numtr += (25 - framCount);  			}  			framCount = 0;  		}  		if (ch == "RIFF") {  		}  		if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  			//skipping index codeBuffer  			aviFile.Read (ckid' 0' len);  			long indLen = ByteToi (ckid);  			aviFile.Seek (indLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  		}  		if (aviFile.Read (ckid' 0' len) < 0)  			return;  		ch = ByteTos (ckid);  		if (aviFile.Position >= aviFile.Length)  			break;  	}  	startOldFrame = startNewFrame;  	startNewFrame = aviFile.Position;  	ch = "";  	//One more frame has been found and can be analyzed  	sizeFrame = startNewFrame - startOldFrame;  	aviFile.Read (ckid' 0' len);  	vidLen = (int)ByteToi (ckid);  	if (vidLen == 144000) {  		aviFile.Read (vauxdata' 0' 500);  		if (vauxdata [0x1CA] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  			newFrame = timeData [0];  			frameLoc = timeData [1];  			//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  			// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  			if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  				//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  				//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  				int secd = frameSequence / 25;  				int mn = secd / 60;  				secd = frameSequence / 25 - 60 * mn;  				int fr = frameSequence - 25 * secd;  				s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  				///Saving the current sequence  				s.endFrame = (int)numtr - 1;  				s.validDate = correct;  				sequences.Add (s);  				//new sequence  				numSequence += 1;  				s = new SEQUENCE ();  				s.seqNumber = numSequence;  				s.startFrame = (int)numtr;  				s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  				prevFrame = currentFrameNumber;  				frameSequence = 0;  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  			frameSequence += 1;  			beforeFrame = oldFrame;  			oldFrame = newFrame;  			oldFrameLoc = frameLoc;  			currentFrameNumber += 1;  			// Correction  		}  		// Jump to Change candidate frame  		aviFile.Seek (buf - 500' SeekOrigin.Current);  		frameStart += 1;  		framCount += 1;  		numtr++;  	}  	// Prepare Change frame  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  }  while (numtr < endFrame);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: do {  	while (ch != vidstr) {  		if (numtr >= endFrame)  			break;  		if (ch == "01wb") {  			aviFile.Read (ckid' 0' len);  			audLen = ByteToi (ckid);  			aviFile.Seek (audLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  			if ((framCount < 24) && (numtr > 24)) {  				// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  				// manque trois frames entre deux audios au frame 15046  				numtr += (25 - framCount);  			}  			framCount = 0;  		}  		if (ch == "RIFF") {  		}  		if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  			//skipping index codeBuffer  			aviFile.Read (ckid' 0' len);  			long indLen = ByteToi (ckid);  			aviFile.Seek (indLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  		}  		if (aviFile.Read (ckid' 0' len) < 0)  			return;  		ch = ByteTos (ckid);  		if (aviFile.Position >= aviFile.Length)  			break;  	}  	startOldFrame = startNewFrame;  	startNewFrame = aviFile.Position;  	ch = "";  	//One more frame has been found and can be analyzed  	sizeFrame = startNewFrame - startOldFrame;  	aviFile.Read (ckid' 0' len);  	vidLen = (int)ByteToi (ckid);  	if (vidLen == 144000) {  		aviFile.Read (vauxdata' 0' 500);  		if (vauxdata [0x1CA] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  			newFrame = timeData [0];  			frameLoc = timeData [1];  			//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  			// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  			if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  				//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  				//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  				int secd = frameSequence / 25;  				int mn = secd / 60;  				secd = frameSequence / 25 - 60 * mn;  				int fr = frameSequence - 25 * secd;  				s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  				///Saving the current sequence  				s.endFrame = (int)numtr - 1;  				s.validDate = correct;  				sequences.Add (s);  				//new sequence  				numSequence += 1;  				s = new SEQUENCE ();  				s.seqNumber = numSequence;  				s.startFrame = (int)numtr;  				s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  				prevFrame = currentFrameNumber;  				frameSequence = 0;  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  			frameSequence += 1;  			beforeFrame = oldFrame;  			oldFrame = newFrame;  			oldFrameLoc = frameLoc;  			currentFrameNumber += 1;  			// Correction  		}  		// Jump to Change candidate frame  		aviFile.Seek (buf - 500' SeekOrigin.Current);  		frameStart += 1;  		framCount += 1;  		numtr++;  	}  	// Prepare Change frame  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  }  while (numtr < endFrame);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: do {  	while (ch != vidstr) {  		if (numtr >= endFrame)  			break;  		if (ch == "01wb") {  			aviFile.Read (ckid' 0' len);  			audLen = ByteToi (ckid);  			aviFile.Seek (audLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  			if ((framCount < 24) && (numtr > 24)) {  				// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  				// manque trois frames entre deux audios au frame 15046  				numtr += (25 - framCount);  			}  			framCount = 0;  		}  		if (ch == "RIFF") {  		}  		if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  			//skipping index codeBuffer  			aviFile.Read (ckid' 0' len);  			long indLen = ByteToi (ckid);  			aviFile.Seek (indLen' SeekOrigin.Current);  			startNewFrame = aviFile.Position;  		}  		if (aviFile.Read (ckid' 0' len) < 0)  			return;  		ch = ByteTos (ckid);  		if (aviFile.Position >= aviFile.Length)  			break;  	}  	startOldFrame = startNewFrame;  	startNewFrame = aviFile.Position;  	ch = "";  	//One more frame has been found and can be analyzed  	sizeFrame = startNewFrame - startOldFrame;  	aviFile.Read (ckid' 0' len);  	vidLen = (int)ByteToi (ckid);  	if (vidLen == 144000) {  		aviFile.Read (vauxdata' 0' 500);  		if (vauxdata [0x1CA] == 0x62) {  			DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  			newFrame = timeData [0];  			frameLoc = timeData [1];  			//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  			// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  			if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  				//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  				//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  				int secd = frameSequence / 25;  				int mn = secd / 60;  				secd = frameSequence / 25 - 60 * mn;  				int fr = frameSequence - 25 * secd;  				s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  				///Saving the current sequence  				s.endFrame = (int)numtr - 1;  				s.validDate = correct;  				sequences.Add (s);  				//new sequence  				numSequence += 1;  				s = new SEQUENCE ();  				s.seqNumber = numSequence;  				s.startFrame = (int)numtr;  				s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  				prevFrame = currentFrameNumber;  				frameSequence = 0;  			}  			frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  			frameSequence += 1;  			beforeFrame = oldFrame;  			oldFrame = newFrame;  			oldFrameLoc = frameLoc;  			currentFrameNumber += 1;  			// Correction  		}  		// Jump to Change candidate frame  		aviFile.Seek (buf - 500' SeekOrigin.Current);  		frameStart += 1;  		framCount += 1;  		numtr++;  	}  	// Prepare Change frame  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  }  while (numtr < endFrame);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: while (ch != vidstr) {  	if (numtr >= endFrame)  		break;  	if (ch == "01wb") {  		aviFile.Read (ckid' 0' len);  		audLen = ByteToi (ckid);  		aviFile.Seek (audLen' SeekOrigin.Current);  		startNewFrame = aviFile.Position;  		if ((framCount < 24) && (numtr > 24)) {  			// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  			// manque trois frames entre deux audios au frame 15046  			numtr += (25 - framCount);  		}  		framCount = 0;  	}  	if (ch == "RIFF") {  	}  	if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  		//skipping index codeBuffer  		aviFile.Read (ckid' 0' len);  		long indLen = ByteToi (ckid);  		aviFile.Seek (indLen' SeekOrigin.Current);  		startNewFrame = aviFile.Position;  	}  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  	if (aviFile.Position >= aviFile.Length)  		break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: while (ch != vidstr) {  	if (numtr >= endFrame)  		break;  	if (ch == "01wb") {  		aviFile.Read (ckid' 0' len);  		audLen = ByteToi (ckid);  		aviFile.Seek (audLen' SeekOrigin.Current);  		startNewFrame = aviFile.Position;  		if ((framCount < 24) && (numtr > 24)) {  			// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  			// manque trois frames entre deux audios au frame 15046  			numtr += (25 - framCount);  		}  		framCount = 0;  	}  	if (ch == "RIFF") {  	}  	if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  		//skipping index codeBuffer  		aviFile.Read (ckid' 0' len);  		long indLen = ByteToi (ckid);  		aviFile.Seek (indLen' SeekOrigin.Current);  		startNewFrame = aviFile.Position;  	}  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  	if (aviFile.Position >= aviFile.Length)  		break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: while (ch != vidstr) {  	if (numtr >= endFrame)  		break;  	if (ch == "01wb") {  		aviFile.Read (ckid' 0' len);  		audLen = ByteToi (ckid);  		aviFile.Seek (audLen' SeekOrigin.Current);  		startNewFrame = aviFile.Position;  		if ((framCount < 24) && (numtr > 24)) {  			// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  			// manque trois frames entre deux audios au frame 15046  			numtr += (25 - framCount);  		}  		framCount = 0;  	}  	if (ch == "RIFF") {  	}  	if ((ch == "ix00") || (ch == "ix01") || (ch == "00ix") || (ch == "01ix") || (ch == "idx1") || (ch == "idx0")) {  		//skipping index codeBuffer  		aviFile.Read (ckid' 0' len);  		long indLen = ByteToi (ckid);  		aviFile.Seek (indLen' SeekOrigin.Current);  		startNewFrame = aviFile.Position;  	}  	if (aviFile.Read (ckid' 0' len) < 0)  		return;  	ch = ByteTos (ckid);  	if (aviFile.Position >= aviFile.Length)  		break;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (ch == "01wb") {  	aviFile.Read (ckid' 0' len);  	audLen = ByteToi (ckid);  	aviFile.Seek (audLen' SeekOrigin.Current);  	startNewFrame = aviFile.Position;  	if ((framCount < 24) && (numtr > 24)) {  		// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  		// manque trois frames entre deux audios au frame 15046  		numtr += (25 - framCount);  	}  	framCount = 0;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (ch == "01wb") {  	aviFile.Read (ckid' 0' len);  	audLen = ByteToi (ckid);  	aviFile.Seek (audLen' SeekOrigin.Current);  	startNewFrame = aviFile.Position;  	if ((framCount < 24) && (numtr > 24)) {  		// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  		// manque trois frames entre deux audios au frame 15046  		numtr += (25 - framCount);  	}  	framCount = 0;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (ch == "01wb") {  	aviFile.Read (ckid' 0' len);  	audLen = ByteToi (ckid);  	aviFile.Seek (audLen' SeekOrigin.Current);  	startNewFrame = aviFile.Position;  	if ((framCount < 24) && (numtr > 24)) {  		// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  		// manque trois frames entre deux audios au frame 15046  		numtr += (25 - framCount);  	}  	framCount = 0;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if ((framCount < 24) && (numtr > 24)) {  	// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  	// manque trois frames entre deux audios au frame 15046  	numtr += (25 - framCount);  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if ((framCount < 24) && (numtr > 24)) {  	// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  	// manque trois frames entre deux audios au frame 15046  	numtr += (25 - framCount);  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if ((framCount < 24) && (numtr > 24)) {  	// utile dans un cas : yunnan2.avi' problme frame 15067 au lieu de 15064  	// manque trois frames entre deux audios au frame 15046  	numtr += (25 - framCount);  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: numtr += (25 - framCount);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vidLen == 144000) {  	aviFile.Read (vauxdata' 0' 500);  	if (vauxdata [0x1CA] == 0x62) {  		DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  		newFrame = timeData [0];  		frameLoc = timeData [1];  		//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  		// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  		if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  			//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  			//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  			int secd = frameSequence / 25;  			int mn = secd / 60;  			secd = frameSequence / 25 - 60 * mn;  			int fr = frameSequence - 25 * secd;  			s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  			///Saving the current sequence  			s.endFrame = (int)numtr - 1;  			s.validDate = correct;  			sequences.Add (s);  			//new sequence  			numSequence += 1;  			s = new SEQUENCE ();  			s.seqNumber = numSequence;  			s.startFrame = (int)numtr;  			s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  			prevFrame = currentFrameNumber;  			frameSequence = 0;  		}  		frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  		frameSequence += 1;  		beforeFrame = oldFrame;  		oldFrame = newFrame;  		oldFrameLoc = frameLoc;  		currentFrameNumber += 1;  		// Correction  	}  	// Jump to Change candidate frame  	aviFile.Seek (buf - 500' SeekOrigin.Current);  	frameStart += 1;  	framCount += 1;  	numtr++;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vidLen == 144000) {  	aviFile.Read (vauxdata' 0' 500);  	if (vauxdata [0x1CA] == 0x62) {  		DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  		newFrame = timeData [0];  		frameLoc = timeData [1];  		//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  		// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  		if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  			//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  			//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  			int secd = frameSequence / 25;  			int mn = secd / 60;  			secd = frameSequence / 25 - 60 * mn;  			int fr = frameSequence - 25 * secd;  			s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  			///Saving the current sequence  			s.endFrame = (int)numtr - 1;  			s.validDate = correct;  			sequences.Add (s);  			//new sequence  			numSequence += 1;  			s = new SEQUENCE ();  			s.seqNumber = numSequence;  			s.startFrame = (int)numtr;  			s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  			prevFrame = currentFrameNumber;  			frameSequence = 0;  		}  		frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  		frameSequence += 1;  		beforeFrame = oldFrame;  		oldFrame = newFrame;  		oldFrameLoc = frameLoc;  		currentFrameNumber += 1;  		// Correction  	}  	// Jump to Change candidate frame  	aviFile.Seek (buf - 500' SeekOrigin.Current);  	frameStart += 1;  	framCount += 1;  	numtr++;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vidLen == 144000) {  	aviFile.Read (vauxdata' 0' 500);  	if (vauxdata [0x1CA] == 0x62) {  		DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  		newFrame = timeData [0];  		frameLoc = timeData [1];  		//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  		// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  		if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  			//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  			//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  			int secd = frameSequence / 25;  			int mn = secd / 60;  			secd = frameSequence / 25 - 60 * mn;  			int fr = frameSequence - 25 * secd;  			s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  			///Saving the current sequence  			s.endFrame = (int)numtr - 1;  			s.validDate = correct;  			sequences.Add (s);  			//new sequence  			numSequence += 1;  			s = new SEQUENCE ();  			s.seqNumber = numSequence;  			s.startFrame = (int)numtr;  			s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  			prevFrame = currentFrameNumber;  			frameSequence = 0;  		}  		frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  		frameSequence += 1;  		beforeFrame = oldFrame;  		oldFrame = newFrame;  		oldFrameLoc = frameLoc;  		currentFrameNumber += 1;  		// Correction  	}  	// Jump to Change candidate frame  	aviFile.Seek (buf - 500' SeekOrigin.Current);  	frameStart += 1;  	framCount += 1;  	numtr++;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vidLen == 144000) {  	aviFile.Read (vauxdata' 0' 500);  	if (vauxdata [0x1CA] == 0x62) {  		DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  		newFrame = timeData [0];  		frameLoc = timeData [1];  		//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  		// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  		if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  			//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  			//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  			int secd = frameSequence / 25;  			int mn = secd / 60;  			secd = frameSequence / 25 - 60 * mn;  			int fr = frameSequence - 25 * secd;  			s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  			///Saving the current sequence  			s.endFrame = (int)numtr - 1;  			s.validDate = correct;  			sequences.Add (s);  			//new sequence  			numSequence += 1;  			s = new SEQUENCE ();  			s.seqNumber = numSequence;  			s.startFrame = (int)numtr;  			s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  			prevFrame = currentFrameNumber;  			frameSequence = 0;  		}  		frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  		frameSequence += 1;  		beforeFrame = oldFrame;  		oldFrame = newFrame;  		oldFrameLoc = frameLoc;  		currentFrameNumber += 1;  		// Correction  	}  	// Jump to Change candidate frame  	aviFile.Seek (buf - 500' SeekOrigin.Current);  	frameStart += 1;  	framCount += 1;  	numtr++;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vidLen == 144000) {  	aviFile.Read (vauxdata' 0' 500);  	if (vauxdata [0x1CA] == 0x62) {  		DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  		newFrame = timeData [0];  		frameLoc = timeData [1];  		//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  		// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  		if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  			//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  			//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  			int secd = frameSequence / 25;  			int mn = secd / 60;  			secd = frameSequence / 25 - 60 * mn;  			int fr = frameSequence - 25 * secd;  			s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  			///Saving the current sequence  			s.endFrame = (int)numtr - 1;  			s.validDate = correct;  			sequences.Add (s);  			//new sequence  			numSequence += 1;  			s = new SEQUENCE ();  			s.seqNumber = numSequence;  			s.startFrame = (int)numtr;  			s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  			prevFrame = currentFrameNumber;  			frameSequence = 0;  		}  		frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  		frameSequence += 1;  		beforeFrame = oldFrame;  		oldFrame = newFrame;  		oldFrameLoc = frameLoc;  		currentFrameNumber += 1;  		// Correction  	}  	// Jump to Change candidate frame  	aviFile.Seek (buf - 500' SeekOrigin.Current);  	frameStart += 1;  	framCount += 1;  	numtr++;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vidLen == 144000) {  	aviFile.Read (vauxdata' 0' 500);  	if (vauxdata [0x1CA] == 0x62) {  		DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  		newFrame = timeData [0];  		frameLoc = timeData [1];  		//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  		// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  		if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  			//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  			//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  			int secd = frameSequence / 25;  			int mn = secd / 60;  			secd = frameSequence / 25 - 60 * mn;  			int fr = frameSequence - 25 * secd;  			s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  			///Saving the current sequence  			s.endFrame = (int)numtr - 1;  			s.validDate = correct;  			sequences.Add (s);  			//new sequence  			numSequence += 1;  			s = new SEQUENCE ();  			s.seqNumber = numSequence;  			s.startFrame = (int)numtr;  			s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  			prevFrame = currentFrameNumber;  			frameSequence = 0;  		}  		frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  		frameSequence += 1;  		beforeFrame = oldFrame;  		oldFrame = newFrame;  		oldFrameLoc = frameLoc;  		currentFrameNumber += 1;  		// Correction  	}  	// Jump to Change candidate frame  	aviFile.Seek (buf - 500' SeekOrigin.Current);  	frameStart += 1;  	framCount += 1;  	numtr++;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vidLen == 144000) {  	aviFile.Read (vauxdata' 0' 500);  	if (vauxdata [0x1CA] == 0x62) {  		DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  		newFrame = timeData [0];  		frameLoc = timeData [1];  		//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  		// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  		if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  			//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  			//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  			int secd = frameSequence / 25;  			int mn = secd / 60;  			secd = frameSequence / 25 - 60 * mn;  			int fr = frameSequence - 25 * secd;  			s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  			///Saving the current sequence  			s.endFrame = (int)numtr - 1;  			s.validDate = correct;  			sequences.Add (s);  			//new sequence  			numSequence += 1;  			s = new SEQUENCE ();  			s.seqNumber = numSequence;  			s.startFrame = (int)numtr;  			s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  			prevFrame = currentFrameNumber;  			frameSequence = 0;  		}  		frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  		frameSequence += 1;  		beforeFrame = oldFrame;  		oldFrame = newFrame;  		oldFrameLoc = frameLoc;  		currentFrameNumber += 1;  		// Correction  	}  	// Jump to Change candidate frame  	aviFile.Seek (buf - 500' SeekOrigin.Current);  	frameStart += 1;  	framCount += 1;  	numtr++;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vidLen == 144000) {  	aviFile.Read (vauxdata' 0' 500);  	if (vauxdata [0x1CA] == 0x62) {  		DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  		newFrame = timeData [0];  		frameLoc = timeData [1];  		//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  		// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  		if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  			//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  			//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  			int secd = frameSequence / 25;  			int mn = secd / 60;  			secd = frameSequence / 25 - 60 * mn;  			int fr = frameSequence - 25 * secd;  			s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  			///Saving the current sequence  			s.endFrame = (int)numtr - 1;  			s.validDate = correct;  			sequences.Add (s);  			//new sequence  			numSequence += 1;  			s = new SEQUENCE ();  			s.seqNumber = numSequence;  			s.startFrame = (int)numtr;  			s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  			prevFrame = currentFrameNumber;  			frameSequence = 0;  		}  		frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  		frameSequence += 1;  		beforeFrame = oldFrame;  		oldFrame = newFrame;  		oldFrameLoc = frameLoc;  		currentFrameNumber += 1;  		// Correction  	}  	// Jump to Change candidate frame  	aviFile.Seek (buf - 500' SeekOrigin.Current);  	frameStart += 1;  	framCount += 1;  	numtr++;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vidLen == 144000) {  	aviFile.Read (vauxdata' 0' 500);  	if (vauxdata [0x1CA] == 0x62) {  		DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  		newFrame = timeData [0];  		frameLoc = timeData [1];  		//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  		// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  		if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  			//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  			//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  			int secd = frameSequence / 25;  			int mn = secd / 60;  			secd = frameSequence / 25 - 60 * mn;  			int fr = frameSequence - 25 * secd;  			s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  			///Saving the current sequence  			s.endFrame = (int)numtr - 1;  			s.validDate = correct;  			sequences.Add (s);  			//new sequence  			numSequence += 1;  			s = new SEQUENCE ();  			s.seqNumber = numSequence;  			s.startFrame = (int)numtr;  			s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  			prevFrame = currentFrameNumber;  			frameSequence = 0;  		}  		frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  		frameSequence += 1;  		beforeFrame = oldFrame;  		oldFrame = newFrame;  		oldFrameLoc = frameLoc;  		currentFrameNumber += 1;  		// Correction  	}  	// Jump to Change candidate frame  	aviFile.Seek (buf - 500' SeekOrigin.Current);  	frameStart += 1;  	framCount += 1;  	numtr++;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vidLen == 144000) {  	aviFile.Read (vauxdata' 0' 500);  	if (vauxdata [0x1CA] == 0x62) {  		DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  		newFrame = timeData [0];  		frameLoc = timeData [1];  		//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  		// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  		if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  			//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  			//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  			int secd = frameSequence / 25;  			int mn = secd / 60;  			secd = frameSequence / 25 - 60 * mn;  			int fr = frameSequence - 25 * secd;  			s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  			///Saving the current sequence  			s.endFrame = (int)numtr - 1;  			s.validDate = correct;  			sequences.Add (s);  			//new sequence  			numSequence += 1;  			s = new SEQUENCE ();  			s.seqNumber = numSequence;  			s.startFrame = (int)numtr;  			s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  			prevFrame = currentFrameNumber;  			frameSequence = 0;  		}  		frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  		frameSequence += 1;  		beforeFrame = oldFrame;  		oldFrame = newFrame;  		oldFrameLoc = frameLoc;  		currentFrameNumber += 1;  		// Correction  	}  	// Jump to Change candidate frame  	aviFile.Seek (buf - 500' SeekOrigin.Current);  	frameStart += 1;  	framCount += 1;  	numtr++;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: aviFile.Read (vauxdata' 0' 500);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vauxdata [0x1CA] == 0x62) {  	DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  	newFrame = timeData [0];  	frameLoc = timeData [1];  	//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  	// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  	if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  		//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  		//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  		int secd = frameSequence / 25;  		int mn = secd / 60;  		secd = frameSequence / 25 - 60 * mn;  		int fr = frameSequence - 25 * secd;  		s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  		///Saving the current sequence  		s.endFrame = (int)numtr - 1;  		s.validDate = correct;  		sequences.Add (s);  		//new sequence  		numSequence += 1;  		s = new SEQUENCE ();  		s.seqNumber = numSequence;  		s.startFrame = (int)numtr;  		s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  		prevFrame = currentFrameNumber;  		frameSequence = 0;  	}  	frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  	frameSequence += 1;  	beforeFrame = oldFrame;  	oldFrame = newFrame;  	oldFrameLoc = frameLoc;  	currentFrameNumber += 1;  	// Correction  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vauxdata [0x1CA] == 0x62) {  	DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  	newFrame = timeData [0];  	frameLoc = timeData [1];  	//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  	// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  	if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  		//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  		//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  		int secd = frameSequence / 25;  		int mn = secd / 60;  		secd = frameSequence / 25 - 60 * mn;  		int fr = frameSequence - 25 * secd;  		s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  		///Saving the current sequence  		s.endFrame = (int)numtr - 1;  		s.validDate = correct;  		sequences.Add (s);  		//new sequence  		numSequence += 1;  		s = new SEQUENCE ();  		s.seqNumber = numSequence;  		s.startFrame = (int)numtr;  		s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  		prevFrame = currentFrameNumber;  		frameSequence = 0;  	}  	frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  	frameSequence += 1;  	beforeFrame = oldFrame;  	oldFrame = newFrame;  	oldFrameLoc = frameLoc;  	currentFrameNumber += 1;  	// Correction  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vauxdata [0x1CA] == 0x62) {  	DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  	newFrame = timeData [0];  	frameLoc = timeData [1];  	//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  	// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  	if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  		//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  		//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  		int secd = frameSequence / 25;  		int mn = secd / 60;  		secd = frameSequence / 25 - 60 * mn;  		int fr = frameSequence - 25 * secd;  		s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  		///Saving the current sequence  		s.endFrame = (int)numtr - 1;  		s.validDate = correct;  		sequences.Add (s);  		//new sequence  		numSequence += 1;  		s = new SEQUENCE ();  		s.seqNumber = numSequence;  		s.startFrame = (int)numtr;  		s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  		prevFrame = currentFrameNumber;  		frameSequence = 0;  	}  	frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  	frameSequence += 1;  	beforeFrame = oldFrame;  	oldFrame = newFrame;  	oldFrameLoc = frameLoc;  	currentFrameNumber += 1;  	// Correction  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vauxdata [0x1CA] == 0x62) {  	DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  	newFrame = timeData [0];  	frameLoc = timeData [1];  	//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  	// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  	if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  		//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  		//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  		int secd = frameSequence / 25;  		int mn = secd / 60;  		secd = frameSequence / 25 - 60 * mn;  		int fr = frameSequence - 25 * secd;  		s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  		///Saving the current sequence  		s.endFrame = (int)numtr - 1;  		s.validDate = correct;  		sequences.Add (s);  		//new sequence  		numSequence += 1;  		s = new SEQUENCE ();  		s.seqNumber = numSequence;  		s.startFrame = (int)numtr;  		s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  		prevFrame = currentFrameNumber;  		frameSequence = 0;  	}  	frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  	frameSequence += 1;  	beforeFrame = oldFrame;  	oldFrame = newFrame;  	oldFrameLoc = frameLoc;  	currentFrameNumber += 1;  	// Correction  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vauxdata [0x1CA] == 0x62) {  	DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  	newFrame = timeData [0];  	frameLoc = timeData [1];  	//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  	// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  	if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  		//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  		//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  		int secd = frameSequence / 25;  		int mn = secd / 60;  		secd = frameSequence / 25 - 60 * mn;  		int fr = frameSequence - 25 * secd;  		s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  		///Saving the current sequence  		s.endFrame = (int)numtr - 1;  		s.validDate = correct;  		sequences.Add (s);  		//new sequence  		numSequence += 1;  		s = new SEQUENCE ();  		s.seqNumber = numSequence;  		s.startFrame = (int)numtr;  		s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  		prevFrame = currentFrameNumber;  		frameSequence = 0;  	}  	frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  	frameSequence += 1;  	beforeFrame = oldFrame;  	oldFrame = newFrame;  	oldFrameLoc = frameLoc;  	currentFrameNumber += 1;  	// Correction  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vauxdata [0x1CA] == 0x62) {  	DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  	newFrame = timeData [0];  	frameLoc = timeData [1];  	//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  	// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  	if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  		//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  		//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  		int secd = frameSequence / 25;  		int mn = secd / 60;  		secd = frameSequence / 25 - 60 * mn;  		int fr = frameSequence - 25 * secd;  		s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  		///Saving the current sequence  		s.endFrame = (int)numtr - 1;  		s.validDate = correct;  		sequences.Add (s);  		//new sequence  		numSequence += 1;  		s = new SEQUENCE ();  		s.seqNumber = numSequence;  		s.startFrame = (int)numtr;  		s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  		prevFrame = currentFrameNumber;  		frameSequence = 0;  	}  	frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  	frameSequence += 1;  	beforeFrame = oldFrame;  	oldFrame = newFrame;  	oldFrameLoc = frameLoc;  	currentFrameNumber += 1;  	// Correction  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if (vauxdata [0x1CA] == 0x62) {  	DateTime[] timeData = ComputeCodeAndStampFrame (vauxdata' 0x1CA);  	newFrame = timeData [0];  	frameLoc = timeData [1];  	//                        Trace.WriteLine(framCount.ToString() + " " + numtr.ToString() + " " + frameNb.ToString() + " " + frameStart.ToString() + " " + vidLen.ToString() + " " + sizeFrame.ToString() + " " + frameLoc.ToLongTimeString() + " " + newFrame.ToLongTimeString());  	// Criterion : timestamp has changed' for more than one second - Le + 5 sert pour shanghai 200503 02.avi  vrifier ?  	if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  		//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  		//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  		int secd = frameSequence / 25;  		int mn = secd / 60;  		secd = frameSequence / 25 - 60 * mn;  		int fr = frameSequence - 25 * secd;  		s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  		///Saving the current sequence  		s.endFrame = (int)numtr - 1;  		s.validDate = correct;  		sequences.Add (s);  		//new sequence  		numSequence += 1;  		s = new SEQUENCE ();  		s.seqNumber = numSequence;  		s.startFrame = (int)numtr;  		s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  		prevFrame = currentFrameNumber;  		frameSequence = 0;  	}  	frameList.Add (currentFrameNumber' new FrameData (currentFrameNumber' newFrame' frameLoc));  	frameSequence += 1;  	beforeFrame = oldFrame;  	oldFrame = newFrame;  	oldFrameLoc = frameLoc;  	currentFrameNumber += 1;  	// Correction  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  	//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  	//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  	int secd = frameSequence / 25;  	int mn = secd / 60;  	secd = frameSequence / 25 - 60 * mn;  	int fr = frameSequence - 25 * secd;  	s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  	///Saving the current sequence  	s.endFrame = (int)numtr - 1;  	s.validDate = correct;  	sequences.Add (s);  	//new sequence  	numSequence += 1;  	s = new SEQUENCE ();  	s.seqNumber = numSequence;  	s.startFrame = (int)numtr;  	s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  	prevFrame = currentFrameNumber;  	frameSequence = 0;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  	//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  	//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  	int secd = frameSequence / 25;  	int mn = secd / 60;  	secd = frameSequence / 25 - 60 * mn;  	int fr = frameSequence - 25 * secd;  	s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  	///Saving the current sequence  	s.endFrame = (int)numtr - 1;  	s.validDate = correct;  	sequences.Add (s);  	//new sequence  	numSequence += 1;  	s = new SEQUENCE ();  	s.seqNumber = numSequence;  	s.startFrame = (int)numtr;  	s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  	prevFrame = currentFrameNumber;  	frameSequence = 0;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  	//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  	//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  	int secd = frameSequence / 25;  	int mn = secd / 60;  	secd = frameSequence / 25 - 60 * mn;  	int fr = frameSequence - 25 * secd;  	s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  	///Saving the current sequence  	s.endFrame = (int)numtr - 1;  	s.validDate = correct;  	sequences.Add (s);  	//new sequence  	numSequence += 1;  	s = new SEQUENCE ();  	s.seqNumber = numSequence;  	s.startFrame = (int)numtr;  	s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  	prevFrame = currentFrameNumber;  	frameSequence = 0;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  	//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  	//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  	int secd = frameSequence / 25;  	int mn = secd / 60;  	secd = frameSequence / 25 - 60 * mn;  	int fr = frameSequence - 25 * secd;  	s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  	///Saving the current sequence  	s.endFrame = (int)numtr - 1;  	s.validDate = correct;  	sequences.Add (s);  	//new sequence  	numSequence += 1;  	s = new SEQUENCE ();  	s.seqNumber = numSequence;  	s.startFrame = (int)numtr;  	s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  	prevFrame = currentFrameNumber;  	frameSequence = 0;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  	//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  	//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  	int secd = frameSequence / 25;  	int mn = secd / 60;  	secd = frameSequence / 25 - 60 * mn;  	int fr = frameSequence - 25 * secd;  	s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  	///Saving the current sequence  	s.endFrame = (int)numtr - 1;  	s.validDate = correct;  	sequences.Add (s);  	//new sequence  	numSequence += 1;  	s = new SEQUENCE ();  	s.seqNumber = numSequence;  	s.startFrame = (int)numtr;  	s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  	prevFrame = currentFrameNumber;  	frameSequence = 0;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  	//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  	//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  	int secd = frameSequence / 25;  	int mn = secd / 60;  	secd = frameSequence / 25 - 60 * mn;  	int fr = frameSequence - 25 * secd;  	s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  	///Saving the current sequence  	s.endFrame = (int)numtr - 1;  	s.validDate = correct;  	sequences.Add (s);  	//new sequence  	numSequence += 1;  	s = new SEQUENCE ();  	s.seqNumber = numSequence;  	s.startFrame = (int)numtr;  	s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  	prevFrame = currentFrameNumber;  	frameSequence = 0;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: if ((currentFrameNumber > 1) && (newFrame != beforeFrame) && (newFrame != oldFrame) && ((newFrame > oldFrame.Add (new TimeSpan (0' 0' 1))) || newFrame < oldFrame) && (currentFrameNumber >= prevFrame + 5)) {  	//                           NewSequence(this'new SequenceEventArgs(fr.timeStamp'fr.timeCode'frNb'lineRead.seqNumber));  	//                            Trace.WriteLine("Nouvelle SEQUENCE " + numtr.ToString() + " " + frameStart.ToString() + "xxxxxxxxxxxxxxxxx");  	int secd = frameSequence / 25;  	int mn = secd / 60;  	secd = frameSequence / 25 - 60 * mn;  	int fr = frameSequence - 25 * secd;  	s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  	///Saving the current sequence  	s.endFrame = (int)numtr - 1;  	s.validDate = correct;  	sequences.Add (s);  	//new sequence  	numSequence += 1;  	s = new SEQUENCE ();  	s.seqNumber = numSequence;  	s.startFrame = (int)numtr;  	s.timeStamp = (correct ? newFrame : DateTime.MaxValue);  	prevFrame = currentFrameNumber;  	frameSequence = 0;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: secd = frameSequence / 25 - 60 * mn;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: secd = frameSequence / 25 - 60 * mn;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: s.duration = new TimeSpan (0' 0' mn' secd' fr * 10);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: aviFile.Seek (buf - 500' SeekOrigin.Current);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: secda = frameSequence / 25 - 60 * mna;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: secda = frameSequence / 25 - 60 * mna;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,FrameAnalysisAlter,The following statement contains a magic number: s.duration = new TimeSpan (0' 0' mna' secda' fra * 10);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if ((data [start] == 0x62) && (data [start + 5] == 0x63)) {  	int a1 = 0;  	int a2 = 0;  	//Jour  	a1 = (int)data [start + 2] & 0x0F;  	a2 = ((int)data [start + 2] & 0x30) / 16;  	int jour = 10 * a2 + a1;  	a1 = (int)data [start + 3] & 0x0F;  	a2 = ((int)data [start + 3] & 0x10) / 16;  	int mois = 10 * a2 + a1;  	a1 = (int)data [start + 4] & 0x0F;  	a2 = ((int)data [start + 4] & 0x30) / 16;  	int an = 10 * a2 + a1;  	if (an < 30)  		an += 2000;  	//Heure  	a1 = (int)data [start + 9] & 0x0F;  	a2 = ((int)data [start + 9] & 0x30) / 16;  	int hour = 10 * a2 + a1;  	// Minutes  	a1 = (int)data [start + 8] & 0x0F;  	a2 = ((int)data [start + 8] & 0x70) / 16;  	int min = 10 * a2 + a1;  	// second  	a1 = (int)data [start + 7] & 0x0F;  	a2 = ((int)data [start + 7] & 0x70) / 16;  	int sec = 10 * a2 + a1;  	// frames  	a1 = (int)data [start + 6] & 0x0F;  	a2 = ((int)data [start + 6] & 0x30) / 16;  	int millis = (10 * a2 + a1) * 40;  	result [0] = new DateTime (an' mois' jour' hour' min' sec);  }  else {  	result [0] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a1 = (int)data [start + 2] & 0x0F;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a2 = ((int)data [start + 2] & 0x30) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a2 = ((int)data [start + 2] & 0x30) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a1 = (int)data [start + 3] & 0x0F;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a2 = ((int)data [start + 3] & 0x10) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a2 = ((int)data [start + 3] & 0x10) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a1 = (int)data [start + 4] & 0x0F;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a2 = ((int)data [start + 4] & 0x30) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a2 = ((int)data [start + 4] & 0x30) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (an < 30)  	an += 2000;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (an < 30)  	an += 2000;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: an += 2000;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a1 = (int)data [start + 9] & 0x0F;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a2 = ((int)data [start + 9] & 0x30) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a2 = ((int)data [start + 9] & 0x30) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a1 = (int)data [start + 8] & 0x0F;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a2 = ((int)data [start + 8] & 0x70) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a2 = ((int)data [start + 8] & 0x70) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a1 = (int)data [start + 7] & 0x0F;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a2 = ((int)data [start + 7] & 0x70) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a2 = ((int)data [start + 7] & 0x70) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a1 = (int)data [start + 6] & 0x0F;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a2 = ((int)data [start + 6] & 0x30) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: a2 = ((int)data [start + 6] & 0x30) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: if (data [debut] == 0x13) {  	int[] d = new int[9];  	d [1] = (int)data [debut + 1] & 0x0F;  	d [2] = ((int)data [debut + 1] & 0x30) / 16;  	d [3] = (int)data [debut + 2] & 0x0F;  	d [4] = ((int)data [debut + 2] & 0x70) / 16;  	d [5] = (int)data [debut + 3] & 0x0F;  	d [6] = ((int)data [debut + 3] & 0x70) / 16;  	d [7] = (int)data [debut + 4] & 0x0F;  	d [8] = ((int)data [debut + 4] & 0x30) / 16;  	//               Trace.WriteLine(directionBit[8].ToString() + directionBit[7].ToString() + "h" + directionBit[6].ToString() + directionBit[5].ToString() + ":" + directionBit[4].ToString() + directionBit[3].ToString() + "F" + directionBit[2].ToString() + directionBit[1].ToString());  	int h = 10 * d [8] + d [7];  	int m = 10 * d [6] + d [5];  	int s = 10 * d [4] + d [3];  	int f = 10 * d [2] + d [1];  	result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  }  else {  	result [1] = DateTime.MinValue;  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [2] = ((int)data [debut + 1] & 0x30) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [2] = ((int)data [debut + 1] & 0x30) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [3] = (int)data [debut + 2] & 0x0F;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [3] = (int)data [debut + 2] & 0x0F;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [4] = ((int)data [debut + 2] & 0x70) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [4] = ((int)data [debut + 2] & 0x70) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [4] = ((int)data [debut + 2] & 0x70) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [5] = (int)data [debut + 3] & 0x0F;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [5] = (int)data [debut + 3] & 0x0F;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [6] = ((int)data [debut + 3] & 0x70) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [6] = ((int)data [debut + 3] & 0x70) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [6] = ((int)data [debut + 3] & 0x70) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [7] = (int)data [debut + 4] & 0x0F;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [7] = (int)data [debut + 4] & 0x0F;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [8] = ((int)data [debut + 4] & 0x30) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [8] = ((int)data [debut + 4] & 0x30) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: d [8] = ((int)data [debut + 4] & 0x30) / 16;  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeCodeAndStampFrame,The following statement contains a magic number: result [1] = new DateTime (1' 1' 1' h' m' s' f * 40);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,AddString,The following statement contains a magic number: aviFile.Read (ckid' 0' 4);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,AddLong,The following statement contains a magic number: aviFile.Read (ckid' 0' 4);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,AddShort,The following statement contains a magic number: aviFile.Read (ckid' 0' 2);  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ByteToi,The following statement contains a magic number: for (int w = 0; w < c.Length; w++) {  	taille = 256 * taille + (uint)c [c.Length - 1 - w];  }  
Magic Number,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,ByteToi,The following statement contains a magic number: taille = 256 * taille + (uint)c [c.Length - 1 - w];  
Magic Number,BinHed,SEQUENCE,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeDuration,The following statement contains a magic number: secFrame = secFrame - minFrame * 60;  
Magic Number,BinHed,SEQUENCE,C:\repos\mbatest_Binhed\BinHed\Video.cs,ComputeDuration,The following statement contains a magic number: return new TimeSpan (0' 0' minFrame' secFrame' fr * 10);  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size (440' 336);  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size (440' 336);  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: if (wordWnd != 0) {  	SetParent (wordWnd' this.Handle.ToInt32 ());  	object fileName = filename;  	object newTemplate = false;  	object docType = 0;  	object readOnly = true;  	object isVisible = true;  	object missing = System.Reflection.Missing.Value;  	try {  		if (wd == null) {  			throw new WordInstanceException ();  		}  		if (wd.Documents == null) {  			throw new DocumentInstanceException ();  		}  		if (wd != null && wd.Documents != null) {  			document = wd.Documents.Add (ref fileName' ref newTemplate' ref docType' ref isVisible);  		}  		if (document == null) {  			throw new ValidDocumentException ();  		}  	}  	catch {  	}  	try {  		wd.ActiveWindow.DisplayRightRuler = false;  		wd.ActiveWindow.DisplayScreenTips = false;  		wd.ActiveWindow.DisplayVerticalRuler = false;  		wd.ActiveWindow.DisplayRightRuler = false;  		wd.ActiveWindow.ActivePane.DisplayRulers = false;  		wd.ActiveWindow.ActivePane.View.Type = WdViewType.wdWebView;  		// .wdNormalView;  	}  	catch {  	}  	int counter = 0;  	//Wd.ActiveWindow.Application.CommandBars.Count;  	for (int i = 0; i < counter; i++) {  		try {  			//				wd.Application.ActiveWindow.CommandBars[i].Enabled=false;  		}  		catch {  		}  	}  	try {  		wd.Visible = true;  		wd.Activate ();  		SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  		MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  	}  	catch {  		MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  	}  	this.Parent.Focus ();  }  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: if (wordWnd != 0) {  	SetParent (wordWnd' this.Handle.ToInt32 ());  	object fileName = filename;  	object newTemplate = false;  	object docType = 0;  	object readOnly = true;  	object isVisible = true;  	object missing = System.Reflection.Missing.Value;  	try {  		if (wd == null) {  			throw new WordInstanceException ();  		}  		if (wd.Documents == null) {  			throw new DocumentInstanceException ();  		}  		if (wd != null && wd.Documents != null) {  			document = wd.Documents.Add (ref fileName' ref newTemplate' ref docType' ref isVisible);  		}  		if (document == null) {  			throw new ValidDocumentException ();  		}  	}  	catch {  	}  	try {  		wd.ActiveWindow.DisplayRightRuler = false;  		wd.ActiveWindow.DisplayScreenTips = false;  		wd.ActiveWindow.DisplayVerticalRuler = false;  		wd.ActiveWindow.DisplayRightRuler = false;  		wd.ActiveWindow.ActivePane.DisplayRulers = false;  		wd.ActiveWindow.ActivePane.View.Type = WdViewType.wdWebView;  		// .wdNormalView;  	}  	catch {  	}  	int counter = 0;  	//Wd.ActiveWindow.Application.CommandBars.Count;  	for (int i = 0; i < counter; i++) {  		try {  			//				wd.Application.ActiveWindow.CommandBars[i].Enabled=false;  		}  		catch {  		}  	}  	try {  		wd.Visible = true;  		wd.Activate ();  		SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  		MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  	}  	catch {  		MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  	}  	this.Parent.Focus ();  }  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: if (wordWnd != 0) {  	SetParent (wordWnd' this.Handle.ToInt32 ());  	object fileName = filename;  	object newTemplate = false;  	object docType = 0;  	object readOnly = true;  	object isVisible = true;  	object missing = System.Reflection.Missing.Value;  	try {  		if (wd == null) {  			throw new WordInstanceException ();  		}  		if (wd.Documents == null) {  			throw new DocumentInstanceException ();  		}  		if (wd != null && wd.Documents != null) {  			document = wd.Documents.Add (ref fileName' ref newTemplate' ref docType' ref isVisible);  		}  		if (document == null) {  			throw new ValidDocumentException ();  		}  	}  	catch {  	}  	try {  		wd.ActiveWindow.DisplayRightRuler = false;  		wd.ActiveWindow.DisplayScreenTips = false;  		wd.ActiveWindow.DisplayVerticalRuler = false;  		wd.ActiveWindow.DisplayRightRuler = false;  		wd.ActiveWindow.ActivePane.DisplayRulers = false;  		wd.ActiveWindow.ActivePane.View.Type = WdViewType.wdWebView;  		// .wdNormalView;  	}  	catch {  	}  	int counter = 0;  	//Wd.ActiveWindow.Application.CommandBars.Count;  	for (int i = 0; i < counter; i++) {  		try {  			//				wd.Application.ActiveWindow.CommandBars[i].Enabled=false;  		}  		catch {  		}  	}  	try {  		wd.Visible = true;  		wd.Activate ();  		SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  		MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  	}  	catch {  		MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  	}  	this.Parent.Focus ();  }  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: if (wordWnd != 0) {  	SetParent (wordWnd' this.Handle.ToInt32 ());  	object fileName = filename;  	object newTemplate = false;  	object docType = 0;  	object readOnly = true;  	object isVisible = true;  	object missing = System.Reflection.Missing.Value;  	try {  		if (wd == null) {  			throw new WordInstanceException ();  		}  		if (wd.Documents == null) {  			throw new DocumentInstanceException ();  		}  		if (wd != null && wd.Documents != null) {  			document = wd.Documents.Add (ref fileName' ref newTemplate' ref docType' ref isVisible);  		}  		if (document == null) {  			throw new ValidDocumentException ();  		}  	}  	catch {  	}  	try {  		wd.ActiveWindow.DisplayRightRuler = false;  		wd.ActiveWindow.DisplayScreenTips = false;  		wd.ActiveWindow.DisplayVerticalRuler = false;  		wd.ActiveWindow.DisplayRightRuler = false;  		wd.ActiveWindow.ActivePane.DisplayRulers = false;  		wd.ActiveWindow.ActivePane.View.Type = WdViewType.wdWebView;  		// .wdNormalView;  	}  	catch {  	}  	int counter = 0;  	//Wd.ActiveWindow.Application.CommandBars.Count;  	for (int i = 0; i < counter; i++) {  		try {  			//				wd.Application.ActiveWindow.CommandBars[i].Enabled=false;  		}  		catch {  		}  	}  	try {  		wd.Visible = true;  		wd.Activate ();  		SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  		MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  	}  	catch {  		MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  	}  	this.Parent.Focus ();  }  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: if (wordWnd != 0) {  	SetParent (wordWnd' this.Handle.ToInt32 ());  	object fileName = filename;  	object newTemplate = false;  	object docType = 0;  	object readOnly = true;  	object isVisible = true;  	object missing = System.Reflection.Missing.Value;  	try {  		if (wd == null) {  			throw new WordInstanceException ();  		}  		if (wd.Documents == null) {  			throw new DocumentInstanceException ();  		}  		if (wd != null && wd.Documents != null) {  			document = wd.Documents.Add (ref fileName' ref newTemplate' ref docType' ref isVisible);  		}  		if (document == null) {  			throw new ValidDocumentException ();  		}  	}  	catch {  	}  	try {  		wd.ActiveWindow.DisplayRightRuler = false;  		wd.ActiveWindow.DisplayScreenTips = false;  		wd.ActiveWindow.DisplayVerticalRuler = false;  		wd.ActiveWindow.DisplayRightRuler = false;  		wd.ActiveWindow.ActivePane.DisplayRulers = false;  		wd.ActiveWindow.ActivePane.View.Type = WdViewType.wdWebView;  		// .wdNormalView;  	}  	catch {  	}  	int counter = 0;  	//Wd.ActiveWindow.Application.CommandBars.Count;  	for (int i = 0; i < counter; i++) {  		try {  			//				wd.Application.ActiveWindow.CommandBars[i].Enabled=false;  		}  		catch {  		}  	}  	try {  		wd.Visible = true;  		wd.Activate ();  		SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  		MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  	}  	catch {  		MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  	}  	this.Parent.Focus ();  }  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: if (wordWnd != 0) {  	SetParent (wordWnd' this.Handle.ToInt32 ());  	object fileName = filename;  	object newTemplate = false;  	object docType = 0;  	object readOnly = true;  	object isVisible = true;  	object missing = System.Reflection.Missing.Value;  	try {  		if (wd == null) {  			throw new WordInstanceException ();  		}  		if (wd.Documents == null) {  			throw new DocumentInstanceException ();  		}  		if (wd != null && wd.Documents != null) {  			document = wd.Documents.Add (ref fileName' ref newTemplate' ref docType' ref isVisible);  		}  		if (document == null) {  			throw new ValidDocumentException ();  		}  	}  	catch {  	}  	try {  		wd.ActiveWindow.DisplayRightRuler = false;  		wd.ActiveWindow.DisplayScreenTips = false;  		wd.ActiveWindow.DisplayVerticalRuler = false;  		wd.ActiveWindow.DisplayRightRuler = false;  		wd.ActiveWindow.ActivePane.DisplayRulers = false;  		wd.ActiveWindow.ActivePane.View.Type = WdViewType.wdWebView;  		// .wdNormalView;  	}  	catch {  	}  	int counter = 0;  	//Wd.ActiveWindow.Application.CommandBars.Count;  	for (int i = 0; i < counter; i++) {  		try {  			//				wd.Application.ActiveWindow.CommandBars[i].Enabled=false;  		}  		catch {  		}  	}  	try {  		wd.Visible = true;  		wd.Activate ();  		SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  		MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  	}  	catch {  		MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  	}  	this.Parent.Focus ();  }  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: try {  	wd.Visible = true;  	wd.Activate ();  	SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  	MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  }  catch {  	MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  }  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: try {  	wd.Visible = true;  	wd.Activate ();  	SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  	MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  }  catch {  	MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  }  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: try {  	wd.Visible = true;  	wd.Activate ();  	SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  	MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  }  catch {  	MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  }  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: try {  	wd.Visible = true;  	wd.Activate ();  	SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  	MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  }  catch {  	MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  }  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: try {  	wd.Visible = true;  	wd.Activate ();  	SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  	MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  }  catch {  	MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  }  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: try {  	wd.Visible = true;  	wd.Activate ();  	SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  	MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  }  catch {  	MessageBox.Show ("Error: do not load the document into the control until the parent window is shown!");  }  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: SetWindowPos (wordWnd' this.Handle.ToInt32 ()' 0' 0' this.Bounds.Width + 20' this.Bounds.Height + 20' SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME);  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,LoadDocument,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,OnResize,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,OnResize,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,OnResize,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Magic Number,BinHed,WinWordControl,C:\repos\mbatest_Binhed\BinHed\WinWordControl.cs,OnResize,The following statement contains a magic number: MoveWindow (wordWnd' -5' -33' this.Bounds.Width + 10' this.Bounds.Height + 57' true);  
Missing Default,BinHed,BinDecoder,C:\repos\mbatest_Binhed\BinHed\Decoders.cs,BinDecoder,The following switch statement is missing a default case: switch (Path.GetExtension (FileName).ToUpper ()) {  case ".BMP":  	DecodeBMP ();  	break;  case "PNG":  	DecodePNG ();  	break;  case ".CHM":  	DecodeCHM ();  	break;  }  
Missing Default,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,hexa_Click,The following switch statement is missing a default case: switch (hexa.Text) {  case "0x":  	hexa.Text = "01";  	view1.SetMode (ViewMode.Bit);  	break;  case "01":  	hexa.Text = "0D";  	view1.SetMode (ViewMode.Dec);  	break;  case "0D":  	hexa.Text = "0x";  	view1.SetMode (ViewMode.Hex);  	break;  }  
Missing Default,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,hexToolStripMenuItem_Click,The following switch statement is missing a default case: switch (t.Text) {  case "Hex":  	searchT = SearchType.Hex;  	hexToolStripMenuItem.Checked = true;  	break;  case "Ansi":  	searchT = SearchType.Ansi;  	ansiToolStripMenuItem.Checked = true;  	break;  case "Unicode":  	searchT = SearchType.Unicode;  	unicodeToolStripMenuItem.Checked = true;  	break;  case "Address":  	searchT = SearchType.Address;  	addressToolStripMenuItem.Checked = true;  	break;  case "Binary":  	searchT = SearchType.Binary;  	binaryToolStripMenuItem.Checked = false;  	break;  }  
Missing Default,BinHed,FileEdit,C:\repos\mbatest_Binhed\BinHed\FileEdit.cs,textBoxPath_TextChanged,The following switch statement is missing a default case: switch (pa.GetType ().Name) {  case "Win32_DiskDrive":  	Win32_DiskDrive p = (Win32_DiskDrive)pa;  	da.ReadsFirstSector (p);  	binaryView.SetScrollSize (p.TotalSectors);  	break;  case "Win32_CDROMDrive":  	Win32_CDROMDrive c = (Win32_CDROMDrive)pa;  	da.ReadsFirstSector (c);  	break;  }  
Missing Default,BinHed,FileViewer,C:\repos\mbatest_Binhed\BinHed\FileViewer.cs,FillTreeNode,The following switch statement is missing a default case: switch (tp [0].Name) {  case "DateTime":  	TreeNode ts = new TreeNode (v.Name + " " + a.ToString ()' 0' 1);  	ts.Tag = v;  	root.Nodes.Add (ts);  	break;  }  
Missing Default,BinHed,FileViewer,C:\repos\mbatest_Binhed\BinHed\FileViewer.cs,FillTreeNode,The following switch statement is missing a default case: switch (v.PropertyType.Name) {  case "Boolean":  case "ELEMENTARY_TYPE":  	s += currentNode.GetType ().GetProperty (v.Name).GetValue (currentNode' null).ToString ();  	break;  case "DateTime":  	s += currentNode.GetType ().GetProperty (v.Name).GetValue (currentNode' null).ToString ();  	break;  case "Instruction":  	s += currentNode.GetType ().GetProperty (v.Name).GetValue (currentNode' null).ToString ();  	break;  case "CodeLigne":  	s += currentNode.GetType ().GetProperty (v.Name).GetValue (currentNode' null).ToString ();  	break;  }  
Missing Default,BinHed,AviAnalyze,C:\repos\mbatest_Binhed\BinHed\Video.cs,Interpret,The following switch statement is missing a default case: switch (fileStruc [streamNumber].fccType) {  case "iavs":  	AddLong ("DVAAuxSrc");  	AddLong ("DVAAuxCtl");  	AddLong ("DVAAuxSrc1");  	AddLong ("DVAAuxCtl1");  	AddLong ("DVVAuxSrc");  	AddLong ("DVVAuxCtl");  	AddLong ("Reserved");  	AddLong ("Reserved");  	break;  case "vids":  	stSize = AddLong ("Size");  	AddLong ("Width");  	stSize -= 4;  	AddLong ("Height");  	stSize -= 4;  	AddShort ("Planes");  	stSize -= 2;  	AddShort ("BitCount");  	stSize -= 2;  	AddString ("Compression");  	stSize -= 4;  	int buf2 = (int)AddLong ("ImageSize");  	stSize -= 4;  	if ((buf2 < buf) && (fileStruc [streamNumber].fccType == "vids"))  		buf = buf2;  	AddLong ("xPelsPerMeter");  	stSize -= 4;  	AddLong ("yPelsPerMeter");  	stSize -= 4;  	AddLong ("Color_Table");  	stSize -= 4;  	AddLong ("Important Color_Table");  	stSize -= 4;  	streamNumber++;  	break;  case "auds":  	AddShort ("Format");  	stSize -= 2;  	AddShort ("nChannels");  	stSize -= 2;  	AddLong ("SamplesPerRec");  	stSize -= 4;  	AddLong ("AvgBytesPerRec");  	stSize -= 4;  	AddShort ("BlockAlign");  	stSize -= 2;  	AddShort ("BitsPerSample");  	stSize -= 2;  	streamNumber++;  	break;  }  
