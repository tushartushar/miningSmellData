Implementation smell,Namespace,Class,File,Method,Description
Long Method,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The method has 130 lines of code.
Long Method,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The method has 118 lines of code.
Long Method,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The method has 181 lines of code.
Long Method,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The method has 141 lines of code.
Long Method,BookReader,Text_Tag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Text_Tag,The method has 117 lines of code.
Long Method,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The method has 120 lines of code.
Long Method,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The method has 134 lines of code.
Long Method,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The method has 264 lines of code.
Long Method,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The method has 108 lines of code.
Long Method,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ReadObjDescription,The method has 109 lines of code.
Long Method,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The method has 118 lines of code.
Long Method,BookReader,PostScriptReader,C:\repos\mbatest_Binhed\BookReader\PsReader.cs,PostScriptReader,The method has 112 lines of code.
Complex Method,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,Cyclomatic complexity of the method is 17
Complex Method,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,Cyclomatic complexity of the method is 11
Complex Method,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,Cyclomatic complexity of the method is 22
Complex Method,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,Cyclomatic complexity of the method is 12
Complex Method,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,Cyclomatic complexity of the method is 10
Complex Method,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,Cyclomatic complexity of the method is 19
Complex Method,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,Cyclomatic complexity of the method is 81
Complex Method,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,ToString,Cyclomatic complexity of the method is 84
Complex Method,BookReader,Text_Tag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Text_Tag,Cyclomatic complexity of the method is 74
Complex Method,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,Cyclomatic complexity of the method is 63
Complex Method,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,Cyclomatic complexity of the method is 80
Complex Method,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,ParseXml,Cyclomatic complexity of the method is 34
Complex Method,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,Cyclomatic complexity of the method is 22
Complex Method,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,FindXrefAddress,Cyclomatic complexity of the method is 9
Complex Method,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ReadObjDescription,Cyclomatic complexity of the method is 23
Complex Method,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,Decompress,Cyclomatic complexity of the method is 18
Complex Method,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,PdfReader,Cyclomatic complexity of the method is 13
Complex Method,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,Cyclomatic complexity of the method is 51
Complex Method,BookReader,Trailer,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,Trailer,Cyclomatic complexity of the method is 18
Complex Method,BookReader,PdfObject,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,AddToDictionnary,Cyclomatic complexity of the method is 13
Complex Method,BookReader,PdfObject,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,GetData,Cyclomatic complexity of the method is 25
Complex Method,BookReader,PdfViewer,C:\repos\mbatest_Binhed\BookReader\PdfViewer.cs,AddKeys,Cyclomatic complexity of the method is 14
Complex Method,BookReader,PdfViewer,C:\repos\mbatest_Binhed\BookReader\PdfViewer.cs,treeView1_AfterSelect,Cyclomatic complexity of the method is 9
Complex Method,BookReader,PostScriptReader,C:\repos\mbatest_Binhed\BookReader\PsReader.cs,PostScriptReader,Cyclomatic complexity of the method is 61
Complex Method,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,Cyclomatic complexity of the method is 11
Complex Method,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,Cyclomatic complexity of the method is 9
Long Parameter List,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The method has 5 parameters.
Long Parameter List,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The method has 5 parameters.
Long Statement,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The length of the statement  "				//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run")); " is 130.
Long Statement,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The length of the statement  "					//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run")); " is 132.
Long Statement,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The length of the statement  "					//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data")); " is 160.
Long Statement,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The length of the statement  "					//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data")); " is 160.
Long Statement,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The length of the statement  "			//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run")); " is 124.
Long Statement,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The length of the statement  "				//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run")); " is 130.
Long Statement,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The length of the statement  "			//                  throw new Exception(MessageLocalization.GetComposedMessage("scanline.must.begin.with.eol.tagCode.word")); " is 125.
Long Statement,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The length of the statement  "			//                  throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0")); " is 129.
Long Statement,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The length of the statement  "				//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0")); " is 134.
Long Statement,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The length of the statement  "				//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0")); " is 134.
Long Statement,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The length of the statement  "		//             throw new Exception(MessageLocalization.GetComposedMessage("tiff.fill.order.tag.must.be.either.1.or.2")); " is 120.
Long Statement,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextLesserThan8Bits,The length of the statement  "		//                throw new Exception(MessageLocalization.GetComposedMessage("tiff.fill.order.tag.must.be.either.1.or.2")); " is 123.
Long Statement,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,ParseXml,The length of the statement  "		/* Only bother with this node if it's an element containing data */if ((textReader.NodeType == XmlNodeType.Element) && (!textReader.IsEmptyElement)) { " is 150.
Long Statement,BookReader,indexEntry,C:\repos\mbatest_Binhed\BookReader\Readers.cs,ReadPage,The length of the statement  "	/*       int length = (int)Header.PdHr.Index[numberOfPages + 1].Offset.Value - (int)Header.PdHr.Index[numberOfPages].Offset.Value;" is 130.
Empty Catch Block,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The method has an empty catch block.
Empty Catch Block,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The method has an empty catch block.
Empty Catch Block,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,LRFFileReader,The method has an empty catch block.
Empty Catch Block,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,ParseXml,The method has an empty catch block.
Empty Catch Block,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The method has an empty catch block.
Empty Catch Block,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The method has an empty catch block.
Empty Catch Block,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The method has an empty catch block.
Empty Catch Block,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The method has an empty catch block.
Empty Catch Block,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The method has an empty catch block.
Empty Catch Block,BookReader,LRFViewer,C:\repos\mbatest_Binhed\BookReader\LRFViewer.cs,forward_Click,The method has an empty catch block.
Empty Catch Block,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,PdfReader,The method has an empty catch block.
Empty Catch Block,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,PdfReader,The method has an empty catch block.
Empty Catch Block,BookReader,Trailer,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,Trailer,The method has an empty catch block.
Empty Catch Block,BookReader,PdfObject,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,AddToDictionnary,The method has an empty catch block.
Empty Catch Block,BookReader,PostScriptReader,C:\repos\mbatest_Binhed\BookReader\PsReader.cs,PostScriptReader,The method has an empty catch block.
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,TIFFFaxDecoder,The following statement contains a magic number: this.prevChangingElems = new int[2 * w];  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,TIFFFaxDecoder,The following statement contains a magic number: this.currChangingElems = new int[2 * w];  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (bitOffset < w) {  	while (isWhite) {  		// White run  		current = NextNBits (10);  		entry = white [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x0f;  		if (bits == 12) {  			// Additional Make up tagCode  			// Get the next 2 bits  			twoBits = NextLesserThan8Bits (2);  			// Consolidate the 2 new bits and last 2 bits into 4 bits  			current = ((current << 2) & 0x000c) | twoBits;  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			bitOffset += code;  			// SkipBit white run  			UpdatePointer (4 - bits);  		}  		else if (bits == 0) {  			// ERROR  			//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  		}  		else if (bits == 15) {  			// EOL  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  		}  		else {  			// 11 bits - 0000 0111 1111 1111 = 0x07ff  			code = (entry >> 5) & 0x07ff;  			bitOffset += code;  			UpdatePointer (10 - bits);  			if (isT == 0) {  				isWhite = false;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	// Check whether this run completed one width' if so  	// advance to next byte boundary for compression = 2.  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  	while (isWhite == false) {  		// Black run  		current = NextLesserThan8Bits (4);  		entry = initBlack [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (code == 100) {  			current = NextNBits (9);  			entry = black [current];  			// Get the 3 fields from the entry  			isT = entry & 0x0001;  			bits = (entry >> 1) & 0x000f;  			code = (entry >> 5) & 0x07ff;  			if (bits == 12) {  				// Additional makeup codes  				UpdatePointer (5);  				current = NextLesserThan8Bits (4);  				entry = additionalMakeup [current];  				bits = (entry >> 1) & 0x07;  				// 3 bits 0000 0111  				code = (entry >> 4) & 0x0fff;  				// 12 bits  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (4 - bits);  			}  			else if (bits == 15) {  				// EOL tagCode  				//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  			}  			else {  				SetToBlack (buffer' lineOffset' bitOffset' code);  				bitOffset += code;  				UpdatePointer (9 - bits);  				if (isT == 0) {  					isWhite = true;  					currChangingElems [changingElemSize++] = bitOffset;  				}  			}  		}  		else if (code == 200) {  			// Is a Terminating tagCode  			current = NextLesserThan8Bits (2);  			entry = twoBitBlack [current];  			code = (entry >> 5) & 0x07ff;  			bits = (entry >> 1) & 0x0f;  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (2 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  		else {  			// Is a Terminating tagCode  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  	// Check whether this run completed one width  	if (bitOffset == w) {  		if (compression == 2) {  			AdvancePointer ();  		}  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite) {  	// White run  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		bitOffset += code;  		// SkipBit white run  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		bitOffset += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite) {  	// White run  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		bitOffset += code;  		// SkipBit white run  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		bitOffset += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite) {  	// White run  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		bitOffset += code;  		// SkipBit white run  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		bitOffset += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite) {  	// White run  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		bitOffset += code;  		// SkipBit white run  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		bitOffset += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite) {  	// White run  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		bitOffset += code;  		// SkipBit white run  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		bitOffset += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite) {  	// White run  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		bitOffset += code;  		// SkipBit white run  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		bitOffset += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite) {  	// White run  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		bitOffset += code;  		// SkipBit white run  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		bitOffset += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite) {  	// White run  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		bitOffset += code;  		// SkipBit white run  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		bitOffset += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite) {  	// White run  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		bitOffset += code;  		// SkipBit white run  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		bitOffset += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: current = NextNBits (10);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	bitOffset += code;  	// SkipBit white run  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	bitOffset += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	bitOffset += code;  	// SkipBit white run  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	bitOffset += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	bitOffset += code;  	// SkipBit white run  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	bitOffset += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	bitOffset += code;  	// SkipBit white run  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	bitOffset += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	bitOffset += code;  	// SkipBit white run  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	bitOffset += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	bitOffset += code;  	// SkipBit white run  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	bitOffset += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	bitOffset += code;  	// SkipBit white run  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	bitOffset += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	bitOffset += code;  	// SkipBit white run  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	bitOffset += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: twoBits = NextLesserThan8Bits (2);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: current = ((current << 2) & 0x000c) | twoBits;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: code = (entry >> 4) & 0x0fff;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: UpdatePointer (4 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 0) {  	// ERROR  	//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	bitOffset += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 0) {  	// ERROR  	//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	bitOffset += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 0) {  	// ERROR  	//                      throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	bitOffset += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 15) {  	// EOL  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	bitOffset += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 15) {  	// EOL  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	bitOffset += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 15) {  	// EOL  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	bitOffset += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: code = (entry >> 5) & 0x07ff;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: UpdatePointer (10 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bitOffset == w) {  	if (compression == 2) {  		AdvancePointer ();  	}  	break;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (compression == 2) {  	AdvancePointer ();  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: while (isWhite == false) {  	// Black run  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			SetToBlack (buffer' lineOffset' bitOffset' code);  			bitOffset += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  				currChangingElems [changingElemSize++] = bitOffset;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		bits = (entry >> 1) & 0x0f;  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (2 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  	else {  		// Is a Terminating tagCode  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: current = NextLesserThan8Bits (4);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: code = (entry >> 5) & 0x07ff;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		SetToBlack (buffer' lineOffset' bitOffset' code);  		bitOffset += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  			currChangingElems [changingElemSize++] = bitOffset;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: current = NextNBits (9);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: code = (entry >> 5) & 0x07ff;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional makeup codes  	UpdatePointer (5);  	current = NextLesserThan8Bits (4);  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  }  else if (bits == 15) {  	// EOL tagCode  	//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional makeup codes  	UpdatePointer (5);  	current = NextLesserThan8Bits (4);  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  }  else if (bits == 15) {  	// EOL tagCode  	//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional makeup codes  	UpdatePointer (5);  	current = NextLesserThan8Bits (4);  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  }  else if (bits == 15) {  	// EOL tagCode  	//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional makeup codes  	UpdatePointer (5);  	current = NextLesserThan8Bits (4);  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  }  else if (bits == 15) {  	// EOL tagCode  	//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional makeup codes  	UpdatePointer (5);  	current = NextLesserThan8Bits (4);  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  }  else if (bits == 15) {  	// EOL tagCode  	//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional makeup codes  	UpdatePointer (5);  	current = NextLesserThan8Bits (4);  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  }  else if (bits == 15) {  	// EOL tagCode  	//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 12) {  	// Additional makeup codes  	UpdatePointer (5);  	current = NextLesserThan8Bits (4);  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  }  else if (bits == 15) {  	// EOL tagCode  	//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: UpdatePointer (5);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: current = NextLesserThan8Bits (4);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: code = (entry >> 4) & 0x0fff;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: UpdatePointer (4 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 15) {  	// EOL tagCode  	//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bits == 15) {  	// EOL tagCode  	//                         throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  		currChangingElems [changingElemSize++] = bitOffset;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: UpdatePointer (9 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	bits = (entry >> 1) & 0x0f;  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (2 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  else {  	// Is a Terminating tagCode  	SetToBlack (buffer' lineOffset' bitOffset' code);  	bitOffset += code;  	UpdatePointer (4 - bits);  	isWhite = true;  	currChangingElems [changingElemSize++] = bitOffset;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: current = NextLesserThan8Bits (2);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: code = (entry >> 5) & 0x07ff;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: UpdatePointer (2 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: UpdatePointer (4 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (bitOffset == w) {  	if (compression == 2) {  		AdvancePointer ();  	}  	break;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeNextScanline,The following statement contains a magic number: if (compression == 2) {  	AdvancePointer ();  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: compression = 3;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: fillBits = (int)((tiffT4Options & 0x04) >> 2);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: for (int lines = 1; lines < height; lines++) {  	// Every line must begin with an EOL followed by a bit which  	// indicates whether the following scanline is 1D or 2D encoded.  	if (ReadEOL (false) == 0) {  		// 2D encoded scanline follows  		// Initialize previous scanlines changing elements' and  		// initialize current scanline'lineRead changing elements array  		temp = prevChangingElems;  		prevChangingElems = currChangingElems;  		currChangingElems = temp;  		currIndex = 0;  		// a0 has to be set just before the start of this scanline.  		a0 = -1;  		isWhite = true;  		bitOffset = startX;  		lastChangingElement = 0;  		while (bitOffset < w) {  			// Get the next changing element  			GetNextChangingElement (a0' isWhite' b);  			b1 = b [0];  			b2 = b [1];  			// Get the next seven bits  			entry = NextLesserThan8Bits (7);  			// Run these through the 2DCodes table  			entry = (int)(twoDCodes [entry] & 0xff);  			// Get the tagCode and the number of bits used up  			code = (entry & 0x78) >> 3;  			bits = entry & 0x07;  			if (code == 0) {  				if (!isWhite) {  					SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  				}  				bitOffset = a0 = b2;  				// Set pointer to consume the correct number of bits.  				UpdatePointer (7 - bits);  			}  			else if (code == 1) {  				// Horizontal  				UpdatePointer (7 - bits);  				// identify the next 2 codes.  				int number;  				if (isWhite) {  					number = DecodeWhiteCodeWord ();  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  					number = DecodeBlackCodeWord ();  					SetToBlack (buffer' lineOffset' bitOffset' number);  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  				}  				else {  					number = DecodeBlackCodeWord ();  					SetToBlack (buffer' lineOffset' bitOffset' number);  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  					number = DecodeWhiteCodeWord ();  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  				}  				a0 = bitOffset;  			}  			else if (code <= 8) {  				// Vertical  				a1 = b1 + (code - 5);  				currChangingElems [currIndex++] = a1;  				// We write the current color till a1 - 1 pos'  				// since a1 is where the next color starts  				if (!isWhite) {  					SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  				}  				bitOffset = a0 = a1;  				isWhite = !isWhite;  				UpdatePointer (7 - bits);  			}  			else {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  			}  		}  		// Add the changing element beyond the current scanline for the  		// other color too  		currChangingElems [currIndex++] = bitOffset;  		changingElemSize = currIndex;  	}  	else {  		// 1D encoded scanline follows  		DecodeNextScanline (buffer' lineOffset' startX);  	}  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: for (int lines = 1; lines < height; lines++) {  	// Every line must begin with an EOL followed by a bit which  	// indicates whether the following scanline is 1D or 2D encoded.  	if (ReadEOL (false) == 0) {  		// 2D encoded scanline follows  		// Initialize previous scanlines changing elements' and  		// initialize current scanline'lineRead changing elements array  		temp = prevChangingElems;  		prevChangingElems = currChangingElems;  		currChangingElems = temp;  		currIndex = 0;  		// a0 has to be set just before the start of this scanline.  		a0 = -1;  		isWhite = true;  		bitOffset = startX;  		lastChangingElement = 0;  		while (bitOffset < w) {  			// Get the next changing element  			GetNextChangingElement (a0' isWhite' b);  			b1 = b [0];  			b2 = b [1];  			// Get the next seven bits  			entry = NextLesserThan8Bits (7);  			// Run these through the 2DCodes table  			entry = (int)(twoDCodes [entry] & 0xff);  			// Get the tagCode and the number of bits used up  			code = (entry & 0x78) >> 3;  			bits = entry & 0x07;  			if (code == 0) {  				if (!isWhite) {  					SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  				}  				bitOffset = a0 = b2;  				// Set pointer to consume the correct number of bits.  				UpdatePointer (7 - bits);  			}  			else if (code == 1) {  				// Horizontal  				UpdatePointer (7 - bits);  				// identify the next 2 codes.  				int number;  				if (isWhite) {  					number = DecodeWhiteCodeWord ();  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  					number = DecodeBlackCodeWord ();  					SetToBlack (buffer' lineOffset' bitOffset' number);  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  				}  				else {  					number = DecodeBlackCodeWord ();  					SetToBlack (buffer' lineOffset' bitOffset' number);  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  					number = DecodeWhiteCodeWord ();  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  				}  				a0 = bitOffset;  			}  			else if (code <= 8) {  				// Vertical  				a1 = b1 + (code - 5);  				currChangingElems [currIndex++] = a1;  				// We write the current color till a1 - 1 pos'  				// since a1 is where the next color starts  				if (!isWhite) {  					SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  				}  				bitOffset = a0 = a1;  				isWhite = !isWhite;  				UpdatePointer (7 - bits);  			}  			else {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  			}  		}  		// Add the changing element beyond the current scanline for the  		// other color too  		currChangingElems [currIndex++] = bitOffset;  		changingElemSize = currIndex;  	}  	else {  		// 1D encoded scanline follows  		DecodeNextScanline (buffer' lineOffset' startX);  	}  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: for (int lines = 1; lines < height; lines++) {  	// Every line must begin with an EOL followed by a bit which  	// indicates whether the following scanline is 1D or 2D encoded.  	if (ReadEOL (false) == 0) {  		// 2D encoded scanline follows  		// Initialize previous scanlines changing elements' and  		// initialize current scanline'lineRead changing elements array  		temp = prevChangingElems;  		prevChangingElems = currChangingElems;  		currChangingElems = temp;  		currIndex = 0;  		// a0 has to be set just before the start of this scanline.  		a0 = -1;  		isWhite = true;  		bitOffset = startX;  		lastChangingElement = 0;  		while (bitOffset < w) {  			// Get the next changing element  			GetNextChangingElement (a0' isWhite' b);  			b1 = b [0];  			b2 = b [1];  			// Get the next seven bits  			entry = NextLesserThan8Bits (7);  			// Run these through the 2DCodes table  			entry = (int)(twoDCodes [entry] & 0xff);  			// Get the tagCode and the number of bits used up  			code = (entry & 0x78) >> 3;  			bits = entry & 0x07;  			if (code == 0) {  				if (!isWhite) {  					SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  				}  				bitOffset = a0 = b2;  				// Set pointer to consume the correct number of bits.  				UpdatePointer (7 - bits);  			}  			else if (code == 1) {  				// Horizontal  				UpdatePointer (7 - bits);  				// identify the next 2 codes.  				int number;  				if (isWhite) {  					number = DecodeWhiteCodeWord ();  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  					number = DecodeBlackCodeWord ();  					SetToBlack (buffer' lineOffset' bitOffset' number);  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  				}  				else {  					number = DecodeBlackCodeWord ();  					SetToBlack (buffer' lineOffset' bitOffset' number);  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  					number = DecodeWhiteCodeWord ();  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  				}  				a0 = bitOffset;  			}  			else if (code <= 8) {  				// Vertical  				a1 = b1 + (code - 5);  				currChangingElems [currIndex++] = a1;  				// We write the current color till a1 - 1 pos'  				// since a1 is where the next color starts  				if (!isWhite) {  					SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  				}  				bitOffset = a0 = a1;  				isWhite = !isWhite;  				UpdatePointer (7 - bits);  			}  			else {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  			}  		}  		// Add the changing element beyond the current scanline for the  		// other color too  		currChangingElems [currIndex++] = bitOffset;  		changingElemSize = currIndex;  	}  	else {  		// 1D encoded scanline follows  		DecodeNextScanline (buffer' lineOffset' startX);  	}  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: for (int lines = 1; lines < height; lines++) {  	// Every line must begin with an EOL followed by a bit which  	// indicates whether the following scanline is 1D or 2D encoded.  	if (ReadEOL (false) == 0) {  		// 2D encoded scanline follows  		// Initialize previous scanlines changing elements' and  		// initialize current scanline'lineRead changing elements array  		temp = prevChangingElems;  		prevChangingElems = currChangingElems;  		currChangingElems = temp;  		currIndex = 0;  		// a0 has to be set just before the start of this scanline.  		a0 = -1;  		isWhite = true;  		bitOffset = startX;  		lastChangingElement = 0;  		while (bitOffset < w) {  			// Get the next changing element  			GetNextChangingElement (a0' isWhite' b);  			b1 = b [0];  			b2 = b [1];  			// Get the next seven bits  			entry = NextLesserThan8Bits (7);  			// Run these through the 2DCodes table  			entry = (int)(twoDCodes [entry] & 0xff);  			// Get the tagCode and the number of bits used up  			code = (entry & 0x78) >> 3;  			bits = entry & 0x07;  			if (code == 0) {  				if (!isWhite) {  					SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  				}  				bitOffset = a0 = b2;  				// Set pointer to consume the correct number of bits.  				UpdatePointer (7 - bits);  			}  			else if (code == 1) {  				// Horizontal  				UpdatePointer (7 - bits);  				// identify the next 2 codes.  				int number;  				if (isWhite) {  					number = DecodeWhiteCodeWord ();  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  					number = DecodeBlackCodeWord ();  					SetToBlack (buffer' lineOffset' bitOffset' number);  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  				}  				else {  					number = DecodeBlackCodeWord ();  					SetToBlack (buffer' lineOffset' bitOffset' number);  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  					number = DecodeWhiteCodeWord ();  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  				}  				a0 = bitOffset;  			}  			else if (code <= 8) {  				// Vertical  				a1 = b1 + (code - 5);  				currChangingElems [currIndex++] = a1;  				// We write the current color till a1 - 1 pos'  				// since a1 is where the next color starts  				if (!isWhite) {  					SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  				}  				bitOffset = a0 = a1;  				isWhite = !isWhite;  				UpdatePointer (7 - bits);  			}  			else {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  			}  		}  		// Add the changing element beyond the current scanline for the  		// other color too  		currChangingElems [currIndex++] = bitOffset;  		changingElemSize = currIndex;  	}  	else {  		// 1D encoded scanline follows  		DecodeNextScanline (buffer' lineOffset' startX);  	}  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: for (int lines = 1; lines < height; lines++) {  	// Every line must begin with an EOL followed by a bit which  	// indicates whether the following scanline is 1D or 2D encoded.  	if (ReadEOL (false) == 0) {  		// 2D encoded scanline follows  		// Initialize previous scanlines changing elements' and  		// initialize current scanline'lineRead changing elements array  		temp = prevChangingElems;  		prevChangingElems = currChangingElems;  		currChangingElems = temp;  		currIndex = 0;  		// a0 has to be set just before the start of this scanline.  		a0 = -1;  		isWhite = true;  		bitOffset = startX;  		lastChangingElement = 0;  		while (bitOffset < w) {  			// Get the next changing element  			GetNextChangingElement (a0' isWhite' b);  			b1 = b [0];  			b2 = b [1];  			// Get the next seven bits  			entry = NextLesserThan8Bits (7);  			// Run these through the 2DCodes table  			entry = (int)(twoDCodes [entry] & 0xff);  			// Get the tagCode and the number of bits used up  			code = (entry & 0x78) >> 3;  			bits = entry & 0x07;  			if (code == 0) {  				if (!isWhite) {  					SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  				}  				bitOffset = a0 = b2;  				// Set pointer to consume the correct number of bits.  				UpdatePointer (7 - bits);  			}  			else if (code == 1) {  				// Horizontal  				UpdatePointer (7 - bits);  				// identify the next 2 codes.  				int number;  				if (isWhite) {  					number = DecodeWhiteCodeWord ();  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  					number = DecodeBlackCodeWord ();  					SetToBlack (buffer' lineOffset' bitOffset' number);  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  				}  				else {  					number = DecodeBlackCodeWord ();  					SetToBlack (buffer' lineOffset' bitOffset' number);  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  					number = DecodeWhiteCodeWord ();  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  				}  				a0 = bitOffset;  			}  			else if (code <= 8) {  				// Vertical  				a1 = b1 + (code - 5);  				currChangingElems [currIndex++] = a1;  				// We write the current color till a1 - 1 pos'  				// since a1 is where the next color starts  				if (!isWhite) {  					SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  				}  				bitOffset = a0 = a1;  				isWhite = !isWhite;  				UpdatePointer (7 - bits);  			}  			else {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  			}  		}  		// Add the changing element beyond the current scanline for the  		// other color too  		currChangingElems [currIndex++] = bitOffset;  		changingElemSize = currIndex;  	}  	else {  		// 1D encoded scanline follows  		DecodeNextScanline (buffer' lineOffset' startX);  	}  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: for (int lines = 1; lines < height; lines++) {  	// Every line must begin with an EOL followed by a bit which  	// indicates whether the following scanline is 1D or 2D encoded.  	if (ReadEOL (false) == 0) {  		// 2D encoded scanline follows  		// Initialize previous scanlines changing elements' and  		// initialize current scanline'lineRead changing elements array  		temp = prevChangingElems;  		prevChangingElems = currChangingElems;  		currChangingElems = temp;  		currIndex = 0;  		// a0 has to be set just before the start of this scanline.  		a0 = -1;  		isWhite = true;  		bitOffset = startX;  		lastChangingElement = 0;  		while (bitOffset < w) {  			// Get the next changing element  			GetNextChangingElement (a0' isWhite' b);  			b1 = b [0];  			b2 = b [1];  			// Get the next seven bits  			entry = NextLesserThan8Bits (7);  			// Run these through the 2DCodes table  			entry = (int)(twoDCodes [entry] & 0xff);  			// Get the tagCode and the number of bits used up  			code = (entry & 0x78) >> 3;  			bits = entry & 0x07;  			if (code == 0) {  				if (!isWhite) {  					SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  				}  				bitOffset = a0 = b2;  				// Set pointer to consume the correct number of bits.  				UpdatePointer (7 - bits);  			}  			else if (code == 1) {  				// Horizontal  				UpdatePointer (7 - bits);  				// identify the next 2 codes.  				int number;  				if (isWhite) {  					number = DecodeWhiteCodeWord ();  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  					number = DecodeBlackCodeWord ();  					SetToBlack (buffer' lineOffset' bitOffset' number);  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  				}  				else {  					number = DecodeBlackCodeWord ();  					SetToBlack (buffer' lineOffset' bitOffset' number);  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  					number = DecodeWhiteCodeWord ();  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  				}  				a0 = bitOffset;  			}  			else if (code <= 8) {  				// Vertical  				a1 = b1 + (code - 5);  				currChangingElems [currIndex++] = a1;  				// We write the current color till a1 - 1 pos'  				// since a1 is where the next color starts  				if (!isWhite) {  					SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  				}  				bitOffset = a0 = a1;  				isWhite = !isWhite;  				UpdatePointer (7 - bits);  			}  			else {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  			}  		}  		// Add the changing element beyond the current scanline for the  		// other color too  		currChangingElems [currIndex++] = bitOffset;  		changingElemSize = currIndex;  	}  	else {  		// 1D encoded scanline follows  		DecodeNextScanline (buffer' lineOffset' startX);  	}  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: for (int lines = 1; lines < height; lines++) {  	// Every line must begin with an EOL followed by a bit which  	// indicates whether the following scanline is 1D or 2D encoded.  	if (ReadEOL (false) == 0) {  		// 2D encoded scanline follows  		// Initialize previous scanlines changing elements' and  		// initialize current scanline'lineRead changing elements array  		temp = prevChangingElems;  		prevChangingElems = currChangingElems;  		currChangingElems = temp;  		currIndex = 0;  		// a0 has to be set just before the start of this scanline.  		a0 = -1;  		isWhite = true;  		bitOffset = startX;  		lastChangingElement = 0;  		while (bitOffset < w) {  			// Get the next changing element  			GetNextChangingElement (a0' isWhite' b);  			b1 = b [0];  			b2 = b [1];  			// Get the next seven bits  			entry = NextLesserThan8Bits (7);  			// Run these through the 2DCodes table  			entry = (int)(twoDCodes [entry] & 0xff);  			// Get the tagCode and the number of bits used up  			code = (entry & 0x78) >> 3;  			bits = entry & 0x07;  			if (code == 0) {  				if (!isWhite) {  					SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  				}  				bitOffset = a0 = b2;  				// Set pointer to consume the correct number of bits.  				UpdatePointer (7 - bits);  			}  			else if (code == 1) {  				// Horizontal  				UpdatePointer (7 - bits);  				// identify the next 2 codes.  				int number;  				if (isWhite) {  					number = DecodeWhiteCodeWord ();  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  					number = DecodeBlackCodeWord ();  					SetToBlack (buffer' lineOffset' bitOffset' number);  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  				}  				else {  					number = DecodeBlackCodeWord ();  					SetToBlack (buffer' lineOffset' bitOffset' number);  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  					number = DecodeWhiteCodeWord ();  					bitOffset += number;  					currChangingElems [currIndex++] = bitOffset;  				}  				a0 = bitOffset;  			}  			else if (code <= 8) {  				// Vertical  				a1 = b1 + (code - 5);  				currChangingElems [currIndex++] = a1;  				// We write the current color till a1 - 1 pos'  				// since a1 is where the next color starts  				if (!isWhite) {  					SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  				}  				bitOffset = a0 = a1;  				isWhite = !isWhite;  				UpdatePointer (7 - bits);  			}  			else {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  			}  		}  		// Add the changing element beyond the current scanline for the  		// other color too  		currChangingElems [currIndex++] = bitOffset;  		changingElemSize = currIndex;  	}  	else {  		// 1D encoded scanline follows  		DecodeNextScanline (buffer' lineOffset' startX);  	}  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (ReadEOL (false) == 0) {  	// 2D encoded scanline follows  	// Initialize previous scanlines changing elements' and  	// initialize current scanline'lineRead changing elements array  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	currChangingElems = temp;  	currIndex = 0;  	// a0 has to be set just before the start of this scanline.  	a0 = -1;  	isWhite = true;  	bitOffset = startX;  	lastChangingElement = 0;  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			UpdatePointer (7 - bits);  			// identify the next 2 codes.  			int number;  			if (isWhite) {  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  			}  			else {  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			currChangingElems [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	currChangingElems [currIndex++] = bitOffset;  	changingElemSize = currIndex;  }  else {  	// 1D encoded scanline follows  	DecodeNextScanline (buffer' lineOffset' startX);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (ReadEOL (false) == 0) {  	// 2D encoded scanline follows  	// Initialize previous scanlines changing elements' and  	// initialize current scanline'lineRead changing elements array  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	currChangingElems = temp;  	currIndex = 0;  	// a0 has to be set just before the start of this scanline.  	a0 = -1;  	isWhite = true;  	bitOffset = startX;  	lastChangingElement = 0;  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			UpdatePointer (7 - bits);  			// identify the next 2 codes.  			int number;  			if (isWhite) {  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  			}  			else {  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			currChangingElems [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	currChangingElems [currIndex++] = bitOffset;  	changingElemSize = currIndex;  }  else {  	// 1D encoded scanline follows  	DecodeNextScanline (buffer' lineOffset' startX);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (ReadEOL (false) == 0) {  	// 2D encoded scanline follows  	// Initialize previous scanlines changing elements' and  	// initialize current scanline'lineRead changing elements array  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	currChangingElems = temp;  	currIndex = 0;  	// a0 has to be set just before the start of this scanline.  	a0 = -1;  	isWhite = true;  	bitOffset = startX;  	lastChangingElement = 0;  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			UpdatePointer (7 - bits);  			// identify the next 2 codes.  			int number;  			if (isWhite) {  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  			}  			else {  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			currChangingElems [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	currChangingElems [currIndex++] = bitOffset;  	changingElemSize = currIndex;  }  else {  	// 1D encoded scanline follows  	DecodeNextScanline (buffer' lineOffset' startX);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (ReadEOL (false) == 0) {  	// 2D encoded scanline follows  	// Initialize previous scanlines changing elements' and  	// initialize current scanline'lineRead changing elements array  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	currChangingElems = temp;  	currIndex = 0;  	// a0 has to be set just before the start of this scanline.  	a0 = -1;  	isWhite = true;  	bitOffset = startX;  	lastChangingElement = 0;  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			UpdatePointer (7 - bits);  			// identify the next 2 codes.  			int number;  			if (isWhite) {  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  			}  			else {  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			currChangingElems [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	currChangingElems [currIndex++] = bitOffset;  	changingElemSize = currIndex;  }  else {  	// 1D encoded scanline follows  	DecodeNextScanline (buffer' lineOffset' startX);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (ReadEOL (false) == 0) {  	// 2D encoded scanline follows  	// Initialize previous scanlines changing elements' and  	// initialize current scanline'lineRead changing elements array  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	currChangingElems = temp;  	currIndex = 0;  	// a0 has to be set just before the start of this scanline.  	a0 = -1;  	isWhite = true;  	bitOffset = startX;  	lastChangingElement = 0;  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			UpdatePointer (7 - bits);  			// identify the next 2 codes.  			int number;  			if (isWhite) {  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  			}  			else {  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			currChangingElems [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	currChangingElems [currIndex++] = bitOffset;  	changingElemSize = currIndex;  }  else {  	// 1D encoded scanline follows  	DecodeNextScanline (buffer' lineOffset' startX);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (ReadEOL (false) == 0) {  	// 2D encoded scanline follows  	// Initialize previous scanlines changing elements' and  	// initialize current scanline'lineRead changing elements array  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	currChangingElems = temp;  	currIndex = 0;  	// a0 has to be set just before the start of this scanline.  	a0 = -1;  	isWhite = true;  	bitOffset = startX;  	lastChangingElement = 0;  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			UpdatePointer (7 - bits);  			// identify the next 2 codes.  			int number;  			if (isWhite) {  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  			}  			else {  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			currChangingElems [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	currChangingElems [currIndex++] = bitOffset;  	changingElemSize = currIndex;  }  else {  	// 1D encoded scanline follows  	DecodeNextScanline (buffer' lineOffset' startX);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (ReadEOL (false) == 0) {  	// 2D encoded scanline follows  	// Initialize previous scanlines changing elements' and  	// initialize current scanline'lineRead changing elements array  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	currChangingElems = temp;  	currIndex = 0;  	// a0 has to be set just before the start of this scanline.  	a0 = -1;  	isWhite = true;  	bitOffset = startX;  	lastChangingElement = 0;  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			UpdatePointer (7 - bits);  			// identify the next 2 codes.  			int number;  			if (isWhite) {  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  			}  			else {  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				currChangingElems [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			currChangingElems [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	currChangingElems [currIndex++] = bitOffset;  	changingElemSize = currIndex;  }  else {  	// 1D encoded scanline follows  	DecodeNextScanline (buffer' lineOffset' startX);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		UpdatePointer (7 - bits);  		// identify the next 2 codes.  		int number;  		if (isWhite) {  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  		}  		else {  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		currChangingElems [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		UpdatePointer (7 - bits);  		// identify the next 2 codes.  		int number;  		if (isWhite) {  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  		}  		else {  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		currChangingElems [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		UpdatePointer (7 - bits);  		// identify the next 2 codes.  		int number;  		if (isWhite) {  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  		}  		else {  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		currChangingElems [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		UpdatePointer (7 - bits);  		// identify the next 2 codes.  		int number;  		if (isWhite) {  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  		}  		else {  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		currChangingElems [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		UpdatePointer (7 - bits);  		// identify the next 2 codes.  		int number;  		if (isWhite) {  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  		}  		else {  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		currChangingElems [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		UpdatePointer (7 - bits);  		// identify the next 2 codes.  		int number;  		if (isWhite) {  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  		}  		else {  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		currChangingElems [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		UpdatePointer (7 - bits);  		// identify the next 2 codes.  		int number;  		if (isWhite) {  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  		}  		else {  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			currChangingElems [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		currChangingElems [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: entry = NextLesserThan8Bits (7);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: code = (entry & 0x78) >> 3;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (code == 0) {  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	UpdatePointer (7 - bits);  	// identify the next 2 codes.  	int number;  	if (isWhite) {  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	else {  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	currChangingElems [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else {  	//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (code == 0) {  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	UpdatePointer (7 - bits);  	// identify the next 2 codes.  	int number;  	if (isWhite) {  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	else {  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	currChangingElems [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else {  	//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (code == 0) {  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	UpdatePointer (7 - bits);  	// identify the next 2 codes.  	int number;  	if (isWhite) {  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	else {  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	currChangingElems [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else {  	//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (code == 0) {  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	UpdatePointer (7 - bits);  	// identify the next 2 codes.  	int number;  	if (isWhite) {  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	else {  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	currChangingElems [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else {  	//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (code == 0) {  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	UpdatePointer (7 - bits);  	// identify the next 2 codes.  	int number;  	if (isWhite) {  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	else {  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	currChangingElems [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else {  	//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: UpdatePointer (7 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	UpdatePointer (7 - bits);  	// identify the next 2 codes.  	int number;  	if (isWhite) {  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	else {  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	currChangingElems [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else {  	//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	UpdatePointer (7 - bits);  	// identify the next 2 codes.  	int number;  	if (isWhite) {  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	else {  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	currChangingElems [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else {  	//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	UpdatePointer (7 - bits);  	// identify the next 2 codes.  	int number;  	if (isWhite) {  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	else {  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	currChangingElems [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else {  	//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	UpdatePointer (7 - bits);  	// identify the next 2 codes.  	int number;  	if (isWhite) {  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	else {  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		currChangingElems [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	currChangingElems [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else {  	//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: UpdatePointer (7 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	currChangingElems [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else {  	//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	currChangingElems [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else {  	//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	currChangingElems [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else {  	//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.3.compressed.data"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: a1 = b1 + (code - 5);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,Decode2D,The following statement contains a magic number: UpdatePointer (7 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: compression = 4;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: for (int lines = 0; lines < height; lines++) {  	// a0 has to be set just before the start of the scanline.  	a0 = -1;  	isWhite = true;  	// Assign the changing elements of the previous scanline to  	// prevChangingElems and start putting this new scanline'lineRead  	// changing elements into the currChangingElems.  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	cce = currChangingElems = temp;  	currIndex = 0;  	// Start decoding the scanline at startX in the raster  	bitOffset = startX;  	// Reset search start position for getNextChangingElement  	lastChangingElement = 0;  	// Till one whole scanline is decoded  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			// Pass  			// We always assume WhiteIsZero format for fax.  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  			// identify the next 2 alternating color codes.  			int number;  			if (isWhite) {  				// Following are white and black runs  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			else {  				// First a black run and then a white run follows  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			cce [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else if (code == 11) {  			if (NextLesserThan8Bits (3) != 7) {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  			}  			int zeros = 0;  			bool exit = false;  			while (!exit) {  				while (NextLesserThan8Bits (1) != 1) {  					zeros++;  				}  				if (zeros > 5) {  					// Exit tagCode  					// Zeros before exit tagCode  					zeros = zeros - 6;  					if (!isWhite && (zeros > 0)) {  						cce [currIndex++] = bitOffset;  					}  					// Zeros before the exit tagCode  					bitOffset += zeros;  					if (zeros > 0) {  						// Some zeros have been written  						isWhite = true;  					}  					// Read in the bit which specifies the color of  					// the following run  					if (NextLesserThan8Bits (1) == 0) {  						if (!isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = true;  					}  					else {  						if (isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = false;  					}  					exit = true;  				}  				if (zeros == 5) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					bitOffset += zeros;  					// Last thing written was white  					isWhite = true;  				}  				else {  					bitOffset += zeros;  					cce [currIndex++] = bitOffset;  					SetToBlack (buffer' lineOffset' bitOffset' 1);  					++bitOffset;  					// Last thing written was black  					isWhite = false;  				}  			}  		}  		else {  			//micah_tessler@yahoo.com  			//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  			//That is' they give up on the current line and move on to the next one  			//set bitOffset to w to move on to the next scan line.  			bitOffset = w;  			UpdatePointer (7 - bits);  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	//make sure that the index does not exceed the bounds of the array  	if (currIndex < cce.Length)  		cce [currIndex++] = bitOffset;  	// Number of changing elements in this scanline.  	changingElemSize = currIndex;  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: for (int lines = 0; lines < height; lines++) {  	// a0 has to be set just before the start of the scanline.  	a0 = -1;  	isWhite = true;  	// Assign the changing elements of the previous scanline to  	// prevChangingElems and start putting this new scanline'lineRead  	// changing elements into the currChangingElems.  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	cce = currChangingElems = temp;  	currIndex = 0;  	// Start decoding the scanline at startX in the raster  	bitOffset = startX;  	// Reset search start position for getNextChangingElement  	lastChangingElement = 0;  	// Till one whole scanline is decoded  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			// Pass  			// We always assume WhiteIsZero format for fax.  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  			// identify the next 2 alternating color codes.  			int number;  			if (isWhite) {  				// Following are white and black runs  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			else {  				// First a black run and then a white run follows  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			cce [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else if (code == 11) {  			if (NextLesserThan8Bits (3) != 7) {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  			}  			int zeros = 0;  			bool exit = false;  			while (!exit) {  				while (NextLesserThan8Bits (1) != 1) {  					zeros++;  				}  				if (zeros > 5) {  					// Exit tagCode  					// Zeros before exit tagCode  					zeros = zeros - 6;  					if (!isWhite && (zeros > 0)) {  						cce [currIndex++] = bitOffset;  					}  					// Zeros before the exit tagCode  					bitOffset += zeros;  					if (zeros > 0) {  						// Some zeros have been written  						isWhite = true;  					}  					// Read in the bit which specifies the color of  					// the following run  					if (NextLesserThan8Bits (1) == 0) {  						if (!isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = true;  					}  					else {  						if (isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = false;  					}  					exit = true;  				}  				if (zeros == 5) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					bitOffset += zeros;  					// Last thing written was white  					isWhite = true;  				}  				else {  					bitOffset += zeros;  					cce [currIndex++] = bitOffset;  					SetToBlack (buffer' lineOffset' bitOffset' 1);  					++bitOffset;  					// Last thing written was black  					isWhite = false;  				}  			}  		}  		else {  			//micah_tessler@yahoo.com  			//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  			//That is' they give up on the current line and move on to the next one  			//set bitOffset to w to move on to the next scan line.  			bitOffset = w;  			UpdatePointer (7 - bits);  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	//make sure that the index does not exceed the bounds of the array  	if (currIndex < cce.Length)  		cce [currIndex++] = bitOffset;  	// Number of changing elements in this scanline.  	changingElemSize = currIndex;  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: for (int lines = 0; lines < height; lines++) {  	// a0 has to be set just before the start of the scanline.  	a0 = -1;  	isWhite = true;  	// Assign the changing elements of the previous scanline to  	// prevChangingElems and start putting this new scanline'lineRead  	// changing elements into the currChangingElems.  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	cce = currChangingElems = temp;  	currIndex = 0;  	// Start decoding the scanline at startX in the raster  	bitOffset = startX;  	// Reset search start position for getNextChangingElement  	lastChangingElement = 0;  	// Till one whole scanline is decoded  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			// Pass  			// We always assume WhiteIsZero format for fax.  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  			// identify the next 2 alternating color codes.  			int number;  			if (isWhite) {  				// Following are white and black runs  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			else {  				// First a black run and then a white run follows  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			cce [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else if (code == 11) {  			if (NextLesserThan8Bits (3) != 7) {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  			}  			int zeros = 0;  			bool exit = false;  			while (!exit) {  				while (NextLesserThan8Bits (1) != 1) {  					zeros++;  				}  				if (zeros > 5) {  					// Exit tagCode  					// Zeros before exit tagCode  					zeros = zeros - 6;  					if (!isWhite && (zeros > 0)) {  						cce [currIndex++] = bitOffset;  					}  					// Zeros before the exit tagCode  					bitOffset += zeros;  					if (zeros > 0) {  						// Some zeros have been written  						isWhite = true;  					}  					// Read in the bit which specifies the color of  					// the following run  					if (NextLesserThan8Bits (1) == 0) {  						if (!isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = true;  					}  					else {  						if (isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = false;  					}  					exit = true;  				}  				if (zeros == 5) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					bitOffset += zeros;  					// Last thing written was white  					isWhite = true;  				}  				else {  					bitOffset += zeros;  					cce [currIndex++] = bitOffset;  					SetToBlack (buffer' lineOffset' bitOffset' 1);  					++bitOffset;  					// Last thing written was black  					isWhite = false;  				}  			}  		}  		else {  			//micah_tessler@yahoo.com  			//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  			//That is' they give up on the current line and move on to the next one  			//set bitOffset to w to move on to the next scan line.  			bitOffset = w;  			UpdatePointer (7 - bits);  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	//make sure that the index does not exceed the bounds of the array  	if (currIndex < cce.Length)  		cce [currIndex++] = bitOffset;  	// Number of changing elements in this scanline.  	changingElemSize = currIndex;  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: for (int lines = 0; lines < height; lines++) {  	// a0 has to be set just before the start of the scanline.  	a0 = -1;  	isWhite = true;  	// Assign the changing elements of the previous scanline to  	// prevChangingElems and start putting this new scanline'lineRead  	// changing elements into the currChangingElems.  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	cce = currChangingElems = temp;  	currIndex = 0;  	// Start decoding the scanline at startX in the raster  	bitOffset = startX;  	// Reset search start position for getNextChangingElement  	lastChangingElement = 0;  	// Till one whole scanline is decoded  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			// Pass  			// We always assume WhiteIsZero format for fax.  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  			// identify the next 2 alternating color codes.  			int number;  			if (isWhite) {  				// Following are white and black runs  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			else {  				// First a black run and then a white run follows  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			cce [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else if (code == 11) {  			if (NextLesserThan8Bits (3) != 7) {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  			}  			int zeros = 0;  			bool exit = false;  			while (!exit) {  				while (NextLesserThan8Bits (1) != 1) {  					zeros++;  				}  				if (zeros > 5) {  					// Exit tagCode  					// Zeros before exit tagCode  					zeros = zeros - 6;  					if (!isWhite && (zeros > 0)) {  						cce [currIndex++] = bitOffset;  					}  					// Zeros before the exit tagCode  					bitOffset += zeros;  					if (zeros > 0) {  						// Some zeros have been written  						isWhite = true;  					}  					// Read in the bit which specifies the color of  					// the following run  					if (NextLesserThan8Bits (1) == 0) {  						if (!isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = true;  					}  					else {  						if (isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = false;  					}  					exit = true;  				}  				if (zeros == 5) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					bitOffset += zeros;  					// Last thing written was white  					isWhite = true;  				}  				else {  					bitOffset += zeros;  					cce [currIndex++] = bitOffset;  					SetToBlack (buffer' lineOffset' bitOffset' 1);  					++bitOffset;  					// Last thing written was black  					isWhite = false;  				}  			}  		}  		else {  			//micah_tessler@yahoo.com  			//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  			//That is' they give up on the current line and move on to the next one  			//set bitOffset to w to move on to the next scan line.  			bitOffset = w;  			UpdatePointer (7 - bits);  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	//make sure that the index does not exceed the bounds of the array  	if (currIndex < cce.Length)  		cce [currIndex++] = bitOffset;  	// Number of changing elements in this scanline.  	changingElemSize = currIndex;  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: for (int lines = 0; lines < height; lines++) {  	// a0 has to be set just before the start of the scanline.  	a0 = -1;  	isWhite = true;  	// Assign the changing elements of the previous scanline to  	// prevChangingElems and start putting this new scanline'lineRead  	// changing elements into the currChangingElems.  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	cce = currChangingElems = temp;  	currIndex = 0;  	// Start decoding the scanline at startX in the raster  	bitOffset = startX;  	// Reset search start position for getNextChangingElement  	lastChangingElement = 0;  	// Till one whole scanline is decoded  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			// Pass  			// We always assume WhiteIsZero format for fax.  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  			// identify the next 2 alternating color codes.  			int number;  			if (isWhite) {  				// Following are white and black runs  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			else {  				// First a black run and then a white run follows  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			cce [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else if (code == 11) {  			if (NextLesserThan8Bits (3) != 7) {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  			}  			int zeros = 0;  			bool exit = false;  			while (!exit) {  				while (NextLesserThan8Bits (1) != 1) {  					zeros++;  				}  				if (zeros > 5) {  					// Exit tagCode  					// Zeros before exit tagCode  					zeros = zeros - 6;  					if (!isWhite && (zeros > 0)) {  						cce [currIndex++] = bitOffset;  					}  					// Zeros before the exit tagCode  					bitOffset += zeros;  					if (zeros > 0) {  						// Some zeros have been written  						isWhite = true;  					}  					// Read in the bit which specifies the color of  					// the following run  					if (NextLesserThan8Bits (1) == 0) {  						if (!isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = true;  					}  					else {  						if (isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = false;  					}  					exit = true;  				}  				if (zeros == 5) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					bitOffset += zeros;  					// Last thing written was white  					isWhite = true;  				}  				else {  					bitOffset += zeros;  					cce [currIndex++] = bitOffset;  					SetToBlack (buffer' lineOffset' bitOffset' 1);  					++bitOffset;  					// Last thing written was black  					isWhite = false;  				}  			}  		}  		else {  			//micah_tessler@yahoo.com  			//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  			//That is' they give up on the current line and move on to the next one  			//set bitOffset to w to move on to the next scan line.  			bitOffset = w;  			UpdatePointer (7 - bits);  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	//make sure that the index does not exceed the bounds of the array  	if (currIndex < cce.Length)  		cce [currIndex++] = bitOffset;  	// Number of changing elements in this scanline.  	changingElemSize = currIndex;  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: for (int lines = 0; lines < height; lines++) {  	// a0 has to be set just before the start of the scanline.  	a0 = -1;  	isWhite = true;  	// Assign the changing elements of the previous scanline to  	// prevChangingElems and start putting this new scanline'lineRead  	// changing elements into the currChangingElems.  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	cce = currChangingElems = temp;  	currIndex = 0;  	// Start decoding the scanline at startX in the raster  	bitOffset = startX;  	// Reset search start position for getNextChangingElement  	lastChangingElement = 0;  	// Till one whole scanline is decoded  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			// Pass  			// We always assume WhiteIsZero format for fax.  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  			// identify the next 2 alternating color codes.  			int number;  			if (isWhite) {  				// Following are white and black runs  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			else {  				// First a black run and then a white run follows  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			cce [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else if (code == 11) {  			if (NextLesserThan8Bits (3) != 7) {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  			}  			int zeros = 0;  			bool exit = false;  			while (!exit) {  				while (NextLesserThan8Bits (1) != 1) {  					zeros++;  				}  				if (zeros > 5) {  					// Exit tagCode  					// Zeros before exit tagCode  					zeros = zeros - 6;  					if (!isWhite && (zeros > 0)) {  						cce [currIndex++] = bitOffset;  					}  					// Zeros before the exit tagCode  					bitOffset += zeros;  					if (zeros > 0) {  						// Some zeros have been written  						isWhite = true;  					}  					// Read in the bit which specifies the color of  					// the following run  					if (NextLesserThan8Bits (1) == 0) {  						if (!isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = true;  					}  					else {  						if (isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = false;  					}  					exit = true;  				}  				if (zeros == 5) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					bitOffset += zeros;  					// Last thing written was white  					isWhite = true;  				}  				else {  					bitOffset += zeros;  					cce [currIndex++] = bitOffset;  					SetToBlack (buffer' lineOffset' bitOffset' 1);  					++bitOffset;  					// Last thing written was black  					isWhite = false;  				}  			}  		}  		else {  			//micah_tessler@yahoo.com  			//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  			//That is' they give up on the current line and move on to the next one  			//set bitOffset to w to move on to the next scan line.  			bitOffset = w;  			UpdatePointer (7 - bits);  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	//make sure that the index does not exceed the bounds of the array  	if (currIndex < cce.Length)  		cce [currIndex++] = bitOffset;  	// Number of changing elements in this scanline.  	changingElemSize = currIndex;  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: for (int lines = 0; lines < height; lines++) {  	// a0 has to be set just before the start of the scanline.  	a0 = -1;  	isWhite = true;  	// Assign the changing elements of the previous scanline to  	// prevChangingElems and start putting this new scanline'lineRead  	// changing elements into the currChangingElems.  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	cce = currChangingElems = temp;  	currIndex = 0;  	// Start decoding the scanline at startX in the raster  	bitOffset = startX;  	// Reset search start position for getNextChangingElement  	lastChangingElement = 0;  	// Till one whole scanline is decoded  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			// Pass  			// We always assume WhiteIsZero format for fax.  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  			// identify the next 2 alternating color codes.  			int number;  			if (isWhite) {  				// Following are white and black runs  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			else {  				// First a black run and then a white run follows  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			cce [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else if (code == 11) {  			if (NextLesserThan8Bits (3) != 7) {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  			}  			int zeros = 0;  			bool exit = false;  			while (!exit) {  				while (NextLesserThan8Bits (1) != 1) {  					zeros++;  				}  				if (zeros > 5) {  					// Exit tagCode  					// Zeros before exit tagCode  					zeros = zeros - 6;  					if (!isWhite && (zeros > 0)) {  						cce [currIndex++] = bitOffset;  					}  					// Zeros before the exit tagCode  					bitOffset += zeros;  					if (zeros > 0) {  						// Some zeros have been written  						isWhite = true;  					}  					// Read in the bit which specifies the color of  					// the following run  					if (NextLesserThan8Bits (1) == 0) {  						if (!isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = true;  					}  					else {  						if (isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = false;  					}  					exit = true;  				}  				if (zeros == 5) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					bitOffset += zeros;  					// Last thing written was white  					isWhite = true;  				}  				else {  					bitOffset += zeros;  					cce [currIndex++] = bitOffset;  					SetToBlack (buffer' lineOffset' bitOffset' 1);  					++bitOffset;  					// Last thing written was black  					isWhite = false;  				}  			}  		}  		else {  			//micah_tessler@yahoo.com  			//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  			//That is' they give up on the current line and move on to the next one  			//set bitOffset to w to move on to the next scan line.  			bitOffset = w;  			UpdatePointer (7 - bits);  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	//make sure that the index does not exceed the bounds of the array  	if (currIndex < cce.Length)  		cce [currIndex++] = bitOffset;  	// Number of changing elements in this scanline.  	changingElemSize = currIndex;  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: for (int lines = 0; lines < height; lines++) {  	// a0 has to be set just before the start of the scanline.  	a0 = -1;  	isWhite = true;  	// Assign the changing elements of the previous scanline to  	// prevChangingElems and start putting this new scanline'lineRead  	// changing elements into the currChangingElems.  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	cce = currChangingElems = temp;  	currIndex = 0;  	// Start decoding the scanline at startX in the raster  	bitOffset = startX;  	// Reset search start position for getNextChangingElement  	lastChangingElement = 0;  	// Till one whole scanline is decoded  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			// Pass  			// We always assume WhiteIsZero format for fax.  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  			// identify the next 2 alternating color codes.  			int number;  			if (isWhite) {  				// Following are white and black runs  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			else {  				// First a black run and then a white run follows  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			cce [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else if (code == 11) {  			if (NextLesserThan8Bits (3) != 7) {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  			}  			int zeros = 0;  			bool exit = false;  			while (!exit) {  				while (NextLesserThan8Bits (1) != 1) {  					zeros++;  				}  				if (zeros > 5) {  					// Exit tagCode  					// Zeros before exit tagCode  					zeros = zeros - 6;  					if (!isWhite && (zeros > 0)) {  						cce [currIndex++] = bitOffset;  					}  					// Zeros before the exit tagCode  					bitOffset += zeros;  					if (zeros > 0) {  						// Some zeros have been written  						isWhite = true;  					}  					// Read in the bit which specifies the color of  					// the following run  					if (NextLesserThan8Bits (1) == 0) {  						if (!isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = true;  					}  					else {  						if (isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = false;  					}  					exit = true;  				}  				if (zeros == 5) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					bitOffset += zeros;  					// Last thing written was white  					isWhite = true;  				}  				else {  					bitOffset += zeros;  					cce [currIndex++] = bitOffset;  					SetToBlack (buffer' lineOffset' bitOffset' 1);  					++bitOffset;  					// Last thing written was black  					isWhite = false;  				}  			}  		}  		else {  			//micah_tessler@yahoo.com  			//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  			//That is' they give up on the current line and move on to the next one  			//set bitOffset to w to move on to the next scan line.  			bitOffset = w;  			UpdatePointer (7 - bits);  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	//make sure that the index does not exceed the bounds of the array  	if (currIndex < cce.Length)  		cce [currIndex++] = bitOffset;  	// Number of changing elements in this scanline.  	changingElemSize = currIndex;  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: for (int lines = 0; lines < height; lines++) {  	// a0 has to be set just before the start of the scanline.  	a0 = -1;  	isWhite = true;  	// Assign the changing elements of the previous scanline to  	// prevChangingElems and start putting this new scanline'lineRead  	// changing elements into the currChangingElems.  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	cce = currChangingElems = temp;  	currIndex = 0;  	// Start decoding the scanline at startX in the raster  	bitOffset = startX;  	// Reset search start position for getNextChangingElement  	lastChangingElement = 0;  	// Till one whole scanline is decoded  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			// Pass  			// We always assume WhiteIsZero format for fax.  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  			// identify the next 2 alternating color codes.  			int number;  			if (isWhite) {  				// Following are white and black runs  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			else {  				// First a black run and then a white run follows  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			cce [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else if (code == 11) {  			if (NextLesserThan8Bits (3) != 7) {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  			}  			int zeros = 0;  			bool exit = false;  			while (!exit) {  				while (NextLesserThan8Bits (1) != 1) {  					zeros++;  				}  				if (zeros > 5) {  					// Exit tagCode  					// Zeros before exit tagCode  					zeros = zeros - 6;  					if (!isWhite && (zeros > 0)) {  						cce [currIndex++] = bitOffset;  					}  					// Zeros before the exit tagCode  					bitOffset += zeros;  					if (zeros > 0) {  						// Some zeros have been written  						isWhite = true;  					}  					// Read in the bit which specifies the color of  					// the following run  					if (NextLesserThan8Bits (1) == 0) {  						if (!isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = true;  					}  					else {  						if (isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = false;  					}  					exit = true;  				}  				if (zeros == 5) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					bitOffset += zeros;  					// Last thing written was white  					isWhite = true;  				}  				else {  					bitOffset += zeros;  					cce [currIndex++] = bitOffset;  					SetToBlack (buffer' lineOffset' bitOffset' 1);  					++bitOffset;  					// Last thing written was black  					isWhite = false;  				}  			}  		}  		else {  			//micah_tessler@yahoo.com  			//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  			//That is' they give up on the current line and move on to the next one  			//set bitOffset to w to move on to the next scan line.  			bitOffset = w;  			UpdatePointer (7 - bits);  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	//make sure that the index does not exceed the bounds of the array  	if (currIndex < cce.Length)  		cce [currIndex++] = bitOffset;  	// Number of changing elements in this scanline.  	changingElemSize = currIndex;  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: for (int lines = 0; lines < height; lines++) {  	// a0 has to be set just before the start of the scanline.  	a0 = -1;  	isWhite = true;  	// Assign the changing elements of the previous scanline to  	// prevChangingElems and start putting this new scanline'lineRead  	// changing elements into the currChangingElems.  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	cce = currChangingElems = temp;  	currIndex = 0;  	// Start decoding the scanline at startX in the raster  	bitOffset = startX;  	// Reset search start position for getNextChangingElement  	lastChangingElement = 0;  	// Till one whole scanline is decoded  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			// Pass  			// We always assume WhiteIsZero format for fax.  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  			// identify the next 2 alternating color codes.  			int number;  			if (isWhite) {  				// Following are white and black runs  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			else {  				// First a black run and then a white run follows  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			cce [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else if (code == 11) {  			if (NextLesserThan8Bits (3) != 7) {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  			}  			int zeros = 0;  			bool exit = false;  			while (!exit) {  				while (NextLesserThan8Bits (1) != 1) {  					zeros++;  				}  				if (zeros > 5) {  					// Exit tagCode  					// Zeros before exit tagCode  					zeros = zeros - 6;  					if (!isWhite && (zeros > 0)) {  						cce [currIndex++] = bitOffset;  					}  					// Zeros before the exit tagCode  					bitOffset += zeros;  					if (zeros > 0) {  						// Some zeros have been written  						isWhite = true;  					}  					// Read in the bit which specifies the color of  					// the following run  					if (NextLesserThan8Bits (1) == 0) {  						if (!isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = true;  					}  					else {  						if (isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = false;  					}  					exit = true;  				}  				if (zeros == 5) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					bitOffset += zeros;  					// Last thing written was white  					isWhite = true;  				}  				else {  					bitOffset += zeros;  					cce [currIndex++] = bitOffset;  					SetToBlack (buffer' lineOffset' bitOffset' 1);  					++bitOffset;  					// Last thing written was black  					isWhite = false;  				}  			}  		}  		else {  			//micah_tessler@yahoo.com  			//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  			//That is' they give up on the current line and move on to the next one  			//set bitOffset to w to move on to the next scan line.  			bitOffset = w;  			UpdatePointer (7 - bits);  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	//make sure that the index does not exceed the bounds of the array  	if (currIndex < cce.Length)  		cce [currIndex++] = bitOffset;  	// Number of changing elements in this scanline.  	changingElemSize = currIndex;  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: for (int lines = 0; lines < height; lines++) {  	// a0 has to be set just before the start of the scanline.  	a0 = -1;  	isWhite = true;  	// Assign the changing elements of the previous scanline to  	// prevChangingElems and start putting this new scanline'lineRead  	// changing elements into the currChangingElems.  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	cce = currChangingElems = temp;  	currIndex = 0;  	// Start decoding the scanline at startX in the raster  	bitOffset = startX;  	// Reset search start position for getNextChangingElement  	lastChangingElement = 0;  	// Till one whole scanline is decoded  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			// Pass  			// We always assume WhiteIsZero format for fax.  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  			// identify the next 2 alternating color codes.  			int number;  			if (isWhite) {  				// Following are white and black runs  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			else {  				// First a black run and then a white run follows  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			cce [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else if (code == 11) {  			if (NextLesserThan8Bits (3) != 7) {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  			}  			int zeros = 0;  			bool exit = false;  			while (!exit) {  				while (NextLesserThan8Bits (1) != 1) {  					zeros++;  				}  				if (zeros > 5) {  					// Exit tagCode  					// Zeros before exit tagCode  					zeros = zeros - 6;  					if (!isWhite && (zeros > 0)) {  						cce [currIndex++] = bitOffset;  					}  					// Zeros before the exit tagCode  					bitOffset += zeros;  					if (zeros > 0) {  						// Some zeros have been written  						isWhite = true;  					}  					// Read in the bit which specifies the color of  					// the following run  					if (NextLesserThan8Bits (1) == 0) {  						if (!isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = true;  					}  					else {  						if (isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = false;  					}  					exit = true;  				}  				if (zeros == 5) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					bitOffset += zeros;  					// Last thing written was white  					isWhite = true;  				}  				else {  					bitOffset += zeros;  					cce [currIndex++] = bitOffset;  					SetToBlack (buffer' lineOffset' bitOffset' 1);  					++bitOffset;  					// Last thing written was black  					isWhite = false;  				}  			}  		}  		else {  			//micah_tessler@yahoo.com  			//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  			//That is' they give up on the current line and move on to the next one  			//set bitOffset to w to move on to the next scan line.  			bitOffset = w;  			UpdatePointer (7 - bits);  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	//make sure that the index does not exceed the bounds of the array  	if (currIndex < cce.Length)  		cce [currIndex++] = bitOffset;  	// Number of changing elements in this scanline.  	changingElemSize = currIndex;  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: for (int lines = 0; lines < height; lines++) {  	// a0 has to be set just before the start of the scanline.  	a0 = -1;  	isWhite = true;  	// Assign the changing elements of the previous scanline to  	// prevChangingElems and start putting this new scanline'lineRead  	// changing elements into the currChangingElems.  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	cce = currChangingElems = temp;  	currIndex = 0;  	// Start decoding the scanline at startX in the raster  	bitOffset = startX;  	// Reset search start position for getNextChangingElement  	lastChangingElement = 0;  	// Till one whole scanline is decoded  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			// Pass  			// We always assume WhiteIsZero format for fax.  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  			// identify the next 2 alternating color codes.  			int number;  			if (isWhite) {  				// Following are white and black runs  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			else {  				// First a black run and then a white run follows  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			cce [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else if (code == 11) {  			if (NextLesserThan8Bits (3) != 7) {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  			}  			int zeros = 0;  			bool exit = false;  			while (!exit) {  				while (NextLesserThan8Bits (1) != 1) {  					zeros++;  				}  				if (zeros > 5) {  					// Exit tagCode  					// Zeros before exit tagCode  					zeros = zeros - 6;  					if (!isWhite && (zeros > 0)) {  						cce [currIndex++] = bitOffset;  					}  					// Zeros before the exit tagCode  					bitOffset += zeros;  					if (zeros > 0) {  						// Some zeros have been written  						isWhite = true;  					}  					// Read in the bit which specifies the color of  					// the following run  					if (NextLesserThan8Bits (1) == 0) {  						if (!isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = true;  					}  					else {  						if (isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = false;  					}  					exit = true;  				}  				if (zeros == 5) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					bitOffset += zeros;  					// Last thing written was white  					isWhite = true;  				}  				else {  					bitOffset += zeros;  					cce [currIndex++] = bitOffset;  					SetToBlack (buffer' lineOffset' bitOffset' 1);  					++bitOffset;  					// Last thing written was black  					isWhite = false;  				}  			}  		}  		else {  			//micah_tessler@yahoo.com  			//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  			//That is' they give up on the current line and move on to the next one  			//set bitOffset to w to move on to the next scan line.  			bitOffset = w;  			UpdatePointer (7 - bits);  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	//make sure that the index does not exceed the bounds of the array  	if (currIndex < cce.Length)  		cce [currIndex++] = bitOffset;  	// Number of changing elements in this scanline.  	changingElemSize = currIndex;  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: for (int lines = 0; lines < height; lines++) {  	// a0 has to be set just before the start of the scanline.  	a0 = -1;  	isWhite = true;  	// Assign the changing elements of the previous scanline to  	// prevChangingElems and start putting this new scanline'lineRead  	// changing elements into the currChangingElems.  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	cce = currChangingElems = temp;  	currIndex = 0;  	// Start decoding the scanline at startX in the raster  	bitOffset = startX;  	// Reset search start position for getNextChangingElement  	lastChangingElement = 0;  	// Till one whole scanline is decoded  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			// Pass  			// We always assume WhiteIsZero format for fax.  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  			// identify the next 2 alternating color codes.  			int number;  			if (isWhite) {  				// Following are white and black runs  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			else {  				// First a black run and then a white run follows  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			cce [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else if (code == 11) {  			if (NextLesserThan8Bits (3) != 7) {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  			}  			int zeros = 0;  			bool exit = false;  			while (!exit) {  				while (NextLesserThan8Bits (1) != 1) {  					zeros++;  				}  				if (zeros > 5) {  					// Exit tagCode  					// Zeros before exit tagCode  					zeros = zeros - 6;  					if (!isWhite && (zeros > 0)) {  						cce [currIndex++] = bitOffset;  					}  					// Zeros before the exit tagCode  					bitOffset += zeros;  					if (zeros > 0) {  						// Some zeros have been written  						isWhite = true;  					}  					// Read in the bit which specifies the color of  					// the following run  					if (NextLesserThan8Bits (1) == 0) {  						if (!isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = true;  					}  					else {  						if (isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = false;  					}  					exit = true;  				}  				if (zeros == 5) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					bitOffset += zeros;  					// Last thing written was white  					isWhite = true;  				}  				else {  					bitOffset += zeros;  					cce [currIndex++] = bitOffset;  					SetToBlack (buffer' lineOffset' bitOffset' 1);  					++bitOffset;  					// Last thing written was black  					isWhite = false;  				}  			}  		}  		else {  			//micah_tessler@yahoo.com  			//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  			//That is' they give up on the current line and move on to the next one  			//set bitOffset to w to move on to the next scan line.  			bitOffset = w;  			UpdatePointer (7 - bits);  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	//make sure that the index does not exceed the bounds of the array  	if (currIndex < cce.Length)  		cce [currIndex++] = bitOffset;  	// Number of changing elements in this scanline.  	changingElemSize = currIndex;  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: for (int lines = 0; lines < height; lines++) {  	// a0 has to be set just before the start of the scanline.  	a0 = -1;  	isWhite = true;  	// Assign the changing elements of the previous scanline to  	// prevChangingElems and start putting this new scanline'lineRead  	// changing elements into the currChangingElems.  	temp = prevChangingElems;  	prevChangingElems = currChangingElems;  	cce = currChangingElems = temp;  	currIndex = 0;  	// Start decoding the scanline at startX in the raster  	bitOffset = startX;  	// Reset search start position for getNextChangingElement  	lastChangingElement = 0;  	// Till one whole scanline is decoded  	while (bitOffset < w) {  		// Get the next changing element  		GetNextChangingElement (a0' isWhite' b);  		b1 = b [0];  		b2 = b [1];  		// Get the next seven bits  		entry = NextLesserThan8Bits (7);  		// Run these through the 2DCodes table  		entry = (int)(twoDCodes [entry] & 0xff);  		// Get the tagCode and the number of bits used up  		code = (entry & 0x78) >> 3;  		bits = entry & 0x07;  		if (code == 0) {  			// Pass  			// We always assume WhiteIsZero format for fax.  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  			}  			bitOffset = a0 = b2;  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  		}  		else if (code == 1) {  			// Horizontal  			// Set pointer to only consume the correct number of bits.  			UpdatePointer (7 - bits);  			// identify the next 2 alternating color codes.  			int number;  			if (isWhite) {  				// Following are white and black runs  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			else {  				// First a black run and then a white run follows  				number = DecodeBlackCodeWord ();  				SetToBlack (buffer' lineOffset' bitOffset' number);  				bitOffset += number;  				cce [currIndex++] = bitOffset;  				number = DecodeWhiteCodeWord ();  				bitOffset += number;  				cce [currIndex++] = bitOffset;  			}  			a0 = bitOffset;  		}  		else if (code <= 8) {  			// Vertical  			a1 = b1 + (code - 5);  			cce [currIndex++] = a1;  			// We write the current color till a1 - 1 pos'  			// since a1 is where the next color starts  			if (!isWhite) {  				SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  			}  			bitOffset = a0 = a1;  			isWhite = !isWhite;  			UpdatePointer (7 - bits);  		}  		else if (code == 11) {  			if (NextLesserThan8Bits (3) != 7) {  				//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  			}  			int zeros = 0;  			bool exit = false;  			while (!exit) {  				while (NextLesserThan8Bits (1) != 1) {  					zeros++;  				}  				if (zeros > 5) {  					// Exit tagCode  					// Zeros before exit tagCode  					zeros = zeros - 6;  					if (!isWhite && (zeros > 0)) {  						cce [currIndex++] = bitOffset;  					}  					// Zeros before the exit tagCode  					bitOffset += zeros;  					if (zeros > 0) {  						// Some zeros have been written  						isWhite = true;  					}  					// Read in the bit which specifies the color of  					// the following run  					if (NextLesserThan8Bits (1) == 0) {  						if (!isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = true;  					}  					else {  						if (isWhite) {  							cce [currIndex++] = bitOffset;  						}  						isWhite = false;  					}  					exit = true;  				}  				if (zeros == 5) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					bitOffset += zeros;  					// Last thing written was white  					isWhite = true;  				}  				else {  					bitOffset += zeros;  					cce [currIndex++] = bitOffset;  					SetToBlack (buffer' lineOffset' bitOffset' 1);  					++bitOffset;  					// Last thing written was black  					isWhite = false;  				}  			}  		}  		else {  			//micah_tessler@yahoo.com  			//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  			//That is' they give up on the current line and move on to the next one  			//set bitOffset to w to move on to the next scan line.  			bitOffset = w;  			UpdatePointer (7 - bits);  		}  	}  	// Add the changing element beyond the current scanline for the  	// other color too  	//make sure that the index does not exceed the bounds of the array  	if (currIndex < cce.Length)  		cce [currIndex++] = bitOffset;  	// Number of changing elements in this scanline.  	changingElemSize = currIndex;  	lineOffset += scanlineStride;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		// Pass  		// We always assume WhiteIsZero format for fax.  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  		// identify the next 2 alternating color codes.  		int number;  		if (isWhite) {  			// Following are white and black runs  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		else {  			// First a black run and then a white run follows  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		cce [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else if (code == 11) {  		if (NextLesserThan8Bits (3) != 7) {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  		}  		int zeros = 0;  		bool exit = false;  		while (!exit) {  			while (NextLesserThan8Bits (1) != 1) {  				zeros++;  			}  			if (zeros > 5) {  				// Exit tagCode  				// Zeros before exit tagCode  				zeros = zeros - 6;  				if (!isWhite && (zeros > 0)) {  					cce [currIndex++] = bitOffset;  				}  				// Zeros before the exit tagCode  				bitOffset += zeros;  				if (zeros > 0) {  					// Some zeros have been written  					isWhite = true;  				}  				// Read in the bit which specifies the color of  				// the following run  				if (NextLesserThan8Bits (1) == 0) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = true;  				}  				else {  					if (isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = false;  				}  				exit = true;  			}  			if (zeros == 5) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				bitOffset += zeros;  				// Last thing written was white  				isWhite = true;  			}  			else {  				bitOffset += zeros;  				cce [currIndex++] = bitOffset;  				SetToBlack (buffer' lineOffset' bitOffset' 1);  				++bitOffset;  				// Last thing written was black  				isWhite = false;  			}  		}  	}  	else {  		//micah_tessler@yahoo.com  		//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  		//That is' they give up on the current line and move on to the next one  		//set bitOffset to w to move on to the next scan line.  		bitOffset = w;  		UpdatePointer (7 - bits);  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		// Pass  		// We always assume WhiteIsZero format for fax.  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  		// identify the next 2 alternating color codes.  		int number;  		if (isWhite) {  			// Following are white and black runs  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		else {  			// First a black run and then a white run follows  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		cce [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else if (code == 11) {  		if (NextLesserThan8Bits (3) != 7) {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  		}  		int zeros = 0;  		bool exit = false;  		while (!exit) {  			while (NextLesserThan8Bits (1) != 1) {  				zeros++;  			}  			if (zeros > 5) {  				// Exit tagCode  				// Zeros before exit tagCode  				zeros = zeros - 6;  				if (!isWhite && (zeros > 0)) {  					cce [currIndex++] = bitOffset;  				}  				// Zeros before the exit tagCode  				bitOffset += zeros;  				if (zeros > 0) {  					// Some zeros have been written  					isWhite = true;  				}  				// Read in the bit which specifies the color of  				// the following run  				if (NextLesserThan8Bits (1) == 0) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = true;  				}  				else {  					if (isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = false;  				}  				exit = true;  			}  			if (zeros == 5) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				bitOffset += zeros;  				// Last thing written was white  				isWhite = true;  			}  			else {  				bitOffset += zeros;  				cce [currIndex++] = bitOffset;  				SetToBlack (buffer' lineOffset' bitOffset' 1);  				++bitOffset;  				// Last thing written was black  				isWhite = false;  			}  		}  	}  	else {  		//micah_tessler@yahoo.com  		//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  		//That is' they give up on the current line and move on to the next one  		//set bitOffset to w to move on to the next scan line.  		bitOffset = w;  		UpdatePointer (7 - bits);  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		// Pass  		// We always assume WhiteIsZero format for fax.  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  		// identify the next 2 alternating color codes.  		int number;  		if (isWhite) {  			// Following are white and black runs  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		else {  			// First a black run and then a white run follows  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		cce [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else if (code == 11) {  		if (NextLesserThan8Bits (3) != 7) {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  		}  		int zeros = 0;  		bool exit = false;  		while (!exit) {  			while (NextLesserThan8Bits (1) != 1) {  				zeros++;  			}  			if (zeros > 5) {  				// Exit tagCode  				// Zeros before exit tagCode  				zeros = zeros - 6;  				if (!isWhite && (zeros > 0)) {  					cce [currIndex++] = bitOffset;  				}  				// Zeros before the exit tagCode  				bitOffset += zeros;  				if (zeros > 0) {  					// Some zeros have been written  					isWhite = true;  				}  				// Read in the bit which specifies the color of  				// the following run  				if (NextLesserThan8Bits (1) == 0) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = true;  				}  				else {  					if (isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = false;  				}  				exit = true;  			}  			if (zeros == 5) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				bitOffset += zeros;  				// Last thing written was white  				isWhite = true;  			}  			else {  				bitOffset += zeros;  				cce [currIndex++] = bitOffset;  				SetToBlack (buffer' lineOffset' bitOffset' 1);  				++bitOffset;  				// Last thing written was black  				isWhite = false;  			}  		}  	}  	else {  		//micah_tessler@yahoo.com  		//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  		//That is' they give up on the current line and move on to the next one  		//set bitOffset to w to move on to the next scan line.  		bitOffset = w;  		UpdatePointer (7 - bits);  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		// Pass  		// We always assume WhiteIsZero format for fax.  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  		// identify the next 2 alternating color codes.  		int number;  		if (isWhite) {  			// Following are white and black runs  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		else {  			// First a black run and then a white run follows  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		cce [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else if (code == 11) {  		if (NextLesserThan8Bits (3) != 7) {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  		}  		int zeros = 0;  		bool exit = false;  		while (!exit) {  			while (NextLesserThan8Bits (1) != 1) {  				zeros++;  			}  			if (zeros > 5) {  				// Exit tagCode  				// Zeros before exit tagCode  				zeros = zeros - 6;  				if (!isWhite && (zeros > 0)) {  					cce [currIndex++] = bitOffset;  				}  				// Zeros before the exit tagCode  				bitOffset += zeros;  				if (zeros > 0) {  					// Some zeros have been written  					isWhite = true;  				}  				// Read in the bit which specifies the color of  				// the following run  				if (NextLesserThan8Bits (1) == 0) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = true;  				}  				else {  					if (isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = false;  				}  				exit = true;  			}  			if (zeros == 5) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				bitOffset += zeros;  				// Last thing written was white  				isWhite = true;  			}  			else {  				bitOffset += zeros;  				cce [currIndex++] = bitOffset;  				SetToBlack (buffer' lineOffset' bitOffset' 1);  				++bitOffset;  				// Last thing written was black  				isWhite = false;  			}  		}  	}  	else {  		//micah_tessler@yahoo.com  		//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  		//That is' they give up on the current line and move on to the next one  		//set bitOffset to w to move on to the next scan line.  		bitOffset = w;  		UpdatePointer (7 - bits);  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		// Pass  		// We always assume WhiteIsZero format for fax.  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  		// identify the next 2 alternating color codes.  		int number;  		if (isWhite) {  			// Following are white and black runs  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		else {  			// First a black run and then a white run follows  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		cce [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else if (code == 11) {  		if (NextLesserThan8Bits (3) != 7) {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  		}  		int zeros = 0;  		bool exit = false;  		while (!exit) {  			while (NextLesserThan8Bits (1) != 1) {  				zeros++;  			}  			if (zeros > 5) {  				// Exit tagCode  				// Zeros before exit tagCode  				zeros = zeros - 6;  				if (!isWhite && (zeros > 0)) {  					cce [currIndex++] = bitOffset;  				}  				// Zeros before the exit tagCode  				bitOffset += zeros;  				if (zeros > 0) {  					// Some zeros have been written  					isWhite = true;  				}  				// Read in the bit which specifies the color of  				// the following run  				if (NextLesserThan8Bits (1) == 0) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = true;  				}  				else {  					if (isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = false;  				}  				exit = true;  			}  			if (zeros == 5) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				bitOffset += zeros;  				// Last thing written was white  				isWhite = true;  			}  			else {  				bitOffset += zeros;  				cce [currIndex++] = bitOffset;  				SetToBlack (buffer' lineOffset' bitOffset' 1);  				++bitOffset;  				// Last thing written was black  				isWhite = false;  			}  		}  	}  	else {  		//micah_tessler@yahoo.com  		//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  		//That is' they give up on the current line and move on to the next one  		//set bitOffset to w to move on to the next scan line.  		bitOffset = w;  		UpdatePointer (7 - bits);  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		// Pass  		// We always assume WhiteIsZero format for fax.  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  		// identify the next 2 alternating color codes.  		int number;  		if (isWhite) {  			// Following are white and black runs  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		else {  			// First a black run and then a white run follows  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		cce [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else if (code == 11) {  		if (NextLesserThan8Bits (3) != 7) {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  		}  		int zeros = 0;  		bool exit = false;  		while (!exit) {  			while (NextLesserThan8Bits (1) != 1) {  				zeros++;  			}  			if (zeros > 5) {  				// Exit tagCode  				// Zeros before exit tagCode  				zeros = zeros - 6;  				if (!isWhite && (zeros > 0)) {  					cce [currIndex++] = bitOffset;  				}  				// Zeros before the exit tagCode  				bitOffset += zeros;  				if (zeros > 0) {  					// Some zeros have been written  					isWhite = true;  				}  				// Read in the bit which specifies the color of  				// the following run  				if (NextLesserThan8Bits (1) == 0) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = true;  				}  				else {  					if (isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = false;  				}  				exit = true;  			}  			if (zeros == 5) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				bitOffset += zeros;  				// Last thing written was white  				isWhite = true;  			}  			else {  				bitOffset += zeros;  				cce [currIndex++] = bitOffset;  				SetToBlack (buffer' lineOffset' bitOffset' 1);  				++bitOffset;  				// Last thing written was black  				isWhite = false;  			}  		}  	}  	else {  		//micah_tessler@yahoo.com  		//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  		//That is' they give up on the current line and move on to the next one  		//set bitOffset to w to move on to the next scan line.  		bitOffset = w;  		UpdatePointer (7 - bits);  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		// Pass  		// We always assume WhiteIsZero format for fax.  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  		// identify the next 2 alternating color codes.  		int number;  		if (isWhite) {  			// Following are white and black runs  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		else {  			// First a black run and then a white run follows  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		cce [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else if (code == 11) {  		if (NextLesserThan8Bits (3) != 7) {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  		}  		int zeros = 0;  		bool exit = false;  		while (!exit) {  			while (NextLesserThan8Bits (1) != 1) {  				zeros++;  			}  			if (zeros > 5) {  				// Exit tagCode  				// Zeros before exit tagCode  				zeros = zeros - 6;  				if (!isWhite && (zeros > 0)) {  					cce [currIndex++] = bitOffset;  				}  				// Zeros before the exit tagCode  				bitOffset += zeros;  				if (zeros > 0) {  					// Some zeros have been written  					isWhite = true;  				}  				// Read in the bit which specifies the color of  				// the following run  				if (NextLesserThan8Bits (1) == 0) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = true;  				}  				else {  					if (isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = false;  				}  				exit = true;  			}  			if (zeros == 5) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				bitOffset += zeros;  				// Last thing written was white  				isWhite = true;  			}  			else {  				bitOffset += zeros;  				cce [currIndex++] = bitOffset;  				SetToBlack (buffer' lineOffset' bitOffset' 1);  				++bitOffset;  				// Last thing written was black  				isWhite = false;  			}  		}  	}  	else {  		//micah_tessler@yahoo.com  		//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  		//That is' they give up on the current line and move on to the next one  		//set bitOffset to w to move on to the next scan line.  		bitOffset = w;  		UpdatePointer (7 - bits);  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		// Pass  		// We always assume WhiteIsZero format for fax.  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  		// identify the next 2 alternating color codes.  		int number;  		if (isWhite) {  			// Following are white and black runs  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		else {  			// First a black run and then a white run follows  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		cce [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else if (code == 11) {  		if (NextLesserThan8Bits (3) != 7) {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  		}  		int zeros = 0;  		bool exit = false;  		while (!exit) {  			while (NextLesserThan8Bits (1) != 1) {  				zeros++;  			}  			if (zeros > 5) {  				// Exit tagCode  				// Zeros before exit tagCode  				zeros = zeros - 6;  				if (!isWhite && (zeros > 0)) {  					cce [currIndex++] = bitOffset;  				}  				// Zeros before the exit tagCode  				bitOffset += zeros;  				if (zeros > 0) {  					// Some zeros have been written  					isWhite = true;  				}  				// Read in the bit which specifies the color of  				// the following run  				if (NextLesserThan8Bits (1) == 0) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = true;  				}  				else {  					if (isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = false;  				}  				exit = true;  			}  			if (zeros == 5) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				bitOffset += zeros;  				// Last thing written was white  				isWhite = true;  			}  			else {  				bitOffset += zeros;  				cce [currIndex++] = bitOffset;  				SetToBlack (buffer' lineOffset' bitOffset' 1);  				++bitOffset;  				// Last thing written was black  				isWhite = false;  			}  		}  	}  	else {  		//micah_tessler@yahoo.com  		//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  		//That is' they give up on the current line and move on to the next one  		//set bitOffset to w to move on to the next scan line.  		bitOffset = w;  		UpdatePointer (7 - bits);  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		// Pass  		// We always assume WhiteIsZero format for fax.  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  		// identify the next 2 alternating color codes.  		int number;  		if (isWhite) {  			// Following are white and black runs  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		else {  			// First a black run and then a white run follows  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		cce [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else if (code == 11) {  		if (NextLesserThan8Bits (3) != 7) {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  		}  		int zeros = 0;  		bool exit = false;  		while (!exit) {  			while (NextLesserThan8Bits (1) != 1) {  				zeros++;  			}  			if (zeros > 5) {  				// Exit tagCode  				// Zeros before exit tagCode  				zeros = zeros - 6;  				if (!isWhite && (zeros > 0)) {  					cce [currIndex++] = bitOffset;  				}  				// Zeros before the exit tagCode  				bitOffset += zeros;  				if (zeros > 0) {  					// Some zeros have been written  					isWhite = true;  				}  				// Read in the bit which specifies the color of  				// the following run  				if (NextLesserThan8Bits (1) == 0) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = true;  				}  				else {  					if (isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = false;  				}  				exit = true;  			}  			if (zeros == 5) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				bitOffset += zeros;  				// Last thing written was white  				isWhite = true;  			}  			else {  				bitOffset += zeros;  				cce [currIndex++] = bitOffset;  				SetToBlack (buffer' lineOffset' bitOffset' 1);  				++bitOffset;  				// Last thing written was black  				isWhite = false;  			}  		}  	}  	else {  		//micah_tessler@yahoo.com  		//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  		//That is' they give up on the current line and move on to the next one  		//set bitOffset to w to move on to the next scan line.  		bitOffset = w;  		UpdatePointer (7 - bits);  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		// Pass  		// We always assume WhiteIsZero format for fax.  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  		// identify the next 2 alternating color codes.  		int number;  		if (isWhite) {  			// Following are white and black runs  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		else {  			// First a black run and then a white run follows  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		cce [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else if (code == 11) {  		if (NextLesserThan8Bits (3) != 7) {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  		}  		int zeros = 0;  		bool exit = false;  		while (!exit) {  			while (NextLesserThan8Bits (1) != 1) {  				zeros++;  			}  			if (zeros > 5) {  				// Exit tagCode  				// Zeros before exit tagCode  				zeros = zeros - 6;  				if (!isWhite && (zeros > 0)) {  					cce [currIndex++] = bitOffset;  				}  				// Zeros before the exit tagCode  				bitOffset += zeros;  				if (zeros > 0) {  					// Some zeros have been written  					isWhite = true;  				}  				// Read in the bit which specifies the color of  				// the following run  				if (NextLesserThan8Bits (1) == 0) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = true;  				}  				else {  					if (isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = false;  				}  				exit = true;  			}  			if (zeros == 5) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				bitOffset += zeros;  				// Last thing written was white  				isWhite = true;  			}  			else {  				bitOffset += zeros;  				cce [currIndex++] = bitOffset;  				SetToBlack (buffer' lineOffset' bitOffset' 1);  				++bitOffset;  				// Last thing written was black  				isWhite = false;  			}  		}  	}  	else {  		//micah_tessler@yahoo.com  		//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  		//That is' they give up on the current line and move on to the next one  		//set bitOffset to w to move on to the next scan line.  		bitOffset = w;  		UpdatePointer (7 - bits);  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		// Pass  		// We always assume WhiteIsZero format for fax.  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  		// identify the next 2 alternating color codes.  		int number;  		if (isWhite) {  			// Following are white and black runs  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		else {  			// First a black run and then a white run follows  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		cce [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else if (code == 11) {  		if (NextLesserThan8Bits (3) != 7) {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  		}  		int zeros = 0;  		bool exit = false;  		while (!exit) {  			while (NextLesserThan8Bits (1) != 1) {  				zeros++;  			}  			if (zeros > 5) {  				// Exit tagCode  				// Zeros before exit tagCode  				zeros = zeros - 6;  				if (!isWhite && (zeros > 0)) {  					cce [currIndex++] = bitOffset;  				}  				// Zeros before the exit tagCode  				bitOffset += zeros;  				if (zeros > 0) {  					// Some zeros have been written  					isWhite = true;  				}  				// Read in the bit which specifies the color of  				// the following run  				if (NextLesserThan8Bits (1) == 0) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = true;  				}  				else {  					if (isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = false;  				}  				exit = true;  			}  			if (zeros == 5) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				bitOffset += zeros;  				// Last thing written was white  				isWhite = true;  			}  			else {  				bitOffset += zeros;  				cce [currIndex++] = bitOffset;  				SetToBlack (buffer' lineOffset' bitOffset' 1);  				++bitOffset;  				// Last thing written was black  				isWhite = false;  			}  		}  	}  	else {  		//micah_tessler@yahoo.com  		//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  		//That is' they give up on the current line and move on to the next one  		//set bitOffset to w to move on to the next scan line.  		bitOffset = w;  		UpdatePointer (7 - bits);  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		// Pass  		// We always assume WhiteIsZero format for fax.  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  		// identify the next 2 alternating color codes.  		int number;  		if (isWhite) {  			// Following are white and black runs  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		else {  			// First a black run and then a white run follows  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		cce [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else if (code == 11) {  		if (NextLesserThan8Bits (3) != 7) {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  		}  		int zeros = 0;  		bool exit = false;  		while (!exit) {  			while (NextLesserThan8Bits (1) != 1) {  				zeros++;  			}  			if (zeros > 5) {  				// Exit tagCode  				// Zeros before exit tagCode  				zeros = zeros - 6;  				if (!isWhite && (zeros > 0)) {  					cce [currIndex++] = bitOffset;  				}  				// Zeros before the exit tagCode  				bitOffset += zeros;  				if (zeros > 0) {  					// Some zeros have been written  					isWhite = true;  				}  				// Read in the bit which specifies the color of  				// the following run  				if (NextLesserThan8Bits (1) == 0) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = true;  				}  				else {  					if (isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = false;  				}  				exit = true;  			}  			if (zeros == 5) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				bitOffset += zeros;  				// Last thing written was white  				isWhite = true;  			}  			else {  				bitOffset += zeros;  				cce [currIndex++] = bitOffset;  				SetToBlack (buffer' lineOffset' bitOffset' 1);  				++bitOffset;  				// Last thing written was black  				isWhite = false;  			}  		}  	}  	else {  		//micah_tessler@yahoo.com  		//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  		//That is' they give up on the current line and move on to the next one  		//set bitOffset to w to move on to the next scan line.  		bitOffset = w;  		UpdatePointer (7 - bits);  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		// Pass  		// We always assume WhiteIsZero format for fax.  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  		// identify the next 2 alternating color codes.  		int number;  		if (isWhite) {  			// Following are white and black runs  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		else {  			// First a black run and then a white run follows  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		cce [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else if (code == 11) {  		if (NextLesserThan8Bits (3) != 7) {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  		}  		int zeros = 0;  		bool exit = false;  		while (!exit) {  			while (NextLesserThan8Bits (1) != 1) {  				zeros++;  			}  			if (zeros > 5) {  				// Exit tagCode  				// Zeros before exit tagCode  				zeros = zeros - 6;  				if (!isWhite && (zeros > 0)) {  					cce [currIndex++] = bitOffset;  				}  				// Zeros before the exit tagCode  				bitOffset += zeros;  				if (zeros > 0) {  					// Some zeros have been written  					isWhite = true;  				}  				// Read in the bit which specifies the color of  				// the following run  				if (NextLesserThan8Bits (1) == 0) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = true;  				}  				else {  					if (isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = false;  				}  				exit = true;  			}  			if (zeros == 5) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				bitOffset += zeros;  				// Last thing written was white  				isWhite = true;  			}  			else {  				bitOffset += zeros;  				cce [currIndex++] = bitOffset;  				SetToBlack (buffer' lineOffset' bitOffset' 1);  				++bitOffset;  				// Last thing written was black  				isWhite = false;  			}  		}  	}  	else {  		//micah_tessler@yahoo.com  		//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  		//That is' they give up on the current line and move on to the next one  		//set bitOffset to w to move on to the next scan line.  		bitOffset = w;  		UpdatePointer (7 - bits);  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (bitOffset < w) {  	// Get the next changing element  	GetNextChangingElement (a0' isWhite' b);  	b1 = b [0];  	b2 = b [1];  	// Get the next seven bits  	entry = NextLesserThan8Bits (7);  	// Run these through the 2DCodes table  	entry = (int)(twoDCodes [entry] & 0xff);  	// Get the tagCode and the number of bits used up  	code = (entry & 0x78) >> 3;  	bits = entry & 0x07;  	if (code == 0) {  		// Pass  		// We always assume WhiteIsZero format for fax.  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  		}  		bitOffset = a0 = b2;  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  	}  	else if (code == 1) {  		// Horizontal  		// Set pointer to only consume the correct number of bits.  		UpdatePointer (7 - bits);  		// identify the next 2 alternating color codes.  		int number;  		if (isWhite) {  			// Following are white and black runs  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		else {  			// First a black run and then a white run follows  			number = DecodeBlackCodeWord ();  			SetToBlack (buffer' lineOffset' bitOffset' number);  			bitOffset += number;  			cce [currIndex++] = bitOffset;  			number = DecodeWhiteCodeWord ();  			bitOffset += number;  			cce [currIndex++] = bitOffset;  		}  		a0 = bitOffset;  	}  	else if (code <= 8) {  		// Vertical  		a1 = b1 + (code - 5);  		cce [currIndex++] = a1;  		// We write the current color till a1 - 1 pos'  		// since a1 is where the next color starts  		if (!isWhite) {  			SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  		}  		bitOffset = a0 = a1;  		isWhite = !isWhite;  		UpdatePointer (7 - bits);  	}  	else if (code == 11) {  		if (NextLesserThan8Bits (3) != 7) {  			//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  		}  		int zeros = 0;  		bool exit = false;  		while (!exit) {  			while (NextLesserThan8Bits (1) != 1) {  				zeros++;  			}  			if (zeros > 5) {  				// Exit tagCode  				// Zeros before exit tagCode  				zeros = zeros - 6;  				if (!isWhite && (zeros > 0)) {  					cce [currIndex++] = bitOffset;  				}  				// Zeros before the exit tagCode  				bitOffset += zeros;  				if (zeros > 0) {  					// Some zeros have been written  					isWhite = true;  				}  				// Read in the bit which specifies the color of  				// the following run  				if (NextLesserThan8Bits (1) == 0) {  					if (!isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = true;  				}  				else {  					if (isWhite) {  						cce [currIndex++] = bitOffset;  					}  					isWhite = false;  				}  				exit = true;  			}  			if (zeros == 5) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				bitOffset += zeros;  				// Last thing written was white  				isWhite = true;  			}  			else {  				bitOffset += zeros;  				cce [currIndex++] = bitOffset;  				SetToBlack (buffer' lineOffset' bitOffset' 1);  				++bitOffset;  				// Last thing written was black  				isWhite = false;  			}  		}  	}  	else {  		//micah_tessler@yahoo.com  		//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  		//That is' they give up on the current line and move on to the next one  		//set bitOffset to w to move on to the next scan line.  		bitOffset = w;  		UpdatePointer (7 - bits);  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: entry = NextLesserThan8Bits (7);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: code = (entry & 0x78) >> 3;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 0) {  	// Pass  	// We always assume WhiteIsZero format for fax.  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 0) {  	// Pass  	// We always assume WhiteIsZero format for fax.  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 0) {  	// Pass  	// We always assume WhiteIsZero format for fax.  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 0) {  	// Pass  	// We always assume WhiteIsZero format for fax.  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 0) {  	// Pass  	// We always assume WhiteIsZero format for fax.  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 0) {  	// Pass  	// We always assume WhiteIsZero format for fax.  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 0) {  	// Pass  	// We always assume WhiteIsZero format for fax.  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 0) {  	// Pass  	// We always assume WhiteIsZero format for fax.  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 0) {  	// Pass  	// We always assume WhiteIsZero format for fax.  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 0) {  	// Pass  	// We always assume WhiteIsZero format for fax.  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 0) {  	// Pass  	// We always assume WhiteIsZero format for fax.  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 0) {  	// Pass  	// We always assume WhiteIsZero format for fax.  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' b2 - bitOffset);  	}  	bitOffset = a0 = b2;  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  }  else if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: UpdatePointer (7 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 1) {  	// Horizontal  	// Set pointer to only consume the correct number of bits.  	UpdatePointer (7 - bits);  	// identify the next 2 alternating color codes.  	int number;  	if (isWhite) {  		// Following are white and black runs  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	else {  		// First a black run and then a white run follows  		number = DecodeBlackCodeWord ();  		SetToBlack (buffer' lineOffset' bitOffset' number);  		bitOffset += number;  		cce [currIndex++] = bitOffset;  		number = DecodeWhiteCodeWord ();  		bitOffset += number;  		cce [currIndex++] = bitOffset;  	}  	a0 = bitOffset;  }  else if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: UpdatePointer (7 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code <= 8) {  	// Vertical  	a1 = b1 + (code - 5);  	cce [currIndex++] = a1;  	// We write the current color till a1 - 1 pos'  	// since a1 is where the next color starts  	if (!isWhite) {  		SetToBlack (buffer' lineOffset' bitOffset' a1 - bitOffset);  	}  	bitOffset = a0 = a1;  	isWhite = !isWhite;  	UpdatePointer (7 - bits);  }  else if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: a1 = b1 + (code - 5);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: UpdatePointer (7 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (code == 11) {  	if (NextLesserThan8Bits (3) != 7) {  		//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  	}  	int zeros = 0;  	bool exit = false;  	while (!exit) {  		while (NextLesserThan8Bits (1) != 1) {  			zeros++;  		}  		if (zeros > 5) {  			// Exit tagCode  			// Zeros before exit tagCode  			zeros = zeros - 6;  			if (!isWhite && (zeros > 0)) {  				cce [currIndex++] = bitOffset;  			}  			// Zeros before the exit tagCode  			bitOffset += zeros;  			if (zeros > 0) {  				// Some zeros have been written  				isWhite = true;  			}  			// Read in the bit which specifies the color of  			// the following run  			if (NextLesserThan8Bits (1) == 0) {  				if (!isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = true;  			}  			else {  				if (isWhite) {  					cce [currIndex++] = bitOffset;  				}  				isWhite = false;  			}  			exit = true;  		}  		if (zeros == 5) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			bitOffset += zeros;  			// Last thing written was white  			isWhite = true;  		}  		else {  			bitOffset += zeros;  			cce [currIndex++] = bitOffset;  			SetToBlack (buffer' lineOffset' bitOffset' 1);  			++bitOffset;  			// Last thing written was black  			isWhite = false;  		}  	}  }  else {  	//micah_tessler@yahoo.com  	//Microsoft TIFF renderers seem to treat entries_offset codes as line-breaks  	//That is' they give up on the current line and move on to the next one  	//set bitOffset to w to move on to the next scan line.  	bitOffset = w;  	UpdatePointer (7 - bits);  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (NextLesserThan8Bits (3) != 7) {  	//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (NextLesserThan8Bits (3) != 7) {  	//                         throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered.while.decoding.2d.group.4.compressed.data"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (!exit) {  	while (NextLesserThan8Bits (1) != 1) {  		zeros++;  	}  	if (zeros > 5) {  		// Exit tagCode  		// Zeros before exit tagCode  		zeros = zeros - 6;  		if (!isWhite && (zeros > 0)) {  			cce [currIndex++] = bitOffset;  		}  		// Zeros before the exit tagCode  		bitOffset += zeros;  		if (zeros > 0) {  			// Some zeros have been written  			isWhite = true;  		}  		// Read in the bit which specifies the color of  		// the following run  		if (NextLesserThan8Bits (1) == 0) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			isWhite = true;  		}  		else {  			if (isWhite) {  				cce [currIndex++] = bitOffset;  			}  			isWhite = false;  		}  		exit = true;  	}  	if (zeros == 5) {  		if (!isWhite) {  			cce [currIndex++] = bitOffset;  		}  		bitOffset += zeros;  		// Last thing written was white  		isWhite = true;  	}  	else {  		bitOffset += zeros;  		cce [currIndex++] = bitOffset;  		SetToBlack (buffer' lineOffset' bitOffset' 1);  		++bitOffset;  		// Last thing written was black  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (!exit) {  	while (NextLesserThan8Bits (1) != 1) {  		zeros++;  	}  	if (zeros > 5) {  		// Exit tagCode  		// Zeros before exit tagCode  		zeros = zeros - 6;  		if (!isWhite && (zeros > 0)) {  			cce [currIndex++] = bitOffset;  		}  		// Zeros before the exit tagCode  		bitOffset += zeros;  		if (zeros > 0) {  			// Some zeros have been written  			isWhite = true;  		}  		// Read in the bit which specifies the color of  		// the following run  		if (NextLesserThan8Bits (1) == 0) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			isWhite = true;  		}  		else {  			if (isWhite) {  				cce [currIndex++] = bitOffset;  			}  			isWhite = false;  		}  		exit = true;  	}  	if (zeros == 5) {  		if (!isWhite) {  			cce [currIndex++] = bitOffset;  		}  		bitOffset += zeros;  		// Last thing written was white  		isWhite = true;  	}  	else {  		bitOffset += zeros;  		cce [currIndex++] = bitOffset;  		SetToBlack (buffer' lineOffset' bitOffset' 1);  		++bitOffset;  		// Last thing written was black  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: while (!exit) {  	while (NextLesserThan8Bits (1) != 1) {  		zeros++;  	}  	if (zeros > 5) {  		// Exit tagCode  		// Zeros before exit tagCode  		zeros = zeros - 6;  		if (!isWhite && (zeros > 0)) {  			cce [currIndex++] = bitOffset;  		}  		// Zeros before the exit tagCode  		bitOffset += zeros;  		if (zeros > 0) {  			// Some zeros have been written  			isWhite = true;  		}  		// Read in the bit which specifies the color of  		// the following run  		if (NextLesserThan8Bits (1) == 0) {  			if (!isWhite) {  				cce [currIndex++] = bitOffset;  			}  			isWhite = true;  		}  		else {  			if (isWhite) {  				cce [currIndex++] = bitOffset;  			}  			isWhite = false;  		}  		exit = true;  	}  	if (zeros == 5) {  		if (!isWhite) {  			cce [currIndex++] = bitOffset;  		}  		bitOffset += zeros;  		// Last thing written was white  		isWhite = true;  	}  	else {  		bitOffset += zeros;  		cce [currIndex++] = bitOffset;  		SetToBlack (buffer' lineOffset' bitOffset' 1);  		++bitOffset;  		// Last thing written was black  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (zeros > 5) {  	// Exit tagCode  	// Zeros before exit tagCode  	zeros = zeros - 6;  	if (!isWhite && (zeros > 0)) {  		cce [currIndex++] = bitOffset;  	}  	// Zeros before the exit tagCode  	bitOffset += zeros;  	if (zeros > 0) {  		// Some zeros have been written  		isWhite = true;  	}  	// Read in the bit which specifies the color of  	// the following run  	if (NextLesserThan8Bits (1) == 0) {  		if (!isWhite) {  			cce [currIndex++] = bitOffset;  		}  		isWhite = true;  	}  	else {  		if (isWhite) {  			cce [currIndex++] = bitOffset;  		}  		isWhite = false;  	}  	exit = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (zeros > 5) {  	// Exit tagCode  	// Zeros before exit tagCode  	zeros = zeros - 6;  	if (!isWhite && (zeros > 0)) {  		cce [currIndex++] = bitOffset;  	}  	// Zeros before the exit tagCode  	bitOffset += zeros;  	if (zeros > 0) {  		// Some zeros have been written  		isWhite = true;  	}  	// Read in the bit which specifies the color of  	// the following run  	if (NextLesserThan8Bits (1) == 0) {  		if (!isWhite) {  			cce [currIndex++] = bitOffset;  		}  		isWhite = true;  	}  	else {  		if (isWhite) {  			cce [currIndex++] = bitOffset;  		}  		isWhite = false;  	}  	exit = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: zeros = zeros - 6;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: if (zeros == 5) {  	if (!isWhite) {  		cce [currIndex++] = bitOffset;  	}  	bitOffset += zeros;  	// Last thing written was white  	isWhite = true;  }  else {  	bitOffset += zeros;  	cce [currIndex++] = bitOffset;  	SetToBlack (buffer' lineOffset' bitOffset' 1);  	++bitOffset;  	// Last thing written was black  	isWhite = false;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeT6,The following statement contains a magic number: UpdatePointer (7 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,SetToBlack,The following statement contains a magic number: if (shift > 0) {  	int maskVal = 1 << (7 - shift);  	byte val = buffer [byteNum];  	while (maskVal > 0 && bitNum < lastBit) {  		val |= (byte)maskVal;  		maskVal >>= 1;  		++bitNum;  	}  	buffer [byteNum] = val;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,SetToBlack,The following statement contains a magic number: byteNum = bitNum >> 3;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,SetToBlack,The following statement contains a magic number: while (bitNum < lastBit - 7) {  	buffer [byteNum++] = (byte)255;  	bitNum += 8;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,SetToBlack,The following statement contains a magic number: while (bitNum < lastBit - 7) {  	buffer [byteNum++] = (byte)255;  	bitNum += 8;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,SetToBlack,The following statement contains a magic number: while (bitNum < lastBit - 7) {  	buffer [byteNum++] = (byte)255;  	bitNum += 8;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,SetToBlack,The following statement contains a magic number: buffer [byteNum++] = (byte)255;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,SetToBlack,The following statement contains a magic number: bitNum += 8;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,SetToBlack,The following statement contains a magic number: while (bitNum < lastBit) {  	byteNum = bitNum >> 3;  	buffer [byteNum] |= (byte)(1 << (7 - (bitNum & 0x7)));  	++bitNum;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,SetToBlack,The following statement contains a magic number: while (bitNum < lastBit) {  	byteNum = bitNum >> 3;  	buffer [byteNum] |= (byte)(1 << (7 - (bitNum & 0x7)));  	++bitNum;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,SetToBlack,The following statement contains a magic number: byteNum = bitNum >> 3;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,SetToBlack,The following statement contains a magic number: buffer [byteNum] |= (byte)(1 << (7 - (bitNum & 0x7)));  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: while (isWhite) {  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: while (isWhite) {  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: while (isWhite) {  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: while (isWhite) {  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: while (isWhite) {  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: while (isWhite) {  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: while (isWhite) {  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: while (isWhite) {  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: while (isWhite) {  	current = NextNBits (10);  	entry = white [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x0f;  	if (bits == 12) {  		// Additional Make up tagCode  		// Get the next 2 bits  		twoBits = NextLesserThan8Bits (2);  		// Consolidate the 2 new bits and last 2 bits into 4 bits  		current = ((current << 2) & 0x000c) | twoBits;  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 0) {  		// ERROR  		//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  	}  	else if (bits == 15) {  		// EOL  		//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  	}  	else {  		// 11 bits - 0000 0111 1111 1111 = 0x07ff  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		UpdatePointer (10 - bits);  		if (isT == 0) {  			isWhite = false;  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: current = NextNBits (10);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional Make up tagCode  	// Get the next 2 bits  	twoBits = NextLesserThan8Bits (2);  	// Consolidate the 2 new bits and last 2 bits into 4 bits  	current = ((current << 2) & 0x000c) | twoBits;  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 0) {  	// ERROR  	//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: twoBits = NextLesserThan8Bits (2);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: current = ((current << 2) & 0x000c) | twoBits;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: code = (entry >> 4) & 0x0fff;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: UpdatePointer (4 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: if (bits == 0) {  	// ERROR  	//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: if (bits == 0) {  	// ERROR  	//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: if (bits == 0) {  	// ERROR  	//                  throw new Exception(MessageLocalization.GetComposedMessage("invalid.tagCode.encountered"));  }  else if (bits == 15) {  	// EOL  	//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: if (bits == 15) {  	// EOL  	//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: if (bits == 15) {  	// EOL  	//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: if (bits == 15) {  	// EOL  	//                 throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.white.run"));  }  else {  	// 11 bits - 0000 0111 1111 1111 = 0x07ff  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	UpdatePointer (10 - bits);  	if (isT == 0) {  		isWhite = false;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: code = (entry >> 5) & 0x07ff;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeWhiteCodeWord,The following statement contains a magic number: UpdatePointer (10 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: while (!isWhite) {  	current = NextLesserThan8Bits (4);  	entry = initBlack [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (code == 100) {  		current = NextNBits (9);  		entry = black [current];  		// Get the 3 fields from the entry  		isT = entry & 0x0001;  		bits = (entry >> 1) & 0x000f;  		code = (entry >> 5) & 0x07ff;  		if (bits == 12) {  			// Additional makeup codes  			UpdatePointer (5);  			current = NextLesserThan8Bits (4);  			entry = additionalMakeup [current];  			bits = (entry >> 1) & 0x07;  			// 3 bits 0000 0111  			code = (entry >> 4) & 0x0fff;  			// 12 bits  			runLength += code;  			UpdatePointer (4 - bits);  		}  		else if (bits == 15) {  			// EOL tagCode  			//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  		}  		else {  			runLength += code;  			UpdatePointer (9 - bits);  			if (isT == 0) {  				isWhite = true;  			}  		}  	}  	else if (code == 200) {  		// Is a Terminating tagCode  		current = NextLesserThan8Bits (2);  		entry = twoBitBlack [current];  		code = (entry >> 5) & 0x07ff;  		runLength += code;  		bits = (entry >> 1) & 0x0f;  		UpdatePointer (2 - bits);  		isWhite = true;  	}  	else {  		// Is a Terminating tagCode  		runLength += code;  		UpdatePointer (4 - bits);  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: current = NextLesserThan8Bits (4);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: code = (entry >> 5) & 0x07ff;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 100) {  	current = NextNBits (9);  	entry = black [current];  	// Get the 3 fields from the entry  	isT = entry & 0x0001;  	bits = (entry >> 1) & 0x000f;  	code = (entry >> 5) & 0x07ff;  	if (bits == 12) {  		// Additional makeup codes  		UpdatePointer (5);  		current = NextLesserThan8Bits (4);  		entry = additionalMakeup [current];  		bits = (entry >> 1) & 0x07;  		// 3 bits 0000 0111  		code = (entry >> 4) & 0x0fff;  		// 12 bits  		runLength += code;  		UpdatePointer (4 - bits);  	}  	else if (bits == 15) {  		// EOL tagCode  		//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  	}  	else {  		runLength += code;  		UpdatePointer (9 - bits);  		if (isT == 0) {  			isWhite = true;  		}  	}  }  else if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: current = NextNBits (9);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: code = (entry >> 5) & 0x07ff;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional makeup codes  	UpdatePointer (5);  	current = NextLesserThan8Bits (4);  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 15) {  	// EOL tagCode  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	runLength += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional makeup codes  	UpdatePointer (5);  	current = NextLesserThan8Bits (4);  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 15) {  	// EOL tagCode  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	runLength += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional makeup codes  	UpdatePointer (5);  	current = NextLesserThan8Bits (4);  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 15) {  	// EOL tagCode  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	runLength += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional makeup codes  	UpdatePointer (5);  	current = NextLesserThan8Bits (4);  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 15) {  	// EOL tagCode  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	runLength += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional makeup codes  	UpdatePointer (5);  	current = NextLesserThan8Bits (4);  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 15) {  	// EOL tagCode  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	runLength += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional makeup codes  	UpdatePointer (5);  	current = NextLesserThan8Bits (4);  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 15) {  	// EOL tagCode  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	runLength += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (bits == 12) {  	// Additional makeup codes  	UpdatePointer (5);  	current = NextLesserThan8Bits (4);  	entry = additionalMakeup [current];  	bits = (entry >> 1) & 0x07;  	// 3 bits 0000 0111  	code = (entry >> 4) & 0x0fff;  	// 12 bits  	runLength += code;  	UpdatePointer (4 - bits);  }  else if (bits == 15) {  	// EOL tagCode  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	runLength += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: UpdatePointer (5);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: current = NextLesserThan8Bits (4);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: code = (entry >> 4) & 0x0fff;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: UpdatePointer (4 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (bits == 15) {  	// EOL tagCode  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	runLength += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (bits == 15) {  	// EOL tagCode  	//                       throw new Exception(MessageLocalization.GetComposedMessage("eol.tagCode.word.encountered.in.black.run"));  }  else {  	runLength += code;  	UpdatePointer (9 - bits);  	if (isT == 0) {  		isWhite = true;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: UpdatePointer (9 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: if (code == 200) {  	// Is a Terminating tagCode  	current = NextLesserThan8Bits (2);  	entry = twoBitBlack [current];  	code = (entry >> 5) & 0x07ff;  	runLength += code;  	bits = (entry >> 1) & 0x0f;  	UpdatePointer (2 - bits);  	isWhite = true;  }  else {  	// Is a Terminating tagCode  	runLength += code;  	UpdatePointer (4 - bits);  	isWhite = true;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: current = NextLesserThan8Bits (2);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: code = (entry >> 5) & 0x07ff;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: UpdatePointer (2 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,DecodeBlackCodeWord,The following statement contains a magic number: UpdatePointer (4 - bits);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (fillBits == 0) {  	int next12Bits = NextNBits (12);  	if (isFirstEOL && next12Bits == 0) {  		// Might have the case of EOL padding being used even  		// though it was not flagged in the T4Options field.  		// This was observed to be the case in TIFFs produced  		// by a well known vendor who shall remain nameless.  		if (NextNBits (4) == 1) {  			// EOL must be padded: reset the fillBits flag.  			fillBits = 1;  			return 1;  		}  	}  	if (next12Bits != 1) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("scanline.must.begin.with.eol.tagCode.word"));  	}  }  else if (fillBits == 1) {  	// First EOL tagCode word xxxx 0000 0000 0001 will occur  	// As many fill bits will be present as required to make  	// the EOL tagCode of 12 bits end on a byte boundary.  	int bitsLeft = 8 - bitPointer;  	if (NextNBits (bitsLeft) != 0) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  	}  	// If the number of bitsLeft is less than 8' then to have a 12  	// bit EOL sequence' two more bytes are certainly going to be  	// required. The first of them has to be all zeros' so ensure  	// that.  	if (bitsLeft < 4) {  		if (NextNBits (8) != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  	// There might be a random number of fill bytes with 0s' so  	// loop till the EOL of 0000 0001 is found' as long as all  	// the bytes preceding it are 0'lineRead.  	int n;  	while ((n = NextNBits (8)) != 1) {  		// If not all zeros  		if (n != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (fillBits == 0) {  	int next12Bits = NextNBits (12);  	if (isFirstEOL && next12Bits == 0) {  		// Might have the case of EOL padding being used even  		// though it was not flagged in the T4Options field.  		// This was observed to be the case in TIFFs produced  		// by a well known vendor who shall remain nameless.  		if (NextNBits (4) == 1) {  			// EOL must be padded: reset the fillBits flag.  			fillBits = 1;  			return 1;  		}  	}  	if (next12Bits != 1) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("scanline.must.begin.with.eol.tagCode.word"));  	}  }  else if (fillBits == 1) {  	// First EOL tagCode word xxxx 0000 0000 0001 will occur  	// As many fill bits will be present as required to make  	// the EOL tagCode of 12 bits end on a byte boundary.  	int bitsLeft = 8 - bitPointer;  	if (NextNBits (bitsLeft) != 0) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  	}  	// If the number of bitsLeft is less than 8' then to have a 12  	// bit EOL sequence' two more bytes are certainly going to be  	// required. The first of them has to be all zeros' so ensure  	// that.  	if (bitsLeft < 4) {  		if (NextNBits (8) != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  	// There might be a random number of fill bytes with 0s' so  	// loop till the EOL of 0000 0001 is found' as long as all  	// the bytes preceding it are 0'lineRead.  	int n;  	while ((n = NextNBits (8)) != 1) {  		// If not all zeros  		if (n != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (fillBits == 0) {  	int next12Bits = NextNBits (12);  	if (isFirstEOL && next12Bits == 0) {  		// Might have the case of EOL padding being used even  		// though it was not flagged in the T4Options field.  		// This was observed to be the case in TIFFs produced  		// by a well known vendor who shall remain nameless.  		if (NextNBits (4) == 1) {  			// EOL must be padded: reset the fillBits flag.  			fillBits = 1;  			return 1;  		}  	}  	if (next12Bits != 1) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("scanline.must.begin.with.eol.tagCode.word"));  	}  }  else if (fillBits == 1) {  	// First EOL tagCode word xxxx 0000 0000 0001 will occur  	// As many fill bits will be present as required to make  	// the EOL tagCode of 12 bits end on a byte boundary.  	int bitsLeft = 8 - bitPointer;  	if (NextNBits (bitsLeft) != 0) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  	}  	// If the number of bitsLeft is less than 8' then to have a 12  	// bit EOL sequence' two more bytes are certainly going to be  	// required. The first of them has to be all zeros' so ensure  	// that.  	if (bitsLeft < 4) {  		if (NextNBits (8) != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  	// There might be a random number of fill bytes with 0s' so  	// loop till the EOL of 0000 0001 is found' as long as all  	// the bytes preceding it are 0'lineRead.  	int n;  	while ((n = NextNBits (8)) != 1) {  		// If not all zeros  		if (n != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (fillBits == 0) {  	int next12Bits = NextNBits (12);  	if (isFirstEOL && next12Bits == 0) {  		// Might have the case of EOL padding being used even  		// though it was not flagged in the T4Options field.  		// This was observed to be the case in TIFFs produced  		// by a well known vendor who shall remain nameless.  		if (NextNBits (4) == 1) {  			// EOL must be padded: reset the fillBits flag.  			fillBits = 1;  			return 1;  		}  	}  	if (next12Bits != 1) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("scanline.must.begin.with.eol.tagCode.word"));  	}  }  else if (fillBits == 1) {  	// First EOL tagCode word xxxx 0000 0000 0001 will occur  	// As many fill bits will be present as required to make  	// the EOL tagCode of 12 bits end on a byte boundary.  	int bitsLeft = 8 - bitPointer;  	if (NextNBits (bitsLeft) != 0) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  	}  	// If the number of bitsLeft is less than 8' then to have a 12  	// bit EOL sequence' two more bytes are certainly going to be  	// required. The first of them has to be all zeros' so ensure  	// that.  	if (bitsLeft < 4) {  		if (NextNBits (8) != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  	// There might be a random number of fill bytes with 0s' so  	// loop till the EOL of 0000 0001 is found' as long as all  	// the bytes preceding it are 0'lineRead.  	int n;  	while ((n = NextNBits (8)) != 1) {  		// If not all zeros  		if (n != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (fillBits == 0) {  	int next12Bits = NextNBits (12);  	if (isFirstEOL && next12Bits == 0) {  		// Might have the case of EOL padding being used even  		// though it was not flagged in the T4Options field.  		// This was observed to be the case in TIFFs produced  		// by a well known vendor who shall remain nameless.  		if (NextNBits (4) == 1) {  			// EOL must be padded: reset the fillBits flag.  			fillBits = 1;  			return 1;  		}  	}  	if (next12Bits != 1) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("scanline.must.begin.with.eol.tagCode.word"));  	}  }  else if (fillBits == 1) {  	// First EOL tagCode word xxxx 0000 0000 0001 will occur  	// As many fill bits will be present as required to make  	// the EOL tagCode of 12 bits end on a byte boundary.  	int bitsLeft = 8 - bitPointer;  	if (NextNBits (bitsLeft) != 0) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  	}  	// If the number of bitsLeft is less than 8' then to have a 12  	// bit EOL sequence' two more bytes are certainly going to be  	// required. The first of them has to be all zeros' so ensure  	// that.  	if (bitsLeft < 4) {  		if (NextNBits (8) != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  	// There might be a random number of fill bytes with 0s' so  	// loop till the EOL of 0000 0001 is found' as long as all  	// the bytes preceding it are 0'lineRead.  	int n;  	while ((n = NextNBits (8)) != 1) {  		// If not all zeros  		if (n != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (fillBits == 0) {  	int next12Bits = NextNBits (12);  	if (isFirstEOL && next12Bits == 0) {  		// Might have the case of EOL padding being used even  		// though it was not flagged in the T4Options field.  		// This was observed to be the case in TIFFs produced  		// by a well known vendor who shall remain nameless.  		if (NextNBits (4) == 1) {  			// EOL must be padded: reset the fillBits flag.  			fillBits = 1;  			return 1;  		}  	}  	if (next12Bits != 1) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("scanline.must.begin.with.eol.tagCode.word"));  	}  }  else if (fillBits == 1) {  	// First EOL tagCode word xxxx 0000 0000 0001 will occur  	// As many fill bits will be present as required to make  	// the EOL tagCode of 12 bits end on a byte boundary.  	int bitsLeft = 8 - bitPointer;  	if (NextNBits (bitsLeft) != 0) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  	}  	// If the number of bitsLeft is less than 8' then to have a 12  	// bit EOL sequence' two more bytes are certainly going to be  	// required. The first of them has to be all zeros' so ensure  	// that.  	if (bitsLeft < 4) {  		if (NextNBits (8) != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  	// There might be a random number of fill bytes with 0s' so  	// loop till the EOL of 0000 0001 is found' as long as all  	// the bytes preceding it are 0'lineRead.  	int n;  	while ((n = NextNBits (8)) != 1) {  		// If not all zeros  		if (n != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (isFirstEOL && next12Bits == 0) {  	// Might have the case of EOL padding being used even  	// though it was not flagged in the T4Options field.  	// This was observed to be the case in TIFFs produced  	// by a well known vendor who shall remain nameless.  	if (NextNBits (4) == 1) {  		// EOL must be padded: reset the fillBits flag.  		fillBits = 1;  		return 1;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (NextNBits (4) == 1) {  	// EOL must be padded: reset the fillBits flag.  	fillBits = 1;  	return 1;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (fillBits == 1) {  	// First EOL tagCode word xxxx 0000 0000 0001 will occur  	// As many fill bits will be present as required to make  	// the EOL tagCode of 12 bits end on a byte boundary.  	int bitsLeft = 8 - bitPointer;  	if (NextNBits (bitsLeft) != 0) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  	}  	// If the number of bitsLeft is less than 8' then to have a 12  	// bit EOL sequence' two more bytes are certainly going to be  	// required. The first of them has to be all zeros' so ensure  	// that.  	if (bitsLeft < 4) {  		if (NextNBits (8) != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  	// There might be a random number of fill bytes with 0s' so  	// loop till the EOL of 0000 0001 is found' as long as all  	// the bytes preceding it are 0'lineRead.  	int n;  	while ((n = NextNBits (8)) != 1) {  		// If not all zeros  		if (n != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (fillBits == 1) {  	// First EOL tagCode word xxxx 0000 0000 0001 will occur  	// As many fill bits will be present as required to make  	// the EOL tagCode of 12 bits end on a byte boundary.  	int bitsLeft = 8 - bitPointer;  	if (NextNBits (bitsLeft) != 0) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  	}  	// If the number of bitsLeft is less than 8' then to have a 12  	// bit EOL sequence' two more bytes are certainly going to be  	// required. The first of them has to be all zeros' so ensure  	// that.  	if (bitsLeft < 4) {  		if (NextNBits (8) != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  	// There might be a random number of fill bytes with 0s' so  	// loop till the EOL of 0000 0001 is found' as long as all  	// the bytes preceding it are 0'lineRead.  	int n;  	while ((n = NextNBits (8)) != 1) {  		// If not all zeros  		if (n != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (fillBits == 1) {  	// First EOL tagCode word xxxx 0000 0000 0001 will occur  	// As many fill bits will be present as required to make  	// the EOL tagCode of 12 bits end on a byte boundary.  	int bitsLeft = 8 - bitPointer;  	if (NextNBits (bitsLeft) != 0) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  	}  	// If the number of bitsLeft is less than 8' then to have a 12  	// bit EOL sequence' two more bytes are certainly going to be  	// required. The first of them has to be all zeros' so ensure  	// that.  	if (bitsLeft < 4) {  		if (NextNBits (8) != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  	// There might be a random number of fill bytes with 0s' so  	// loop till the EOL of 0000 0001 is found' as long as all  	// the bytes preceding it are 0'lineRead.  	int n;  	while ((n = NextNBits (8)) != 1) {  		// If not all zeros  		if (n != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (fillBits == 1) {  	// First EOL tagCode word xxxx 0000 0000 0001 will occur  	// As many fill bits will be present as required to make  	// the EOL tagCode of 12 bits end on a byte boundary.  	int bitsLeft = 8 - bitPointer;  	if (NextNBits (bitsLeft) != 0) {  		//                  throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  	}  	// If the number of bitsLeft is less than 8' then to have a 12  	// bit EOL sequence' two more bytes are certainly going to be  	// required. The first of them has to be all zeros' so ensure  	// that.  	if (bitsLeft < 4) {  		if (NextNBits (8) != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  	// There might be a random number of fill bytes with 0s' so  	// loop till the EOL of 0000 0001 is found' as long as all  	// the bytes preceding it are 0'lineRead.  	int n;  	while ((n = NextNBits (8)) != 1) {  		// If not all zeros  		if (n != 0) {  			//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  		}  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (bitsLeft < 4) {  	if (NextNBits (8) != 0) {  		//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (bitsLeft < 4) {  	if (NextNBits (8) != 0) {  		//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: if (NextNBits (8) != 0) {  	//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,ReadEOL,The following statement contains a magic number: while ((n = NextNBits (8)) != 1) {  	// If not all zeros  	if (n != 0) {  		//                       throw new Exception(MessageLocalization.GetComposedMessage("all.fill.bits.preceding.eol.tagCode.must.be.0"));  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,GetNextChangingElement,The following statement contains a magic number: for (; i < ces; i += 2) {  	int temp = pce [i];  	if (temp > a0) {  		lastChangingElement = i;  		ret [0] = temp;  		break;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,GetNextChangingElement,The following statement contains a magic number: i += 2
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if (fillOrder == 1) {  	b = data [bp];  	if (bp == l) {  		next = 0x00;  		next2next = 0x00;  	}  	else if ((bp + 1) == l) {  		next = data [bp + 1];  		next2next = 0x00;  	}  	else {  		next = data [bp + 1];  		next2next = data [bp + 2];  	}  }  else if (fillOrder == 2) {  	b = flipTable [data [bp] & 0xff];  	if (bp == l) {  		next = 0x00;  		next2next = 0x00;  	}  	else if ((bp + 1) == l) {  		next = flipTable [data [bp + 1] & 0xff];  		next2next = 0x00;  	}  	else {  		next = flipTable [data [bp + 1] & 0xff];  		next2next = flipTable [data [bp + 2] & 0xff];  	}  }  else {  	//             throw new Exception(MessageLocalization.GetComposedMessage("tiff.fill.order.tag.must.be.either.1.or.2"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if (fillOrder == 1) {  	b = data [bp];  	if (bp == l) {  		next = 0x00;  		next2next = 0x00;  	}  	else if ((bp + 1) == l) {  		next = data [bp + 1];  		next2next = 0x00;  	}  	else {  		next = data [bp + 1];  		next2next = data [bp + 2];  	}  }  else if (fillOrder == 2) {  	b = flipTable [data [bp] & 0xff];  	if (bp == l) {  		next = 0x00;  		next2next = 0x00;  	}  	else if ((bp + 1) == l) {  		next = flipTable [data [bp + 1] & 0xff];  		next2next = 0x00;  	}  	else {  		next = flipTable [data [bp + 1] & 0xff];  		next2next = flipTable [data [bp + 2] & 0xff];  	}  }  else {  	//             throw new Exception(MessageLocalization.GetComposedMessage("tiff.fill.order.tag.must.be.either.1.or.2"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if (fillOrder == 1) {  	b = data [bp];  	if (bp == l) {  		next = 0x00;  		next2next = 0x00;  	}  	else if ((bp + 1) == l) {  		next = data [bp + 1];  		next2next = 0x00;  	}  	else {  		next = data [bp + 1];  		next2next = data [bp + 2];  	}  }  else if (fillOrder == 2) {  	b = flipTable [data [bp] & 0xff];  	if (bp == l) {  		next = 0x00;  		next2next = 0x00;  	}  	else if ((bp + 1) == l) {  		next = flipTable [data [bp + 1] & 0xff];  		next2next = 0x00;  	}  	else {  		next = flipTable [data [bp + 1] & 0xff];  		next2next = flipTable [data [bp + 2] & 0xff];  	}  }  else {  	//             throw new Exception(MessageLocalization.GetComposedMessage("tiff.fill.order.tag.must.be.either.1.or.2"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if (bp == l) {  	next = 0x00;  	next2next = 0x00;  }  else if ((bp + 1) == l) {  	next = data [bp + 1];  	next2next = 0x00;  }  else {  	next = data [bp + 1];  	next2next = data [bp + 2];  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if ((bp + 1) == l) {  	next = data [bp + 1];  	next2next = 0x00;  }  else {  	next = data [bp + 1];  	next2next = data [bp + 2];  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: next2next = data [bp + 2];  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if (fillOrder == 2) {  	b = flipTable [data [bp] & 0xff];  	if (bp == l) {  		next = 0x00;  		next2next = 0x00;  	}  	else if ((bp + 1) == l) {  		next = flipTable [data [bp + 1] & 0xff];  		next2next = 0x00;  	}  	else {  		next = flipTable [data [bp + 1] & 0xff];  		next2next = flipTable [data [bp + 2] & 0xff];  	}  }  else {  	//             throw new Exception(MessageLocalization.GetComposedMessage("tiff.fill.order.tag.must.be.either.1.or.2"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if (fillOrder == 2) {  	b = flipTable [data [bp] & 0xff];  	if (bp == l) {  		next = 0x00;  		next2next = 0x00;  	}  	else if ((bp + 1) == l) {  		next = flipTable [data [bp + 1] & 0xff];  		next2next = 0x00;  	}  	else {  		next = flipTable [data [bp + 1] & 0xff];  		next2next = flipTable [data [bp + 2] & 0xff];  	}  }  else {  	//             throw new Exception(MessageLocalization.GetComposedMessage("tiff.fill.order.tag.must.be.either.1.or.2"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if (bp == l) {  	next = 0x00;  	next2next = 0x00;  }  else if ((bp + 1) == l) {  	next = flipTable [data [bp + 1] & 0xff];  	next2next = 0x00;  }  else {  	next = flipTable [data [bp + 1] & 0xff];  	next2next = flipTable [data [bp + 2] & 0xff];  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if ((bp + 1) == l) {  	next = flipTable [data [bp + 1] & 0xff];  	next2next = 0x00;  }  else {  	next = flipTable [data [bp + 1] & 0xff];  	next2next = flipTable [data [bp + 2] & 0xff];  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: next2next = flipTable [data [bp + 2] & 0xff];  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if (bitsFromNextByte > 8) {  	bitsFromNext2NextByte = bitsFromNextByte - 8;  	bitsFromNextByte = 8;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if (bitsFromNextByte > 8) {  	bitsFromNext2NextByte = bitsFromNextByte - 8;  	bitsFromNextByte = 8;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if (bitsFromNextByte > 8) {  	bitsFromNext2NextByte = bitsFromNextByte - 8;  	bitsFromNextByte = 8;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: bitsFromNext2NextByte = bitsFromNextByte - 8;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: bitsFromNextByte = 8;  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if (bitsFromNext2NextByte != 0) {  	i2 <<= bitsFromNext2NextByte;  	i3 = (next2next & table2 [bitsFromNext2NextByte]) >> (8 - bitsFromNext2NextByte);  	i2 |= i3;  	bytePointer++;  	bitPointer = bitsFromNext2NextByte;  }  else {  	if (bitsFromNextByte == 8) {  		bitPointer = 0;  		bytePointer++;  	}  	else {  		bitPointer = bitsFromNextByte;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if (bitsFromNext2NextByte != 0) {  	i2 <<= bitsFromNext2NextByte;  	i3 = (next2next & table2 [bitsFromNext2NextByte]) >> (8 - bitsFromNext2NextByte);  	i2 |= i3;  	bytePointer++;  	bitPointer = bitsFromNext2NextByte;  }  else {  	if (bitsFromNextByte == 8) {  		bitPointer = 0;  		bytePointer++;  	}  	else {  		bitPointer = bitsFromNextByte;  	}  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: i3 = (next2next & table2 [bitsFromNext2NextByte]) >> (8 - bitsFromNext2NextByte);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextNBits,The following statement contains a magic number: if (bitsFromNextByte == 8) {  	bitPointer = 0;  	bytePointer++;  }  else {  	bitPointer = bitsFromNextByte;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextLesserThan8Bits,The following statement contains a magic number: if (fillOrder == 1) {  	b = data [bp];  	if (bp == l) {  		next = 0x00;  	}  	else {  		next = data [bp + 1];  	}  }  else if (fillOrder == 2) {  	b = flipTable [data [bp] & 0xff];  	if (bp == l) {  		next = 0x00;  	}  	else {  		next = flipTable [data [bp + 1] & 0xff];  	}  }  else {  	//                throw new Exception(MessageLocalization.GetComposedMessage("tiff.fill.order.tag.must.be.either.1.or.2"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextLesserThan8Bits,The following statement contains a magic number: if (fillOrder == 2) {  	b = flipTable [data [bp] & 0xff];  	if (bp == l) {  		next = 0x00;  	}  	else {  		next = flipTable [data [bp + 1] & 0xff];  	}  }  else {  	//                throw new Exception(MessageLocalization.GetComposedMessage("tiff.fill.order.tag.must.be.either.1.or.2"));  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextLesserThan8Bits,The following statement contains a magic number: if (shift >= 0) {  	i1 = (b & table1 [bitsLeft]) >> shift;  	bitPointer += bitsToGet;  	if (bitPointer == 8) {  		bitPointer = 0;  		bytePointer++;  	}  }  else {  	i1 = (b & table1 [bitsLeft]) << (-shift);  	i2 = (next & table2 [bitsFromNextByte]) >> (8 - bitsFromNextByte);  	i1 |= i2;  	bytePointer++;  	bitPointer = bitsFromNextByte;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextLesserThan8Bits,The following statement contains a magic number: if (shift >= 0) {  	i1 = (b & table1 [bitsLeft]) >> shift;  	bitPointer += bitsToGet;  	if (bitPointer == 8) {  		bitPointer = 0;  		bytePointer++;  	}  }  else {  	i1 = (b & table1 [bitsLeft]) << (-shift);  	i2 = (next & table2 [bitsFromNextByte]) >> (8 - bitsFromNextByte);  	i1 |= i2;  	bytePointer++;  	bitPointer = bitsFromNextByte;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextLesserThan8Bits,The following statement contains a magic number: if (bitPointer == 8) {  	bitPointer = 0;  	bytePointer++;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,NextLesserThan8Bits,The following statement contains a magic number: i2 = (next & table2 [bitsFromNextByte]) >> (8 - bitsFromNextByte);  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,UpdatePointer,The following statement contains a magic number: if (i < 0) {  	bytePointer--;  	bitPointer = 8 + i;  }  else {  	bitPointer = i;  }  
Magic Number,BookReader,TIFFFaxDecoder,C:\repos\mbatest_Binhed\BookReader\Decoders.cs,UpdatePointer,The following statement contains a magic number: bitPointer = 8 + i;  
Magic Number,BookReader,LRFHeader,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFHeader,The following statement contains a magic number: unknown7 = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 20);  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following statement contains a magic number: switch (objType) {  case LrfObjectType.Toc:  	//LrfTags[3].Data.Value  	string s = Encoding.Unicode.GetString ((byte[])LrfTags [3].Data.Value);  	BitStreamReader ms = new BitStreamReader ((byte[])LrfTags [3].Data.Value' false);  	tc = new TOC (ms' LrfTags [3].PositionOfStructureInFile + 2);  	break;  case LrfObjectType.Text:  	#region Decompress and parse text  	Text = new ELEMENTARY_TYPE (Uncompress ()' LrfTags [4].PositionOfStructureInFile' LrfTags [4].LengthInFile);  	#endregion  	break;  case LrfObjectType.Block:  	ParseLinks (4);  	break;  case LrfObjectType.Page:  	ParseLinks (6);  	break;  case LrfObjectType.Canvas:  	/*                      *                                     Buffer.BlockCopy((byte[])ob.LrfTags[2].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer);                                     Buffer.BlockCopy((byte[])ob.LrfTags[6].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer); */break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following statement contains a magic number: switch (objType) {  case LrfObjectType.Toc:  	//LrfTags[3].Data.Value  	string s = Encoding.Unicode.GetString ((byte[])LrfTags [3].Data.Value);  	BitStreamReader ms = new BitStreamReader ((byte[])LrfTags [3].Data.Value' false);  	tc = new TOC (ms' LrfTags [3].PositionOfStructureInFile + 2);  	break;  case LrfObjectType.Text:  	#region Decompress and parse text  	Text = new ELEMENTARY_TYPE (Uncompress ()' LrfTags [4].PositionOfStructureInFile' LrfTags [4].LengthInFile);  	#endregion  	break;  case LrfObjectType.Block:  	ParseLinks (4);  	break;  case LrfObjectType.Page:  	ParseLinks (6);  	break;  case LrfObjectType.Canvas:  	/*                      *                                     Buffer.BlockCopy((byte[])ob.LrfTags[2].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer);                                     Buffer.BlockCopy((byte[])ob.LrfTags[6].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer); */break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following statement contains a magic number: switch (objType) {  case LrfObjectType.Toc:  	//LrfTags[3].Data.Value  	string s = Encoding.Unicode.GetString ((byte[])LrfTags [3].Data.Value);  	BitStreamReader ms = new BitStreamReader ((byte[])LrfTags [3].Data.Value' false);  	tc = new TOC (ms' LrfTags [3].PositionOfStructureInFile + 2);  	break;  case LrfObjectType.Text:  	#region Decompress and parse text  	Text = new ELEMENTARY_TYPE (Uncompress ()' LrfTags [4].PositionOfStructureInFile' LrfTags [4].LengthInFile);  	#endregion  	break;  case LrfObjectType.Block:  	ParseLinks (4);  	break;  case LrfObjectType.Page:  	ParseLinks (6);  	break;  case LrfObjectType.Canvas:  	/*                      *                                     Buffer.BlockCopy((byte[])ob.LrfTags[2].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer);                                     Buffer.BlockCopy((byte[])ob.LrfTags[6].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer); */break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following statement contains a magic number: switch (objType) {  case LrfObjectType.Toc:  	//LrfTags[3].Data.Value  	string s = Encoding.Unicode.GetString ((byte[])LrfTags [3].Data.Value);  	BitStreamReader ms = new BitStreamReader ((byte[])LrfTags [3].Data.Value' false);  	tc = new TOC (ms' LrfTags [3].PositionOfStructureInFile + 2);  	break;  case LrfObjectType.Text:  	#region Decompress and parse text  	Text = new ELEMENTARY_TYPE (Uncompress ()' LrfTags [4].PositionOfStructureInFile' LrfTags [4].LengthInFile);  	#endregion  	break;  case LrfObjectType.Block:  	ParseLinks (4);  	break;  case LrfObjectType.Page:  	ParseLinks (6);  	break;  case LrfObjectType.Canvas:  	/*                      *                                     Buffer.BlockCopy((byte[])ob.LrfTags[2].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer);                                     Buffer.BlockCopy((byte[])ob.LrfTags[6].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer); */break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following statement contains a magic number: switch (objType) {  case LrfObjectType.Toc:  	//LrfTags[3].Data.Value  	string s = Encoding.Unicode.GetString ((byte[])LrfTags [3].Data.Value);  	BitStreamReader ms = new BitStreamReader ((byte[])LrfTags [3].Data.Value' false);  	tc = new TOC (ms' LrfTags [3].PositionOfStructureInFile + 2);  	break;  case LrfObjectType.Text:  	#region Decompress and parse text  	Text = new ELEMENTARY_TYPE (Uncompress ()' LrfTags [4].PositionOfStructureInFile' LrfTags [4].LengthInFile);  	#endregion  	break;  case LrfObjectType.Block:  	ParseLinks (4);  	break;  case LrfObjectType.Page:  	ParseLinks (6);  	break;  case LrfObjectType.Canvas:  	/*                      *                                     Buffer.BlockCopy((byte[])ob.LrfTags[2].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer);                                     Buffer.BlockCopy((byte[])ob.LrfTags[6].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer); */break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following statement contains a magic number: switch (objType) {  case LrfObjectType.Toc:  	//LrfTags[3].Data.Value  	string s = Encoding.Unicode.GetString ((byte[])LrfTags [3].Data.Value);  	BitStreamReader ms = new BitStreamReader ((byte[])LrfTags [3].Data.Value' false);  	tc = new TOC (ms' LrfTags [3].PositionOfStructureInFile + 2);  	break;  case LrfObjectType.Text:  	#region Decompress and parse text  	Text = new ELEMENTARY_TYPE (Uncompress ()' LrfTags [4].PositionOfStructureInFile' LrfTags [4].LengthInFile);  	#endregion  	break;  case LrfObjectType.Block:  	ParseLinks (4);  	break;  case LrfObjectType.Page:  	ParseLinks (6);  	break;  case LrfObjectType.Canvas:  	/*                      *                                     Buffer.BlockCopy((byte[])ob.LrfTags[2].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer);                                     Buffer.BlockCopy((byte[])ob.LrfTags[6].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer); */break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following statement contains a magic number: switch (objType) {  case LrfObjectType.Toc:  	//LrfTags[3].Data.Value  	string s = Encoding.Unicode.GetString ((byte[])LrfTags [3].Data.Value);  	BitStreamReader ms = new BitStreamReader ((byte[])LrfTags [3].Data.Value' false);  	tc = new TOC (ms' LrfTags [3].PositionOfStructureInFile + 2);  	break;  case LrfObjectType.Text:  	#region Decompress and parse text  	Text = new ELEMENTARY_TYPE (Uncompress ()' LrfTags [4].PositionOfStructureInFile' LrfTags [4].LengthInFile);  	#endregion  	break;  case LrfObjectType.Block:  	ParseLinks (4);  	break;  case LrfObjectType.Page:  	ParseLinks (6);  	break;  case LrfObjectType.Canvas:  	/*                      *                                     Buffer.BlockCopy((byte[])ob.LrfTags[2].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer);                                     Buffer.BlockCopy((byte[])ob.LrfTags[6].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer); */break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following statement contains a magic number: switch (objType) {  case LrfObjectType.Toc:  	//LrfTags[3].Data.Value  	string s = Encoding.Unicode.GetString ((byte[])LrfTags [3].Data.Value);  	BitStreamReader ms = new BitStreamReader ((byte[])LrfTags [3].Data.Value' false);  	tc = new TOC (ms' LrfTags [3].PositionOfStructureInFile + 2);  	break;  case LrfObjectType.Text:  	#region Decompress and parse text  	Text = new ELEMENTARY_TYPE (Uncompress ()' LrfTags [4].PositionOfStructureInFile' LrfTags [4].LengthInFile);  	#endregion  	break;  case LrfObjectType.Block:  	ParseLinks (4);  	break;  case LrfObjectType.Page:  	ParseLinks (6);  	break;  case LrfObjectType.Canvas:  	/*                      *                                     Buffer.BlockCopy((byte[])ob.LrfTags[2].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer);                                     Buffer.BlockCopy((byte[])ob.LrfTags[6].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer); */break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following statement contains a magic number: tc = new TOC (ms' LrfTags [3].PositionOfStructureInFile + 2);  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following statement contains a magic number: tc = new TOC (ms' LrfTags [3].PositionOfStructureInFile + 2);  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following statement contains a magic number: Text = new ELEMENTARY_TYPE (Uncompress ()' LrfTags [4].PositionOfStructureInFile' LrfTags [4].LengthInFile);  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following statement contains a magic number: Text = new ELEMENTARY_TYPE (Uncompress ()' LrfTags [4].PositionOfStructureInFile' LrfTags [4].LengthInFile);  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following statement contains a magic number: ParseLinks (4);  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following statement contains a magic number: ParseLinks (6);  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,ParseLinks,The following statement contains a magic number: while (ms.Position < ms.Length) {  	others.Add (new LRFTag (ms' LrfTags [6].Data.PositionOfStructureInFile' 0' 0));  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,ParseLinks,The following statement contains a magic number: others.Add (new LRFTag (ms' LrfTags [6].Data.PositionOfStructureInFile' 0' 0));  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: Buffer.BlockCopy ((byte[])LrfTags [4].Data.Value' 4' data' 0' len - 4);  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: Buffer.BlockCopy ((byte[])LrfTags [4].Data.Value' 4' data' 0' len - 4);  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: Buffer.BlockCopy ((byte[])LrfTags [4].Data.Value' 4' data' 0' len - 4);  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (ms.Position < ms.Length) {  	Text_Tag tt = new Text_Tag (ms' LrfTags [4].Data.PositionOfStructureInFile);  	text_Tags.Add (tt);  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<a href=\"\">";  			//Begin button ?  			//link reference  			u += 4;  			break;  		case 0xa8:  			s = "</a>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<a href=\"\">";  			//Begin button ?  			//link reference  			u += 4;  			break;  		case 0xa8:  			s = "</a>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<a href=\"\">";  			//Begin button ?  			//link reference  			u += 4;  			break;  		case 0xa8:  			s = "</a>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<a href=\"\">";  			//Begin button ?  			//link reference  			u += 4;  			break;  		case 0xa8:  			s = "</a>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<a href=\"\">";  			//Begin button ?  			//link reference  			u += 4;  			break;  		case 0xa8:  			s = "</a>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<a href=\"\">";  			//Begin button ?  			//link reference  			u += 4;  			break;  		case 0xa8:  			s = "</a>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<a href=\"\">";  			//Begin button ?  			//link reference  			u += 4;  			break;  		case 0xa8:  			s = "</a>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<a href=\"\">";  			//Begin button ?  			//link reference  			u += 4;  			break;  		case 0xa8:  			s = "</a>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<a href=\"\">";  			//Begin button ?  			//link reference  			u += 4;  			break;  		case 0xa8:  			s = "</a>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<a href=\"\">";  			//Begin button ?  			//link reference  			u += 4;  			break;  		case 0xa8:  			s = "</a>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<a href=\"\">";  		//Begin button ?  		//link reference  		u += 4;  		break;  	case 0xa8:  		s = "</a>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<a href=\"\">";  		//Begin button ?  		//link reference  		u += 4;  		break;  	case 0xa8:  		s = "</a>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<a href=\"\">";  		//Begin button ?  		//link reference  		u += 4;  		break;  	case 0xa8:  		s = "</a>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<a href=\"\">";  		//Begin button ?  		//link reference  		u += 4;  		break;  	case 0xa8:  		s = "</a>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<a href=\"\">";  		//Begin button ?  		//link reference  		u += 4;  		break;  	case 0xa8:  		s = "</a>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<a href=\"\">";  		//Begin button ?  		//link reference  		u += 4;  		break;  	case 0xa8:  		s = "</a>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<a href=\"\">";  		//Begin button ?  		//link reference  		u += 4;  		break;  	case 0xa8:  		s = "</a>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<a href=\"\">";  		//Begin button ?  		//link reference  		u += 4;  		break;  	case 0xa8:  		s = "</a>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<a href=\"\">";  		//Begin button ?  		//link reference  		u += 4;  		break;  	case 0xa8:  		s = "</a>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<a href=\"\">";  		//Begin button ?  		//link reference  		u += 4;  		break;  	case 0xa8:  		s = "</a>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<a href=\"\">";  	//Begin button ?  	//link reference  	u += 4;  	break;  case 0xa8:  	s = "</a>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<a href=\"\">";  	//Begin button ?  	//link reference  	u += 4;  	break;  case 0xa8:  	s = "</a>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<a href=\"\">";  	//Begin button ?  	//link reference  	u += 4;  	break;  case 0xa8:  	s = "</a>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<a href=\"\">";  	//Begin button ?  	//link reference  	u += 4;  	break;  case 0xa8:  	s = "</a>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<a href=\"\">";  	//Begin button ?  	//link reference  	u += 4;  	break;  case 0xa8:  	s = "</a>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<a href=\"\">";  	//Begin button ?  	//link reference  	u += 4;  	break;  case 0xa8:  	s = "</a>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<a href=\"\">";  	//Begin button ?  	//link reference  	u += 4;  	break;  case 0xa8:  	s = "</a>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<a href=\"\">";  	//Begin button ?  	//link reference  	u += 4;  	break;  case 0xa8:  	s = "</a>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 2;  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 2;  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 4;  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 2;  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 4;  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 4;  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (buffer [u + 3] != 0xF5) {  	u++;  	s += "_";  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 2;  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 2;  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 2;  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,ToString,The following statement contains a magic number: switch ((short)baseTag.ObType.Value) {  case 0x01:  	text = text + "Page Tree ";  	break;  case 0x02:  	text = text + "Page ";  	break;  case 0x03:  	text = text + "Header ";  	break;  case 0x04:  	text = text + "Footer ";  	break;  case 0x05:  	text = text + "Page Atr ";  	break;  case 0x06:  	text = text + "Block ";  	break;  case 0x07:  	text = text + "Block Atr ";  	break;  case 0x08:  	text = text + "Mini Page ";  	break;  case 0x09:  	text = text + "Block List ";  	break;  case 0x0A:  	text = text + "Text ";  	if (Text != null)  		if (((string)Text.Value).Length < 50)  			text += (string)Text.Value;  		else  			text += ((string)Text.Value).Substring (0' 50);  	break;  case 0x0B:  	text = text + "Text Atr ";  	break;  case 0x0C:  	text = text + "Image ";  	break;  case 0x0D:  	text = text + "Canvas ";  	break;  case 0x0E:  	text = text + "Paragraph Atr ";  	break;  case 0x11:  	text = text + "Image Stream ";  	break;  case 0x12:  	text = text + "Import ";  	break;  case 0x13:  	text = text + "Button ";  	break;  case 0x14:  	text = text + "Window ";  	break;  case 0x15:  	text = text + "Pop Up Win ";  	break;  case 0x16:  	text = text + "Sound ";  	break;  case 0x17:  	text = text + "Plane Stream ";  	break;  case 0x19:  	text = text + "Font ";  	break;  case 0x1A:  	text = text + "Object Info ";  	break;  case 0x1C:  	text = text + "Book Atr ";  	break;  case 0x1D:  	text = text + "Simple Text ";  	break;  case 0x1E:  	text = text + "Toc ";  	break;  default:  	text = text + "";  	break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,ToString,The following statement contains a magic number: switch ((short)baseTag.ObType.Value) {  case 0x01:  	text = text + "Page Tree ";  	break;  case 0x02:  	text = text + "Page ";  	break;  case 0x03:  	text = text + "Header ";  	break;  case 0x04:  	text = text + "Footer ";  	break;  case 0x05:  	text = text + "Page Atr ";  	break;  case 0x06:  	text = text + "Block ";  	break;  case 0x07:  	text = text + "Block Atr ";  	break;  case 0x08:  	text = text + "Mini Page ";  	break;  case 0x09:  	text = text + "Block List ";  	break;  case 0x0A:  	text = text + "Text ";  	if (Text != null)  		if (((string)Text.Value).Length < 50)  			text += (string)Text.Value;  		else  			text += ((string)Text.Value).Substring (0' 50);  	break;  case 0x0B:  	text = text + "Text Atr ";  	break;  case 0x0C:  	text = text + "Image ";  	break;  case 0x0D:  	text = text + "Canvas ";  	break;  case 0x0E:  	text = text + "Paragraph Atr ";  	break;  case 0x11:  	text = text + "Image Stream ";  	break;  case 0x12:  	text = text + "Import ";  	break;  case 0x13:  	text = text + "Button ";  	break;  case 0x14:  	text = text + "Window ";  	break;  case 0x15:  	text = text + "Pop Up Win ";  	break;  case 0x16:  	text = text + "Sound ";  	break;  case 0x17:  	text = text + "Plane Stream ";  	break;  case 0x19:  	text = text + "Font ";  	break;  case 0x1A:  	text = text + "Object Info ";  	break;  case 0x1C:  	text = text + "Book Atr ";  	break;  case 0x1D:  	text = text + "Simple Text ";  	break;  case 0x1E:  	text = text + "Toc ";  	break;  default:  	text = text + "";  	break;  }  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,ToString,The following statement contains a magic number: if (Text != null)  	if (((string)Text.Value).Length < 50)  		text += (string)Text.Value;  	else  		text += ((string)Text.Value).Substring (0' 50);  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,ToString,The following statement contains a magic number: if (Text != null)  	if (((string)Text.Value).Length < 50)  		text += (string)Text.Value;  	else  		text += ((string)Text.Value).Substring (0' 50);  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,ToString,The following statement contains a magic number: if (((string)Text.Value).Length < 50)  	text += (string)Text.Value;  else  	text += ((string)Text.Value).Substring (0' 50);  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,ToString,The following statement contains a magic number: if (((string)Text.Value).Length < 50)  	text += (string)Text.Value;  else  	text += ((string)Text.Value).Substring (0' 50);  
Magic Number,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,ToString,The following statement contains a magic number: text += ((string)Text.Value).Substring (0' 50);  
Magic Number,BookReader,Text_Tag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Text_Tag,The following statement contains a magic number: if (((ushort)tag.Value & 0xff00) == 0xf500) {  	#region Parse text tag  	switch ((ushort)tag.Value & 0x00ff) {  	case 0x00:  		break;  	case 0x11:  		//Font size  		data = new ELEMENTARY_TYPE (ms' offset' typeof(short));  		// u += 2;// Size ?  		html = "font-size";  		html += ":" + ((short)data.Value).ToString ();  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		//       s = "";  		data = new ELEMENTARY_TYPE (ms' offset' typeof(short));  		//u += 2;// Weight ?  		html = "font-weight";  		switch ((short)data.Value) {  		case 0x2bc:  			html += ":bold";  			break;  		case 0x190:  			html += ":normal";  			break;  		default:  			break;  		}  		break;  	case 0x16:  		//Font Face name  		/*           while (buffer[u + 3] != 0xF5)                                    {                                        u++;                                        s += "_";                                    }*/break;  	case 0x17:  	case 0x18:  		//     s = "";//  		data = new ELEMENTARY_TYPE (ms' offset' typeof(int));  		//u += 4;// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		data = new ELEMENTARY_TYPE (ms' offset' typeof(short));  		//u += 2;  		break;  	case 0x81:  		html = "<I>";  		break;  	case 0x82:  		html = "</I>";  		break;  	case 0xa1:  		data = new ELEMENTARY_TYPE (ms' offset' typeof(int));  		html = "<P>";  		break;  	case 0xa2:  		html = "</P>";  		break;  	case 0xa7:  		data = new ELEMENTARY_TYPE (ms' offset' typeof(int));  		// u += 4;  		html = "<a href=\"" + ((int)data.Value).ToString ("x8") + "\">";  		break;  	case 0xa8:  		html = "</a>";  		//end button  		break;  	case 0xb7:  		html = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		html = "</sup>";  		//End sup  		break;  	case 0xcc:  		int length = ms.ReadShort ();  		data = new ELEMENTARY_TYPE (ms' offset' Encoding.Unicode' length / 2);  		html = (string)data.Value;  		break;  	case 0xd1:  		//         s = "";  		image = new Image_Data (ms' offset);  		html = "<img src= \"" + ((int)image.Image_reference.Value).ToString ("x8") + "\"/>";  		break;  	case 0xd2:  		//         s = "</P>";  		break;  	default:  		//     s = "";  		break;  	}  	#endregion  }  else {  	txt += Encoding.Unicode.GetString (BitConverter.GetBytes ((ushort)tag.Value));  }  
Magic Number,BookReader,Text_Tag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Text_Tag,The following statement contains a magic number: switch ((ushort)tag.Value & 0x00ff) {  case 0x00:  	break;  case 0x11:  	//Font size  	data = new ELEMENTARY_TYPE (ms' offset' typeof(short));  	// u += 2;// Size ?  	html = "font-size";  	html += ":" + ((short)data.Value).ToString ();  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	//       s = "";  	data = new ELEMENTARY_TYPE (ms' offset' typeof(short));  	//u += 2;// Weight ?  	html = "font-weight";  	switch ((short)data.Value) {  	case 0x2bc:  		html += ":bold";  		break;  	case 0x190:  		html += ":normal";  		break;  	default:  		break;  	}  	break;  case 0x16:  	//Font Face name  	/*           while (buffer[u + 3] != 0xF5)                                    {                                        u++;                                        s += "_";                                    }*/break;  case 0x17:  case 0x18:  	//     s = "";//  	data = new ELEMENTARY_TYPE (ms' offset' typeof(int));  	//u += 4;// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	data = new ELEMENTARY_TYPE (ms' offset' typeof(short));  	//u += 2;  	break;  case 0x81:  	html = "<I>";  	break;  case 0x82:  	html = "</I>";  	break;  case 0xa1:  	data = new ELEMENTARY_TYPE (ms' offset' typeof(int));  	html = "<P>";  	break;  case 0xa2:  	html = "</P>";  	break;  case 0xa7:  	data = new ELEMENTARY_TYPE (ms' offset' typeof(int));  	// u += 4;  	html = "<a href=\"" + ((int)data.Value).ToString ("x8") + "\">";  	break;  case 0xa8:  	html = "</a>";  	//end button  	break;  case 0xb7:  	html = "<sup>";  	//Begin sup  	break;  case 0xb8:  	html = "</sup>";  	//End sup  	break;  case 0xcc:  	int length = ms.ReadShort ();  	data = new ELEMENTARY_TYPE (ms' offset' Encoding.Unicode' length / 2);  	html = (string)data.Value;  	break;  case 0xd1:  	//         s = "";  	image = new Image_Data (ms' offset);  	html = "<img src= \"" + ((int)image.Image_reference.Value).ToString ("x8") + "\"/>";  	break;  case 0xd2:  	//         s = "</P>";  	break;  default:  	//     s = "";  	break;  }  
Magic Number,BookReader,Text_Tag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Text_Tag,The following statement contains a magic number: data = new ELEMENTARY_TYPE (ms' offset' Encoding.Unicode' length / 2);  
Magic Number,BookReader,TOC,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,TOC,The following statement contains a magic number: while (sw.Position < sw.Length) {  	nbEntries = new ELEMENTARY_TYPE (sw' offset' typeof(int));  	for (int w = 0; w < (int)nbEntries.Value; w++) {  		entries_offset.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  	}  	page_destination = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  	bloc_destination = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  	for (int w = 0; w < (int)nbEntries.Value; w++) {  		TOC_Entry entry = new TOC_Entry (sw' offset + 2);  		entries.Add (entry);  	}  }  
Magic Number,BookReader,TOC,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,TOC,The following statement contains a magic number: for (int w = 0; w < (int)nbEntries.Value; w++) {  	TOC_Entry entry = new TOC_Entry (sw' offset + 2);  	entries.Add (entry);  }  
Magic Number,BookReader,TOC_Entry,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,TOC_Entry,The following statement contains a magic number: title = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' (ushort)strLength.Value / 2);  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: f500 = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: if (datasize >= 0)// Fixed size   {  	try {  		switch (((byte[])f500.Value) [0]) {  		case 0x03:  			//link;  			data = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		case 0x04:  			//streamSize  			streamSize = new ELEMENTARY_TYPE (sw' offset' typeof(int));  			break;  		case 0x4a:  			//Image rect  			data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 4);  			image_Height = new ELEMENTARY_TYPE (sw' offset' typeof(short));  			image_width = new ELEMENTARY_TYPE (sw' offset' typeof(short));  			break;  		case 0x4b:  			image_Size = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		case 0x4c:  			imageStream_Id = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		case 0x6c:  			page_Destination = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			bloc_Destination = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		case 0x75:  		case 0x76:  		case 0x77:  		case 0x79:  		case 0x7A:  			data = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  			break;  		case 0x7B:  			//child page tree  			data = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		default:  			data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' datasize);  			//sw.ReadBytes(datasize);  			break;  		}  	}  	catch (Exception ex) {  	}  }  else//Variable length   {  	try {  		switch (((byte[])f500.Value) [0]) {  		case 0x05:  			data = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' streamsize);  			//Reads data stream;  			break;  		case 0x0b:  			//Page  			ids_Number = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  			content_Ids = new List<ELEMENTARY_TYPE> ();  			for (int i = 0; i < (ushort)ids_Number.Value; i++) {  				content_Ids.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  			}  			break;  		case 0x5c:  			//pagelist  			ids_Number = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  			content_Ids = new List<ELEMENTARY_TYPE> ();  			for (int i = 0; i < (ushort)ids_Number.Value; i++) {  				content_Ids.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  			}  			break;  		default:  			List<byte> ints = new List<byte> ();  			int start = (int)sw.Position;  			byte x = sw.ReadByte ();  			while (x != 0xF5) {  				ints.Add (x);  				x = sw.ReadByte ();  			}  			sw.Position = start;  			if (ints.Count > 1)  				switch (((byte[])f500.Value) [0]) {  				case 0x16:  					fontLength = new ELEMENTARY_TYPE (sw' offset' typeof(short));  					font = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' (ints.Count - 3) / 2);  					// (short)fontLength.Value / 2 +1);  					break;  				default:  					data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' ints.Count - 1);  					break;  				}  			break;  		}  	}  	catch {  	}  }  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: if (datasize >= 0)// Fixed size   {  	try {  		switch (((byte[])f500.Value) [0]) {  		case 0x03:  			//link;  			data = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		case 0x04:  			//streamSize  			streamSize = new ELEMENTARY_TYPE (sw' offset' typeof(int));  			break;  		case 0x4a:  			//Image rect  			data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 4);  			image_Height = new ELEMENTARY_TYPE (sw' offset' typeof(short));  			image_width = new ELEMENTARY_TYPE (sw' offset' typeof(short));  			break;  		case 0x4b:  			image_Size = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		case 0x4c:  			imageStream_Id = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		case 0x6c:  			page_Destination = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			bloc_Destination = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		case 0x75:  		case 0x76:  		case 0x77:  		case 0x79:  		case 0x7A:  			data = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  			break;  		case 0x7B:  			//child page tree  			data = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		default:  			data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' datasize);  			//sw.ReadBytes(datasize);  			break;  		}  	}  	catch (Exception ex) {  	}  }  else//Variable length   {  	try {  		switch (((byte[])f500.Value) [0]) {  		case 0x05:  			data = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' streamsize);  			//Reads data stream;  			break;  		case 0x0b:  			//Page  			ids_Number = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  			content_Ids = new List<ELEMENTARY_TYPE> ();  			for (int i = 0; i < (ushort)ids_Number.Value; i++) {  				content_Ids.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  			}  			break;  		case 0x5c:  			//pagelist  			ids_Number = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  			content_Ids = new List<ELEMENTARY_TYPE> ();  			for (int i = 0; i < (ushort)ids_Number.Value; i++) {  				content_Ids.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  			}  			break;  		default:  			List<byte> ints = new List<byte> ();  			int start = (int)sw.Position;  			byte x = sw.ReadByte ();  			while (x != 0xF5) {  				ints.Add (x);  				x = sw.ReadByte ();  			}  			sw.Position = start;  			if (ints.Count > 1)  				switch (((byte[])f500.Value) [0]) {  				case 0x16:  					fontLength = new ELEMENTARY_TYPE (sw' offset' typeof(short));  					font = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' (ints.Count - 3) / 2);  					// (short)fontLength.Value / 2 +1);  					break;  				default:  					data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' ints.Count - 1);  					break;  				}  			break;  		}  	}  	catch {  	}  }  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: if (datasize >= 0)// Fixed size   {  	try {  		switch (((byte[])f500.Value) [0]) {  		case 0x03:  			//link;  			data = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		case 0x04:  			//streamSize  			streamSize = new ELEMENTARY_TYPE (sw' offset' typeof(int));  			break;  		case 0x4a:  			//Image rect  			data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 4);  			image_Height = new ELEMENTARY_TYPE (sw' offset' typeof(short));  			image_width = new ELEMENTARY_TYPE (sw' offset' typeof(short));  			break;  		case 0x4b:  			image_Size = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		case 0x4c:  			imageStream_Id = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		case 0x6c:  			page_Destination = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			bloc_Destination = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		case 0x75:  		case 0x76:  		case 0x77:  		case 0x79:  		case 0x7A:  			data = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  			break;  		case 0x7B:  			//child page tree  			data = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  			break;  		default:  			data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' datasize);  			//sw.ReadBytes(datasize);  			break;  		}  	}  	catch (Exception ex) {  	}  }  else//Variable length   {  	try {  		switch (((byte[])f500.Value) [0]) {  		case 0x05:  			data = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' streamsize);  			//Reads data stream;  			break;  		case 0x0b:  			//Page  			ids_Number = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  			content_Ids = new List<ELEMENTARY_TYPE> ();  			for (int i = 0; i < (ushort)ids_Number.Value; i++) {  				content_Ids.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  			}  			break;  		case 0x5c:  			//pagelist  			ids_Number = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  			content_Ids = new List<ELEMENTARY_TYPE> ();  			for (int i = 0; i < (ushort)ids_Number.Value; i++) {  				content_Ids.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  			}  			break;  		default:  			List<byte> ints = new List<byte> ();  			int start = (int)sw.Position;  			byte x = sw.ReadByte ();  			while (x != 0xF5) {  				ints.Add (x);  				x = sw.ReadByte ();  			}  			sw.Position = start;  			if (ints.Count > 1)  				switch (((byte[])f500.Value) [0]) {  				case 0x16:  					fontLength = new ELEMENTARY_TYPE (sw' offset' typeof(short));  					font = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' (ints.Count - 3) / 2);  					// (short)fontLength.Value / 2 +1);  					break;  				default:  					data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' ints.Count - 1);  					break;  				}  			break;  		}  	}  	catch {  	}  }  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: try {  	switch (((byte[])f500.Value) [0]) {  	case 0x03:  		//link;  		data = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  		break;  	case 0x04:  		//streamSize  		streamSize = new ELEMENTARY_TYPE (sw' offset' typeof(int));  		break;  	case 0x4a:  		//Image rect  		data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 4);  		image_Height = new ELEMENTARY_TYPE (sw' offset' typeof(short));  		image_width = new ELEMENTARY_TYPE (sw' offset' typeof(short));  		break;  	case 0x4b:  		image_Size = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  		break;  	case 0x4c:  		imageStream_Id = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  		break;  	case 0x6c:  		page_Destination = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  		bloc_Destination = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  		break;  	case 0x75:  	case 0x76:  	case 0x77:  	case 0x79:  	case 0x7A:  		data = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  		break;  	case 0x7B:  		//child page tree  		data = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  		break;  	default:  		data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' datasize);  		//sw.ReadBytes(datasize);  		break;  	}  }  catch (Exception ex) {  }  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: switch (((byte[])f500.Value) [0]) {  case 0x03:  	//link;  	data = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  	break;  case 0x04:  	//streamSize  	streamSize = new ELEMENTARY_TYPE (sw' offset' typeof(int));  	break;  case 0x4a:  	//Image rect  	data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 4);  	image_Height = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	image_width = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	break;  case 0x4b:  	image_Size = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  	break;  case 0x4c:  	imageStream_Id = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  	break;  case 0x6c:  	page_Destination = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  	bloc_Destination = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  	break;  case 0x75:  case 0x76:  case 0x77:  case 0x79:  case 0x7A:  	data = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	break;  case 0x7B:  	//child page tree  	data = new ELEMENTARY_TYPE (sw' offset' typeof(uint));  	break;  default:  	data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' datasize);  	//sw.ReadBytes(datasize);  	break;  }  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 4);  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: try {  	switch (((byte[])f500.Value) [0]) {  	case 0x05:  		data = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' streamsize);  		//Reads data stream;  		break;  	case 0x0b:  		//Page  		ids_Number = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  		content_Ids = new List<ELEMENTARY_TYPE> ();  		for (int i = 0; i < (ushort)ids_Number.Value; i++) {  			content_Ids.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  		}  		break;  	case 0x5c:  		//pagelist  		ids_Number = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  		content_Ids = new List<ELEMENTARY_TYPE> ();  		for (int i = 0; i < (ushort)ids_Number.Value; i++) {  			content_Ids.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  		}  		break;  	default:  		List<byte> ints = new List<byte> ();  		int start = (int)sw.Position;  		byte x = sw.ReadByte ();  		while (x != 0xF5) {  			ints.Add (x);  			x = sw.ReadByte ();  		}  		sw.Position = start;  		if (ints.Count > 1)  			switch (((byte[])f500.Value) [0]) {  			case 0x16:  				fontLength = new ELEMENTARY_TYPE (sw' offset' typeof(short));  				font = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' (ints.Count - 3) / 2);  				// (short)fontLength.Value / 2 +1);  				break;  			default:  				data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' ints.Count - 1);  				break;  			}  		break;  	}  }  catch {  }  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: try {  	switch (((byte[])f500.Value) [0]) {  	case 0x05:  		data = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' streamsize);  		//Reads data stream;  		break;  	case 0x0b:  		//Page  		ids_Number = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  		content_Ids = new List<ELEMENTARY_TYPE> ();  		for (int i = 0; i < (ushort)ids_Number.Value; i++) {  			content_Ids.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  		}  		break;  	case 0x5c:  		//pagelist  		ids_Number = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  		content_Ids = new List<ELEMENTARY_TYPE> ();  		for (int i = 0; i < (ushort)ids_Number.Value; i++) {  			content_Ids.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  		}  		break;  	default:  		List<byte> ints = new List<byte> ();  		int start = (int)sw.Position;  		byte x = sw.ReadByte ();  		while (x != 0xF5) {  			ints.Add (x);  			x = sw.ReadByte ();  		}  		sw.Position = start;  		if (ints.Count > 1)  			switch (((byte[])f500.Value) [0]) {  			case 0x16:  				fontLength = new ELEMENTARY_TYPE (sw' offset' typeof(short));  				font = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' (ints.Count - 3) / 2);  				// (short)fontLength.Value / 2 +1);  				break;  			default:  				data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' ints.Count - 1);  				break;  			}  		break;  	}  }  catch {  }  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: switch (((byte[])f500.Value) [0]) {  case 0x05:  	data = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' streamsize);  	//Reads data stream;  	break;  case 0x0b:  	//Page  	ids_Number = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	content_Ids = new List<ELEMENTARY_TYPE> ();  	for (int i = 0; i < (ushort)ids_Number.Value; i++) {  		content_Ids.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  	}  	break;  case 0x5c:  	//pagelist  	ids_Number = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	content_Ids = new List<ELEMENTARY_TYPE> ();  	for (int i = 0; i < (ushort)ids_Number.Value; i++) {  		content_Ids.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  	}  	break;  default:  	List<byte> ints = new List<byte> ();  	int start = (int)sw.Position;  	byte x = sw.ReadByte ();  	while (x != 0xF5) {  		ints.Add (x);  		x = sw.ReadByte ();  	}  	sw.Position = start;  	if (ints.Count > 1)  		switch (((byte[])f500.Value) [0]) {  		case 0x16:  			fontLength = new ELEMENTARY_TYPE (sw' offset' typeof(short));  			font = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' (ints.Count - 3) / 2);  			// (short)fontLength.Value / 2 +1);  			break;  		default:  			data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' ints.Count - 1);  			break;  		}  	break;  }  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: switch (((byte[])f500.Value) [0]) {  case 0x05:  	data = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' streamsize);  	//Reads data stream;  	break;  case 0x0b:  	//Page  	ids_Number = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	content_Ids = new List<ELEMENTARY_TYPE> ();  	for (int i = 0; i < (ushort)ids_Number.Value; i++) {  		content_Ids.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  	}  	break;  case 0x5c:  	//pagelist  	ids_Number = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	content_Ids = new List<ELEMENTARY_TYPE> ();  	for (int i = 0; i < (ushort)ids_Number.Value; i++) {  		content_Ids.Add (new ELEMENTARY_TYPE (sw' offset' typeof(uint)));  	}  	break;  default:  	List<byte> ints = new List<byte> ();  	int start = (int)sw.Position;  	byte x = sw.ReadByte ();  	while (x != 0xF5) {  		ints.Add (x);  		x = sw.ReadByte ();  	}  	sw.Position = start;  	if (ints.Count > 1)  		switch (((byte[])f500.Value) [0]) {  		case 0x16:  			fontLength = new ELEMENTARY_TYPE (sw' offset' typeof(short));  			font = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' (ints.Count - 3) / 2);  			// (short)fontLength.Value / 2 +1);  			break;  		default:  			data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' ints.Count - 1);  			break;  		}  	break;  }  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: if (ints.Count > 1)  	switch (((byte[])f500.Value) [0]) {  	case 0x16:  		fontLength = new ELEMENTARY_TYPE (sw' offset' typeof(short));  		font = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' (ints.Count - 3) / 2);  		// (short)fontLength.Value / 2 +1);  		break;  	default:  		data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' ints.Count - 1);  		break;  	}  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: if (ints.Count > 1)  	switch (((byte[])f500.Value) [0]) {  	case 0x16:  		fontLength = new ELEMENTARY_TYPE (sw' offset' typeof(short));  		font = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' (ints.Count - 3) / 2);  		// (short)fontLength.Value / 2 +1);  		break;  	default:  		data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' ints.Count - 1);  		break;  	}  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: switch (((byte[])f500.Value) [0]) {  case 0x16:  	fontLength = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	font = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' (ints.Count - 3) / 2);  	// (short)fontLength.Value / 2 +1);  	break;  default:  	data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' ints.Count - 1);  	break;  }  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: switch (((byte[])f500.Value) [0]) {  case 0x16:  	fontLength = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	font = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' (ints.Count - 3) / 2);  	// (short)fontLength.Value / 2 +1);  	break;  default:  	data = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' ints.Count - 1);  	break;  }  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: font = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' (ints.Count - 3) / 2);  
Magic Number,BookReader,LRFTag,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LRFTag,The following statement contains a magic number: font = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' (ints.Count - 3) / 2);  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: Buffer.BlockCopy ((byte[])text.LrfTags [4].Data.Value' 4' data' 0' len - 4);  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: Buffer.BlockCopy ((byte[])text.LrfTags [4].Data.Value' 4' data' 0' len - 4);  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: Buffer.BlockCopy ((byte[])text.LrfTags [4].Data.Value' 4' data' 0' len - 4);  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<h1>";  			//Begin button ?  			u += 4;  			break;  		case 0xa8:  			s = "</h1>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<h1>";  			//Begin button ?  			u += 4;  			break;  		case 0xa8:  			s = "</h1>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<h1>";  			//Begin button ?  			u += 4;  			break;  		case 0xa8:  			s = "</h1>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<h1>";  			//Begin button ?  			u += 4;  			break;  		case 0xa8:  			s = "</h1>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<h1>";  			//Begin button ?  			u += 4;  			break;  		case 0xa8:  			s = "</h1>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<h1>";  			//Begin button ?  			u += 4;  			break;  		case 0xa8:  			s = "</h1>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<h1>";  			//Begin button ?  			u += 4;  			break;  		case 0xa8:  			s = "</h1>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<h1>";  			//Begin button ?  			u += 4;  			break;  		case 0xa8:  			s = "</h1>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<h1>";  			//Begin button ?  			u += 4;  			break;  		case 0xa8:  			s = "</h1>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (u < buffer.Length - 1) {  	#region Parse  	if (buffer [u + 1] == 0xf5) {  		if (txt.Count > 0) {  			s = Encoding.Unicode.GetString (txt.ToArray ());  			tags.Add (s);  			txts.Add (txt);  			txt.Clear ();  		}  		switch (buffer [u]) {  		case 0x00:  			s = "<P>";  			break;  		case 0x11:  			s = "";  			//Font Size  			u += 2;  			// Size ?  			break;  		case 0x12:  		case 0x13:  		case 0x14:  		case 0x15:  			//Font weight  			s = "";  			u += 2;  			// Weight ?  			break;  		case 0x17:  		case 0x18:  			s = "";  			//  			u += 4;  			// Weight ?  			break;  		case 0x19:  		//Word space  		case 0x1A:  		case 0x1B:  		//Base Line SkipBit  		case 0x1C:  		case 0x1D:  		case 0x1E:  		case 0x25:  		case 0x26:  		case 0x31:  		case 0x32:  		case 0x33:  			s = "";  			u += 2;  			break;  		case 0x81:  			s = "<I>";  			break;  		case 0x82:  			s = "</I>";  			break;  		case 0xa1:  		case 0xa2:  			s = "<P>";  			u += 4;  			break;  		case 0xa7:  			s = "<h1>";  			//Begin button ?  			u += 4;  			break;  		case 0xa8:  			s = "</h1>";  			//end button  			break;  		case 0xb7:  			s = "<sup>";  			//Begin sup  			break;  		case 0xb8:  			s = "</sup>";  			//End sup  			break;  		case 0x16:  		//Font Face name  		case 0xd1:  			s = "";  			while (buffer [u + 3] != 0xF5) {  				u++;  				s += "_";  			}  			break;  		case 0xd2:  			s = "</P>";  			break;  		case 0xcc:  			s = "";  			//<a href  			u += 2;  			break;  		default:  			s = "";  			break;  		}  		if (s != "")  			tags.Add (s);  		s = "";  		u += 2;  	}  	else {  		//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  		{  			txt.Add (buffer [u]);  			txt.Add (buffer [u + 1]);  		}  		u += 2;  	}  	#endregion  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<h1>";  		//Begin button ?  		u += 4;  		break;  	case 0xa8:  		s = "</h1>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<h1>";  		//Begin button ?  		u += 4;  		break;  	case 0xa8:  		s = "</h1>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<h1>";  		//Begin button ?  		u += 4;  		break;  	case 0xa8:  		s = "</h1>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<h1>";  		//Begin button ?  		u += 4;  		break;  	case 0xa8:  		s = "</h1>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<h1>";  		//Begin button ?  		u += 4;  		break;  	case 0xa8:  		s = "</h1>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<h1>";  		//Begin button ?  		u += 4;  		break;  	case 0xa8:  		s = "</h1>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<h1>";  		//Begin button ?  		u += 4;  		break;  	case 0xa8:  		s = "</h1>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<h1>";  		//Begin button ?  		u += 4;  		break;  	case 0xa8:  		s = "</h1>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<h1>";  		//Begin button ?  		u += 4;  		break;  	case 0xa8:  		s = "</h1>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: if (buffer [u + 1] == 0xf5) {  	if (txt.Count > 0) {  		s = Encoding.Unicode.GetString (txt.ToArray ());  		tags.Add (s);  		txts.Add (txt);  		txt.Clear ();  	}  	switch (buffer [u]) {  	case 0x00:  		s = "<P>";  		break;  	case 0x11:  		s = "";  		//Font Size  		u += 2;  		// Size ?  		break;  	case 0x12:  	case 0x13:  	case 0x14:  	case 0x15:  		//Font weight  		s = "";  		u += 2;  		// Weight ?  		break;  	case 0x17:  	case 0x18:  		s = "";  		//  		u += 4;  		// Weight ?  		break;  	case 0x19:  	//Word space  	case 0x1A:  	case 0x1B:  	//Base Line SkipBit  	case 0x1C:  	case 0x1D:  	case 0x1E:  	case 0x25:  	case 0x26:  	case 0x31:  	case 0x32:  	case 0x33:  		s = "";  		u += 2;  		break;  	case 0x81:  		s = "<I>";  		break;  	case 0x82:  		s = "</I>";  		break;  	case 0xa1:  	case 0xa2:  		s = "<P>";  		u += 4;  		break;  	case 0xa7:  		s = "<h1>";  		//Begin button ?  		u += 4;  		break;  	case 0xa8:  		s = "</h1>";  		//end button  		break;  	case 0xb7:  		s = "<sup>";  		//Begin sup  		break;  	case 0xb8:  		s = "</sup>";  		//End sup  		break;  	case 0x16:  	//Font Face name  	case 0xd1:  		s = "";  		while (buffer [u + 3] != 0xF5) {  			u++;  			s += "_";  		}  		break;  	case 0xd2:  		s = "</P>";  		break;  	case 0xcc:  		s = "";  		//<a href  		u += 2;  		break;  	default:  		s = "";  		break;  	}  	if (s != "")  		tags.Add (s);  	s = "";  	u += 2;  }  else {  	//             if ((buffer[inTime] != 0x00) || (buffer[inTime + 1] != 0x00))  	{  		txt.Add (buffer [u]);  		txt.Add (buffer [u + 1]);  	}  	u += 2;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<h1>";  	//Begin button ?  	u += 4;  	break;  case 0xa8:  	s = "</h1>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<h1>";  	//Begin button ?  	u += 4;  	break;  case 0xa8:  	s = "</h1>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<h1>";  	//Begin button ?  	u += 4;  	break;  case 0xa8:  	s = "</h1>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<h1>";  	//Begin button ?  	u += 4;  	break;  case 0xa8:  	s = "</h1>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<h1>";  	//Begin button ?  	u += 4;  	break;  case 0xa8:  	s = "</h1>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<h1>";  	//Begin button ?  	u += 4;  	break;  case 0xa8:  	s = "</h1>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<h1>";  	//Begin button ?  	u += 4;  	break;  case 0xa8:  	s = "</h1>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: switch (buffer [u]) {  case 0x00:  	s = "<P>";  	break;  case 0x11:  	s = "";  	//Font Size  	u += 2;  	// Size ?  	break;  case 0x12:  case 0x13:  case 0x14:  case 0x15:  	//Font weight  	s = "";  	u += 2;  	// Weight ?  	break;  case 0x17:  case 0x18:  	s = "";  	//  	u += 4;  	// Weight ?  	break;  case 0x19:  //Word space  case 0x1A:  case 0x1B:  //Base Line SkipBit  case 0x1C:  case 0x1D:  case 0x1E:  case 0x25:  case 0x26:  case 0x31:  case 0x32:  case 0x33:  	s = "";  	u += 2;  	break;  case 0x81:  	s = "<I>";  	break;  case 0x82:  	s = "</I>";  	break;  case 0xa1:  case 0xa2:  	s = "<P>";  	u += 4;  	break;  case 0xa7:  	s = "<h1>";  	//Begin button ?  	u += 4;  	break;  case 0xa8:  	s = "</h1>";  	//end button  	break;  case 0xb7:  	s = "<sup>";  	//Begin sup  	break;  case 0xb8:  	s = "</sup>";  	//End sup  	break;  case 0x16:  //Font Face name  case 0xd1:  	s = "";  	while (buffer [u + 3] != 0xF5) {  		u++;  		s += "_";  	}  	break;  case 0xd2:  	s = "</P>";  	break;  case 0xcc:  	s = "";  	//<a href  	u += 2;  	break;  default:  	s = "";  	break;  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 2;  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 2;  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 4;  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 2;  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 4;  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 4;  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: while (buffer [u + 3] != 0xF5) {  	u++;  	s += "_";  }  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 2;  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 2;  
Magic Number,BookReader,TextBlock,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,Uncompress,The following statement contains a magic number: u += 2;  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X00' 6' "0bject Start "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X02' 4' "0bject Info Link "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X03' 4' "Link "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X04' 4' "Stream Size "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X07' 4' "odd-side header ID"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X08' 4' "even-side header ID"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X09' 4' "odd-side footer ID"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X0A' 4' "even-side footer ID"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X0C' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X0E' 2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X0F' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X10' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X11' 2' "Font Size "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X12' 2' "Font Width "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X13' 2' "Font Escapement "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X14' 2' "Font Orientation "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X15' 2' "Font Weight "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X17' 4' "Text Color "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X18' 4' "Text Bg Color "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X19' 2' "Word Space "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X1A' 2' "Letter Space "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X1B' 2' "Base Line Skip "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X1C' 2' "Line Space "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X1D' 2' "Par Indent "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X1E' 2' "Par Skip "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X1F' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X20' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X21' 2' "top margin in dots"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X22' 2' "header height in dots"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X23' 2' "header separation in dots"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X24' 2' "left margin in dots"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X25' 2' "Page Height "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X26' 2' "Page Width "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X27' 2' "footer space in dots"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X28' 2' "footer height in dots"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X29' 6' "background image reference"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X2A' 2' "show or hide"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X2B' 2' "high or low"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X2C' 2' "even-side margin"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X2D' 4' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X2E' 2' "block attributes"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X2F' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X30' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X31' 2' "Block Width "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X32' 2' "Block Height "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X33' 2' "Block Rule "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X34' 4' "block background color in RGBA"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X35' 2' "block layout mode"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X36' 2' "frame width in dots"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X37' 4' "frame color in RGBA"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X38' 2' "frame mode"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X39' 2' "top skip in dots"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X3A' 2' "side margin in dots"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X3B' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X3C' 2' "alignment"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X3D' 2' "foot skip in dots"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X3E' 2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X3F' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X40' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X41' 2' "Mini Page Height "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X42' 2' "Mini Page Width "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X43' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X44' 4' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X45' 4' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X46' 2' "Location Y "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X47' 2' "Location X "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X48' 2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X49' 8' "Put Sound "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X4A' 8' "Image Rect "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X4B' 4' "Image Size "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X4C' 4' "Image Stream "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X4E' 12' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X4F' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X50' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X51' 2' "Canvas Width "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X52' 2' "Canvas Height "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X53' 4' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X54' 2' "Stream Flags "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X57' 2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X58' 2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X5B' 2' "View Point "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X5E' 2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X5F' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X60' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X61' 2' "button flags"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X6C' 8' "Jump To "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X6F' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X70' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X73' 10' "Ruled Line "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X74' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X75' 2' "Ruby Align "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X76' 2' "Ruby Overhang "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X77' 2' "Emp Dots Position "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X78' 4' "Emp Dots Code "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X79' 2' "Emp Line Position "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X7A' 2' "Emp Line Mode "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X7B' 4' "Child Page Tree "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X7C' 4' "Parent Page Tree "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X7D' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X7E' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X7F' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X80' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X83' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X84' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X85' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X86' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X87' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X88' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X89' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X8A' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X8B' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X8C' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X8D' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X8E' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X8F' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X90' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X91' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X92' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X93' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X94' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X95' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X96' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X97' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X98' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X99' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X9A' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X9B' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X9C' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X9D' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X9E' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0X9F' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XA0' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XA1' 4' "Begin P "' "<P>"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XA3' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XA4' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XA7' 4' "Begin Button "' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XA8' 2' "End Button "' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XA9' 2' "Begin Ruby "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XAA' 2' "End Ruby "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XAB' 2' "Begin Ruby Base "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XAC' 2' "End Ruby Base "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XAD' 2' "Begin Ruby Text "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XAE' 2' "End Ruby Text "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XAF' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XB0' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XB1' 2' "Koma Yokomoji "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XB2' 2' "end yokomoji"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XB3' 2' "Tate "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XB4' 2' "Tate "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XB5' 2' "Nekase "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XB6' 2' "Nekase "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XB7' 2' "Begin Sup "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XB8' 2' "End Sup "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XB9' 2' "Begin Sub "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XBA' 2' "End Sub "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XBB' 2' "start bold"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XBC' 2' "end bold"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XBD' 2' "start no-break"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XBE' 2' "end no-break"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XBF' -2' "start emphasis box"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XC0' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XC1' 2' "Begin emphasis Line "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XC3' 2' "Begin Draw Char "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XC5' 2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XC6' 2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XC8' 2' "Koma Auto Spacing "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XCA' 2' "Space "' "&nbsp;"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XCC' 2' "Unicode string"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XCD' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XCE' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XCF' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XD0' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XD3' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XD4' 2' "Wait "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XD5' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XD7' 14' "Move Obj "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XD8' 4' "Book Font "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XD9' 8' "Koma Plot Text "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XDA' 2' "Wait sound"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XDB' 2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XDC' 2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XDD' 2' "Char Space "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XDE' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XDF' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XE0' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XE1' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XE2' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XE3' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XE4' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XE5' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XE6' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XE7' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XE8' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XE9' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XEA' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XEB' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XEC' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XED' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XEE' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XEF' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XF0' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XF1' 2' "Line Width "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XF2' 4' "Line Color "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XF3' 4' "Fill Color "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XF4' 2' "Line Mode "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XF5' 4' "Move To "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XF6' 4' "Line To "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XF7' 4' "Draw Box "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XF8' 4' "Draw Ellipse "));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XF9' 6' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XFA' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XFB' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XFC' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XFD' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XFE' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,FillTagList,The following statement contains a magic number: TagTypes.Add (new TagType (0XFF' -2' "Unknown"));  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: for (int u = 0; u < (ushort)pageTreeObject.LrfTags [1].Ids_Number.Value; u++) {  	#region read one page  	LrfObject page = listLrfObjects [(uint)pageTreeObject.LrfTags [1].Content_Ids [u].Value];  	pageTreeObject.AddSon (page);  	//lrfTags[1] : list of related index' block' text' attributes ...  	#region get all objects  	for (int i = 0; i < (ushort)page.LrfTags [1].Ids_Number.Value; i++) {  		try {  			ELEMENTARY_TYPE pageref = page.LrfTags [1].Content_Ids [i];  			LrfObject obj = listLrfObjects [(uint)pageref.Value];  			//               page.AddSon(obj);  			if ((int)obj.ObjType == 0x0C) {  				#region find Images  				if (images == null)  					images = new List<LrfObject> ();  				uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  				// two short : height' width  				LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  				uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  				// ReadUint((byte[])image.LrfTags[3].Data.Value);  				if (code == 0xE0FFD8FF) {  					try {  						MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  						//JPEG image  						obj.Image = Image.FromStream (imageStream);  						images.Add (obj);  						imageStream.Close ();  					}  					catch {  					}  				}  				#endregion  			}  		}  		catch {  		}  	}  	#endregion  	//lrfTags[2] : link contains Bloc attribute  	try {  		page.Attribute = listLrfObjects [(uint)page.LrfTags [2].Data.Value];  	}  	catch {  	}  	foreach (ELEMENTARY_TYPE uref in page.LrfTags [1].Content_Ids) {  		//       page.AddSon(listLrfObjects[(uint)uref.Value]);  	}  	foreach (LRFTag tag in page.Others) {  		switch (((byte[])tag.F500.Value) [0]) {  		case 0x03:  			//Link  			LrfObject ob = listLrfObjects [(uint)tag.Data.Value];  			page.AddSon (ob);  			switch (ob.ObjType) {  			case LrfObjectType.Canvas:  				#region Add canvas  				//        Canvas c = new Canvas(ob);  				//        page.AddSon(c);  				break;  			#endregion  			case LrfObjectType.Block:  				#region Add block  				foreach (LRFTag tago in ob.Others) {  					LrfObject tx = listLrfObjects [(uint)tago.Data.Value];  					ob.AddSon (tx);  					tx.Attribute = listLrfObjects [(uint)tx.LrfTags [1].Data.Value];  				}  				ob.Attribute = listLrfObjects [(uint)ob.LrfTags [1].Data.Value];  				break;  			#endregion  			default:  				break;  			}  			break;  		case 0x73:  			//Ruled line  			break;  		default:  			try {  				ob = listLrfObjects [(uint)tag.Data.Value];  				page.AddSon (ob);  			}  			catch {  			}  			;  			break;  		}  	}  	#endregion  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: for (int u = 0; u < (ushort)pageTreeObject.LrfTags [1].Ids_Number.Value; u++) {  	#region read one page  	LrfObject page = listLrfObjects [(uint)pageTreeObject.LrfTags [1].Content_Ids [u].Value];  	pageTreeObject.AddSon (page);  	//lrfTags[1] : list of related index' block' text' attributes ...  	#region get all objects  	for (int i = 0; i < (ushort)page.LrfTags [1].Ids_Number.Value; i++) {  		try {  			ELEMENTARY_TYPE pageref = page.LrfTags [1].Content_Ids [i];  			LrfObject obj = listLrfObjects [(uint)pageref.Value];  			//               page.AddSon(obj);  			if ((int)obj.ObjType == 0x0C) {  				#region find Images  				if (images == null)  					images = new List<LrfObject> ();  				uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  				// two short : height' width  				LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  				uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  				// ReadUint((byte[])image.LrfTags[3].Data.Value);  				if (code == 0xE0FFD8FF) {  					try {  						MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  						//JPEG image  						obj.Image = Image.FromStream (imageStream);  						images.Add (obj);  						imageStream.Close ();  					}  					catch {  					}  				}  				#endregion  			}  		}  		catch {  		}  	}  	#endregion  	//lrfTags[2] : link contains Bloc attribute  	try {  		page.Attribute = listLrfObjects [(uint)page.LrfTags [2].Data.Value];  	}  	catch {  	}  	foreach (ELEMENTARY_TYPE uref in page.LrfTags [1].Content_Ids) {  		//       page.AddSon(listLrfObjects[(uint)uref.Value]);  	}  	foreach (LRFTag tag in page.Others) {  		switch (((byte[])tag.F500.Value) [0]) {  		case 0x03:  			//Link  			LrfObject ob = listLrfObjects [(uint)tag.Data.Value];  			page.AddSon (ob);  			switch (ob.ObjType) {  			case LrfObjectType.Canvas:  				#region Add canvas  				//        Canvas c = new Canvas(ob);  				//        page.AddSon(c);  				break;  			#endregion  			case LrfObjectType.Block:  				#region Add block  				foreach (LRFTag tago in ob.Others) {  					LrfObject tx = listLrfObjects [(uint)tago.Data.Value];  					ob.AddSon (tx);  					tx.Attribute = listLrfObjects [(uint)tx.LrfTags [1].Data.Value];  				}  				ob.Attribute = listLrfObjects [(uint)ob.LrfTags [1].Data.Value];  				break;  			#endregion  			default:  				break;  			}  			break;  		case 0x73:  			//Ruled line  			break;  		default:  			try {  				ob = listLrfObjects [(uint)tag.Data.Value];  				page.AddSon (ob);  			}  			catch {  			}  			;  			break;  		}  	}  	#endregion  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: for (int u = 0; u < (ushort)pageTreeObject.LrfTags [1].Ids_Number.Value; u++) {  	#region read one page  	LrfObject page = listLrfObjects [(uint)pageTreeObject.LrfTags [1].Content_Ids [u].Value];  	pageTreeObject.AddSon (page);  	//lrfTags[1] : list of related index' block' text' attributes ...  	#region get all objects  	for (int i = 0; i < (ushort)page.LrfTags [1].Ids_Number.Value; i++) {  		try {  			ELEMENTARY_TYPE pageref = page.LrfTags [1].Content_Ids [i];  			LrfObject obj = listLrfObjects [(uint)pageref.Value];  			//               page.AddSon(obj);  			if ((int)obj.ObjType == 0x0C) {  				#region find Images  				if (images == null)  					images = new List<LrfObject> ();  				uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  				// two short : height' width  				LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  				uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  				// ReadUint((byte[])image.LrfTags[3].Data.Value);  				if (code == 0xE0FFD8FF) {  					try {  						MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  						//JPEG image  						obj.Image = Image.FromStream (imageStream);  						images.Add (obj);  						imageStream.Close ();  					}  					catch {  					}  				}  				#endregion  			}  		}  		catch {  		}  	}  	#endregion  	//lrfTags[2] : link contains Bloc attribute  	try {  		page.Attribute = listLrfObjects [(uint)page.LrfTags [2].Data.Value];  	}  	catch {  	}  	foreach (ELEMENTARY_TYPE uref in page.LrfTags [1].Content_Ids) {  		//       page.AddSon(listLrfObjects[(uint)uref.Value]);  	}  	foreach (LRFTag tag in page.Others) {  		switch (((byte[])tag.F500.Value) [0]) {  		case 0x03:  			//Link  			LrfObject ob = listLrfObjects [(uint)tag.Data.Value];  			page.AddSon (ob);  			switch (ob.ObjType) {  			case LrfObjectType.Canvas:  				#region Add canvas  				//        Canvas c = new Canvas(ob);  				//        page.AddSon(c);  				break;  			#endregion  			case LrfObjectType.Block:  				#region Add block  				foreach (LRFTag tago in ob.Others) {  					LrfObject tx = listLrfObjects [(uint)tago.Data.Value];  					ob.AddSon (tx);  					tx.Attribute = listLrfObjects [(uint)tx.LrfTags [1].Data.Value];  				}  				ob.Attribute = listLrfObjects [(uint)ob.LrfTags [1].Data.Value];  				break;  			#endregion  			default:  				break;  			}  			break;  		case 0x73:  			//Ruled line  			break;  		default:  			try {  				ob = listLrfObjects [(uint)tag.Data.Value];  				page.AddSon (ob);  			}  			catch {  			}  			;  			break;  		}  	}  	#endregion  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: for (int u = 0; u < (ushort)pageTreeObject.LrfTags [1].Ids_Number.Value; u++) {  	#region read one page  	LrfObject page = listLrfObjects [(uint)pageTreeObject.LrfTags [1].Content_Ids [u].Value];  	pageTreeObject.AddSon (page);  	//lrfTags[1] : list of related index' block' text' attributes ...  	#region get all objects  	for (int i = 0; i < (ushort)page.LrfTags [1].Ids_Number.Value; i++) {  		try {  			ELEMENTARY_TYPE pageref = page.LrfTags [1].Content_Ids [i];  			LrfObject obj = listLrfObjects [(uint)pageref.Value];  			//               page.AddSon(obj);  			if ((int)obj.ObjType == 0x0C) {  				#region find Images  				if (images == null)  					images = new List<LrfObject> ();  				uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  				// two short : height' width  				LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  				uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  				// ReadUint((byte[])image.LrfTags[3].Data.Value);  				if (code == 0xE0FFD8FF) {  					try {  						MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  						//JPEG image  						obj.Image = Image.FromStream (imageStream);  						images.Add (obj);  						imageStream.Close ();  					}  					catch {  					}  				}  				#endregion  			}  		}  		catch {  		}  	}  	#endregion  	//lrfTags[2] : link contains Bloc attribute  	try {  		page.Attribute = listLrfObjects [(uint)page.LrfTags [2].Data.Value];  	}  	catch {  	}  	foreach (ELEMENTARY_TYPE uref in page.LrfTags [1].Content_Ids) {  		//       page.AddSon(listLrfObjects[(uint)uref.Value]);  	}  	foreach (LRFTag tag in page.Others) {  		switch (((byte[])tag.F500.Value) [0]) {  		case 0x03:  			//Link  			LrfObject ob = listLrfObjects [(uint)tag.Data.Value];  			page.AddSon (ob);  			switch (ob.ObjType) {  			case LrfObjectType.Canvas:  				#region Add canvas  				//        Canvas c = new Canvas(ob);  				//        page.AddSon(c);  				break;  			#endregion  			case LrfObjectType.Block:  				#region Add block  				foreach (LRFTag tago in ob.Others) {  					LrfObject tx = listLrfObjects [(uint)tago.Data.Value];  					ob.AddSon (tx);  					tx.Attribute = listLrfObjects [(uint)tx.LrfTags [1].Data.Value];  				}  				ob.Attribute = listLrfObjects [(uint)ob.LrfTags [1].Data.Value];  				break;  			#endregion  			default:  				break;  			}  			break;  		case 0x73:  			//Ruled line  			break;  		default:  			try {  				ob = listLrfObjects [(uint)tag.Data.Value];  				page.AddSon (ob);  			}  			catch {  			}  			;  			break;  		}  	}  	#endregion  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: for (int u = 0; u < (ushort)pageTreeObject.LrfTags [1].Ids_Number.Value; u++) {  	#region read one page  	LrfObject page = listLrfObjects [(uint)pageTreeObject.LrfTags [1].Content_Ids [u].Value];  	pageTreeObject.AddSon (page);  	//lrfTags[1] : list of related index' block' text' attributes ...  	#region get all objects  	for (int i = 0; i < (ushort)page.LrfTags [1].Ids_Number.Value; i++) {  		try {  			ELEMENTARY_TYPE pageref = page.LrfTags [1].Content_Ids [i];  			LrfObject obj = listLrfObjects [(uint)pageref.Value];  			//               page.AddSon(obj);  			if ((int)obj.ObjType == 0x0C) {  				#region find Images  				if (images == null)  					images = new List<LrfObject> ();  				uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  				// two short : height' width  				LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  				uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  				// ReadUint((byte[])image.LrfTags[3].Data.Value);  				if (code == 0xE0FFD8FF) {  					try {  						MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  						//JPEG image  						obj.Image = Image.FromStream (imageStream);  						images.Add (obj);  						imageStream.Close ();  					}  					catch {  					}  				}  				#endregion  			}  		}  		catch {  		}  	}  	#endregion  	//lrfTags[2] : link contains Bloc attribute  	try {  		page.Attribute = listLrfObjects [(uint)page.LrfTags [2].Data.Value];  	}  	catch {  	}  	foreach (ELEMENTARY_TYPE uref in page.LrfTags [1].Content_Ids) {  		//       page.AddSon(listLrfObjects[(uint)uref.Value]);  	}  	foreach (LRFTag tag in page.Others) {  		switch (((byte[])tag.F500.Value) [0]) {  		case 0x03:  			//Link  			LrfObject ob = listLrfObjects [(uint)tag.Data.Value];  			page.AddSon (ob);  			switch (ob.ObjType) {  			case LrfObjectType.Canvas:  				#region Add canvas  				//        Canvas c = new Canvas(ob);  				//        page.AddSon(c);  				break;  			#endregion  			case LrfObjectType.Block:  				#region Add block  				foreach (LRFTag tago in ob.Others) {  					LrfObject tx = listLrfObjects [(uint)tago.Data.Value];  					ob.AddSon (tx);  					tx.Attribute = listLrfObjects [(uint)tx.LrfTags [1].Data.Value];  				}  				ob.Attribute = listLrfObjects [(uint)ob.LrfTags [1].Data.Value];  				break;  			#endregion  			default:  				break;  			}  			break;  		case 0x73:  			//Ruled line  			break;  		default:  			try {  				ob = listLrfObjects [(uint)tag.Data.Value];  				page.AddSon (ob);  			}  			catch {  			}  			;  			break;  		}  	}  	#endregion  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: for (int i = 0; i < (ushort)page.LrfTags [1].Ids_Number.Value; i++) {  	try {  		ELEMENTARY_TYPE pageref = page.LrfTags [1].Content_Ids [i];  		LrfObject obj = listLrfObjects [(uint)pageref.Value];  		//               page.AddSon(obj);  		if ((int)obj.ObjType == 0x0C) {  			#region find Images  			if (images == null)  				images = new List<LrfObject> ();  			uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  			// two short : height' width  			LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  			uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  			// ReadUint((byte[])image.LrfTags[3].Data.Value);  			if (code == 0xE0FFD8FF) {  				try {  					MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  					//JPEG image  					obj.Image = Image.FromStream (imageStream);  					images.Add (obj);  					imageStream.Close ();  				}  				catch {  				}  			}  			#endregion  		}  	}  	catch {  	}  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: for (int i = 0; i < (ushort)page.LrfTags [1].Ids_Number.Value; i++) {  	try {  		ELEMENTARY_TYPE pageref = page.LrfTags [1].Content_Ids [i];  		LrfObject obj = listLrfObjects [(uint)pageref.Value];  		//               page.AddSon(obj);  		if ((int)obj.ObjType == 0x0C) {  			#region find Images  			if (images == null)  				images = new List<LrfObject> ();  			uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  			// two short : height' width  			LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  			uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  			// ReadUint((byte[])image.LrfTags[3].Data.Value);  			if (code == 0xE0FFD8FF) {  				try {  					MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  					//JPEG image  					obj.Image = Image.FromStream (imageStream);  					images.Add (obj);  					imageStream.Close ();  				}  				catch {  				}  			}  			#endregion  		}  	}  	catch {  	}  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: for (int i = 0; i < (ushort)page.LrfTags [1].Ids_Number.Value; i++) {  	try {  		ELEMENTARY_TYPE pageref = page.LrfTags [1].Content_Ids [i];  		LrfObject obj = listLrfObjects [(uint)pageref.Value];  		//               page.AddSon(obj);  		if ((int)obj.ObjType == 0x0C) {  			#region find Images  			if (images == null)  				images = new List<LrfObject> ();  			uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  			// two short : height' width  			LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  			uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  			// ReadUint((byte[])image.LrfTags[3].Data.Value);  			if (code == 0xE0FFD8FF) {  				try {  					MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  					//JPEG image  					obj.Image = Image.FromStream (imageStream);  					images.Add (obj);  					imageStream.Close ();  				}  				catch {  				}  			}  			#endregion  		}  	}  	catch {  	}  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: for (int i = 0; i < (ushort)page.LrfTags [1].Ids_Number.Value; i++) {  	try {  		ELEMENTARY_TYPE pageref = page.LrfTags [1].Content_Ids [i];  		LrfObject obj = listLrfObjects [(uint)pageref.Value];  		//               page.AddSon(obj);  		if ((int)obj.ObjType == 0x0C) {  			#region find Images  			if (images == null)  				images = new List<LrfObject> ();  			uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  			// two short : height' width  			LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  			uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  			// ReadUint((byte[])image.LrfTags[3].Data.Value);  			if (code == 0xE0FFD8FF) {  				try {  					MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  					//JPEG image  					obj.Image = Image.FromStream (imageStream);  					images.Add (obj);  					imageStream.Close ();  				}  				catch {  				}  			}  			#endregion  		}  	}  	catch {  	}  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: try {  	ELEMENTARY_TYPE pageref = page.LrfTags [1].Content_Ids [i];  	LrfObject obj = listLrfObjects [(uint)pageref.Value];  	//               page.AddSon(obj);  	if ((int)obj.ObjType == 0x0C) {  		#region find Images  		if (images == null)  			images = new List<LrfObject> ();  		uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  		// two short : height' width  		LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  		uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  		// ReadUint((byte[])image.LrfTags[3].Data.Value);  		if (code == 0xE0FFD8FF) {  			try {  				MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  				//JPEG image  				obj.Image = Image.FromStream (imageStream);  				images.Add (obj);  				imageStream.Close ();  			}  			catch {  			}  		}  		#endregion  	}  }  catch {  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: try {  	ELEMENTARY_TYPE pageref = page.LrfTags [1].Content_Ids [i];  	LrfObject obj = listLrfObjects [(uint)pageref.Value];  	//               page.AddSon(obj);  	if ((int)obj.ObjType == 0x0C) {  		#region find Images  		if (images == null)  			images = new List<LrfObject> ();  		uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  		// two short : height' width  		LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  		uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  		// ReadUint((byte[])image.LrfTags[3].Data.Value);  		if (code == 0xE0FFD8FF) {  			try {  				MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  				//JPEG image  				obj.Image = Image.FromStream (imageStream);  				images.Add (obj);  				imageStream.Close ();  			}  			catch {  			}  		}  		#endregion  	}  }  catch {  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: try {  	ELEMENTARY_TYPE pageref = page.LrfTags [1].Content_Ids [i];  	LrfObject obj = listLrfObjects [(uint)pageref.Value];  	//               page.AddSon(obj);  	if ((int)obj.ObjType == 0x0C) {  		#region find Images  		if (images == null)  			images = new List<LrfObject> ();  		uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  		// two short : height' width  		LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  		uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  		// ReadUint((byte[])image.LrfTags[3].Data.Value);  		if (code == 0xE0FFD8FF) {  			try {  				MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  				//JPEG image  				obj.Image = Image.FromStream (imageStream);  				images.Add (obj);  				imageStream.Close ();  			}  			catch {  			}  		}  		#endregion  	}  }  catch {  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: try {  	ELEMENTARY_TYPE pageref = page.LrfTags [1].Content_Ids [i];  	LrfObject obj = listLrfObjects [(uint)pageref.Value];  	//               page.AddSon(obj);  	if ((int)obj.ObjType == 0x0C) {  		#region find Images  		if (images == null)  			images = new List<LrfObject> ();  		uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  		// two short : height' width  		LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  		uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  		// ReadUint((byte[])image.LrfTags[3].Data.Value);  		if (code == 0xE0FFD8FF) {  			try {  				MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  				//JPEG image  				obj.Image = Image.FromStream (imageStream);  				images.Add (obj);  				imageStream.Close ();  			}  			catch {  			}  		}  		#endregion  	}  }  catch {  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: if ((int)obj.ObjType == 0x0C) {  	#region find Images  	if (images == null)  		images = new List<LrfObject> ();  	uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  	// two short : height' width  	LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  	uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  	// ReadUint((byte[])image.LrfTags[3].Data.Value);  	if (code == 0xE0FFD8FF) {  		try {  			MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  			//JPEG image  			obj.Image = Image.FromStream (imageStream);  			images.Add (obj);  			imageStream.Close ();  		}  		catch {  		}  	}  	#endregion  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: if ((int)obj.ObjType == 0x0C) {  	#region find Images  	if (images == null)  		images = new List<LrfObject> ();  	uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  	// two short : height' width  	LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  	uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  	// ReadUint((byte[])image.LrfTags[3].Data.Value);  	if (code == 0xE0FFD8FF) {  		try {  			MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  			//JPEG image  			obj.Image = Image.FromStream (imageStream);  			images.Add (obj);  			imageStream.Close ();  		}  		catch {  		}  	}  	#endregion  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: if ((int)obj.ObjType == 0x0C) {  	#region find Images  	if (images == null)  		images = new List<LrfObject> ();  	uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  	// two short : height' width  	LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  	uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  	// ReadUint((byte[])image.LrfTags[3].Data.Value);  	if (code == 0xE0FFD8FF) {  		try {  			MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  			//JPEG image  			obj.Image = Image.FromStream (imageStream);  			images.Add (obj);  			imageStream.Close ();  		}  		catch {  		}  	}  	#endregion  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: if ((int)obj.ObjType == 0x0C) {  	#region find Images  	if (images == null)  		images = new List<LrfObject> ();  	uint imageSize = (uint)obj.LrfTags [2].Image_Size.Value;  	// two short : height' width  	LrfObject image = listLrfObjects [(uint)obj.LrfTags [3].Image_Id.Value];  	uint code = BitConverter.ToUInt32 ((byte[])image.LrfTags [3].Data.Value' 0);  	// ReadUint((byte[])image.LrfTags[3].Data.Value);  	if (code == 0xE0FFD8FF) {  		try {  			MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  			//JPEG image  			obj.Image = Image.FromStream (imageStream);  			images.Add (obj);  			imageStream.Close ();  		}  		catch {  		}  	}  	#endregion  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: if (code == 0xE0FFD8FF) {  	try {  		MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  		//JPEG image  		obj.Image = Image.FromStream (imageStream);  		images.Add (obj);  		imageStream.Close ();  	}  	catch {  	}  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: try {  	MemoryStream imageStream = new MemoryStream ((byte[])image.LrfTags [3].Data.Value);  	//JPEG image  	obj.Image = Image.FromStream (imageStream);  	images.Add (obj);  	imageStream.Close ();  }  catch {  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: try {  	page.Attribute = listLrfObjects [(uint)page.LrfTags [2].Data.Value];  }  catch {  }  
Magic Number,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,Structure,The following statement contains a magic number: page.Attribute = listLrfObjects [(uint)page.LrfTags [2].Data.Value];  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,FindXrefAddress,The following statement contains a magic number: n -= 5;  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,FindObjectRef,The following statement contains a magic number: if (objOffset [2].IndexOf ("n") >= 0) {  	FS.Seek (offset' SeekOrigin.Begin);  	string number = ReadString ();  	objRef.Add (int.Parse (number)' offset);  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ReadObjDescription,The following statement contains a magic number: if (u == 4) {  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,Decompress,The following statement contains a magic number: if (pdf.Dictionnary.TryGetValue ("Filter"' out filter)) {  	if (filter.Contains ("[")) {  		filter.Replace ("["' "").Replace ("]"' "").Replace ("/"' "");  		string[] fil = filter.Split (' ');  		foreach (string s in fil) {  		}  	}  	switch (filter) {  	case "ASCIIHexDecode":  	case "ASCII85Decode":  	case "LZWDecode":  	case "RunLengthDecode":  		break;  	case "DCTDecode":  		break;  	case "CCITTFaxDecode":  		TIFFFaxDecoder Tf = new TIFFFaxDecoder (1' 0' 0);  		break;  	case "FlateDecode":  		try {  			byte[] b = new byte[buffer.Length * 3];  			Inflater i = new Inflater ();  			i.SetInput (buffer);  			i.Inflate (b);  			int x = i.TotalOut;  			byte[] bOut = new byte[i.TotalOut];  			Buffer.BlockCopy (b' 0' bOut' 0' i.TotalOut);  			UnicodeEncoding encoderU = new UnicodeEncoding ();  			pdf.RawData = encoderU.GetString (pdf.RawStreamData);  			return bOut;  		}  		catch {  			return null;  		}  	default:  		pdf.RawData = encoder.GetString (pdf.RawStreamData);  		return buffer;  	}  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,Decompress,The following statement contains a magic number: switch (filter) {  case "ASCIIHexDecode":  case "ASCII85Decode":  case "LZWDecode":  case "RunLengthDecode":  	break;  case "DCTDecode":  	break;  case "CCITTFaxDecode":  	TIFFFaxDecoder Tf = new TIFFFaxDecoder (1' 0' 0);  	break;  case "FlateDecode":  	try {  		byte[] b = new byte[buffer.Length * 3];  		Inflater i = new Inflater ();  		i.SetInput (buffer);  		i.Inflate (b);  		int x = i.TotalOut;  		byte[] bOut = new byte[i.TotalOut];  		Buffer.BlockCopy (b' 0' bOut' 0' i.TotalOut);  		UnicodeEncoding encoderU = new UnicodeEncoding ();  		pdf.RawData = encoderU.GetString (pdf.RawStreamData);  		return bOut;  	}  	catch {  		return null;  	}  default:  	pdf.RawData = encoder.GetString (pdf.RawStreamData);  	return buffer;  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,Decompress,The following statement contains a magic number: try {  	byte[] b = new byte[buffer.Length * 3];  	Inflater i = new Inflater ();  	i.SetInput (buffer);  	i.Inflate (b);  	int x = i.TotalOut;  	byte[] bOut = new byte[i.TotalOut];  	Buffer.BlockCopy (b' 0' bOut' 0' i.TotalOut);  	UnicodeEncoding encoderU = new UnicodeEncoding ();  	pdf.RawData = encoderU.GetString (pdf.RawStreamData);  	return bOut;  }  catch {  	return null;  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: foreach (KeyValuePair<string' string> kvp in pf.Dictionnary) {  	#region Dictionnary  	if (!kvp.Key.Contains ("Parent") && !kvp.Key.Contains ("Prev") && kvp.Value.Contains (" R")) {  		try {  			string[] n = kvp.Value.Replace ("["' "").Replace ("]"' "").Trim ().Split (' ');  			int lev = Array.IndexOf (n' "R"' 0);  			while ((lev >= 0) && (lev < n.Length)) {  				int num = -1;  				if (lev >= 2)  					num = int.Parse (n [lev - 2]);  				if (num >= 0) {  					PdfObject pdf;  					if (!objects.TryGetValue (num' out pdf))  						pdf = ReadObjDescription (num);  					if (pdf != null) {  						if (pdf.ObjectType == null)  							pdf.ObjectType += kvp.Key;  						pf.AddAttribute (pdf);  						switch (kvp.Key) {  						case "D":  							break;  						case "A":  							break;  						case "Limits":  						case "Outlines":  						case "Next":  						case "First":  							//      ParseDicRec(pdf);  							break;  						case "Last":  							break;  						case "Annots":  							string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  							int i = 0;  							while (i < pages.Length) {  								PdfObject ann;  								if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  									ann = ReadObjDescription (int.Parse (pages [i]));  								i += 3;  								if (ann != null)  									pdf.AddAttribute (ann);  							}  							break;  						case "Contents":  							switch (pf.ObjectType) {  							case "Page":  								if (pf.RawStreamData == null)  									pf.RawStreamData = pdf.RawStreamData;  								else {  									byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  									Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  									Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  									pdf.StreamData = buf;  								}  								Encoding enc = Encoding.Default;  								pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  								break;  							}  							break;  						default:  							if (pdf != null) {  								switch (pf.ObjectType) {  								case "Page":  									Encoding enc = Encoding.Default;  									if (pdf.StreamData != null)  										pdf.DecodedStream = enc.GetString (pdf.StreamData);  									break;  								case "Metadata":  									pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  									break;  								case "FontDescriptor":  									break;  								}  							}  							break;  						}  					}  				}  				lev = Array.IndexOf (n' "R"' lev + 1);  			}  		}  		catch (Exception e) {  			Trace.WriteLine (e.Message);  		}  	}  	#endregion  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: foreach (KeyValuePair<string' string> kvp in pf.Dictionnary) {  	#region Dictionnary  	if (!kvp.Key.Contains ("Parent") && !kvp.Key.Contains ("Prev") && kvp.Value.Contains (" R")) {  		try {  			string[] n = kvp.Value.Replace ("["' "").Replace ("]"' "").Trim ().Split (' ');  			int lev = Array.IndexOf (n' "R"' 0);  			while ((lev >= 0) && (lev < n.Length)) {  				int num = -1;  				if (lev >= 2)  					num = int.Parse (n [lev - 2]);  				if (num >= 0) {  					PdfObject pdf;  					if (!objects.TryGetValue (num' out pdf))  						pdf = ReadObjDescription (num);  					if (pdf != null) {  						if (pdf.ObjectType == null)  							pdf.ObjectType += kvp.Key;  						pf.AddAttribute (pdf);  						switch (kvp.Key) {  						case "D":  							break;  						case "A":  							break;  						case "Limits":  						case "Outlines":  						case "Next":  						case "First":  							//      ParseDicRec(pdf);  							break;  						case "Last":  							break;  						case "Annots":  							string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  							int i = 0;  							while (i < pages.Length) {  								PdfObject ann;  								if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  									ann = ReadObjDescription (int.Parse (pages [i]));  								i += 3;  								if (ann != null)  									pdf.AddAttribute (ann);  							}  							break;  						case "Contents":  							switch (pf.ObjectType) {  							case "Page":  								if (pf.RawStreamData == null)  									pf.RawStreamData = pdf.RawStreamData;  								else {  									byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  									Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  									Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  									pdf.StreamData = buf;  								}  								Encoding enc = Encoding.Default;  								pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  								break;  							}  							break;  						default:  							if (pdf != null) {  								switch (pf.ObjectType) {  								case "Page":  									Encoding enc = Encoding.Default;  									if (pdf.StreamData != null)  										pdf.DecodedStream = enc.GetString (pdf.StreamData);  									break;  								case "Metadata":  									pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  									break;  								case "FontDescriptor":  									break;  								}  							}  							break;  						}  					}  				}  				lev = Array.IndexOf (n' "R"' lev + 1);  			}  		}  		catch (Exception e) {  			Trace.WriteLine (e.Message);  		}  	}  	#endregion  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: foreach (KeyValuePair<string' string> kvp in pf.Dictionnary) {  	#region Dictionnary  	if (!kvp.Key.Contains ("Parent") && !kvp.Key.Contains ("Prev") && kvp.Value.Contains (" R")) {  		try {  			string[] n = kvp.Value.Replace ("["' "").Replace ("]"' "").Trim ().Split (' ');  			int lev = Array.IndexOf (n' "R"' 0);  			while ((lev >= 0) && (lev < n.Length)) {  				int num = -1;  				if (lev >= 2)  					num = int.Parse (n [lev - 2]);  				if (num >= 0) {  					PdfObject pdf;  					if (!objects.TryGetValue (num' out pdf))  						pdf = ReadObjDescription (num);  					if (pdf != null) {  						if (pdf.ObjectType == null)  							pdf.ObjectType += kvp.Key;  						pf.AddAttribute (pdf);  						switch (kvp.Key) {  						case "D":  							break;  						case "A":  							break;  						case "Limits":  						case "Outlines":  						case "Next":  						case "First":  							//      ParseDicRec(pdf);  							break;  						case "Last":  							break;  						case "Annots":  							string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  							int i = 0;  							while (i < pages.Length) {  								PdfObject ann;  								if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  									ann = ReadObjDescription (int.Parse (pages [i]));  								i += 3;  								if (ann != null)  									pdf.AddAttribute (ann);  							}  							break;  						case "Contents":  							switch (pf.ObjectType) {  							case "Page":  								if (pf.RawStreamData == null)  									pf.RawStreamData = pdf.RawStreamData;  								else {  									byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  									Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  									Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  									pdf.StreamData = buf;  								}  								Encoding enc = Encoding.Default;  								pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  								break;  							}  							break;  						default:  							if (pdf != null) {  								switch (pf.ObjectType) {  								case "Page":  									Encoding enc = Encoding.Default;  									if (pdf.StreamData != null)  										pdf.DecodedStream = enc.GetString (pdf.StreamData);  									break;  								case "Metadata":  									pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  									break;  								case "FontDescriptor":  									break;  								}  							}  							break;  						}  					}  				}  				lev = Array.IndexOf (n' "R"' lev + 1);  			}  		}  		catch (Exception e) {  			Trace.WriteLine (e.Message);  		}  	}  	#endregion  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: if (!kvp.Key.Contains ("Parent") && !kvp.Key.Contains ("Prev") && kvp.Value.Contains (" R")) {  	try {  		string[] n = kvp.Value.Replace ("["' "").Replace ("]"' "").Trim ().Split (' ');  		int lev = Array.IndexOf (n' "R"' 0);  		while ((lev >= 0) && (lev < n.Length)) {  			int num = -1;  			if (lev >= 2)  				num = int.Parse (n [lev - 2]);  			if (num >= 0) {  				PdfObject pdf;  				if (!objects.TryGetValue (num' out pdf))  					pdf = ReadObjDescription (num);  				if (pdf != null) {  					if (pdf.ObjectType == null)  						pdf.ObjectType += kvp.Key;  					pf.AddAttribute (pdf);  					switch (kvp.Key) {  					case "D":  						break;  					case "A":  						break;  					case "Limits":  					case "Outlines":  					case "Next":  					case "First":  						//      ParseDicRec(pdf);  						break;  					case "Last":  						break;  					case "Annots":  						string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  						int i = 0;  						while (i < pages.Length) {  							PdfObject ann;  							if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  								ann = ReadObjDescription (int.Parse (pages [i]));  							i += 3;  							if (ann != null)  								pdf.AddAttribute (ann);  						}  						break;  					case "Contents":  						switch (pf.ObjectType) {  						case "Page":  							if (pf.RawStreamData == null)  								pf.RawStreamData = pdf.RawStreamData;  							else {  								byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  								Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  								Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  								pdf.StreamData = buf;  							}  							Encoding enc = Encoding.Default;  							pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  							break;  						}  						break;  					default:  						if (pdf != null) {  							switch (pf.ObjectType) {  							case "Page":  								Encoding enc = Encoding.Default;  								if (pdf.StreamData != null)  									pdf.DecodedStream = enc.GetString (pdf.StreamData);  								break;  							case "Metadata":  								pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  								break;  							case "FontDescriptor":  								break;  							}  						}  						break;  					}  				}  			}  			lev = Array.IndexOf (n' "R"' lev + 1);  		}  	}  	catch (Exception e) {  		Trace.WriteLine (e.Message);  	}  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: if (!kvp.Key.Contains ("Parent") && !kvp.Key.Contains ("Prev") && kvp.Value.Contains (" R")) {  	try {  		string[] n = kvp.Value.Replace ("["' "").Replace ("]"' "").Trim ().Split (' ');  		int lev = Array.IndexOf (n' "R"' 0);  		while ((lev >= 0) && (lev < n.Length)) {  			int num = -1;  			if (lev >= 2)  				num = int.Parse (n [lev - 2]);  			if (num >= 0) {  				PdfObject pdf;  				if (!objects.TryGetValue (num' out pdf))  					pdf = ReadObjDescription (num);  				if (pdf != null) {  					if (pdf.ObjectType == null)  						pdf.ObjectType += kvp.Key;  					pf.AddAttribute (pdf);  					switch (kvp.Key) {  					case "D":  						break;  					case "A":  						break;  					case "Limits":  					case "Outlines":  					case "Next":  					case "First":  						//      ParseDicRec(pdf);  						break;  					case "Last":  						break;  					case "Annots":  						string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  						int i = 0;  						while (i < pages.Length) {  							PdfObject ann;  							if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  								ann = ReadObjDescription (int.Parse (pages [i]));  							i += 3;  							if (ann != null)  								pdf.AddAttribute (ann);  						}  						break;  					case "Contents":  						switch (pf.ObjectType) {  						case "Page":  							if (pf.RawStreamData == null)  								pf.RawStreamData = pdf.RawStreamData;  							else {  								byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  								Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  								Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  								pdf.StreamData = buf;  							}  							Encoding enc = Encoding.Default;  							pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  							break;  						}  						break;  					default:  						if (pdf != null) {  							switch (pf.ObjectType) {  							case "Page":  								Encoding enc = Encoding.Default;  								if (pdf.StreamData != null)  									pdf.DecodedStream = enc.GetString (pdf.StreamData);  								break;  							case "Metadata":  								pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  								break;  							case "FontDescriptor":  								break;  							}  						}  						break;  					}  				}  			}  			lev = Array.IndexOf (n' "R"' lev + 1);  		}  	}  	catch (Exception e) {  		Trace.WriteLine (e.Message);  	}  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: if (!kvp.Key.Contains ("Parent") && !kvp.Key.Contains ("Prev") && kvp.Value.Contains (" R")) {  	try {  		string[] n = kvp.Value.Replace ("["' "").Replace ("]"' "").Trim ().Split (' ');  		int lev = Array.IndexOf (n' "R"' 0);  		while ((lev >= 0) && (lev < n.Length)) {  			int num = -1;  			if (lev >= 2)  				num = int.Parse (n [lev - 2]);  			if (num >= 0) {  				PdfObject pdf;  				if (!objects.TryGetValue (num' out pdf))  					pdf = ReadObjDescription (num);  				if (pdf != null) {  					if (pdf.ObjectType == null)  						pdf.ObjectType += kvp.Key;  					pf.AddAttribute (pdf);  					switch (kvp.Key) {  					case "D":  						break;  					case "A":  						break;  					case "Limits":  					case "Outlines":  					case "Next":  					case "First":  						//      ParseDicRec(pdf);  						break;  					case "Last":  						break;  					case "Annots":  						string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  						int i = 0;  						while (i < pages.Length) {  							PdfObject ann;  							if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  								ann = ReadObjDescription (int.Parse (pages [i]));  							i += 3;  							if (ann != null)  								pdf.AddAttribute (ann);  						}  						break;  					case "Contents":  						switch (pf.ObjectType) {  						case "Page":  							if (pf.RawStreamData == null)  								pf.RawStreamData = pdf.RawStreamData;  							else {  								byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  								Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  								Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  								pdf.StreamData = buf;  							}  							Encoding enc = Encoding.Default;  							pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  							break;  						}  						break;  					default:  						if (pdf != null) {  							switch (pf.ObjectType) {  							case "Page":  								Encoding enc = Encoding.Default;  								if (pdf.StreamData != null)  									pdf.DecodedStream = enc.GetString (pdf.StreamData);  								break;  							case "Metadata":  								pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  								break;  							case "FontDescriptor":  								break;  							}  						}  						break;  					}  				}  			}  			lev = Array.IndexOf (n' "R"' lev + 1);  		}  	}  	catch (Exception e) {  		Trace.WriteLine (e.Message);  	}  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: try {  	string[] n = kvp.Value.Replace ("["' "").Replace ("]"' "").Trim ().Split (' ');  	int lev = Array.IndexOf (n' "R"' 0);  	while ((lev >= 0) && (lev < n.Length)) {  		int num = -1;  		if (lev >= 2)  			num = int.Parse (n [lev - 2]);  		if (num >= 0) {  			PdfObject pdf;  			if (!objects.TryGetValue (num' out pdf))  				pdf = ReadObjDescription (num);  			if (pdf != null) {  				if (pdf.ObjectType == null)  					pdf.ObjectType += kvp.Key;  				pf.AddAttribute (pdf);  				switch (kvp.Key) {  				case "D":  					break;  				case "A":  					break;  				case "Limits":  				case "Outlines":  				case "Next":  				case "First":  					//      ParseDicRec(pdf);  					break;  				case "Last":  					break;  				case "Annots":  					string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  					int i = 0;  					while (i < pages.Length) {  						PdfObject ann;  						if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  							ann = ReadObjDescription (int.Parse (pages [i]));  						i += 3;  						if (ann != null)  							pdf.AddAttribute (ann);  					}  					break;  				case "Contents":  					switch (pf.ObjectType) {  					case "Page":  						if (pf.RawStreamData == null)  							pf.RawStreamData = pdf.RawStreamData;  						else {  							byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  							Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  							Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  							pdf.StreamData = buf;  						}  						Encoding enc = Encoding.Default;  						pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  						break;  					}  					break;  				default:  					if (pdf != null) {  						switch (pf.ObjectType) {  						case "Page":  							Encoding enc = Encoding.Default;  							if (pdf.StreamData != null)  								pdf.DecodedStream = enc.GetString (pdf.StreamData);  							break;  						case "Metadata":  							pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  							break;  						case "FontDescriptor":  							break;  						}  					}  					break;  				}  			}  		}  		lev = Array.IndexOf (n' "R"' lev + 1);  	}  }  catch (Exception e) {  	Trace.WriteLine (e.Message);  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: try {  	string[] n = kvp.Value.Replace ("["' "").Replace ("]"' "").Trim ().Split (' ');  	int lev = Array.IndexOf (n' "R"' 0);  	while ((lev >= 0) && (lev < n.Length)) {  		int num = -1;  		if (lev >= 2)  			num = int.Parse (n [lev - 2]);  		if (num >= 0) {  			PdfObject pdf;  			if (!objects.TryGetValue (num' out pdf))  				pdf = ReadObjDescription (num);  			if (pdf != null) {  				if (pdf.ObjectType == null)  					pdf.ObjectType += kvp.Key;  				pf.AddAttribute (pdf);  				switch (kvp.Key) {  				case "D":  					break;  				case "A":  					break;  				case "Limits":  				case "Outlines":  				case "Next":  				case "First":  					//      ParseDicRec(pdf);  					break;  				case "Last":  					break;  				case "Annots":  					string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  					int i = 0;  					while (i < pages.Length) {  						PdfObject ann;  						if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  							ann = ReadObjDescription (int.Parse (pages [i]));  						i += 3;  						if (ann != null)  							pdf.AddAttribute (ann);  					}  					break;  				case "Contents":  					switch (pf.ObjectType) {  					case "Page":  						if (pf.RawStreamData == null)  							pf.RawStreamData = pdf.RawStreamData;  						else {  							byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  							Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  							Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  							pdf.StreamData = buf;  						}  						Encoding enc = Encoding.Default;  						pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  						break;  					}  					break;  				default:  					if (pdf != null) {  						switch (pf.ObjectType) {  						case "Page":  							Encoding enc = Encoding.Default;  							if (pdf.StreamData != null)  								pdf.DecodedStream = enc.GetString (pdf.StreamData);  							break;  						case "Metadata":  							pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  							break;  						case "FontDescriptor":  							break;  						}  					}  					break;  				}  			}  		}  		lev = Array.IndexOf (n' "R"' lev + 1);  	}  }  catch (Exception e) {  	Trace.WriteLine (e.Message);  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: try {  	string[] n = kvp.Value.Replace ("["' "").Replace ("]"' "").Trim ().Split (' ');  	int lev = Array.IndexOf (n' "R"' 0);  	while ((lev >= 0) && (lev < n.Length)) {  		int num = -1;  		if (lev >= 2)  			num = int.Parse (n [lev - 2]);  		if (num >= 0) {  			PdfObject pdf;  			if (!objects.TryGetValue (num' out pdf))  				pdf = ReadObjDescription (num);  			if (pdf != null) {  				if (pdf.ObjectType == null)  					pdf.ObjectType += kvp.Key;  				pf.AddAttribute (pdf);  				switch (kvp.Key) {  				case "D":  					break;  				case "A":  					break;  				case "Limits":  				case "Outlines":  				case "Next":  				case "First":  					//      ParseDicRec(pdf);  					break;  				case "Last":  					break;  				case "Annots":  					string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  					int i = 0;  					while (i < pages.Length) {  						PdfObject ann;  						if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  							ann = ReadObjDescription (int.Parse (pages [i]));  						i += 3;  						if (ann != null)  							pdf.AddAttribute (ann);  					}  					break;  				case "Contents":  					switch (pf.ObjectType) {  					case "Page":  						if (pf.RawStreamData == null)  							pf.RawStreamData = pdf.RawStreamData;  						else {  							byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  							Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  							Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  							pdf.StreamData = buf;  						}  						Encoding enc = Encoding.Default;  						pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  						break;  					}  					break;  				default:  					if (pdf != null) {  						switch (pf.ObjectType) {  						case "Page":  							Encoding enc = Encoding.Default;  							if (pdf.StreamData != null)  								pdf.DecodedStream = enc.GetString (pdf.StreamData);  							break;  						case "Metadata":  							pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  							break;  						case "FontDescriptor":  							break;  						}  					}  					break;  				}  			}  		}  		lev = Array.IndexOf (n' "R"' lev + 1);  	}  }  catch (Exception e) {  	Trace.WriteLine (e.Message);  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: while ((lev >= 0) && (lev < n.Length)) {  	int num = -1;  	if (lev >= 2)  		num = int.Parse (n [lev - 2]);  	if (num >= 0) {  		PdfObject pdf;  		if (!objects.TryGetValue (num' out pdf))  			pdf = ReadObjDescription (num);  		if (pdf != null) {  			if (pdf.ObjectType == null)  				pdf.ObjectType += kvp.Key;  			pf.AddAttribute (pdf);  			switch (kvp.Key) {  			case "D":  				break;  			case "A":  				break;  			case "Limits":  			case "Outlines":  			case "Next":  			case "First":  				//      ParseDicRec(pdf);  				break;  			case "Last":  				break;  			case "Annots":  				string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  				int i = 0;  				while (i < pages.Length) {  					PdfObject ann;  					if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  						ann = ReadObjDescription (int.Parse (pages [i]));  					i += 3;  					if (ann != null)  						pdf.AddAttribute (ann);  				}  				break;  			case "Contents":  				switch (pf.ObjectType) {  				case "Page":  					if (pf.RawStreamData == null)  						pf.RawStreamData = pdf.RawStreamData;  					else {  						byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  						Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  						Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  						pdf.StreamData = buf;  					}  					Encoding enc = Encoding.Default;  					pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  					break;  				}  				break;  			default:  				if (pdf != null) {  					switch (pf.ObjectType) {  					case "Page":  						Encoding enc = Encoding.Default;  						if (pdf.StreamData != null)  							pdf.DecodedStream = enc.GetString (pdf.StreamData);  						break;  					case "Metadata":  						pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  						break;  					case "FontDescriptor":  						break;  					}  				}  				break;  			}  		}  	}  	lev = Array.IndexOf (n' "R"' lev + 1);  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: while ((lev >= 0) && (lev < n.Length)) {  	int num = -1;  	if (lev >= 2)  		num = int.Parse (n [lev - 2]);  	if (num >= 0) {  		PdfObject pdf;  		if (!objects.TryGetValue (num' out pdf))  			pdf = ReadObjDescription (num);  		if (pdf != null) {  			if (pdf.ObjectType == null)  				pdf.ObjectType += kvp.Key;  			pf.AddAttribute (pdf);  			switch (kvp.Key) {  			case "D":  				break;  			case "A":  				break;  			case "Limits":  			case "Outlines":  			case "Next":  			case "First":  				//      ParseDicRec(pdf);  				break;  			case "Last":  				break;  			case "Annots":  				string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  				int i = 0;  				while (i < pages.Length) {  					PdfObject ann;  					if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  						ann = ReadObjDescription (int.Parse (pages [i]));  					i += 3;  					if (ann != null)  						pdf.AddAttribute (ann);  				}  				break;  			case "Contents":  				switch (pf.ObjectType) {  				case "Page":  					if (pf.RawStreamData == null)  						pf.RawStreamData = pdf.RawStreamData;  					else {  						byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  						Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  						Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  						pdf.StreamData = buf;  					}  					Encoding enc = Encoding.Default;  					pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  					break;  				}  				break;  			default:  				if (pdf != null) {  					switch (pf.ObjectType) {  					case "Page":  						Encoding enc = Encoding.Default;  						if (pdf.StreamData != null)  							pdf.DecodedStream = enc.GetString (pdf.StreamData);  						break;  					case "Metadata":  						pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  						break;  					case "FontDescriptor":  						break;  					}  				}  				break;  			}  		}  	}  	lev = Array.IndexOf (n' "R"' lev + 1);  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: while ((lev >= 0) && (lev < n.Length)) {  	int num = -1;  	if (lev >= 2)  		num = int.Parse (n [lev - 2]);  	if (num >= 0) {  		PdfObject pdf;  		if (!objects.TryGetValue (num' out pdf))  			pdf = ReadObjDescription (num);  		if (pdf != null) {  			if (pdf.ObjectType == null)  				pdf.ObjectType += kvp.Key;  			pf.AddAttribute (pdf);  			switch (kvp.Key) {  			case "D":  				break;  			case "A":  				break;  			case "Limits":  			case "Outlines":  			case "Next":  			case "First":  				//      ParseDicRec(pdf);  				break;  			case "Last":  				break;  			case "Annots":  				string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  				int i = 0;  				while (i < pages.Length) {  					PdfObject ann;  					if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  						ann = ReadObjDescription (int.Parse (pages [i]));  					i += 3;  					if (ann != null)  						pdf.AddAttribute (ann);  				}  				break;  			case "Contents":  				switch (pf.ObjectType) {  				case "Page":  					if (pf.RawStreamData == null)  						pf.RawStreamData = pdf.RawStreamData;  					else {  						byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  						Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  						Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  						pdf.StreamData = buf;  					}  					Encoding enc = Encoding.Default;  					pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  					break;  				}  				break;  			default:  				if (pdf != null) {  					switch (pf.ObjectType) {  					case "Page":  						Encoding enc = Encoding.Default;  						if (pdf.StreamData != null)  							pdf.DecodedStream = enc.GetString (pdf.StreamData);  						break;  					case "Metadata":  						pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  						break;  					case "FontDescriptor":  						break;  					}  				}  				break;  			}  		}  	}  	lev = Array.IndexOf (n' "R"' lev + 1);  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: if (lev >= 2)  	num = int.Parse (n [lev - 2]);  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: if (lev >= 2)  	num = int.Parse (n [lev - 2]);  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: num = int.Parse (n [lev - 2]);  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: if (num >= 0) {  	PdfObject pdf;  	if (!objects.TryGetValue (num' out pdf))  		pdf = ReadObjDescription (num);  	if (pdf != null) {  		if (pdf.ObjectType == null)  			pdf.ObjectType += kvp.Key;  		pf.AddAttribute (pdf);  		switch (kvp.Key) {  		case "D":  			break;  		case "A":  			break;  		case "Limits":  		case "Outlines":  		case "Next":  		case "First":  			//      ParseDicRec(pdf);  			break;  		case "Last":  			break;  		case "Annots":  			string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  			int i = 0;  			while (i < pages.Length) {  				PdfObject ann;  				if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  					ann = ReadObjDescription (int.Parse (pages [i]));  				i += 3;  				if (ann != null)  					pdf.AddAttribute (ann);  			}  			break;  		case "Contents":  			switch (pf.ObjectType) {  			case "Page":  				if (pf.RawStreamData == null)  					pf.RawStreamData = pdf.RawStreamData;  				else {  					byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  					Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  					Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  					pdf.StreamData = buf;  				}  				Encoding enc = Encoding.Default;  				pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  				break;  			}  			break;  		default:  			if (pdf != null) {  				switch (pf.ObjectType) {  				case "Page":  					Encoding enc = Encoding.Default;  					if (pdf.StreamData != null)  						pdf.DecodedStream = enc.GetString (pdf.StreamData);  					break;  				case "Metadata":  					pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  					break;  				case "FontDescriptor":  					break;  				}  			}  			break;  		}  	}  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: if (pdf != null) {  	if (pdf.ObjectType == null)  		pdf.ObjectType += kvp.Key;  	pf.AddAttribute (pdf);  	switch (kvp.Key) {  	case "D":  		break;  	case "A":  		break;  	case "Limits":  	case "Outlines":  	case "Next":  	case "First":  		//      ParseDicRec(pdf);  		break;  	case "Last":  		break;  	case "Annots":  		string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  		int i = 0;  		while (i < pages.Length) {  			PdfObject ann;  			if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  				ann = ReadObjDescription (int.Parse (pages [i]));  			i += 3;  			if (ann != null)  				pdf.AddAttribute (ann);  		}  		break;  	case "Contents":  		switch (pf.ObjectType) {  		case "Page":  			if (pf.RawStreamData == null)  				pf.RawStreamData = pdf.RawStreamData;  			else {  				byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  				Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  				Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  				pdf.StreamData = buf;  			}  			Encoding enc = Encoding.Default;  			pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  			break;  		}  		break;  	default:  		if (pdf != null) {  			switch (pf.ObjectType) {  			case "Page":  				Encoding enc = Encoding.Default;  				if (pdf.StreamData != null)  					pdf.DecodedStream = enc.GetString (pdf.StreamData);  				break;  			case "Metadata":  				pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  				break;  			case "FontDescriptor":  				break;  			}  		}  		break;  	}  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: switch (kvp.Key) {  case "D":  	break;  case "A":  	break;  case "Limits":  case "Outlines":  case "Next":  case "First":  	//      ParseDicRec(pdf);  	break;  case "Last":  	break;  case "Annots":  	string[] pages = pdf.RawData.Replace ("["' "").Replace ("]"' "").Split (' ');  	int i = 0;  	while (i < pages.Length) {  		PdfObject ann;  		if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  			ann = ReadObjDescription (int.Parse (pages [i]));  		i += 3;  		if (ann != null)  			pdf.AddAttribute (ann);  	}  	break;  case "Contents":  	switch (pf.ObjectType) {  	case "Page":  		if (pf.RawStreamData == null)  			pf.RawStreamData = pdf.RawStreamData;  		else {  			byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  			Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  			Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  			pdf.StreamData = buf;  		}  		Encoding enc = Encoding.Default;  		pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  		break;  	}  	break;  default:  	if (pdf != null) {  		switch (pf.ObjectType) {  		case "Page":  			Encoding enc = Encoding.Default;  			if (pdf.StreamData != null)  				pdf.DecodedStream = enc.GetString (pdf.StreamData);  			break;  		case "Metadata":  			pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  			break;  		case "FontDescriptor":  			break;  		}  	}  	break;  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: while (i < pages.Length) {  	PdfObject ann;  	if (!objects.TryGetValue (int.Parse (pages [i])' out ann))  		ann = ReadObjDescription (int.Parse (pages [i]));  	i += 3;  	if (ann != null)  		pdf.AddAttribute (ann);  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: i += 3;  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: if (pf.RawData != null)  	if (pf.RawData.Contains ("R")) {  		string[] n = pf.RawData.Replace ("["' "").Replace ("]"' "").Trim ().Split (' ');  		int lev = Array.IndexOf (n' "R"' 0);  		while ((lev >= 0) && (lev < n.Length)) {  			int num = -1;  			if (lev >= 2)  				num = int.Parse (n [lev - 2]);  			if (num >= 0) {  				PdfObject pdf;  				if (!objects.TryGetValue (num' out pdf))  					pdf = ReadObjDescription (num);  				if (pdf != null) {  					//                          if (pdf.ObjectType == null)                                 pdf.ObjectType += kvp.Key;  					pf.AddAttribute (pdf);  				}  				lev = Array.IndexOf (n' "R"' lev + 1);  			}  		}  	}  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: if (pf.RawData != null)  	if (pf.RawData.Contains ("R")) {  		string[] n = pf.RawData.Replace ("["' "").Replace ("]"' "").Trim ().Split (' ');  		int lev = Array.IndexOf (n' "R"' 0);  		while ((lev >= 0) && (lev < n.Length)) {  			int num = -1;  			if (lev >= 2)  				num = int.Parse (n [lev - 2]);  			if (num >= 0) {  				PdfObject pdf;  				if (!objects.TryGetValue (num' out pdf))  					pdf = ReadObjDescription (num);  				if (pdf != null) {  					//                          if (pdf.ObjectType == null)                                 pdf.ObjectType += kvp.Key;  					pf.AddAttribute (pdf);  				}  				lev = Array.IndexOf (n' "R"' lev + 1);  			}  		}  	}  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: if (pf.RawData.Contains ("R")) {  	string[] n = pf.RawData.Replace ("["' "").Replace ("]"' "").Trim ().Split (' ');  	int lev = Array.IndexOf (n' "R"' 0);  	while ((lev >= 0) && (lev < n.Length)) {  		int num = -1;  		if (lev >= 2)  			num = int.Parse (n [lev - 2]);  		if (num >= 0) {  			PdfObject pdf;  			if (!objects.TryGetValue (num' out pdf))  				pdf = ReadObjDescription (num);  			if (pdf != null) {  				//                          if (pdf.ObjectType == null)                                 pdf.ObjectType += kvp.Key;  				pf.AddAttribute (pdf);  			}  			lev = Array.IndexOf (n' "R"' lev + 1);  		}  	}  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: if (pf.RawData.Contains ("R")) {  	string[] n = pf.RawData.Replace ("["' "").Replace ("]"' "").Trim ().Split (' ');  	int lev = Array.IndexOf (n' "R"' 0);  	while ((lev >= 0) && (lev < n.Length)) {  		int num = -1;  		if (lev >= 2)  			num = int.Parse (n [lev - 2]);  		if (num >= 0) {  			PdfObject pdf;  			if (!objects.TryGetValue (num' out pdf))  				pdf = ReadObjDescription (num);  			if (pdf != null) {  				//                          if (pdf.ObjectType == null)                                 pdf.ObjectType += kvp.Key;  				pf.AddAttribute (pdf);  			}  			lev = Array.IndexOf (n' "R"' lev + 1);  		}  	}  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: while ((lev >= 0) && (lev < n.Length)) {  	int num = -1;  	if (lev >= 2)  		num = int.Parse (n [lev - 2]);  	if (num >= 0) {  		PdfObject pdf;  		if (!objects.TryGetValue (num' out pdf))  			pdf = ReadObjDescription (num);  		if (pdf != null) {  			//                          if (pdf.ObjectType == null)                                 pdf.ObjectType += kvp.Key;  			pf.AddAttribute (pdf);  		}  		lev = Array.IndexOf (n' "R"' lev + 1);  	}  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: while ((lev >= 0) && (lev < n.Length)) {  	int num = -1;  	if (lev >= 2)  		num = int.Parse (n [lev - 2]);  	if (num >= 0) {  		PdfObject pdf;  		if (!objects.TryGetValue (num' out pdf))  			pdf = ReadObjDescription (num);  		if (pdf != null) {  			//                          if (pdf.ObjectType == null)                                 pdf.ObjectType += kvp.Key;  			pf.AddAttribute (pdf);  		}  		lev = Array.IndexOf (n' "R"' lev + 1);  	}  }  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: if (lev >= 2)  	num = int.Parse (n [lev - 2]);  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: if (lev >= 2)  	num = int.Parse (n [lev - 2]);  
Magic Number,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following statement contains a magic number: num = int.Parse (n [lev - 2]);  
Magic Number,BookReader,PdfViewer,C:\repos\mbatest_Binhed\BookReader\PdfViewer.cs,AddKeys,The following statement contains a magic number: foreach (KeyValuePair<string' string> kvp in dic) {  	TreeNode tk = new TreeNode (kvp.Key + " : " + kvp.Value);  	string t = kvp.Value;  	switch (t [0]) {  	case '<':  		t = kvp.Value.Replace ("<<"' "").Replace (">>"' "");  		break;  	case '[':  		t = kvp.Value.Replace ("["' "").Replace ("]"' "");  		break;  	default:  		break;  	}  	t = t.Trim ();  	string[] s = t.Split (' ');  	if (t.Contains ("R")) {  		string text = "";  		int lev = Array.IndexOf (s' "R"' 0);  		while ((lev >= 0) && (lev < s.Length)) {  			text = s [lev - 2] + " " + s [lev - 1] + " " + s [lev];  			TreeNode tn = new TreeNode (text);  			tk.Nodes.Add (tn);  			lev = Array.IndexOf (s' "R"' lev + 1);  		}  	}  	else {  		if (s.Length > 1)  			foreach (string ss in s) {  				if (ss.Trim () != "") {  					TreeNode tn = new TreeNode (ss);  					tk.Nodes.Add (tn);  				}  			}  		root.Nodes.Add (tk);  	}  }  
Magic Number,BookReader,PdfViewer,C:\repos\mbatest_Binhed\BookReader\PdfViewer.cs,AddKeys,The following statement contains a magic number: if (t.Contains ("R")) {  	string text = "";  	int lev = Array.IndexOf (s' "R"' 0);  	while ((lev >= 0) && (lev < s.Length)) {  		text = s [lev - 2] + " " + s [lev - 1] + " " + s [lev];  		TreeNode tn = new TreeNode (text);  		tk.Nodes.Add (tn);  		lev = Array.IndexOf (s' "R"' lev + 1);  	}  }  else {  	if (s.Length > 1)  		foreach (string ss in s) {  			if (ss.Trim () != "") {  				TreeNode tn = new TreeNode (ss);  				tk.Nodes.Add (tn);  			}  		}  	root.Nodes.Add (tk);  }  
Magic Number,BookReader,PdfViewer,C:\repos\mbatest_Binhed\BookReader\PdfViewer.cs,AddKeys,The following statement contains a magic number: while ((lev >= 0) && (lev < s.Length)) {  	text = s [lev - 2] + " " + s [lev - 1] + " " + s [lev];  	TreeNode tn = new TreeNode (text);  	tk.Nodes.Add (tn);  	lev = Array.IndexOf (s' "R"' lev + 1);  }  
Magic Number,BookReader,PdfViewer,C:\repos\mbatest_Binhed\BookReader\PdfViewer.cs,AddKeys,The following statement contains a magic number: text = s [lev - 2] + " " + s [lev - 1] + " " + s [lev];  
Magic Number,BookReader,PostScriptReader,C:\repos\mbatest_Binhed\BookReader\PsReader.cs,PostScriptReader,The following statement contains a magic number: while (!FS.EndOfStream) {  	try {  		lineRead = FS.ReadLine ();  		lineNumber++;  		string start = "";  		if (lineRead.Length > 2) {  			start = lineRead.Substring (0' 2);  			switch (start) {  			case "%%":  				#region Comments  				AddLine (lineRead' ref lineNumber);  				string[] data = lineRead.Split (':');  				if (data.Length > 1) {  					switch (data [0].ToLower ()) {  					case "%%begindefault":  						while (!lineRead.ToLower ().StartsWith ("%%enddefault")) {  							lineRead = FS.ReadLine ();  							lineNumber++;  							if (lineRead.StartsWith ("%")) {  								AddLine (lineRead' ref lineNumber);  							}  						}  						break;  					case "%%beginsetup":  						while (!lineRead.ToLower ().StartsWith ("%%endsetup")) {  							lineRead = FS.ReadLine ();  							lineNumber++;  							if (lineRead.StartsWith ("%")) {  								AddLine (lineRead' ref lineNumber);  							}  						}  						break;  					case "%%beginprolog":  						while (!lineRead.ToLower ().StartsWith ("%%endprolog")) {  							lineRead = FS.ReadLine ();  							lineNumber++;  							if (lineRead.StartsWith ("%")) {  								AddLine (lineRead' ref lineNumber);  							}  						}  						break;  					case "%%beginprocset":  						while (!lineRead.ToLower ().StartsWith ("%%endprocset")) {  							lineRead = FS.ReadLine ();  							lineNumber++;  							if (lineRead.StartsWith ("%")) {  								AddLine (lineRead' ref lineNumber);  							}  						}  						break;  					case "%%title":  						title = data [1];  						break;  					case "%%version":  						break;  					case "%%creator":  						break;  					case "%%creationdate":  						break;  					case "%%documentdata":  						break;  					case "%%languagelevel":  						break;  					case "%%boundingbox":  						break;  					case "%%hiresboundingbox":  						break;  					case "%%pages":  						break;  					case "%%pageorder":  						break;  					case "%%documentprocesscolors":  						break;  					case "%%documentsuppliedresources":  						break;  					case "%%feature":  						break;  					case "%%papersize":  						break;  					case "%%page":  						string text = "";  						while (!lineRead.Contains (" eop")) {  							lineRead = FS.ReadLine ();  							text += InnerText (lineRead);  							lineNumber++;  						}  						pages.Add (text);  						break;  					}  				}  				#endregion  				break;  			case "%!":  				break;  			case "% ":  				comments.Add (lineRead);  				break;  			default:  				break;  			}  		}  	}  	catch (Exception e) {  	}  }  
Magic Number,BookReader,PostScriptReader,C:\repos\mbatest_Binhed\BookReader\PsReader.cs,PostScriptReader,The following statement contains a magic number: while (!FS.EndOfStream) {  	try {  		lineRead = FS.ReadLine ();  		lineNumber++;  		string start = "";  		if (lineRead.Length > 2) {  			start = lineRead.Substring (0' 2);  			switch (start) {  			case "%%":  				#region Comments  				AddLine (lineRead' ref lineNumber);  				string[] data = lineRead.Split (':');  				if (data.Length > 1) {  					switch (data [0].ToLower ()) {  					case "%%begindefault":  						while (!lineRead.ToLower ().StartsWith ("%%enddefault")) {  							lineRead = FS.ReadLine ();  							lineNumber++;  							if (lineRead.StartsWith ("%")) {  								AddLine (lineRead' ref lineNumber);  							}  						}  						break;  					case "%%beginsetup":  						while (!lineRead.ToLower ().StartsWith ("%%endsetup")) {  							lineRead = FS.ReadLine ();  							lineNumber++;  							if (lineRead.StartsWith ("%")) {  								AddLine (lineRead' ref lineNumber);  							}  						}  						break;  					case "%%beginprolog":  						while (!lineRead.ToLower ().StartsWith ("%%endprolog")) {  							lineRead = FS.ReadLine ();  							lineNumber++;  							if (lineRead.StartsWith ("%")) {  								AddLine (lineRead' ref lineNumber);  							}  						}  						break;  					case "%%beginprocset":  						while (!lineRead.ToLower ().StartsWith ("%%endprocset")) {  							lineRead = FS.ReadLine ();  							lineNumber++;  							if (lineRead.StartsWith ("%")) {  								AddLine (lineRead' ref lineNumber);  							}  						}  						break;  					case "%%title":  						title = data [1];  						break;  					case "%%version":  						break;  					case "%%creator":  						break;  					case "%%creationdate":  						break;  					case "%%documentdata":  						break;  					case "%%languagelevel":  						break;  					case "%%boundingbox":  						break;  					case "%%hiresboundingbox":  						break;  					case "%%pages":  						break;  					case "%%pageorder":  						break;  					case "%%documentprocesscolors":  						break;  					case "%%documentsuppliedresources":  						break;  					case "%%feature":  						break;  					case "%%papersize":  						break;  					case "%%page":  						string text = "";  						while (!lineRead.Contains (" eop")) {  							lineRead = FS.ReadLine ();  							text += InnerText (lineRead);  							lineNumber++;  						}  						pages.Add (text);  						break;  					}  				}  				#endregion  				break;  			case "%!":  				break;  			case "% ":  				comments.Add (lineRead);  				break;  			default:  				break;  			}  		}  	}  	catch (Exception e) {  	}  }  
Magic Number,BookReader,PostScriptReader,C:\repos\mbatest_Binhed\BookReader\PsReader.cs,PostScriptReader,The following statement contains a magic number: try {  	lineRead = FS.ReadLine ();  	lineNumber++;  	string start = "";  	if (lineRead.Length > 2) {  		start = lineRead.Substring (0' 2);  		switch (start) {  		case "%%":  			#region Comments  			AddLine (lineRead' ref lineNumber);  			string[] data = lineRead.Split (':');  			if (data.Length > 1) {  				switch (data [0].ToLower ()) {  				case "%%begindefault":  					while (!lineRead.ToLower ().StartsWith ("%%enddefault")) {  						lineRead = FS.ReadLine ();  						lineNumber++;  						if (lineRead.StartsWith ("%")) {  							AddLine (lineRead' ref lineNumber);  						}  					}  					break;  				case "%%beginsetup":  					while (!lineRead.ToLower ().StartsWith ("%%endsetup")) {  						lineRead = FS.ReadLine ();  						lineNumber++;  						if (lineRead.StartsWith ("%")) {  							AddLine (lineRead' ref lineNumber);  						}  					}  					break;  				case "%%beginprolog":  					while (!lineRead.ToLower ().StartsWith ("%%endprolog")) {  						lineRead = FS.ReadLine ();  						lineNumber++;  						if (lineRead.StartsWith ("%")) {  							AddLine (lineRead' ref lineNumber);  						}  					}  					break;  				case "%%beginprocset":  					while (!lineRead.ToLower ().StartsWith ("%%endprocset")) {  						lineRead = FS.ReadLine ();  						lineNumber++;  						if (lineRead.StartsWith ("%")) {  							AddLine (lineRead' ref lineNumber);  						}  					}  					break;  				case "%%title":  					title = data [1];  					break;  				case "%%version":  					break;  				case "%%creator":  					break;  				case "%%creationdate":  					break;  				case "%%documentdata":  					break;  				case "%%languagelevel":  					break;  				case "%%boundingbox":  					break;  				case "%%hiresboundingbox":  					break;  				case "%%pages":  					break;  				case "%%pageorder":  					break;  				case "%%documentprocesscolors":  					break;  				case "%%documentsuppliedresources":  					break;  				case "%%feature":  					break;  				case "%%papersize":  					break;  				case "%%page":  					string text = "";  					while (!lineRead.Contains (" eop")) {  						lineRead = FS.ReadLine ();  						text += InnerText (lineRead);  						lineNumber++;  					}  					pages.Add (text);  					break;  				}  			}  			#endregion  			break;  		case "%!":  			break;  		case "% ":  			comments.Add (lineRead);  			break;  		default:  			break;  		}  	}  }  catch (Exception e) {  }  
Magic Number,BookReader,PostScriptReader,C:\repos\mbatest_Binhed\BookReader\PsReader.cs,PostScriptReader,The following statement contains a magic number: try {  	lineRead = FS.ReadLine ();  	lineNumber++;  	string start = "";  	if (lineRead.Length > 2) {  		start = lineRead.Substring (0' 2);  		switch (start) {  		case "%%":  			#region Comments  			AddLine (lineRead' ref lineNumber);  			string[] data = lineRead.Split (':');  			if (data.Length > 1) {  				switch (data [0].ToLower ()) {  				case "%%begindefault":  					while (!lineRead.ToLower ().StartsWith ("%%enddefault")) {  						lineRead = FS.ReadLine ();  						lineNumber++;  						if (lineRead.StartsWith ("%")) {  							AddLine (lineRead' ref lineNumber);  						}  					}  					break;  				case "%%beginsetup":  					while (!lineRead.ToLower ().StartsWith ("%%endsetup")) {  						lineRead = FS.ReadLine ();  						lineNumber++;  						if (lineRead.StartsWith ("%")) {  							AddLine (lineRead' ref lineNumber);  						}  					}  					break;  				case "%%beginprolog":  					while (!lineRead.ToLower ().StartsWith ("%%endprolog")) {  						lineRead = FS.ReadLine ();  						lineNumber++;  						if (lineRead.StartsWith ("%")) {  							AddLine (lineRead' ref lineNumber);  						}  					}  					break;  				case "%%beginprocset":  					while (!lineRead.ToLower ().StartsWith ("%%endprocset")) {  						lineRead = FS.ReadLine ();  						lineNumber++;  						if (lineRead.StartsWith ("%")) {  							AddLine (lineRead' ref lineNumber);  						}  					}  					break;  				case "%%title":  					title = data [1];  					break;  				case "%%version":  					break;  				case "%%creator":  					break;  				case "%%creationdate":  					break;  				case "%%documentdata":  					break;  				case "%%languagelevel":  					break;  				case "%%boundingbox":  					break;  				case "%%hiresboundingbox":  					break;  				case "%%pages":  					break;  				case "%%pageorder":  					break;  				case "%%documentprocesscolors":  					break;  				case "%%documentsuppliedresources":  					break;  				case "%%feature":  					break;  				case "%%papersize":  					break;  				case "%%page":  					string text = "";  					while (!lineRead.Contains (" eop")) {  						lineRead = FS.ReadLine ();  						text += InnerText (lineRead);  						lineNumber++;  					}  					pages.Add (text);  					break;  				}  			}  			#endregion  			break;  		case "%!":  			break;  		case "% ":  			comments.Add (lineRead);  			break;  		default:  			break;  		}  	}  }  catch (Exception e) {  }  
Magic Number,BookReader,PostScriptReader,C:\repos\mbatest_Binhed\BookReader\PsReader.cs,PostScriptReader,The following statement contains a magic number: if (lineRead.Length > 2) {  	start = lineRead.Substring (0' 2);  	switch (start) {  	case "%%":  		#region Comments  		AddLine (lineRead' ref lineNumber);  		string[] data = lineRead.Split (':');  		if (data.Length > 1) {  			switch (data [0].ToLower ()) {  			case "%%begindefault":  				while (!lineRead.ToLower ().StartsWith ("%%enddefault")) {  					lineRead = FS.ReadLine ();  					lineNumber++;  					if (lineRead.StartsWith ("%")) {  						AddLine (lineRead' ref lineNumber);  					}  				}  				break;  			case "%%beginsetup":  				while (!lineRead.ToLower ().StartsWith ("%%endsetup")) {  					lineRead = FS.ReadLine ();  					lineNumber++;  					if (lineRead.StartsWith ("%")) {  						AddLine (lineRead' ref lineNumber);  					}  				}  				break;  			case "%%beginprolog":  				while (!lineRead.ToLower ().StartsWith ("%%endprolog")) {  					lineRead = FS.ReadLine ();  					lineNumber++;  					if (lineRead.StartsWith ("%")) {  						AddLine (lineRead' ref lineNumber);  					}  				}  				break;  			case "%%beginprocset":  				while (!lineRead.ToLower ().StartsWith ("%%endprocset")) {  					lineRead = FS.ReadLine ();  					lineNumber++;  					if (lineRead.StartsWith ("%")) {  						AddLine (lineRead' ref lineNumber);  					}  				}  				break;  			case "%%title":  				title = data [1];  				break;  			case "%%version":  				break;  			case "%%creator":  				break;  			case "%%creationdate":  				break;  			case "%%documentdata":  				break;  			case "%%languagelevel":  				break;  			case "%%boundingbox":  				break;  			case "%%hiresboundingbox":  				break;  			case "%%pages":  				break;  			case "%%pageorder":  				break;  			case "%%documentprocesscolors":  				break;  			case "%%documentsuppliedresources":  				break;  			case "%%feature":  				break;  			case "%%papersize":  				break;  			case "%%page":  				string text = "";  				while (!lineRead.Contains (" eop")) {  					lineRead = FS.ReadLine ();  					text += InnerText (lineRead);  					lineNumber++;  				}  				pages.Add (text);  				break;  			}  		}  		#endregion  		break;  	case "%!":  		break;  	case "% ":  		comments.Add (lineRead);  		break;  	default:  		break;  	}  }  
Magic Number,BookReader,PostScriptReader,C:\repos\mbatest_Binhed\BookReader\PsReader.cs,PostScriptReader,The following statement contains a magic number: if (lineRead.Length > 2) {  	start = lineRead.Substring (0' 2);  	switch (start) {  	case "%%":  		#region Comments  		AddLine (lineRead' ref lineNumber);  		string[] data = lineRead.Split (':');  		if (data.Length > 1) {  			switch (data [0].ToLower ()) {  			case "%%begindefault":  				while (!lineRead.ToLower ().StartsWith ("%%enddefault")) {  					lineRead = FS.ReadLine ();  					lineNumber++;  					if (lineRead.StartsWith ("%")) {  						AddLine (lineRead' ref lineNumber);  					}  				}  				break;  			case "%%beginsetup":  				while (!lineRead.ToLower ().StartsWith ("%%endsetup")) {  					lineRead = FS.ReadLine ();  					lineNumber++;  					if (lineRead.StartsWith ("%")) {  						AddLine (lineRead' ref lineNumber);  					}  				}  				break;  			case "%%beginprolog":  				while (!lineRead.ToLower ().StartsWith ("%%endprolog")) {  					lineRead = FS.ReadLine ();  					lineNumber++;  					if (lineRead.StartsWith ("%")) {  						AddLine (lineRead' ref lineNumber);  					}  				}  				break;  			case "%%beginprocset":  				while (!lineRead.ToLower ().StartsWith ("%%endprocset")) {  					lineRead = FS.ReadLine ();  					lineNumber++;  					if (lineRead.StartsWith ("%")) {  						AddLine (lineRead' ref lineNumber);  					}  				}  				break;  			case "%%title":  				title = data [1];  				break;  			case "%%version":  				break;  			case "%%creator":  				break;  			case "%%creationdate":  				break;  			case "%%documentdata":  				break;  			case "%%languagelevel":  				break;  			case "%%boundingbox":  				break;  			case "%%hiresboundingbox":  				break;  			case "%%pages":  				break;  			case "%%pageorder":  				break;  			case "%%documentprocesscolors":  				break;  			case "%%documentsuppliedresources":  				break;  			case "%%feature":  				break;  			case "%%papersize":  				break;  			case "%%page":  				string text = "";  				while (!lineRead.Contains (" eop")) {  					lineRead = FS.ReadLine ();  					text += InnerText (lineRead);  					lineNumber++;  				}  				pages.Add (text);  				break;  			}  		}  		#endregion  		break;  	case "%!":  		break;  	case "% ":  		comments.Add (lineRead);  		break;  	default:  		break;  	}  }  
Magic Number,BookReader,PostScriptReader,C:\repos\mbatest_Binhed\BookReader\PsReader.cs,PostScriptReader,The following statement contains a magic number: start = lineRead.Substring (0' 2);  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,MobiFileReader,The following statement contains a magic number: for (int i = 0; i < 10/*Header.PdHr.Index.Count*/; i++) {  	Header.PdHr.Index [i].Page = Read (FileName' i);  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: while (i < buffer.Length) {  	try {  		if (buffer [i] == 0x00) {  			t += enc.GetString (buffer' i' 1);  			i++;  		}  		else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  			int start = i + 1;  			int end = start + buffer [i];  			i++;  			for (int j = start; j < end; j++) {  				string a = enc.GetString (buffer' j' 1);  				t += a;  				i++;  			}  		}  		else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  			t += enc.GetString (buffer' i' 1);  			i++;  		}  		else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  			int dist1 = buffer [i] & 0x3F;  			if (buffer [i] == 0x80) {  			}  			int dist2 = buffer [i + 1] & 0xF8;  			int dist = (256 * dist1 + dist2) >> 3;  			int lengthData = buffer [i + 1] & 0x07;  			try {  				t += t.Substring (t.Length - dist' lengthData + 3);  			}  			catch (Exception e) {  				for (int u = 0; u < lengthData + 3; u++)  					t += " ";  			}  			i += 2;  		}  		else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  			byte[] bb = new byte[1];  			bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  			t += " " + enc.GetString (bb' 0' 1);  			i++;  		}  	}  	catch (Exception ex) {  		break;  	}  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: while (i < buffer.Length) {  	try {  		if (buffer [i] == 0x00) {  			t += enc.GetString (buffer' i' 1);  			i++;  		}  		else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  			int start = i + 1;  			int end = start + buffer [i];  			i++;  			for (int j = start; j < end; j++) {  				string a = enc.GetString (buffer' j' 1);  				t += a;  				i++;  			}  		}  		else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  			t += enc.GetString (buffer' i' 1);  			i++;  		}  		else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  			int dist1 = buffer [i] & 0x3F;  			if (buffer [i] == 0x80) {  			}  			int dist2 = buffer [i + 1] & 0xF8;  			int dist = (256 * dist1 + dist2) >> 3;  			int lengthData = buffer [i + 1] & 0x07;  			try {  				t += t.Substring (t.Length - dist' lengthData + 3);  			}  			catch (Exception e) {  				for (int u = 0; u < lengthData + 3; u++)  					t += " ";  			}  			i += 2;  		}  		else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  			byte[] bb = new byte[1];  			bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  			t += " " + enc.GetString (bb' 0' 1);  			i++;  		}  	}  	catch (Exception ex) {  		break;  	}  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: while (i < buffer.Length) {  	try {  		if (buffer [i] == 0x00) {  			t += enc.GetString (buffer' i' 1);  			i++;  		}  		else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  			int start = i + 1;  			int end = start + buffer [i];  			i++;  			for (int j = start; j < end; j++) {  				string a = enc.GetString (buffer' j' 1);  				t += a;  				i++;  			}  		}  		else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  			t += enc.GetString (buffer' i' 1);  			i++;  		}  		else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  			int dist1 = buffer [i] & 0x3F;  			if (buffer [i] == 0x80) {  			}  			int dist2 = buffer [i + 1] & 0xF8;  			int dist = (256 * dist1 + dist2) >> 3;  			int lengthData = buffer [i + 1] & 0x07;  			try {  				t += t.Substring (t.Length - dist' lengthData + 3);  			}  			catch (Exception e) {  				for (int u = 0; u < lengthData + 3; u++)  					t += " ";  			}  			i += 2;  		}  		else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  			byte[] bb = new byte[1];  			bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  			t += " " + enc.GetString (bb' 0' 1);  			i++;  		}  	}  	catch (Exception ex) {  		break;  	}  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: while (i < buffer.Length) {  	try {  		if (buffer [i] == 0x00) {  			t += enc.GetString (buffer' i' 1);  			i++;  		}  		else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  			int start = i + 1;  			int end = start + buffer [i];  			i++;  			for (int j = start; j < end; j++) {  				string a = enc.GetString (buffer' j' 1);  				t += a;  				i++;  			}  		}  		else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  			t += enc.GetString (buffer' i' 1);  			i++;  		}  		else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  			int dist1 = buffer [i] & 0x3F;  			if (buffer [i] == 0x80) {  			}  			int dist2 = buffer [i + 1] & 0xF8;  			int dist = (256 * dist1 + dist2) >> 3;  			int lengthData = buffer [i + 1] & 0x07;  			try {  				t += t.Substring (t.Length - dist' lengthData + 3);  			}  			catch (Exception e) {  				for (int u = 0; u < lengthData + 3; u++)  					t += " ";  			}  			i += 2;  		}  		else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  			byte[] bb = new byte[1];  			bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  			t += " " + enc.GetString (bb' 0' 1);  			i++;  		}  	}  	catch (Exception ex) {  		break;  	}  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: while (i < buffer.Length) {  	try {  		if (buffer [i] == 0x00) {  			t += enc.GetString (buffer' i' 1);  			i++;  		}  		else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  			int start = i + 1;  			int end = start + buffer [i];  			i++;  			for (int j = start; j < end; j++) {  				string a = enc.GetString (buffer' j' 1);  				t += a;  				i++;  			}  		}  		else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  			t += enc.GetString (buffer' i' 1);  			i++;  		}  		else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  			int dist1 = buffer [i] & 0x3F;  			if (buffer [i] == 0x80) {  			}  			int dist2 = buffer [i + 1] & 0xF8;  			int dist = (256 * dist1 + dist2) >> 3;  			int lengthData = buffer [i + 1] & 0x07;  			try {  				t += t.Substring (t.Length - dist' lengthData + 3);  			}  			catch (Exception e) {  				for (int u = 0; u < lengthData + 3; u++)  					t += " ";  			}  			i += 2;  		}  		else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  			byte[] bb = new byte[1];  			bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  			t += " " + enc.GetString (bb' 0' 1);  			i++;  		}  	}  	catch (Exception ex) {  		break;  	}  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: try {  	if (buffer [i] == 0x00) {  		t += enc.GetString (buffer' i' 1);  		i++;  	}  	else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  		int start = i + 1;  		int end = start + buffer [i];  		i++;  		for (int j = start; j < end; j++) {  			string a = enc.GetString (buffer' j' 1);  			t += a;  			i++;  		}  	}  	else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  		t += enc.GetString (buffer' i' 1);  		i++;  	}  	else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  		int dist1 = buffer [i] & 0x3F;  		if (buffer [i] == 0x80) {  		}  		int dist2 = buffer [i + 1] & 0xF8;  		int dist = (256 * dist1 + dist2) >> 3;  		int lengthData = buffer [i + 1] & 0x07;  		try {  			t += t.Substring (t.Length - dist' lengthData + 3);  		}  		catch (Exception e) {  			for (int u = 0; u < lengthData + 3; u++)  				t += " ";  		}  		i += 2;  	}  	else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  		byte[] bb = new byte[1];  		bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  		t += " " + enc.GetString (bb' 0' 1);  		i++;  	}  }  catch (Exception ex) {  	break;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: try {  	if (buffer [i] == 0x00) {  		t += enc.GetString (buffer' i' 1);  		i++;  	}  	else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  		int start = i + 1;  		int end = start + buffer [i];  		i++;  		for (int j = start; j < end; j++) {  			string a = enc.GetString (buffer' j' 1);  			t += a;  			i++;  		}  	}  	else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  		t += enc.GetString (buffer' i' 1);  		i++;  	}  	else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  		int dist1 = buffer [i] & 0x3F;  		if (buffer [i] == 0x80) {  		}  		int dist2 = buffer [i + 1] & 0xF8;  		int dist = (256 * dist1 + dist2) >> 3;  		int lengthData = buffer [i + 1] & 0x07;  		try {  			t += t.Substring (t.Length - dist' lengthData + 3);  		}  		catch (Exception e) {  			for (int u = 0; u < lengthData + 3; u++)  				t += " ";  		}  		i += 2;  	}  	else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  		byte[] bb = new byte[1];  		bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  		t += " " + enc.GetString (bb' 0' 1);  		i++;  	}  }  catch (Exception ex) {  	break;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: try {  	if (buffer [i] == 0x00) {  		t += enc.GetString (buffer' i' 1);  		i++;  	}  	else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  		int start = i + 1;  		int end = start + buffer [i];  		i++;  		for (int j = start; j < end; j++) {  			string a = enc.GetString (buffer' j' 1);  			t += a;  			i++;  		}  	}  	else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  		t += enc.GetString (buffer' i' 1);  		i++;  	}  	else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  		int dist1 = buffer [i] & 0x3F;  		if (buffer [i] == 0x80) {  		}  		int dist2 = buffer [i + 1] & 0xF8;  		int dist = (256 * dist1 + dist2) >> 3;  		int lengthData = buffer [i + 1] & 0x07;  		try {  			t += t.Substring (t.Length - dist' lengthData + 3);  		}  		catch (Exception e) {  			for (int u = 0; u < lengthData + 3; u++)  				t += " ";  		}  		i += 2;  	}  	else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  		byte[] bb = new byte[1];  		bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  		t += " " + enc.GetString (bb' 0' 1);  		i++;  	}  }  catch (Exception ex) {  	break;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: try {  	if (buffer [i] == 0x00) {  		t += enc.GetString (buffer' i' 1);  		i++;  	}  	else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  		int start = i + 1;  		int end = start + buffer [i];  		i++;  		for (int j = start; j < end; j++) {  			string a = enc.GetString (buffer' j' 1);  			t += a;  			i++;  		}  	}  	else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  		t += enc.GetString (buffer' i' 1);  		i++;  	}  	else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  		int dist1 = buffer [i] & 0x3F;  		if (buffer [i] == 0x80) {  		}  		int dist2 = buffer [i + 1] & 0xF8;  		int dist = (256 * dist1 + dist2) >> 3;  		int lengthData = buffer [i + 1] & 0x07;  		try {  			t += t.Substring (t.Length - dist' lengthData + 3);  		}  		catch (Exception e) {  			for (int u = 0; u < lengthData + 3; u++)  				t += " ";  		}  		i += 2;  	}  	else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  		byte[] bb = new byte[1];  		bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  		t += " " + enc.GetString (bb' 0' 1);  		i++;  	}  }  catch (Exception ex) {  	break;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: try {  	if (buffer [i] == 0x00) {  		t += enc.GetString (buffer' i' 1);  		i++;  	}  	else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  		int start = i + 1;  		int end = start + buffer [i];  		i++;  		for (int j = start; j < end; j++) {  			string a = enc.GetString (buffer' j' 1);  			t += a;  			i++;  		}  	}  	else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  		t += enc.GetString (buffer' i' 1);  		i++;  	}  	else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  		int dist1 = buffer [i] & 0x3F;  		if (buffer [i] == 0x80) {  		}  		int dist2 = buffer [i + 1] & 0xF8;  		int dist = (256 * dist1 + dist2) >> 3;  		int lengthData = buffer [i + 1] & 0x07;  		try {  			t += t.Substring (t.Length - dist' lengthData + 3);  		}  		catch (Exception e) {  			for (int u = 0; u < lengthData + 3; u++)  				t += " ";  		}  		i += 2;  	}  	else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  		byte[] bb = new byte[1];  		bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  		t += " " + enc.GetString (bb' 0' 1);  		i++;  	}  }  catch (Exception ex) {  	break;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if (buffer [i] == 0x00) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  	int start = i + 1;  	int end = start + buffer [i];  	i++;  	for (int j = start; j < end; j++) {  		string a = enc.GetString (buffer' j' 1);  		t += a;  		i++;  	}  }  else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if (buffer [i] == 0x00) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  	int start = i + 1;  	int end = start + buffer [i];  	i++;  	for (int j = start; j < end; j++) {  		string a = enc.GetString (buffer' j' 1);  		t += a;  		i++;  	}  }  else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if (buffer [i] == 0x00) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  	int start = i + 1;  	int end = start + buffer [i];  	i++;  	for (int j = start; j < end; j++) {  		string a = enc.GetString (buffer' j' 1);  		t += a;  		i++;  	}  }  else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if (buffer [i] == 0x00) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  	int start = i + 1;  	int end = start + buffer [i];  	i++;  	for (int j = start; j < end; j++) {  		string a = enc.GetString (buffer' j' 1);  		t += a;  		i++;  	}  }  else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if (buffer [i] == 0x00) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  	int start = i + 1;  	int end = start + buffer [i];  	i++;  	for (int j = start; j < end; j++) {  		string a = enc.GetString (buffer' j' 1);  		t += a;  		i++;  	}  }  else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  	int start = i + 1;  	int end = start + buffer [i];  	i++;  	for (int j = start; j < end; j++) {  		string a = enc.GetString (buffer' j' 1);  		t += a;  		i++;  	}  }  else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  	int start = i + 1;  	int end = start + buffer [i];  	i++;  	for (int j = start; j < end; j++) {  		string a = enc.GetString (buffer' j' 1);  		t += a;  		i++;  	}  }  else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  	int start = i + 1;  	int end = start + buffer [i];  	i++;  	for (int j = start; j < end; j++) {  		string a = enc.GetString (buffer' j' 1);  		t += a;  		i++;  	}  }  else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  	int start = i + 1;  	int end = start + buffer [i];  	i++;  	for (int j = start; j < end; j++) {  		string a = enc.GetString (buffer' j' 1);  		t += a;  		i++;  	}  }  else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x01) && (buffer [i] <= 0x08)) {  	int start = i + 1;  	int end = start + buffer [i];  	i++;  	for (int j = start; j < end; j++) {  		string a = enc.GetString (buffer' j' 1);  		t += a;  		i++;  	}  }  else if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x09) && (buffer [i] <= 0x7F)) {  	t += enc.GetString (buffer' i' 1);  	i++;  }  else if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: if ((buffer [i] >= 0x80) && (buffer [i] <= 0xbF)) {  	int dist1 = buffer [i] & 0x3F;  	if (buffer [i] == 0x80) {  	}  	int dist2 = buffer [i + 1] & 0xF8;  	int dist = (256 * dist1 + dist2) >> 3;  	int lengthData = buffer [i + 1] & 0x07;  	try {  		t += t.Substring (t.Length - dist' lengthData + 3);  	}  	catch (Exception e) {  		for (int u = 0; u < lengthData + 3; u++)  			t += " ";  	}  	i += 2;  }  else if ((buffer [i] >= 0xc0) && (buffer [i] <= 0xFF)) {  	byte[] bb = new byte[1];  	bb [0] = Convert.ToByte (buffer [i] ^ 0x80);  	t += " " + enc.GetString (bb' 0' 1);  	i++;  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: try {  	t += t.Substring (t.Length - dist' lengthData + 3);  }  catch (Exception e) {  	for (int u = 0; u < lengthData + 3; u++)  		t += " ";  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: try {  	t += t.Substring (t.Length - dist' lengthData + 3);  }  catch (Exception e) {  	for (int u = 0; u < lengthData + 3; u++)  		t += " ";  }  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: t += t.Substring (t.Length - dist' lengthData + 3);  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: for (int u = 0; u < lengthData + 3; u++)  	t += " ";  
Magic Number,BookReader,MobiFileReader,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Uncompress,The following statement contains a magic number: i += 2;  
Magic Number,BookReader,indexEntry,C:\repos\mbatest_Binhed\BookReader\Readers.cs,indexEntry,The following statement contains a magic number: if (sh) {  	offset = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();  	number = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();  }  else {  	offset = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();  	type = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 3);  	//sw.ReadString(3);  	number = new ELEMENTARY_TYPE (sw' 0' typeof(byte));  	//int)sw.ReadByte();  }  
Magic Number,BookReader,indexEntry,C:\repos\mbatest_Binhed\BookReader\Readers.cs,indexEntry,The following statement contains a magic number: type = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 3);  
Magic Number,BookReader,indexEntry,C:\repos\mbatest_Binhed\BookReader\Readers.cs,ToString,The following statement contains a magic number: return page.Text.Substring (0' 50);  
Magic Number,BookReader,exthEntry,C:\repos\mbatest_Binhed\BookReader\Readers.cs,exthEntry,The following statement contains a magic number: data = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' (int)length.Value - 8);  
Magic Number,BookReader,palmDocHdr,C:\repos\mbatest_Binhed\BookReader\Readers.cs,palmDocHdr,The following statement contains a magic number: title = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 32);  
Magic Number,BookReader,palmDocHdr,C:\repos\mbatest_Binhed\BookReader\Readers.cs,palmDocHdr,The following statement contains a magic number: createDate = new DateTime (1970' 1' 1) + new TimeSpan (0' 0' (int)create.Value);  
Magic Number,BookReader,palmDocHdr,C:\repos\mbatest_Binhed\BookReader\Readers.cs,palmDocHdr,The following statement contains a magic number: modifDate = new DateTime (1970' 1' 1) + new TimeSpan (0' 0' (int)modif.Value);  
Magic Number,BookReader,palmDocHdr,C:\repos\mbatest_Binhed\BookReader\Readers.cs,palmDocHdr,The following statement contains a magic number: backupDate = new DateTime (1970' 1' 1) + new TimeSpan (0' 0' (int)backup.Value);  
Magic Number,BookReader,palmDocHdr,C:\repos\mbatest_Binhed\BookReader\Readers.cs,palmDocHdr,The following statement contains a magic number: type = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 4);  
Magic Number,BookReader,palmDocHdr,C:\repos\mbatest_Binhed\BookReader\Readers.cs,palmDocHdr,The following statement contains a magic number: creator = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 4);  
Magic Number,BookReader,mobiHdr,C:\repos\mbatest_Binhed\BookReader\Readers.cs,mobiHdr,The following statement contains a magic number: identifier = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 4);  
Magic Number,BookReader,mobiHdr,C:\repos\mbatest_Binhed\BookReader\Readers.cs,mobiHdr,The following statement contains a magic number: sw.ReadBytes (40);  
Magic Number,BookReader,mobiHdr,C:\repos\mbatest_Binhed\BookReader\Readers.cs,mobiHdr,The following statement contains a magic number: sw.ReadBytes (16);  
Magic Number,BookReader,mobiHdr,C:\repos\mbatest_Binhed\BookReader\Readers.cs,mobiHdr,The following statement contains a magic number: sw.ReadBytes (32);  
Magic Number,BookReader,mobiHdr,C:\repos\mbatest_Binhed\BookReader\Readers.cs,mobiHdr,The following statement contains a magic number: sw.ReadBytes (2);  
Magic Number,BookReader,ExtHdr,C:\repos\mbatest_Binhed\BookReader\Readers.cs,ExtHdr,The following statement contains a magic number: identifier = new ELEMENTARY_TYPE (sw' 0' Encoding.Default' 4);  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: if ((string)pdHr.Creator.Value == "MOBI") {  	#region MOBI FileHeader  	sw.ReadBytes (2);  	//Gap to data  	compression = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	//(uint)sw.ReadShort();//Compression  	sw.ReadBytes (2);  	//unused  	textLength = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();  	recordCount = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(uint)sw.ReadShort();//Number of PDB records used for the text of the book.  	recordSize = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(uint)sw.ReadShort();//Number of PDB records used for the text of the book.  	currentPosition = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();//current position in the text  	mHdr = new mobiHdr (sw);  	if ((int)mHdr.Exthflags.Value != 0) {  		extHdr = new ExtHdr (sw);  		for (int u = 0; u < (int)extHdr.RecCount.Value; u++) {  			exthEntry entry = new exthEntry (sw);  			extHdr.index.Add (entry);  			switch ((int)entry.Typeext.Value) {  			case 100:  				author = (string)entry.Data.Value;  				break;  			case 101:  				publisher = (string)entry.Data.Value;  				break;  			}  		}  	}  	int start = (int)pdHr.Index [0].Offset.Value + (int)mHdr.FullNameOffset.Value;  	sw.Position = start;  	title = sw.ReadString ((int)mHdr.FullNamelength.Value);  	#endregion  }  else {  	#region TEXt FileHeader  	sw.Position = (int)pdHr.Index [0].Offset.Value;  	sw.Position = (int)pdHr.Index [1].Offset.Value;  	string text = MobiFileReader.Uncompress (sw.ReadBlock (800));  	int i = text.IndexOf ("Title>") + "Title>".Length;  	int j = text.IndexOf ('<'' i);  	title = text.Substring (i' j - i);  	i = text.IndexOf ("Creator>"' j) + "Creator>".Length;  	j = text.IndexOf ('<'' i);  	author = text.Substring (i' j - i);  	i = text.IndexOf ("Date>"' j) + "Date>".Length;  	j = text.IndexOf ('<'' i);  	date = text.Substring (i' j - i);  	sw.Position = (int)pdHr.Index [2].Offset.Value;  	#endregion  }  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: if ((string)pdHr.Creator.Value == "MOBI") {  	#region MOBI FileHeader  	sw.ReadBytes (2);  	//Gap to data  	compression = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	//(uint)sw.ReadShort();//Compression  	sw.ReadBytes (2);  	//unused  	textLength = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();  	recordCount = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(uint)sw.ReadShort();//Number of PDB records used for the text of the book.  	recordSize = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(uint)sw.ReadShort();//Number of PDB records used for the text of the book.  	currentPosition = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();//current position in the text  	mHdr = new mobiHdr (sw);  	if ((int)mHdr.Exthflags.Value != 0) {  		extHdr = new ExtHdr (sw);  		for (int u = 0; u < (int)extHdr.RecCount.Value; u++) {  			exthEntry entry = new exthEntry (sw);  			extHdr.index.Add (entry);  			switch ((int)entry.Typeext.Value) {  			case 100:  				author = (string)entry.Data.Value;  				break;  			case 101:  				publisher = (string)entry.Data.Value;  				break;  			}  		}  	}  	int start = (int)pdHr.Index [0].Offset.Value + (int)mHdr.FullNameOffset.Value;  	sw.Position = start;  	title = sw.ReadString ((int)mHdr.FullNamelength.Value);  	#endregion  }  else {  	#region TEXt FileHeader  	sw.Position = (int)pdHr.Index [0].Offset.Value;  	sw.Position = (int)pdHr.Index [1].Offset.Value;  	string text = MobiFileReader.Uncompress (sw.ReadBlock (800));  	int i = text.IndexOf ("Title>") + "Title>".Length;  	int j = text.IndexOf ('<'' i);  	title = text.Substring (i' j - i);  	i = text.IndexOf ("Creator>"' j) + "Creator>".Length;  	j = text.IndexOf ('<'' i);  	author = text.Substring (i' j - i);  	i = text.IndexOf ("Date>"' j) + "Date>".Length;  	j = text.IndexOf ('<'' i);  	date = text.Substring (i' j - i);  	sw.Position = (int)pdHr.Index [2].Offset.Value;  	#endregion  }  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: if ((string)pdHr.Creator.Value == "MOBI") {  	#region MOBI FileHeader  	sw.ReadBytes (2);  	//Gap to data  	compression = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	//(uint)sw.ReadShort();//Compression  	sw.ReadBytes (2);  	//unused  	textLength = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();  	recordCount = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(uint)sw.ReadShort();//Number of PDB records used for the text of the book.  	recordSize = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(uint)sw.ReadShort();//Number of PDB records used for the text of the book.  	currentPosition = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();//current position in the text  	mHdr = new mobiHdr (sw);  	if ((int)mHdr.Exthflags.Value != 0) {  		extHdr = new ExtHdr (sw);  		for (int u = 0; u < (int)extHdr.RecCount.Value; u++) {  			exthEntry entry = new exthEntry (sw);  			extHdr.index.Add (entry);  			switch ((int)entry.Typeext.Value) {  			case 100:  				author = (string)entry.Data.Value;  				break;  			case 101:  				publisher = (string)entry.Data.Value;  				break;  			}  		}  	}  	int start = (int)pdHr.Index [0].Offset.Value + (int)mHdr.FullNameOffset.Value;  	sw.Position = start;  	title = sw.ReadString ((int)mHdr.FullNamelength.Value);  	#endregion  }  else {  	#region TEXt FileHeader  	sw.Position = (int)pdHr.Index [0].Offset.Value;  	sw.Position = (int)pdHr.Index [1].Offset.Value;  	string text = MobiFileReader.Uncompress (sw.ReadBlock (800));  	int i = text.IndexOf ("Title>") + "Title>".Length;  	int j = text.IndexOf ('<'' i);  	title = text.Substring (i' j - i);  	i = text.IndexOf ("Creator>"' j) + "Creator>".Length;  	j = text.IndexOf ('<'' i);  	author = text.Substring (i' j - i);  	i = text.IndexOf ("Date>"' j) + "Date>".Length;  	j = text.IndexOf ('<'' i);  	date = text.Substring (i' j - i);  	sw.Position = (int)pdHr.Index [2].Offset.Value;  	#endregion  }  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: if ((string)pdHr.Creator.Value == "MOBI") {  	#region MOBI FileHeader  	sw.ReadBytes (2);  	//Gap to data  	compression = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	//(uint)sw.ReadShort();//Compression  	sw.ReadBytes (2);  	//unused  	textLength = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();  	recordCount = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(uint)sw.ReadShort();//Number of PDB records used for the text of the book.  	recordSize = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(uint)sw.ReadShort();//Number of PDB records used for the text of the book.  	currentPosition = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();//current position in the text  	mHdr = new mobiHdr (sw);  	if ((int)mHdr.Exthflags.Value != 0) {  		extHdr = new ExtHdr (sw);  		for (int u = 0; u < (int)extHdr.RecCount.Value; u++) {  			exthEntry entry = new exthEntry (sw);  			extHdr.index.Add (entry);  			switch ((int)entry.Typeext.Value) {  			case 100:  				author = (string)entry.Data.Value;  				break;  			case 101:  				publisher = (string)entry.Data.Value;  				break;  			}  		}  	}  	int start = (int)pdHr.Index [0].Offset.Value + (int)mHdr.FullNameOffset.Value;  	sw.Position = start;  	title = sw.ReadString ((int)mHdr.FullNamelength.Value);  	#endregion  }  else {  	#region TEXt FileHeader  	sw.Position = (int)pdHr.Index [0].Offset.Value;  	sw.Position = (int)pdHr.Index [1].Offset.Value;  	string text = MobiFileReader.Uncompress (sw.ReadBlock (800));  	int i = text.IndexOf ("Title>") + "Title>".Length;  	int j = text.IndexOf ('<'' i);  	title = text.Substring (i' j - i);  	i = text.IndexOf ("Creator>"' j) + "Creator>".Length;  	j = text.IndexOf ('<'' i);  	author = text.Substring (i' j - i);  	i = text.IndexOf ("Date>"' j) + "Date>".Length;  	j = text.IndexOf ('<'' i);  	date = text.Substring (i' j - i);  	sw.Position = (int)pdHr.Index [2].Offset.Value;  	#endregion  }  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: if ((string)pdHr.Creator.Value == "MOBI") {  	#region MOBI FileHeader  	sw.ReadBytes (2);  	//Gap to data  	compression = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	//(uint)sw.ReadShort();//Compression  	sw.ReadBytes (2);  	//unused  	textLength = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();  	recordCount = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(uint)sw.ReadShort();//Number of PDB records used for the text of the book.  	recordSize = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(uint)sw.ReadShort();//Number of PDB records used for the text of the book.  	currentPosition = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();//current position in the text  	mHdr = new mobiHdr (sw);  	if ((int)mHdr.Exthflags.Value != 0) {  		extHdr = new ExtHdr (sw);  		for (int u = 0; u < (int)extHdr.RecCount.Value; u++) {  			exthEntry entry = new exthEntry (sw);  			extHdr.index.Add (entry);  			switch ((int)entry.Typeext.Value) {  			case 100:  				author = (string)entry.Data.Value;  				break;  			case 101:  				publisher = (string)entry.Data.Value;  				break;  			}  		}  	}  	int start = (int)pdHr.Index [0].Offset.Value + (int)mHdr.FullNameOffset.Value;  	sw.Position = start;  	title = sw.ReadString ((int)mHdr.FullNamelength.Value);  	#endregion  }  else {  	#region TEXt FileHeader  	sw.Position = (int)pdHr.Index [0].Offset.Value;  	sw.Position = (int)pdHr.Index [1].Offset.Value;  	string text = MobiFileReader.Uncompress (sw.ReadBlock (800));  	int i = text.IndexOf ("Title>") + "Title>".Length;  	int j = text.IndexOf ('<'' i);  	title = text.Substring (i' j - i);  	i = text.IndexOf ("Creator>"' j) + "Creator>".Length;  	j = text.IndexOf ('<'' i);  	author = text.Substring (i' j - i);  	i = text.IndexOf ("Date>"' j) + "Date>".Length;  	j = text.IndexOf ('<'' i);  	date = text.Substring (i' j - i);  	sw.Position = (int)pdHr.Index [2].Offset.Value;  	#endregion  }  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: if ((string)pdHr.Creator.Value == "MOBI") {  	#region MOBI FileHeader  	sw.ReadBytes (2);  	//Gap to data  	compression = new ELEMENTARY_TYPE (sw' 0' typeof(short));  	//(uint)sw.ReadShort();//Compression  	sw.ReadBytes (2);  	//unused  	textLength = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();  	recordCount = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(uint)sw.ReadShort();//Number of PDB records used for the text of the book.  	recordSize = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(uint)sw.ReadShort();//Number of PDB records used for the text of the book.  	currentPosition = new ELEMENTARY_TYPE (sw' 0' typeof(int));  	//(int)sw.ReadInteger();//current position in the text  	mHdr = new mobiHdr (sw);  	if ((int)mHdr.Exthflags.Value != 0) {  		extHdr = new ExtHdr (sw);  		for (int u = 0; u < (int)extHdr.RecCount.Value; u++) {  			exthEntry entry = new exthEntry (sw);  			extHdr.index.Add (entry);  			switch ((int)entry.Typeext.Value) {  			case 100:  				author = (string)entry.Data.Value;  				break;  			case 101:  				publisher = (string)entry.Data.Value;  				break;  			}  		}  	}  	int start = (int)pdHr.Index [0].Offset.Value + (int)mHdr.FullNameOffset.Value;  	sw.Position = start;  	title = sw.ReadString ((int)mHdr.FullNamelength.Value);  	#endregion  }  else {  	#region TEXt FileHeader  	sw.Position = (int)pdHr.Index [0].Offset.Value;  	sw.Position = (int)pdHr.Index [1].Offset.Value;  	string text = MobiFileReader.Uncompress (sw.ReadBlock (800));  	int i = text.IndexOf ("Title>") + "Title>".Length;  	int j = text.IndexOf ('<'' i);  	title = text.Substring (i' j - i);  	i = text.IndexOf ("Creator>"' j) + "Creator>".Length;  	j = text.IndexOf ('<'' i);  	author = text.Substring (i' j - i);  	i = text.IndexOf ("Date>"' j) + "Date>".Length;  	j = text.IndexOf ('<'' i);  	date = text.Substring (i' j - i);  	sw.Position = (int)pdHr.Index [2].Offset.Value;  	#endregion  }  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: sw.ReadBytes (2);  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: sw.ReadBytes (2);  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: if ((int)mHdr.Exthflags.Value != 0) {  	extHdr = new ExtHdr (sw);  	for (int u = 0; u < (int)extHdr.RecCount.Value; u++) {  		exthEntry entry = new exthEntry (sw);  		extHdr.index.Add (entry);  		switch ((int)entry.Typeext.Value) {  		case 100:  			author = (string)entry.Data.Value;  			break;  		case 101:  			publisher = (string)entry.Data.Value;  			break;  		}  	}  }  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: if ((int)mHdr.Exthflags.Value != 0) {  	extHdr = new ExtHdr (sw);  	for (int u = 0; u < (int)extHdr.RecCount.Value; u++) {  		exthEntry entry = new exthEntry (sw);  		extHdr.index.Add (entry);  		switch ((int)entry.Typeext.Value) {  		case 100:  			author = (string)entry.Data.Value;  			break;  		case 101:  			publisher = (string)entry.Data.Value;  			break;  		}  	}  }  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: for (int u = 0; u < (int)extHdr.RecCount.Value; u++) {  	exthEntry entry = new exthEntry (sw);  	extHdr.index.Add (entry);  	switch ((int)entry.Typeext.Value) {  	case 100:  		author = (string)entry.Data.Value;  		break;  	case 101:  		publisher = (string)entry.Data.Value;  		break;  	}  }  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: for (int u = 0; u < (int)extHdr.RecCount.Value; u++) {  	exthEntry entry = new exthEntry (sw);  	extHdr.index.Add (entry);  	switch ((int)entry.Typeext.Value) {  	case 100:  		author = (string)entry.Data.Value;  		break;  	case 101:  		publisher = (string)entry.Data.Value;  		break;  	}  }  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: switch ((int)entry.Typeext.Value) {  case 100:  	author = (string)entry.Data.Value;  	break;  case 101:  	publisher = (string)entry.Data.Value;  	break;  }  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: switch ((int)entry.Typeext.Value) {  case 100:  	author = (string)entry.Data.Value;  	break;  case 101:  	publisher = (string)entry.Data.Value;  	break;  }  
Magic Number,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following statement contains a magic number: sw.Position = (int)pdHr.Index [2].Offset.Value;  
Magic Number,BookReader,PrcPage,C:\repos\mbatest_Binhed\BookReader\Readers.cs,ToString,The following statement contains a magic number: return text.Substring (0' 40);  
Missing Default,BookReader,LrfObject,C:\repos\mbatest_Binhed\BookReader\Lrf.cs,LrfObject,The following switch statement is missing a default case: switch (objType) {  case LrfObjectType.Toc:  	//LrfTags[3].Data.Value  	string s = Encoding.Unicode.GetString ((byte[])LrfTags [3].Data.Value);  	BitStreamReader ms = new BitStreamReader ((byte[])LrfTags [3].Data.Value' false);  	tc = new TOC (ms' LrfTags [3].PositionOfStructureInFile + 2);  	break;  case LrfObjectType.Text:  	#region Decompress and parse text  	Text = new ELEMENTARY_TYPE (Uncompress ()' LrfTags [4].PositionOfStructureInFile' LrfTags [4].LengthInFile);  	#endregion  	break;  case LrfObjectType.Block:  	ParseLinks (4);  	break;  case LrfObjectType.Page:  	ParseLinks (6);  	break;  case LrfObjectType.Canvas:  	/*                      *                                     Buffer.BlockCopy((byte[])ob.LrfTags[2].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer);                                     Buffer.BlockCopy((byte[])ob.LrfTags[6].Data.Value' 0' buffer' 0' 2);                                     c.Height = (int)ReadShortUint(buffer); */break;  }  
Missing Default,BookReader,LRFFileReader,C:\repos\mbatest_Binhed\BookReader\LrfReader.cs,ParseXml,The following switch statement is missing a default case: switch (textReader.Name) {  case "Page":  	string page = textReader.ReadElementString ();  	break;  case "Creator":  	creator = textReader.ReadElementString ();  	break;  case "Language":  	language = textReader.ReadElementString ();  	break;  case "BookID":  	bookId = textReader.ReadElementString ();  	break;  case "Author":  	if (textReader.GetAttribute ("reading") != null) {  		author = textReader.GetAttribute ("reading");  	}  	author = textReader.ReadElementString ();  	break;  case "Title":  	if (textReader.GetAttribute ("reading") != null) {  		title = textReader.GetAttribute ("reading");  	}  	title = textReader.ReadElementString ();  	break;  case "CreationDate":  	date = textReader.ReadElementString ().Trim ();  	break;  case "Publisher":  	publisher = textReader.ReadElementString ().Trim ();  	break;  case "FreeText":  	freeText = textReader.ReadElementString ().Trim ();  	break;  }  
Missing Default,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following switch statement is missing a default case: switch (pf.ObjectType) {  case "Page":  	if (pf.RawStreamData == null)  		pf.RawStreamData = pdf.RawStreamData;  	else {  		byte[] buf = new byte[pdf.RawStreamData.Length + pf.RawStreamData.Length];  		Buffer.BlockCopy (pf.RawStreamData' 0' buf' 0' pf.RawStreamData.Length);  		Buffer.BlockCopy (pdf.RawStreamData' 0' buf' pf.RawStreamData.Length' pdf.RawStreamData.Length);  		pdf.StreamData = buf;  	}  	Encoding enc = Encoding.Default;  	pdf.DecodedStream = enc.GetString (pdf.RawStreamData);  	break;  }  
Missing Default,BookReader,PdfReader,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,ParseDic,The following switch statement is missing a default case: switch (pf.ObjectType) {  case "Page":  	Encoding enc = Encoding.Default;  	if (pdf.StreamData != null)  		pdf.DecodedStream = enc.GetString (pdf.StreamData);  	break;  case "Metadata":  	pdf.DecodedStream = encoder.GetString (pdf.RawStreamData);  	break;  case "FontDescriptor":  	break;  }  
Missing Default,BookReader,Trailer,C:\repos\mbatest_Binhed\BookReader\PdfReader.cs,Trailer,The following switch statement is missing a default case: switch (tt [0]) {  case "Size":  	docSize = d;  	break;  case "Root":  	root = d;  	break;  case "Info":  	info = d;  	break;  case "Prev":  	prev = d;  	break;  case "XRefStm":  	XRefStm = d;  	break;  }  
Missing Default,BookReader,Header,C:\repos\mbatest_Binhed\BookReader\Readers.cs,Header,The following switch statement is missing a default case: switch ((int)entry.Typeext.Value) {  case 100:  	author = (string)entry.Data.Value;  	break;  case 101:  	publisher = (string)entry.Data.Value;  	break;  }  
