Implementation smell,Namespace,Class,File,Method,Description
Long Method,Utils,Crc32_,C:\repos\mbatest_Binhed\Utils\Utils.cs,CountCrc,The method has 268 lines of code.
Complex Method,Utils,ELEMENTARY_TYPE,C:\repos\mbatest_Binhed\Utils\ElemantaryType.cs,ELEMENTARY_TYPE,Cyclomatic complexity of the method is 36
Complex Method,Utils,ELEMENTARY_TYPE,C:\repos\mbatest_Binhed\Utils\ElemantaryType.cs,ELEMENTARY_TYPE,Cyclomatic complexity of the method is 24
Complex Method,Utils,ELEMENTARY_TYPE,C:\repos\mbatest_Binhed\Utils\ElemantaryType.cs,ToString,Cyclomatic complexity of the method is 11
Complex Method,Utils,FileType,C:\repos\mbatest_Binhed\Utils\Utils.cs,FileType,Cyclomatic complexity of the method is 42
Long Parameter List,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,BinaryFileReader,The method has 5 parameters.
Long Parameter List,Utils,FileType,C:\repos\mbatest_Binhed\Utils\Utils.cs,FileType,The method has 5 parameters.
Long Parameter List,Utils,Crc32,C:\repos\mbatest_Binhed\Utils\Utils.cs,CalculateHash,The method has 5 parameters.
Long Statement,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadPts_dts,The length of the statement  "	long p = (pts [0] & 0x0E << 29) + ((pts [1] & 0x7F) << 21) + ((pts [2] & 0xFE) << 14) + (pts [3] << 7) + ((pts [4] & 0xFE) >> 1); " is 129.
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,ReadStringZ,The following statement contains a magic number: if (eng == Encoding.Unicode) {  	byte[] a = ReadBytes (2);  	while (a [0] != 0) {  		bytes.Add (a [0]);  		bytes.Add (a [1]);  		a = ReadBytes (2);  	}  }  else {  	byte[] a = ReadBytes (1);  	while (a [0] != 0) {  		bytes.Add (a [0]);  		a = ReadBytes (1);  	}  }  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,ReadStringZ,The following statement contains a magic number: if (eng == Encoding.Unicode) {  	byte[] a = ReadBytes (2);  	while (a [0] != 0) {  		bytes.Add (a [0]);  		bytes.Add (a [1]);  		a = ReadBytes (2);  	}  }  else {  	byte[] a = ReadBytes (1);  	while (a [0] != 0) {  		bytes.Add (a [0]);  		a = ReadBytes (1);  	}  }  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,ReadStringZ,The following statement contains a magic number: while (a [0] != 0) {  	bytes.Add (a [0]);  	bytes.Add (a [1]);  	a = ReadBytes (2);  }  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,ReadStringZ,The following statement contains a magic number: a = ReadBytes (2);  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,ReadShort,The following statement contains a magic number: return (short)BytesToInteger (ReadBytes (2));  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,ReadInteger,The following statement contains a magic number: return (int)BytesToInteger (ReadBytes (4));  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,ReadLongInteger,The following statement contains a magic number: return BytesToInteger (ReadBytes (8));  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,ReadIndex,The following statement contains a magic number: switch (offType) {  case 2:  	return ReadShort ();  case 4:  	return ReadInteger ();  default:  	return 0;  }  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,ReadIndex,The following statement contains a magic number: switch (offType) {  case 2:  	return ReadShort ();  case 4:  	return ReadInteger ();  default:  	return 0;  }  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,FromBCD,The following statement contains a magic number: return digit1 * 10 + digit2;  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,BytesToInteger,The following statement contains a magic number: if (littleEndian) {  	for (int w = 0; w < c.Length; w++) {  		data = 256 * data + (uint)c [c.Length - 1 - w];  	}  }  else {  	for (int w = c.Length - 1; w >= 0; w--) {  		data = 256 * data + (uint)c [c.Length - 1 - w];  	}  }  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,BytesToInteger,The following statement contains a magic number: if (littleEndian) {  	for (int w = 0; w < c.Length; w++) {  		data = 256 * data + (uint)c [c.Length - 1 - w];  	}  }  else {  	for (int w = c.Length - 1; w >= 0; w--) {  		data = 256 * data + (uint)c [c.Length - 1 - w];  	}  }  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,BytesToInteger,The following statement contains a magic number: for (int w = 0; w < c.Length; w++) {  	data = 256 * data + (uint)c [c.Length - 1 - w];  }  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,BytesToInteger,The following statement contains a magic number: data = 256 * data + (uint)c [c.Length - 1 - w];  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,BytesToInteger,The following statement contains a magic number: for (int w = c.Length - 1; w >= 0; w--) {  	data = 256 * data + (uint)c [c.Length - 1 - w];  }  
Magic Number,Utils,BinaryFileReader,C:\repos\mbatest_Binhed\Utils\BinaryFileReader.cs,BytesToInteger,The following statement contains a magic number: data = 256 * data + (uint)c [c.Length - 1 - w];  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadBit,The following statement contains a magic number: if (currentBit == 8) {  	Position++;  	currentBit = 0;  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadBit,The following statement contains a magic number: value = value >> (7 - bitIndex);  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,RangeToInt,The following statement contains a magic number: for (int k = 0; k < bits.Count; k++) {  	i = (i * 2 + bits [k]);  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,RangeToInt,The following statement contains a magic number: i = (i * 2 + bits [k]);  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadLongFromBits,The following statement contains a magic number: return ReadIntFromBits (8);  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadShortFromBits,The following statement contains a magic number: return ReadIntFromBits (2);  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadIntFromBits,The following statement contains a magic number: if (littleEndian) {  	for (int k = 0; k < length; k++) {  		i = (i * 2 + bytes [k]);  	}  }  else {  	for (int k = length - 1; k >= 0; k--) {  		i = (i * 2 + bytes [k]);  	}  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadIntFromBits,The following statement contains a magic number: if (littleEndian) {  	for (int k = 0; k < length; k++) {  		i = (i * 2 + bytes [k]);  	}  }  else {  	for (int k = length - 1; k >= 0; k--) {  		i = (i * 2 + bytes [k]);  	}  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadIntFromBits,The following statement contains a magic number: for (int k = 0; k < length; k++) {  	i = (i * 2 + bytes [k]);  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadIntFromBits,The following statement contains a magic number: i = (i * 2 + bytes [k]);  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadIntFromBits,The following statement contains a magic number: for (int k = length - 1; k >= 0; k--) {  	i = (i * 2 + bytes [k]);  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadIntFromBits,The following statement contains a magic number: i = (i * 2 + bytes [k]);  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadIntegerFromBits,The following statement contains a magic number: if (littleEndian) {  	for (int k = 0; k < length; k++) {  		i = (i * 2 + (ulong)bits [k]);  	}  }  else {  	for (int k = length - 1; k >= 0; k--) {  		i = (i * 2 + (ulong)bits [k]);  	}  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadIntegerFromBits,The following statement contains a magic number: if (littleEndian) {  	for (int k = 0; k < length; k++) {  		i = (i * 2 + (ulong)bits [k]);  	}  }  else {  	for (int k = length - 1; k >= 0; k--) {  		i = (i * 2 + (ulong)bits [k]);  	}  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadIntegerFromBits,The following statement contains a magic number: for (int k = 0; k < length; k++) {  	i = (i * 2 + (ulong)bits [k]);  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadIntegerFromBits,The following statement contains a magic number: i = (i * 2 + (ulong)bits [k]);  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadIntegerFromBits,The following statement contains a magic number: for (int k = length - 1; k >= 0; k--) {  	i = (i * 2 + (ulong)bits [k]);  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadIntegerFromBits,The following statement contains a magic number: i = (i * 2 + (ulong)bits [k]);  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadGolomb,The following statement contains a magic number: if (currentBit == -1) {  	Position--;  	currentBit = 7;  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadGolomb,The following statement contains a magic number: currentBit = 7;  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ue,The following statement contains a magic number: while (ReadBit () == 0 && i < 32 && BitPosition < Length * 8) {  	i++;  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ue,The following statement contains a magic number: while (ReadBit () == 0 && i < 32 && BitPosition < Length * 8) {  	i++;  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,se,The following statement contains a magic number: if ((r & 0x01) == 0x01) {  	r = (r + 1) / 2;  }  else {  	r = -(r / 2);  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,se,The following statement contains a magic number: if ((r & 0x01) == 0x01) {  	r = (r + 1) / 2;  }  else {  	r = -(r / 2);  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,se,The following statement contains a magic number: r = (r + 1) / 2;  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,se,The following statement contains a magic number: r = -(r / 2);  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadPts_dts,The following statement contains a magic number: Buffer.BlockCopy (buffer' (int)Position' pts' 0' 5);  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadPts_dts,The following statement contains a magic number: return p / 90;  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,SkipByte,The following statement contains a magic number: BitPosition += i * 8;  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadVint,The following statement contains a magic number: if (x == 1) {  	BitPosition--;  	ret = new ELEMENTARY_TYPE (this' 0' typeof(byte));  }  else {  	x = ReadBit ();  	BitPosition -= 2;  	ret = new ELEMENTARY_TYPE (this' 0' typeof(byte));  }  
Magic Number,Utils,BitStreamReader,C:\repos\mbatest_Binhed\Utils\BitStreamReader2.cs,ReadVint,The following statement contains a magic number: BitPosition -= 2;  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToInteger,The following statement contains a magic number: if (littleEndian) {  	for (int w = 0; w < c.Length; w++) {  		data = 256 * data + (uint)c [c.Length - 1 - w];  	}  }  else {  	for (int w = c.Length - 1; w >= 0; w--) {  		data = 256 * data + (uint)c [c.Length - 1 - w];  	}  }  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToInteger,The following statement contains a magic number: if (littleEndian) {  	for (int w = 0; w < c.Length; w++) {  		data = 256 * data + (uint)c [c.Length - 1 - w];  	}  }  else {  	for (int w = c.Length - 1; w >= 0; w--) {  		data = 256 * data + (uint)c [c.Length - 1 - w];  	}  }  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToInteger,The following statement contains a magic number: for (int w = 0; w < c.Length; w++) {  	data = 256 * data + (uint)c [c.Length - 1 - w];  }  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToInteger,The following statement contains a magic number: data = 256 * data + (uint)c [c.Length - 1 - w];  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToInteger,The following statement contains a magic number: for (int w = c.Length - 1; w >= 0; w--) {  	data = 256 * data + (uint)c [c.Length - 1 - w];  }  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToInteger,The following statement contains a magic number: data = 256 * data + (uint)c [c.Length - 1 - w];  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToLong,The following statement contains a magic number: if (littleEndian) {  	for (int w = 0; w < c.Length; w++) {  		taille = 256 * taille + (uint)c [c.Length - 1 - w];  	}  }  else {  	for (int w = c.Length - 1; w >= 0; w--) {  		taille = 256 * taille + (uint)c [c.Length - 1 - w];  	}  }  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToLong,The following statement contains a magic number: if (littleEndian) {  	for (int w = 0; w < c.Length; w++) {  		taille = 256 * taille + (uint)c [c.Length - 1 - w];  	}  }  else {  	for (int w = c.Length - 1; w >= 0; w--) {  		taille = 256 * taille + (uint)c [c.Length - 1 - w];  	}  }  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToLong,The following statement contains a magic number: for (int w = 0; w < c.Length; w++) {  	taille = 256 * taille + (uint)c [c.Length - 1 - w];  }  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToLong,The following statement contains a magic number: taille = 256 * taille + (uint)c [c.Length - 1 - w];  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToLong,The following statement contains a magic number: for (int w = c.Length - 1; w >= 0; w--) {  	taille = 256 * taille + (uint)c [c.Length - 1 - w];  }  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToLong,The following statement contains a magic number: taille = 256 * taille + (uint)c [c.Length - 1 - w];  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToShortInteger,The following statement contains a magic number: if (littleEndian) {  	taille = 256 * (uint)c [1] + (uint)c [0];  }  else {  	taille = 256 * (uint)c [0] + (uint)c [1];  }  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToShortInteger,The following statement contains a magic number: if (littleEndian) {  	taille = 256 * (uint)c [1] + (uint)c [0];  }  else {  	taille = 256 * (uint)c [0] + (uint)c [1];  }  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToShortInteger,The following statement contains a magic number: taille = 256 * (uint)c [1] + (uint)c [0];  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ByteToShortInteger,The following statement contains a magic number: taille = 256 * (uint)c [0] + (uint)c [1];  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ReadInteger,The following statement contains a magic number: Buffer.BlockCopy (buffer' add' n' 0' 4);  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,ReadShortInteger,The following statement contains a magic number: Buffer.BlockCopy (buffer' add' n' 0' 2);  
Magic Number,Utils,BufferConvert,C:\repos\mbatest_Binhed\Utils\Convert.cs,FromBCD,The following statement contains a magic number: return digit1 * 10 + digit2;  
Magic Number,Utils,ELEMENTARY_TYPE,C:\repos\mbatest_Binhed\Utils\ElemantaryType.cs,ELEMENTARY_TYPE,The following statement contains a magic number: LengthInFile = 4;  
Magic Number,Utils,Crc32_,C:\repos\mbatest_Binhed\Utils\Utils.cs,CountCrc,The following statement contains a magic number: for (i = 0; i < n; i++) {  	c = crctab [((int)c ^ pBuf [i]) & 0xff] ^ (c >> 8);  }  
Magic Number,Utils,Crc32_,C:\repos\mbatest_Binhed\Utils\Utils.cs,CountCrc,The following statement contains a magic number: c = crctab [((int)c ^ pBuf [i]) & 0xff] ^ (c >> 8);  
Magic Number,Utils,Crc32,C:\repos\mbatest_Binhed\Utils\Utils.cs,InitializeTable,The following statement contains a magic number: for (var i = 0; i < 256; i++) {  	var entry = (UInt32)i;  	for (var j = 0; j < 8; j++)  		if ((entry & 1) == 1)  			entry = (entry >> 1) ^ polynomial;  		else  			entry = entry >> 1;  	createTable [i] = entry;  }  
Magic Number,Utils,Crc32,C:\repos\mbatest_Binhed\Utils\Utils.cs,InitializeTable,The following statement contains a magic number: for (var i = 0; i < 256; i++) {  	var entry = (UInt32)i;  	for (var j = 0; j < 8; j++)  		if ((entry & 1) == 1)  			entry = (entry >> 1) ^ polynomial;  		else  			entry = entry >> 1;  	createTable [i] = entry;  }  
Magic Number,Utils,Crc32,C:\repos\mbatest_Binhed\Utils\Utils.cs,InitializeTable,The following statement contains a magic number: for (var j = 0; j < 8; j++)  	if ((entry & 1) == 1)  		entry = (entry >> 1) ^ polynomial;  	else  		entry = entry >> 1;  
Magic Number,Utils,Crc32,C:\repos\mbatest_Binhed\Utils\Utils.cs,CalculateHash,The following statement contains a magic number: for (var i = start; i < size - start; i++)  	crc = (crc >> 8) ^ table [buffer [i] ^ crc & 0xff];  
Magic Number,Utils,Crc32,C:\repos\mbatest_Binhed\Utils\Utils.cs,CalculateHash,The following statement contains a magic number: crc = (crc >> 8) ^ table [buffer [i] ^ crc & 0xff];  
Missing Default,Utils,ELEMENTARY_TYPE,C:\repos\mbatest_Binhed\Utils\ElemantaryType.cs,ELEMENTARY_TYPE,The following switch statement is missing a default case: switch (t.Name) {  case "Byte":  	byte ub = sw.ReadByte ();  	value = ub;  	break;  case "Int16":  	short us = sw.ReadShort ();  	value = us;  	break;  case "UInt16":  	ushort u = (ushort)sw.ReadShort ();  	value = u;  	break;  case "Int32":  	int uis = sw.ReadInteger ();  	value = uis;  	break;  case "UInt32":  	uint ui = (uint)sw.ReadInteger ();  	value = ui;  	break;  case "UInt64":  	ulong ulb = (ulong)sw.ReadLong ();  	value = ulb;  	break;  case "Int64":  	long ul = sw.ReadLong ();  	value = ul;  	break;  case "DateTime":  	long ud = sw.ReadLong ();  	value = ToDateTime (ud);  	break;  case "Guid":  	Guid g = new Guid (sw.ReadBytes (0x10));  	value = g;  	break;  }  
Missing Default,Utils,ELEMENTARY_TYPE,C:\repos\mbatest_Binhed\Utils\ElemantaryType.cs,ELEMENTARY_TYPE,The following switch statement is missing a default case: switch (t.Name) {  case "Int32":  	int uis = (int)sw.ReadIntegerFromBytes (length);  	value = uis;  	break;  case "UInt32":  	uint ui = (uint)sw.ReadIntegerFromBytes (length);  	value = ui;  	break;  case "UInt64":  	ulong ulb = (ulong)sw.ReadIntegerFromBytes (length);  	value = ulb;  	break;  case "Int64":  	long ul = sw.ReadIntegerFromBytes (length);  	value = ul;  	break;  case "Byte[]":  	byte[] b = sw.ReadBlock (length);  	value = b;  	break;  case "Bitmap":  	byte[] im = sw.ReadBlock (length);  	using (MemoryStream ts = new MemoryStream (im' 0' length)) {  		Image thumbnail = Image.FromStream (ts);  		value = thumbnail;  	}  	break;  /*               case "Short[]":                                    short[] bs = sw.ReadBytes(length);                                    value = bs;                                    break;                                case "Int32[]":                                    int[] bi = sw.ReadBytes(length);                                    value = bi;                                    break;                                case "Int64[]":                                    long[] bl = sw.ReadBytes(length);                                    value = bl;                                    break;*/}  
Missing Default,Utils,FileType,C:\repos\mbatest_Binhed\Utils\Utils.cs,FileType,The following switch statement is missing a default case: switch (cat) {  case "web":  	category = FileCategory.web;  	break;  case "office":  	category = FileCategory.office;  	break;  case "audio":  	category = FileCategory.audio;  	break;  case "video":  	category = FileCategory.video;  	break;  case "bluray":  	category = FileCategory.bluray;  	break;  case "dvd":  	category = FileCategory.dvd;  	break;  case "database":  	category = FileCategory.database;  	break;  case "code":  	category = FileCategory.code;  	break;  case "cabinet":  	category = FileCategory.cabinet;  	break;  case "compressed":  	category = FileCategory.compressed;  	break;  case "font":  	category = FileCategory.font;  	break;  case "help":  	category = FileCategory.help;  	break;  case "image":  	category = FileCategory.image;  	break;  case "text":  	category = FileCategory.text;  	break;  }  
