Implementation smell,Namespace,Class,File,Method,Description
Long Method,LowLevel,HardwareViewer,C:\repos\mbatest_Binhed\LowLevel\HardwareViewer.cs,Init,The method has 282 lines of code.
Long Method,LowLevel,DiskAccess,C:\repos\mbatest_Binhed\LowLevel\System.cs,Drives,The method has 109 lines of code.
Long Method,LowLevel,Win32_CDROMDrive,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_CDROMDrive,The method has 100 lines of code.
Long Method,LowLevel,Win32_DiskDrive,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_DiskDrive,The method has 104 lines of code.
Long Method,LowLevel,Win32_ComputerSystem,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_ComputerSystem,The method has 118 lines of code.
Long Method,LowLevel,Win32_OperatingSystem,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_OperatingSystem,The method has 127 lines of code.
Long Method,LowLevel,Win32_VideoController,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_VideoController,The method has 120 lines of code.
Complex Method,LowLevel,ATTRIBUTE_RECORD_HEADER,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,ATTRIBUTE_RECORD_HEADER,Cyclomatic complexity of the method is 8
Complex Method,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,Cyclomatic complexity of the method is 10
Complex Method,LowLevel,FILE_RECORD_SEGMENT,C:\repos\mbatest_Binhed\LowLevel\MFT.cs,FILE_RECORD_SEGMENT,Cyclomatic complexity of the method is 11
Complex Method,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,RequestData,Cyclomatic complexity of the method is 13
Complex Method,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ParseBlock,Cyclomatic complexity of the method is 12
Complex Method,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,Cyclomatic complexity of the method is 39
Complex Method,LowLevel,LowLevelViewer,C:\repos\mbatest_Binhed\LowLevel\Form1.cs,FillTreeNode,Cyclomatic complexity of the method is 40
Complex Method,LowLevel,HardwareViewer,C:\repos\mbatest_Binhed\LowLevel\HardwareViewer.cs,Init,Cyclomatic complexity of the method is 40
Complex Method,LowLevel,DiskAccess,C:\repos\mbatest_Binhed\LowLevel\System.cs,Drives,Cyclomatic complexity of the method is 25
Complex Method,LowLevel,Win32_BIOS,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_BIOS,Cyclomatic complexity of the method is 27
Complex Method,LowLevel,Win32_BootConfiguration,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_BootConfiguration,Cyclomatic complexity of the method is 10
Complex Method,LowLevel,Win32_DiskPartition,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_DiskPartition,Cyclomatic complexity of the method is 35
Complex Method,LowLevel,Win32_Fan,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_Fan,Cyclomatic complexity of the method is 23
Complex Method,LowLevel,Win32_MotherboardDevice,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_MotherboardDevice,Cyclomatic complexity of the method is 23
Complex Method,LowLevel,Win32_Processor,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_Processor,Cyclomatic complexity of the method is 49
Complex Method,LowLevel,Win32_CDROMDrive,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_CDROMDrive,Cyclomatic complexity of the method is 50
Complex Method,LowLevel,Win32_DiskDrive,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_DiskDrive,Cyclomatic complexity of the method is 52
Complex Method,LowLevel,Win32_Battery,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_Battery,Cyclomatic complexity of the method is 34
Complex Method,LowLevel,Win32_ComputerSystem,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_ComputerSystem,Cyclomatic complexity of the method is 59
Complex Method,LowLevel,Win32_Volume,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_Volume,Cyclomatic complexity of the method is 42
Complex Method,LowLevel,Win32_LogicalDisk,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_LogicalDisk,Cyclomatic complexity of the method is 41
Complex Method,LowLevel,Win32_MemoryArray,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_MemoryArray,Cyclomatic complexity of the method is 40
Complex Method,LowLevel,Win32_MemoryDevice,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_MemoryDevice,Cyclomatic complexity of the method is 40
Complex Method,LowLevel,Win32_Keyboard,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_Keyboard,Cyclomatic complexity of the method is 24
Complex Method,LowLevel,Win32_NetworkAdapter,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_NetworkAdapter,Cyclomatic complexity of the method is 41
Complex Method,LowLevel,Win32_OperatingSystem,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_OperatingSystem,Cyclomatic complexity of the method is 63
Complex Method,LowLevel,Win32_VideoController,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_VideoController,Cyclomatic complexity of the method is 60
Complex Method,LowLevel,Win32_DesktopMonitor,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_DesktopMonitor,Cyclomatic complexity of the method is 29
Complex Method,LowLevel,Win32_PointingDevice,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_PointingDevice,Cyclomatic complexity of the method is 34
Complex Method,LowLevel,Win32_BaseBoard,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_BaseBoard,Cyclomatic complexity of the method is 30
Complex Method,LowLevel,Win32_USBHub,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_USBHub,Cyclomatic complexity of the method is 29
Complex Method,LowLevel,Win32_CodecFile,C:\repos\mbatest_Binhed\LowLevel\HardWare.cs,Win32_CodecFile,Cyclomatic complexity of the method is 35
Long Parameter List,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,CreateFile,The method has 7 parameters.
Long Parameter List,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadFile,The method has 5 parameters.
Long Parameter List,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,WriteFile,The method has 5 parameters.
Long Parameter List,LowLevel,LowLevelViewer,C:\repos\mbatest_Binhed\LowLevel\Form1.cs,CreateFile,The method has 7 parameters.
Long Parameter List,LowLevel,LowLevelViewer,C:\repos\mbatest_Binhed\LowLevel\Form1.cs,ReadFile,The method has 5 parameters.
Long Parameter List,LowLevel,RawAccess,C:\repos\mbatest_Binhed\LowLevel\RawAccess.cs,CreateFile,The method has 7 parameters.
Long Parameter List,LowLevel,RawAccess,C:\repos\mbatest_Binhed\LowLevel\RawAccess.cs,DeviceIoControl,The method has 8 parameters.
Long Statement,LowLevel,Partition,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,ClusterToSector,The length of the statement  "		return directoryOffset + /*((short)((BootRecord_Fat16)Boot_Sector).Root_Directory_Entries.Value * 0x20)/(short) Boot_Sector.Bytes_Per_Sector.Value+*/(cluster) * (byte)((BootRecord_Fat16)Boot_Sector).Sectors_Per_Cluster.Value; " is 225.
Long Statement,LowLevel,ChsSector,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,ToString,The length of the statement  "	return "Head : " + head.ToString ("x2") + "' Cylinder : " + cylinder.ToString ("x2") + "' Secteur :" + sector.ToString ("x2"); " is 126.
Long Statement,LowLevel,BootRecord_Fat32,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,ClusterToSector,The length of the statement  "	return Size_of_System_Area + (int)Reserved_Sectors.Value + (int)Sectors_Per_FAT.Value * (byte)Number_of_Fats.Value + (cluster - 2) * (int)Sectors_Per_Cluster.Value; " is 164.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,RequestData,The length of the statement  "			BitStreamReader sw = new BitStreamReader (ReadSectors (st' 10 * (short)currentPartition.Boot_Sector.Bytes_Per_Sector.Value)' false); " is 132.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,RequestData,The length of the statement  "			Directory rd = new Directory (sw' currentPartition' st * (short)currentPartition.Boot_Sector.Bytes_Per_Sector.Value' 0); " is 120.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,RequestData,The length of the statement  "		long off = (uint)indx.FileReference.SegmentNumberLowPart.Value * 2 + currentPartition.ClusterToSector ((long)boot.MFT_Start.Value); " is 131.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,RequestData,The length of the statement  "		FILE_RECORD_SEGMENT fs = new FILE_RECORD_SEGMENT (sw' off * (short)boot.Bytes_Per_Sector.Value' currentPartition' (int)(uint)indx.FileReference.SegmentNumberLowPart.Value); " is 172.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,RequestData,The length of the statement  "		long off = (uint)att.Base_File_Reference_of_the_attribute.SegmentNumberLowPart.Value * 2 + currentPartition.ClusterToSector ((long)boot.MFT_Start.Value); " is 153.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,RequestData,The length of the statement  "		FILE_RECORD_SEGMENT fs = new FILE_RECORD_SEGMENT (sw' off * (short)boot.Bytes_Per_Sector.Value' currentPartition' (int)(uint)att.Base_File_Reference_of_the_attribute.SegmentNumberLowPart.Value); " is 194.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ParseBlock,The length of the statement  "		FILE_RECORD_SEGMENT fs = new FILE_RECORD_SEGMENT (new BitStreamReader (data' false)' sector * 0x200' currentPartition' 0); " is 122.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadsFirstSector,The length of the statement  "			currentDrive.Booting_Catalog = new Booting_Catalog (new BitStreamReader (sector' false)' (int)currentDrive.Boot_Record.Absolute_pointer_to_boot_catalog.Value * SizeBuffer); " is 172.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadsFirstSector,The length of the statement  "	byte[] record = ReadSector (drivestring' (int)currentDrive.Volume_Structure_Descriptor.Directory_Record.Directory_Record_Root_Directory.Value); " is 143.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadsFirstSector,The length of the statement  "	currentDrive.CD_RootDirectory = new CDDirectory (new BitStreamReader (record' true)' SizeBuffer * (int)currentDrive.Volume_Structure_Descriptor.Directory_Record.Directory_Record_Root_Directory.Value); " is 200.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadsFirstSector,The length of the statement  "		currentDrive.CD_RootDirectory.Subentries.Add (new CDDirectory (new BitStreamReader (record' true)' (int)dr.Directory_Record_Root_Directory.Value * SizeBuffer)); " is 160.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadSector,The length of the statement  "	SafeFileHandle handleValue = RawDiskAccess.CreateFile (drivestring' GENERIC_READ' FILE_SHARE_READ' IntPtr.Zero' OPEN_EXISTING' 0' IntPtr.Zero); " is 143.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ParseIndexAllocation,The length of the statement  "	long st = (long)(att.Nonresident.Startcluster * (byte)boot.Sectors_Per_Cluster.Value + (uint)boot.Hidden_Sectors.Value + p.Start_Partition); " is 140.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ParseIndexAllocation,The length of the statement  "		fs.Index.Add (new INDX (new BitStreamReader (ReadSectors (st' (int)boot.Cluster_Per_Index.Value * (byte)boot.Sectors_Per_Cluster.Value * (short)boot.Bytes_Per_Sector.Value)' false)' st * (short)boot.Bytes_Per_Sector.Value)); " is 224.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The length of the statement  "			p.Master_File_Table = new MFT (new BitStreamReader (ReadSectors (startMFT' FileRecordsNumber * 2 * (short)p.Boot_Sector.Bytes_Per_Sector.Value)' false)' startMFT * SizeBuffer' p' FileRecordsNumber); " is 198.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The length of the statement  "			p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (short)((BootRecord_Fat16)p.Boot_Sector).Sectors_Per_FAT.Value * 2; " is 162.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The length of the statement  "			BitStreamReader ms = new BitStreamReader (ReadSectors (p.directoryOffset' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value * 0x20)' false); " is 160.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The length of the statement  "			p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value); " is 177.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The length of the statement  "			p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (int)((BootRecord_Fat32)p.Boot_Sector).Sectors_Per_FAT.Value * (byte)((BootRecord_Fat32)p.Boot_Sector).Number_of_Fats.Value; " is 219.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The length of the statement  "			p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat32)p.Boot_Sector).Root_Directory_Entries.Value); " is 177.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadSectors,The length of the statement  "	SafeFileHandle handleValue = CreateFile (currentDrive.DeviceID' GENERIC_READ' FILE_SHARE_READ' IntPtr.Zero' OPEN_EXISTING' 0' IntPtr.Zero); " is 139.
Long Statement,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,WriteSectors,The length of the statement  "	SafeFileHandle handleValue = CreateFile (currentDrive.DeviceID' GENERIC_WRITE' 0' IntPtr.Zero' OPEN_EXISTING' 0' IntPtr.Zero); " is 126.
Long Statement,LowLevel,LowLevelViewer,C:\repos\mbatest_Binhed\LowLevel\Form1.cs,ReadSector,The length of the statement  "	SafeFileHandle handleValue = CreateFile (textBoxPath.Text' GENERIC_READ' 0' IntPtr.Zero' OPEN_EXISTING' 0' IntPtr.Zero); " is 120.
Empty Catch Block,LowLevel,INDEX_ENTRY,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,INDEX_ENTRY,The method has an empty catch block.
Empty Catch Block,LowLevel,INDEX_ENTRY_DATA,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,INDEX_ENTRY_DATA,The method has an empty catch block.
Empty Catch Block,LowLevel,INDEX_ENTRY_DATA,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,INDEX_ENTRY_DATA,The method has an empty catch block.
Empty Catch Block,LowLevel,INDEX_ENTRY_DATA,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,INDEX_ENTRY_DATA,The method has an empty catch block.
Empty Catch Block,LowLevel,INDEX_ENTRY_DATA,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,INDEX_ENTRY_DATA,The method has an empty catch block.
Empty Catch Block,LowLevel,MasterBootRecord,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,MasterBootRecord,The method has an empty catch block.
Empty Catch Block,LowLevel,LowLevelViewer,C:\repos\mbatest_Binhed\LowLevel\Form1.cs,FillTreeNode,The method has an empty catch block.
Magic Number,LowLevel,ATTRIBUTE_LIST_ENTRY,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,ATTRIBUTE_LIST_ENTRY,The following statement contains a magic number: if (LengthInFile % 8 > 0) {  	sw.ReadBytes (8 - ((int)LengthInFile % 8));  }  
Magic Number,LowLevel,ATTRIBUTE_LIST_ENTRY,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,ATTRIBUTE_LIST_ENTRY,The following statement contains a magic number: if (LengthInFile % 8 > 0) {  	sw.ReadBytes (8 - ((int)LengthInFile % 8));  }  
Magic Number,LowLevel,ATTRIBUTE_LIST_ENTRY,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,ATTRIBUTE_LIST_ENTRY,The following statement contains a magic number: if (LengthInFile % 8 > 0) {  	sw.ReadBytes (8 - ((int)LengthInFile % 8));  }  
Magic Number,LowLevel,ATTRIBUTE_LIST_ENTRY,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,ATTRIBUTE_LIST_ENTRY,The following statement contains a magic number: sw.ReadBytes (8 - ((int)LengthInFile % 8));  
Magic Number,LowLevel,ATTRIBUTE_LIST_ENTRY,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,ATTRIBUTE_LIST_ENTRY,The following statement contains a magic number: sw.ReadBytes (8 - ((int)LengthInFile % 8));  
Magic Number,LowLevel,ACL,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,ACL,The following statement contains a magic number: sw.ReadBytes (2);  
Magic Number,LowLevel,INDEX_ROOT,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,INDEX_ROOT,The following statement contains a magic number: attributeType = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 2);  
Magic Number,LowLevel,INDEX_ROOT,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,INDEX_ROOT,The following statement contains a magic number: padding = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 3);  
Magic Number,LowLevel,INDEX_HEADER,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,INDEX_HEADER,The following statement contains a magic number: padding = sw.ReadBytes (3);  
Magic Number,LowLevel,VOLUME_NAME,C:\repos\mbatest_Binhed\LowLevel\Attributes.cs,VOLUME_NAME,The following statement contains a magic number: volumeName = sw.ReadString (length / 2' Encoding.Unicode);  
Magic Number,LowLevel,Directory_Record,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Directory_Record,The following statement contains a magic number: sw.Position += 4;  
Magic Number,LowLevel,Directory_Record,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Directory_Record,The following statement contains a magic number: sw.Position += 4;  
Magic Number,LowLevel,Directory_Record,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Directory_Record,The following statement contains a magic number: recording_date = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 7);  
Magic Number,LowLevel,Directory_Record,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Directory_Record,The following statement contains a magic number: sw.Position += 2;  
Magic Number,LowLevel,Directory_Record,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Directory_Record,The following statement contains a magic number: if (((byte)length_of_File_Identifier.Value) > 8) {  	sw.Position -= (byte)length_of_File_Identifier.Value;  	file_Identifier = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' (byte)length_of_File_Identifier.Value - 2);  }  
Magic Number,LowLevel,Directory_Record,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Directory_Record,The following statement contains a magic number: if (((byte)length_of_File_Identifier.Value) > 8) {  	sw.Position -= (byte)length_of_File_Identifier.Value;  	file_Identifier = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' (byte)length_of_File_Identifier.Value - 2);  }  
Magic Number,LowLevel,Directory_Record,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Directory_Record,The following statement contains a magic number: file_Identifier = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' (byte)length_of_File_Identifier.Value - 2);  
Magic Number,LowLevel,Initial_Entry,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Initial_Entry,The following statement contains a magic number: unused2 = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 20);  
Magic Number,LowLevel,Validation_Entry,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Validation_Entry,The following statement contains a magic number: id_string = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 22);  
Magic Number,LowLevel,Validation_Entry,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Validation_Entry,The following statement contains a magic number: keyBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  
Magic Number,LowLevel,CDBootRecord,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,CDBootRecord,The following statement contains a magic number: identifier = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 5);  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: boot_System_Identifier = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 32);  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: boot_System = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 32);  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: sw.Position = 80;  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: sw.Position += 4;  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: sw.Position = 120;  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: sw.Position += 2;  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: sw.Position += 2;  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: sw.Position += 2;  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: sw.Position += 4;  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: sw.Position += 2;  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: sw.Position += 2;  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: sw.Position += 2;  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: sw.Position = 156;  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: sw.Position = 190;  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: volume_Set_Identifier = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 128);  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: publisher_Identifier = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 128);  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: data_Preparer_Identifier = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 128);  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: application_Identifier = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 128);  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: copyright_File_Identifier = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 36);  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: abstract_File_Identifier = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 36);  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: bibliographic_File_Identifier = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 36);  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: sw.Position = 813;  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: volume_Creation_Date = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 16);  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: volume_Modification_Date = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 16);  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: volume_Expiration_Date = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 16);  
Magic Number,LowLevel,Volume_Structure_Description,C:\repos\mbatest_Binhed\LowLevel\ECMA_167.cs,Volume_Structure_Description,The following statement contains a magic number: structData = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2041 - (int)sw.Position);  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (entryNumber < 0x50) {  	ELEMENTARY_TYPE st = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 05);  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE checksum = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	ELEMENTARY_TYPE mid = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 06);  	ELEMENTARY_TYPE cluster = new ELEMENTARY_TYPE (sw' offset' typeof(short));  	ELEMENTARY_TYPE end = new ELEMENTARY_TYPE (sw' offset' Encoding.Unicode' 02);  	nameBytes = new ELEMENTARY_TYPE ((string)st.Value + (string)mid.Value + (string)end.Value' offset);  	name = (string)nameBytes.Value;  	sw.Position = start + 0x20;  }  else {  	sw.Position--;  	nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  	//sw.ReadBytes(11);  	if (((byte[])nameBytes.Value) [0] == 0x00)  		return;  	attributes = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	reserved = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createHour = new ELEMENTARY_TYPE (sw' offset' typeof(byte));  	createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  	//sw.ReadBytes(2);  	startOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(ushort));  	;  	// sw.ReadShort();  	sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  	//sw.ReadBytes(4);  	switch (((byte[])nameBytes.Value) [0]) {  	case 0xE5:  		isDeleted = true;  		break;  	case 0x05:  		((byte[])nameBytes.Value) [0] = 0xE5;  		break;  	case 0x2E:  		//parent  		break;  	}  	if (HasLongFileName) {  		List<byte> by = new List<byte> ();  		name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  		name += Encoding.Unicode.GetString ((byte[])createTime.Value);  		name += Encoding.Unicode.GetString ((byte[])createDate.Value);  		name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  		name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  		name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  		name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  	}  	else {  		name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  		extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  	}  	startSector = p.ClusterToSector ((ushort)startOfFile.Value);  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: nameBytes = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 11);  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: createTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: createDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: lastAccessDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: eaIndex = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: lastModifiedTime = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: lastModifiedDate = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: sizeOfFile = new ELEMENTARY_TYPE (sw' offset' typeof(int)' 4);  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (HasLongFileName) {  	List<byte> by = new List<byte> ();  	name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  	name += Encoding.Unicode.GetString ((byte[])createTime.Value);  	name += Encoding.Unicode.GetString ((byte[])createDate.Value);  	name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  	name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  	name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  	name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  	name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  }  else {  	name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  	extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (HasLongFileName) {  	List<byte> by = new List<byte> ();  	name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  	name += Encoding.Unicode.GetString ((byte[])createTime.Value);  	name += Encoding.Unicode.GetString ((byte[])createDate.Value);  	name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  	name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  	name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  	name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  	name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  }  else {  	name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  	extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (HasLongFileName) {  	List<byte> by = new List<byte> ();  	name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  	name += Encoding.Unicode.GetString ((byte[])createTime.Value);  	name += Encoding.Unicode.GetString ((byte[])createDate.Value);  	name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  	name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  	name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  	name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  	name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  }  else {  	name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  	extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: if (HasLongFileName) {  	List<byte> by = new List<byte> ();  	name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  	name += Encoding.Unicode.GetString ((byte[])createTime.Value);  	name += Encoding.Unicode.GetString ((byte[])createDate.Value);  	name += Encoding.Unicode.GetString ((byte[])lastAccessDate.Value);  	name += Encoding.Unicode.GetString ((byte[])eaIndex.Value);  	name += Encoding.Unicode.GetString ((byte[])lastModifiedTime.Value);  	name += Encoding.Unicode.GetString ((byte[])lastModifiedDate.Value);  	name += Encoding.Unicode.GetString (BitConverter.GetBytes ((int)sizeOfFile.Value));  }  else {  	name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  	extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  }  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: name = Encoding.Unicode.GetString ((byte[])nameBytes.Value' 1' 10);  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: name = Encoding.Default.GetString ((byte[])nameBytes.Value' 0' 8).Trim ();  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following statement contains a magic number: extension = Encoding.Default.GetString ((byte[])nameBytes.Value' 8' 3).Trim ();  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,ShortToDate,The following statement contains a magic number: return new DateTime (y + 1980' m' d' h' mn' s * 2);  
Magic Number,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,ShortToDate,The following statement contains a magic number: return new DateTime (y + 1980' m' d' h' mn' s * 2);  
Magic Number,LowLevel,MULTI_SECTOR_HEADER,C:\repos\mbatest_Binhed\LowLevel\MFT.cs,MULTI_SECTOR_HEADER,The following statement contains a magic number: signature = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 4);  
Magic Number,LowLevel,MasterBootRecord,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,MasterBootRecord,The following statement contains a magic number: bootCode = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 218);  
Magic Number,LowLevel,MasterBootRecord,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,MasterBootRecord,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	Partition p = new Partition (sw' offset);  	partitions.Add (p);  }  
Magic Number,LowLevel,Partition,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,Partition,The following statement contains a magic number: partitionSize = (ulong)(uint)totalSectors.Value * 512;  
Magic Number,LowLevel,Partition,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,ClusterToSector,The following statement contains a magic number: switch (partitionType) {  case LowLevel.PartitionType.NTFS:  	return cluster * (byte)Boot_Sector.Sectors_Per_Cluster.Value + (uint)Boot_Sector.Hidden_Sectors.Value + startPartition;  case LowLevel.PartitionType.Dell_Utility:  case LowLevel.PartitionType.FAT12:  case LowLevel.PartitionType.FAT16:  	return directoryOffset + /*((short)((BootRecord_Fat16)Boot_Sector).Root_Directory_Entries.Value * 0x20)/(short) Boot_Sector.Bytes_Per_Sector.Value+*/(cluster) * (byte)((BootRecord_Fat16)Boot_Sector).Sectors_Per_Cluster.Value;  case LowLevel.PartitionType.Win95_OSR2_FAT32_adressage_LBA:  	return directoryOffset + (byte)((BootRecord_Fat32)Boot_Sector).Sectors_Per_Cluster.Value * (cluster - 2);  default:  	return -1;  }  
Magic Number,LowLevel,Partition,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,ClusterToSector,The following statement contains a magic number: return directoryOffset + (byte)((BootRecord_Fat32)Boot_Sector).Sectors_Per_Cluster.Value * (cluster - 2);  
Magic Number,LowLevel,ChsSector,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,ChsSector,The following statement contains a magic number: cylinder = (b [1] & 0xC0) * 256 + b [2];  
Magic Number,LowLevel,ChsSector,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,ChsSector,The following statement contains a magic number: cylinder = (b [1] & 0xC0) * 256 + b [2];  
Magic Number,LowLevel,ChsSector,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,ChsSector,The following statement contains a magic number: LengthInFile = 3;  
Magic Number,LowLevel,BootRecord,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord,The following statement contains a magic number: jmp = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 3);  
Magic Number,LowLevel,BootRecord,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord,The following statement contains a magic number: oEM = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 8);  
Magic Number,LowLevel,BootRecord_Fat16,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_Fat16,The following statement contains a magic number: volumeLabel = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 11);  
Magic Number,LowLevel,BootRecord_Fat16,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_Fat16,The following statement contains a magic number: fileSystem = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 8);  
Magic Number,LowLevel,BootRecord_Fat16,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_Fat16,The following statement contains a magic number: bootCode = sw.ReadBytes (448);  
Magic Number,LowLevel,BootRecord_Fat16,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_Fat16,The following statement contains a magic number: Signature = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  
Magic Number,LowLevel,BootRecord_Fat16,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,ClusterToSector,The following statement contains a magic number: return Size_of_System_Area + (cluster - 2) * (int)Sectors_Per_Cluster.Value;  
Magic Number,LowLevel,BootRecord_Fat32,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_Fat32,The following statement contains a magic number: sw.ReadBytes (12);  
Magic Number,LowLevel,BootRecord_Fat32,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_Fat32,The following statement contains a magic number: volLabel32 = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 11);  
Magic Number,LowLevel,BootRecord_Fat32,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_Fat32,The following statement contains a magic number: fileSystem32 = new ELEMENTARY_TYPE (sw' offset' Encoding.Default' 8);  
Magic Number,LowLevel,BootRecord_Fat32,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_Fat32,The following statement contains a magic number: Signature = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  
Magic Number,LowLevel,BootRecord_Fat32,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_Fat32,The following statement contains a magic number: Size_of_System_Area = (short)Reserved_Sectors.Value + (byte)Number_of_Fats.Value * (int)Sectors_Per_FAT.Value + (int)Math.Ceiling ((float)((short)Root_Directory_Entries.Value * 32) / (float)(short)Bytes_Per_Sector.Value);  
Magic Number,LowLevel,BootRecord_Fat32,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,ClusterToSector,The following statement contains a magic number: return Size_of_System_Area + (int)Reserved_Sectors.Value + (int)Sectors_Per_FAT.Value * (byte)Number_of_Fats.Value + (cluster - 2) * (int)Sectors_Per_Cluster.Value;  
Magic Number,LowLevel,BootRecord_Dell,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_Dell,The following statement contains a magic number: volLabel32 = sw.ReadString (11);  
Magic Number,LowLevel,BootRecord_Dell,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_Dell,The following statement contains a magic number: fileSystem32 = sw.ReadString (8);  
Magic Number,LowLevel,BootRecord_Dell,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_Dell,The following statement contains a magic number: Signature = new ELEMENTARY_TYPE (sw' 0' typeof(byte[])' 2);  
Magic Number,LowLevel,BootRecord_NTFS,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_NTFS,The following statement contains a magic number: notUsed2 = sw.ReadBytes (4);  
Magic Number,LowLevel,BootRecord_NTFS,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_NTFS,The following statement contains a magic number: volSerialNumber = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 8);  
Magic Number,LowLevel,BootRecord_NTFS,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,BootRecord_NTFS,The following statement contains a magic number: Signature = new ELEMENTARY_TYPE (sw' offset' typeof(byte[])' 2);  
Magic Number,LowLevel,FSInformationSector,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,FSInformationSector,The following statement contains a magic number: rrAA = sw.ReadString (4);  
Magic Number,LowLevel,FSInformationSector,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,FSInformationSector,The following statement contains a magic number: reserved = sw.ReadBytes (480);  
Magic Number,LowLevel,FSInformationSector,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,FSInformationSector,The following statement contains a magic number: rrAA2 = sw.ReadString (4);  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,RequestData,The following statement contains a magic number: if (t.Name == typeof(Root16Entry).Name) {  	Root16Entry root = (Root16Entry)o;  	if (root.IsSubdirectory) {  		long st = root.DataStartSector;  		BitStreamReader sw = new BitStreamReader (ReadSectors (st' 10 * (short)currentPartition.Boot_Sector.Bytes_Per_Sector.Value)' false);  		Directory rd = new Directory (sw' currentPartition' st * (short)currentPartition.Boot_Sector.Bytes_Per_Sector.Value' 0);  		detail = rd;  	}  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,RequestData,The following statement contains a magic number: if (root.IsSubdirectory) {  	long st = root.DataStartSector;  	BitStreamReader sw = new BitStreamReader (ReadSectors (st' 10 * (short)currentPartition.Boot_Sector.Bytes_Per_Sector.Value)' false);  	Directory rd = new Directory (sw' currentPartition' st * (short)currentPartition.Boot_Sector.Bytes_Per_Sector.Value' 0);  	detail = rd;  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,RequestData,The following statement contains a magic number: if (t.Name == typeof(INDEX_ENTRY).Name) {  	INDEX_ENTRY indx = (INDEX_ENTRY)o;  	BootRecord_NTFS boot = (BootRecord_NTFS)currentPartition.Boot_Sector;  	long off = (uint)indx.FileReference.SegmentNumberLowPart.Value * 2 + currentPartition.ClusterToSector ((long)boot.MFT_Start.Value);  	BitStreamReader sw = new BitStreamReader (ReadSectors (off' 2 * (short)boot.Bytes_Per_Sector.Value)' false);  	FILE_RECORD_SEGMENT fs = new FILE_RECORD_SEGMENT (sw' off * (short)boot.Bytes_Per_Sector.Value' currentPartition' (int)(uint)indx.FileReference.SegmentNumberLowPart.Value);  	if (fs.Is_Directory) {  		foreach (ATTRIBUTE_RECORD_HEADER att in fs.Attributes) {  			if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  				ParseIndexAllocation (boot' fs' att' currentPartition);  				break;  			}  		}  		detail = fs;  	}  	if (fs.Is_File) {  		detail = fs;  	}  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,RequestData,The following statement contains a magic number: if (t.Name == typeof(INDEX_ENTRY).Name) {  	INDEX_ENTRY indx = (INDEX_ENTRY)o;  	BootRecord_NTFS boot = (BootRecord_NTFS)currentPartition.Boot_Sector;  	long off = (uint)indx.FileReference.SegmentNumberLowPart.Value * 2 + currentPartition.ClusterToSector ((long)boot.MFT_Start.Value);  	BitStreamReader sw = new BitStreamReader (ReadSectors (off' 2 * (short)boot.Bytes_Per_Sector.Value)' false);  	FILE_RECORD_SEGMENT fs = new FILE_RECORD_SEGMENT (sw' off * (short)boot.Bytes_Per_Sector.Value' currentPartition' (int)(uint)indx.FileReference.SegmentNumberLowPart.Value);  	if (fs.Is_Directory) {  		foreach (ATTRIBUTE_RECORD_HEADER att in fs.Attributes) {  			if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  				ParseIndexAllocation (boot' fs' att' currentPartition);  				break;  			}  		}  		detail = fs;  	}  	if (fs.Is_File) {  		detail = fs;  	}  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,RequestData,The following statement contains a magic number: if (t.Name == typeof(ATTRIBUTE_LIST_ENTRY).Name) {  	ATTRIBUTE_LIST_ENTRY att = (ATTRIBUTE_LIST_ENTRY)o;  	BootRecord_NTFS boot = (BootRecord_NTFS)currentPartition.Boot_Sector;  	long off = (uint)att.Base_File_Reference_of_the_attribute.SegmentNumberLowPart.Value * 2 + currentPartition.ClusterToSector ((long)boot.MFT_Start.Value);  	BitStreamReader sw = new BitStreamReader (ReadSectors (off' 2 * (short)boot.Bytes_Per_Sector.Value)' false);  	FILE_RECORD_SEGMENT fs = new FILE_RECORD_SEGMENT (sw' off * (short)boot.Bytes_Per_Sector.Value' currentPartition' (int)(uint)att.Base_File_Reference_of_the_attribute.SegmentNumberLowPart.Value);  	foreach (ATTRIBUTE_RECORD_HEADER attr in fs.Attributes) {  		if (attr.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  			ParseIndexAllocation (boot' fs' attr' currentPartition);  			break;  		}  	}  	detail = fs;  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,RequestData,The following statement contains a magic number: if (t.Name == typeof(ATTRIBUTE_LIST_ENTRY).Name) {  	ATTRIBUTE_LIST_ENTRY att = (ATTRIBUTE_LIST_ENTRY)o;  	BootRecord_NTFS boot = (BootRecord_NTFS)currentPartition.Boot_Sector;  	long off = (uint)att.Base_File_Reference_of_the_attribute.SegmentNumberLowPart.Value * 2 + currentPartition.ClusterToSector ((long)boot.MFT_Start.Value);  	BitStreamReader sw = new BitStreamReader (ReadSectors (off' 2 * (short)boot.Bytes_Per_Sector.Value)' false);  	FILE_RECORD_SEGMENT fs = new FILE_RECORD_SEGMENT (sw' off * (short)boot.Bytes_Per_Sector.Value' currentPartition' (int)(uint)att.Base_File_Reference_of_the_attribute.SegmentNumberLowPart.Value);  	foreach (ATTRIBUTE_RECORD_HEADER attr in fs.Attributes) {  		if (attr.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  			ParseIndexAllocation (boot' fs' attr' currentPartition);  			break;  		}  	}  	detail = fs;  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ParseBlock,The following statement contains a magic number: switch (head) {  case "FILE":  	if (currentPartition == null)  		return null;  	FILE_RECORD_SEGMENT fs = new FILE_RECORD_SEGMENT (new BitStreamReader (data' false)' sector * 0x200' currentPartition' 0);  	dt = fs;  	break;  case "INDX":  	data = ReadSectors (sector' 8 * 0x200);  	INDX indx = new INDX (new BitStreamReader (data' false)' sector * 0x200);  	dt = indx;  	break;  case "RDR":  	break;  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ParseBlock,The following statement contains a magic number: data = ReadSectors (sector' 8 * 0x200);  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadSector,The following statement contains a magic number: if (handleValue.IsInvalid) {  	return null;  }  else {  	long Offset = sectorNumber * SizeBuffer;  	byte[] buffer = new byte[SizeBuffer];  	int read = 0;  	//  Offset = 0x8000;  	int moveToHigh = (int)(Offset >> 32);  	uint x = RawDiskAccess.SetFilePointer (handleValue' (int)Offset' out moveToHigh' RawDiskAccess.EMoveMethod.Current);  	int y = RawDiskAccess.ReadFile (handleValue' buffer' (int)SizeBuffer' out read' IntPtr.Zero);  	handleValue.Close ();  	return buffer;  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,Change,The following statement contains a magic number: if (currentDrive.GetType ().Name.StartsWith ("Win32_CD")) {  	SecteurNumber = shift;  	string drivestring = @"\\.\" + ((Win32_CDROMDrive)currentDrive).Drive;  	SectorBuffer = ReadSector (drivestring' (int)SecteurNumber);  	;  }  else {  	SecteurNumber = shift;  	long[] chs = SectorToChs (SecteurNumber);  	Cylinder = (int)chs [0];  	Track = (int)chs [1];  	Sector = (int)chs [2];  	SizeBuffer = sb;  	SectorBuffer = ReadSectors (SecteurNumber' sb);  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,Change,The following statement contains a magic number: Sector = (int)chs [2];  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,CHSToSector,The following statement contains a magic number: return (chs [0] * (long)numberOfTracks + chs [1]) * (long)numberOfSectors + chs [2] - 1;  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,SectorToChs,The following statement contains a magic number: chs [2] = (lba % (long)numberOfSectors) + 1;  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: foreach (Partition p in mbr.Partitions) {  	SectorBuffer = ReadSectors ((uint)p.Start_Sector.Value + startPartition' SizeBuffer);  	BitStreamReader sw = new BitStreamReader (SectorBuffer' false);  	switch (p.Partition_Type) {  	case PartitionType.NTFS:  		#region NTFS  		p.Start_Partition = startPartition;  		p.Boot_Sector = new BootRecord_NTFS (sw' ((uint)p.Start_Sector.Value + startPartition) * SizeBuffer);  		BootRecord_NTFS nt = (BootRecord_NTFS)p.Boot_Sector;  		long startMFT = p.ClusterToSector ((long)nt.MFT_Start.Value);  		int FileRecordsNumber = 0x23;  		p.Master_File_Table = new MFT (new BitStreamReader (ReadSectors (startMFT' FileRecordsNumber * 2 * (short)p.Boot_Sector.Bytes_Per_Sector.Value)' false)' startMFT * SizeBuffer' p' FileRecordsNumber);  		foreach (FILE_RECORD_SEGMENT frs in p.Master_File_Table.File_Records) {  			switch (frs.Name) {  			case "$AttrDef":  				#region Attributes  				foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  					if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.DATA) {  						long st = p.ClusterToSector ((int)(att.Nonresident.Startcluster));  						// * (byte)p.Boot_Sector.Sectors_Per_Cluster.Value + (uint)p.Boot_Sector.Hidden_Sectors.Value);  						byte[] am = ReadSectors (st' 0x40 * 2 * 0x200);  						BitStreamReader sm = new BitStreamReader (am' false);  						frs.Attribute_Definitions = new List<ATTRIBUTE_DEFINITION_DATA> ();  						for (int i = 0; i < 0x10; i++) {  							sm.Position = i * 0xa0;  							// catch with standard length  							ATTRIBUTE_DEFINITION_DATA def = new ATTRIBUTE_DEFINITION_DATA (sm' st * 0x200);  							frs.Attribute_Definitions.Add (def);  						}  						break;  					}  				}  				break;  			#endregion  			case ".":  				#region Root directory  				foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  					if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  						ParseIndexAllocation ((BootRecord_NTFS)p.Boot_Sector' frs' att' p);  						break;  					}  				}  				break;  			#endregion  			}  		}  		break;  	#endregion  	case PartitionType.Dell_Utility:  	case PartitionType.FAT12:  	case PartitionType.FAT16:  		#region FAT16  		p.Boot_Sector = new BootRecord_Fat16 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  		p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (short)((BootRecord_Fat16)p.Boot_Sector).Sectors_Per_FAT.Value * 2;  		BitStreamReader ms = new BitStreamReader (ReadSectors (p.directoryOffset' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value * 0x20)' false);  		p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value);  		break;  	#endregion  	case PartitionType.Win95_OSR2_FAT32_adressage_LBA:  	case PartitionType.Win95_OSR2_FAT32_adressage_CHS:  		#region FAT32  		p.Boot_Sector = new BootRecord_Fat32 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  		p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (int)((BootRecord_Fat32)p.Boot_Sector).Sectors_Per_FAT.Value * (byte)((BootRecord_Fat32)p.Boot_Sector).Number_of_Fats.Value;  		ms = new BitStreamReader (ReadSectors (p.directoryOffset' 0x40 * 200)' false);  		p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat32)p.Boot_Sector).Root_Directory_Entries.Value);  		break;  	#endregion  	case PartitionType.Étendue_adressage_LBA:  		#region Extended Partition  		p.Extended_Partition_Master_Boot = ReadMasterBoot ((uint)p.Start_Sector.Value);  		break;  	#endregion  	}  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: foreach (Partition p in mbr.Partitions) {  	SectorBuffer = ReadSectors ((uint)p.Start_Sector.Value + startPartition' SizeBuffer);  	BitStreamReader sw = new BitStreamReader (SectorBuffer' false);  	switch (p.Partition_Type) {  	case PartitionType.NTFS:  		#region NTFS  		p.Start_Partition = startPartition;  		p.Boot_Sector = new BootRecord_NTFS (sw' ((uint)p.Start_Sector.Value + startPartition) * SizeBuffer);  		BootRecord_NTFS nt = (BootRecord_NTFS)p.Boot_Sector;  		long startMFT = p.ClusterToSector ((long)nt.MFT_Start.Value);  		int FileRecordsNumber = 0x23;  		p.Master_File_Table = new MFT (new BitStreamReader (ReadSectors (startMFT' FileRecordsNumber * 2 * (short)p.Boot_Sector.Bytes_Per_Sector.Value)' false)' startMFT * SizeBuffer' p' FileRecordsNumber);  		foreach (FILE_RECORD_SEGMENT frs in p.Master_File_Table.File_Records) {  			switch (frs.Name) {  			case "$AttrDef":  				#region Attributes  				foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  					if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.DATA) {  						long st = p.ClusterToSector ((int)(att.Nonresident.Startcluster));  						// * (byte)p.Boot_Sector.Sectors_Per_Cluster.Value + (uint)p.Boot_Sector.Hidden_Sectors.Value);  						byte[] am = ReadSectors (st' 0x40 * 2 * 0x200);  						BitStreamReader sm = new BitStreamReader (am' false);  						frs.Attribute_Definitions = new List<ATTRIBUTE_DEFINITION_DATA> ();  						for (int i = 0; i < 0x10; i++) {  							sm.Position = i * 0xa0;  							// catch with standard length  							ATTRIBUTE_DEFINITION_DATA def = new ATTRIBUTE_DEFINITION_DATA (sm' st * 0x200);  							frs.Attribute_Definitions.Add (def);  						}  						break;  					}  				}  				break;  			#endregion  			case ".":  				#region Root directory  				foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  					if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  						ParseIndexAllocation ((BootRecord_NTFS)p.Boot_Sector' frs' att' p);  						break;  					}  				}  				break;  			#endregion  			}  		}  		break;  	#endregion  	case PartitionType.Dell_Utility:  	case PartitionType.FAT12:  	case PartitionType.FAT16:  		#region FAT16  		p.Boot_Sector = new BootRecord_Fat16 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  		p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (short)((BootRecord_Fat16)p.Boot_Sector).Sectors_Per_FAT.Value * 2;  		BitStreamReader ms = new BitStreamReader (ReadSectors (p.directoryOffset' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value * 0x20)' false);  		p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value);  		break;  	#endregion  	case PartitionType.Win95_OSR2_FAT32_adressage_LBA:  	case PartitionType.Win95_OSR2_FAT32_adressage_CHS:  		#region FAT32  		p.Boot_Sector = new BootRecord_Fat32 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  		p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (int)((BootRecord_Fat32)p.Boot_Sector).Sectors_Per_FAT.Value * (byte)((BootRecord_Fat32)p.Boot_Sector).Number_of_Fats.Value;  		ms = new BitStreamReader (ReadSectors (p.directoryOffset' 0x40 * 200)' false);  		p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat32)p.Boot_Sector).Root_Directory_Entries.Value);  		break;  	#endregion  	case PartitionType.Étendue_adressage_LBA:  		#region Extended Partition  		p.Extended_Partition_Master_Boot = ReadMasterBoot ((uint)p.Start_Sector.Value);  		break;  	#endregion  	}  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: foreach (Partition p in mbr.Partitions) {  	SectorBuffer = ReadSectors ((uint)p.Start_Sector.Value + startPartition' SizeBuffer);  	BitStreamReader sw = new BitStreamReader (SectorBuffer' false);  	switch (p.Partition_Type) {  	case PartitionType.NTFS:  		#region NTFS  		p.Start_Partition = startPartition;  		p.Boot_Sector = new BootRecord_NTFS (sw' ((uint)p.Start_Sector.Value + startPartition) * SizeBuffer);  		BootRecord_NTFS nt = (BootRecord_NTFS)p.Boot_Sector;  		long startMFT = p.ClusterToSector ((long)nt.MFT_Start.Value);  		int FileRecordsNumber = 0x23;  		p.Master_File_Table = new MFT (new BitStreamReader (ReadSectors (startMFT' FileRecordsNumber * 2 * (short)p.Boot_Sector.Bytes_Per_Sector.Value)' false)' startMFT * SizeBuffer' p' FileRecordsNumber);  		foreach (FILE_RECORD_SEGMENT frs in p.Master_File_Table.File_Records) {  			switch (frs.Name) {  			case "$AttrDef":  				#region Attributes  				foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  					if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.DATA) {  						long st = p.ClusterToSector ((int)(att.Nonresident.Startcluster));  						// * (byte)p.Boot_Sector.Sectors_Per_Cluster.Value + (uint)p.Boot_Sector.Hidden_Sectors.Value);  						byte[] am = ReadSectors (st' 0x40 * 2 * 0x200);  						BitStreamReader sm = new BitStreamReader (am' false);  						frs.Attribute_Definitions = new List<ATTRIBUTE_DEFINITION_DATA> ();  						for (int i = 0; i < 0x10; i++) {  							sm.Position = i * 0xa0;  							// catch with standard length  							ATTRIBUTE_DEFINITION_DATA def = new ATTRIBUTE_DEFINITION_DATA (sm' st * 0x200);  							frs.Attribute_Definitions.Add (def);  						}  						break;  					}  				}  				break;  			#endregion  			case ".":  				#region Root directory  				foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  					if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  						ParseIndexAllocation ((BootRecord_NTFS)p.Boot_Sector' frs' att' p);  						break;  					}  				}  				break;  			#endregion  			}  		}  		break;  	#endregion  	case PartitionType.Dell_Utility:  	case PartitionType.FAT12:  	case PartitionType.FAT16:  		#region FAT16  		p.Boot_Sector = new BootRecord_Fat16 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  		p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (short)((BootRecord_Fat16)p.Boot_Sector).Sectors_Per_FAT.Value * 2;  		BitStreamReader ms = new BitStreamReader (ReadSectors (p.directoryOffset' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value * 0x20)' false);  		p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value);  		break;  	#endregion  	case PartitionType.Win95_OSR2_FAT32_adressage_LBA:  	case PartitionType.Win95_OSR2_FAT32_adressage_CHS:  		#region FAT32  		p.Boot_Sector = new BootRecord_Fat32 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  		p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (int)((BootRecord_Fat32)p.Boot_Sector).Sectors_Per_FAT.Value * (byte)((BootRecord_Fat32)p.Boot_Sector).Number_of_Fats.Value;  		ms = new BitStreamReader (ReadSectors (p.directoryOffset' 0x40 * 200)' false);  		p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat32)p.Boot_Sector).Root_Directory_Entries.Value);  		break;  	#endregion  	case PartitionType.Étendue_adressage_LBA:  		#region Extended Partition  		p.Extended_Partition_Master_Boot = ReadMasterBoot ((uint)p.Start_Sector.Value);  		break;  	#endregion  	}  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: foreach (Partition p in mbr.Partitions) {  	SectorBuffer = ReadSectors ((uint)p.Start_Sector.Value + startPartition' SizeBuffer);  	BitStreamReader sw = new BitStreamReader (SectorBuffer' false);  	switch (p.Partition_Type) {  	case PartitionType.NTFS:  		#region NTFS  		p.Start_Partition = startPartition;  		p.Boot_Sector = new BootRecord_NTFS (sw' ((uint)p.Start_Sector.Value + startPartition) * SizeBuffer);  		BootRecord_NTFS nt = (BootRecord_NTFS)p.Boot_Sector;  		long startMFT = p.ClusterToSector ((long)nt.MFT_Start.Value);  		int FileRecordsNumber = 0x23;  		p.Master_File_Table = new MFT (new BitStreamReader (ReadSectors (startMFT' FileRecordsNumber * 2 * (short)p.Boot_Sector.Bytes_Per_Sector.Value)' false)' startMFT * SizeBuffer' p' FileRecordsNumber);  		foreach (FILE_RECORD_SEGMENT frs in p.Master_File_Table.File_Records) {  			switch (frs.Name) {  			case "$AttrDef":  				#region Attributes  				foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  					if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.DATA) {  						long st = p.ClusterToSector ((int)(att.Nonresident.Startcluster));  						// * (byte)p.Boot_Sector.Sectors_Per_Cluster.Value + (uint)p.Boot_Sector.Hidden_Sectors.Value);  						byte[] am = ReadSectors (st' 0x40 * 2 * 0x200);  						BitStreamReader sm = new BitStreamReader (am' false);  						frs.Attribute_Definitions = new List<ATTRIBUTE_DEFINITION_DATA> ();  						for (int i = 0; i < 0x10; i++) {  							sm.Position = i * 0xa0;  							// catch with standard length  							ATTRIBUTE_DEFINITION_DATA def = new ATTRIBUTE_DEFINITION_DATA (sm' st * 0x200);  							frs.Attribute_Definitions.Add (def);  						}  						break;  					}  				}  				break;  			#endregion  			case ".":  				#region Root directory  				foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  					if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  						ParseIndexAllocation ((BootRecord_NTFS)p.Boot_Sector' frs' att' p);  						break;  					}  				}  				break;  			#endregion  			}  		}  		break;  	#endregion  	case PartitionType.Dell_Utility:  	case PartitionType.FAT12:  	case PartitionType.FAT16:  		#region FAT16  		p.Boot_Sector = new BootRecord_Fat16 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  		p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (short)((BootRecord_Fat16)p.Boot_Sector).Sectors_Per_FAT.Value * 2;  		BitStreamReader ms = new BitStreamReader (ReadSectors (p.directoryOffset' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value * 0x20)' false);  		p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value);  		break;  	#endregion  	case PartitionType.Win95_OSR2_FAT32_adressage_LBA:  	case PartitionType.Win95_OSR2_FAT32_adressage_CHS:  		#region FAT32  		p.Boot_Sector = new BootRecord_Fat32 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  		p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (int)((BootRecord_Fat32)p.Boot_Sector).Sectors_Per_FAT.Value * (byte)((BootRecord_Fat32)p.Boot_Sector).Number_of_Fats.Value;  		ms = new BitStreamReader (ReadSectors (p.directoryOffset' 0x40 * 200)' false);  		p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat32)p.Boot_Sector).Root_Directory_Entries.Value);  		break;  	#endregion  	case PartitionType.Étendue_adressage_LBA:  		#region Extended Partition  		p.Extended_Partition_Master_Boot = ReadMasterBoot ((uint)p.Start_Sector.Value);  		break;  	#endregion  	}  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: switch (p.Partition_Type) {  case PartitionType.NTFS:  	#region NTFS  	p.Start_Partition = startPartition;  	p.Boot_Sector = new BootRecord_NTFS (sw' ((uint)p.Start_Sector.Value + startPartition) * SizeBuffer);  	BootRecord_NTFS nt = (BootRecord_NTFS)p.Boot_Sector;  	long startMFT = p.ClusterToSector ((long)nt.MFT_Start.Value);  	int FileRecordsNumber = 0x23;  	p.Master_File_Table = new MFT (new BitStreamReader (ReadSectors (startMFT' FileRecordsNumber * 2 * (short)p.Boot_Sector.Bytes_Per_Sector.Value)' false)' startMFT * SizeBuffer' p' FileRecordsNumber);  	foreach (FILE_RECORD_SEGMENT frs in p.Master_File_Table.File_Records) {  		switch (frs.Name) {  		case "$AttrDef":  			#region Attributes  			foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  				if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.DATA) {  					long st = p.ClusterToSector ((int)(att.Nonresident.Startcluster));  					// * (byte)p.Boot_Sector.Sectors_Per_Cluster.Value + (uint)p.Boot_Sector.Hidden_Sectors.Value);  					byte[] am = ReadSectors (st' 0x40 * 2 * 0x200);  					BitStreamReader sm = new BitStreamReader (am' false);  					frs.Attribute_Definitions = new List<ATTRIBUTE_DEFINITION_DATA> ();  					for (int i = 0; i < 0x10; i++) {  						sm.Position = i * 0xa0;  						// catch with standard length  						ATTRIBUTE_DEFINITION_DATA def = new ATTRIBUTE_DEFINITION_DATA (sm' st * 0x200);  						frs.Attribute_Definitions.Add (def);  					}  					break;  				}  			}  			break;  		#endregion  		case ".":  			#region Root directory  			foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  				if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  					ParseIndexAllocation ((BootRecord_NTFS)p.Boot_Sector' frs' att' p);  					break;  				}  			}  			break;  		#endregion  		}  	}  	break;  #endregion  case PartitionType.Dell_Utility:  case PartitionType.FAT12:  case PartitionType.FAT16:  	#region FAT16  	p.Boot_Sector = new BootRecord_Fat16 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  	p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (short)((BootRecord_Fat16)p.Boot_Sector).Sectors_Per_FAT.Value * 2;  	BitStreamReader ms = new BitStreamReader (ReadSectors (p.directoryOffset' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value * 0x20)' false);  	p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value);  	break;  #endregion  case PartitionType.Win95_OSR2_FAT32_adressage_LBA:  case PartitionType.Win95_OSR2_FAT32_adressage_CHS:  	#region FAT32  	p.Boot_Sector = new BootRecord_Fat32 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  	p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (int)((BootRecord_Fat32)p.Boot_Sector).Sectors_Per_FAT.Value * (byte)((BootRecord_Fat32)p.Boot_Sector).Number_of_Fats.Value;  	ms = new BitStreamReader (ReadSectors (p.directoryOffset' 0x40 * 200)' false);  	p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat32)p.Boot_Sector).Root_Directory_Entries.Value);  	break;  #endregion  case PartitionType.Étendue_adressage_LBA:  	#region Extended Partition  	p.Extended_Partition_Master_Boot = ReadMasterBoot ((uint)p.Start_Sector.Value);  	break;  #endregion  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: switch (p.Partition_Type) {  case PartitionType.NTFS:  	#region NTFS  	p.Start_Partition = startPartition;  	p.Boot_Sector = new BootRecord_NTFS (sw' ((uint)p.Start_Sector.Value + startPartition) * SizeBuffer);  	BootRecord_NTFS nt = (BootRecord_NTFS)p.Boot_Sector;  	long startMFT = p.ClusterToSector ((long)nt.MFT_Start.Value);  	int FileRecordsNumber = 0x23;  	p.Master_File_Table = new MFT (new BitStreamReader (ReadSectors (startMFT' FileRecordsNumber * 2 * (short)p.Boot_Sector.Bytes_Per_Sector.Value)' false)' startMFT * SizeBuffer' p' FileRecordsNumber);  	foreach (FILE_RECORD_SEGMENT frs in p.Master_File_Table.File_Records) {  		switch (frs.Name) {  		case "$AttrDef":  			#region Attributes  			foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  				if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.DATA) {  					long st = p.ClusterToSector ((int)(att.Nonresident.Startcluster));  					// * (byte)p.Boot_Sector.Sectors_Per_Cluster.Value + (uint)p.Boot_Sector.Hidden_Sectors.Value);  					byte[] am = ReadSectors (st' 0x40 * 2 * 0x200);  					BitStreamReader sm = new BitStreamReader (am' false);  					frs.Attribute_Definitions = new List<ATTRIBUTE_DEFINITION_DATA> ();  					for (int i = 0; i < 0x10; i++) {  						sm.Position = i * 0xa0;  						// catch with standard length  						ATTRIBUTE_DEFINITION_DATA def = new ATTRIBUTE_DEFINITION_DATA (sm' st * 0x200);  						frs.Attribute_Definitions.Add (def);  					}  					break;  				}  			}  			break;  		#endregion  		case ".":  			#region Root directory  			foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  				if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  					ParseIndexAllocation ((BootRecord_NTFS)p.Boot_Sector' frs' att' p);  					break;  				}  			}  			break;  		#endregion  		}  	}  	break;  #endregion  case PartitionType.Dell_Utility:  case PartitionType.FAT12:  case PartitionType.FAT16:  	#region FAT16  	p.Boot_Sector = new BootRecord_Fat16 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  	p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (short)((BootRecord_Fat16)p.Boot_Sector).Sectors_Per_FAT.Value * 2;  	BitStreamReader ms = new BitStreamReader (ReadSectors (p.directoryOffset' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value * 0x20)' false);  	p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value);  	break;  #endregion  case PartitionType.Win95_OSR2_FAT32_adressage_LBA:  case PartitionType.Win95_OSR2_FAT32_adressage_CHS:  	#region FAT32  	p.Boot_Sector = new BootRecord_Fat32 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  	p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (int)((BootRecord_Fat32)p.Boot_Sector).Sectors_Per_FAT.Value * (byte)((BootRecord_Fat32)p.Boot_Sector).Number_of_Fats.Value;  	ms = new BitStreamReader (ReadSectors (p.directoryOffset' 0x40 * 200)' false);  	p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat32)p.Boot_Sector).Root_Directory_Entries.Value);  	break;  #endregion  case PartitionType.Étendue_adressage_LBA:  	#region Extended Partition  	p.Extended_Partition_Master_Boot = ReadMasterBoot ((uint)p.Start_Sector.Value);  	break;  #endregion  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: switch (p.Partition_Type) {  case PartitionType.NTFS:  	#region NTFS  	p.Start_Partition = startPartition;  	p.Boot_Sector = new BootRecord_NTFS (sw' ((uint)p.Start_Sector.Value + startPartition) * SizeBuffer);  	BootRecord_NTFS nt = (BootRecord_NTFS)p.Boot_Sector;  	long startMFT = p.ClusterToSector ((long)nt.MFT_Start.Value);  	int FileRecordsNumber = 0x23;  	p.Master_File_Table = new MFT (new BitStreamReader (ReadSectors (startMFT' FileRecordsNumber * 2 * (short)p.Boot_Sector.Bytes_Per_Sector.Value)' false)' startMFT * SizeBuffer' p' FileRecordsNumber);  	foreach (FILE_RECORD_SEGMENT frs in p.Master_File_Table.File_Records) {  		switch (frs.Name) {  		case "$AttrDef":  			#region Attributes  			foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  				if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.DATA) {  					long st = p.ClusterToSector ((int)(att.Nonresident.Startcluster));  					// * (byte)p.Boot_Sector.Sectors_Per_Cluster.Value + (uint)p.Boot_Sector.Hidden_Sectors.Value);  					byte[] am = ReadSectors (st' 0x40 * 2 * 0x200);  					BitStreamReader sm = new BitStreamReader (am' false);  					frs.Attribute_Definitions = new List<ATTRIBUTE_DEFINITION_DATA> ();  					for (int i = 0; i < 0x10; i++) {  						sm.Position = i * 0xa0;  						// catch with standard length  						ATTRIBUTE_DEFINITION_DATA def = new ATTRIBUTE_DEFINITION_DATA (sm' st * 0x200);  						frs.Attribute_Definitions.Add (def);  					}  					break;  				}  			}  			break;  		#endregion  		case ".":  			#region Root directory  			foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  				if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  					ParseIndexAllocation ((BootRecord_NTFS)p.Boot_Sector' frs' att' p);  					break;  				}  			}  			break;  		#endregion  		}  	}  	break;  #endregion  case PartitionType.Dell_Utility:  case PartitionType.FAT12:  case PartitionType.FAT16:  	#region FAT16  	p.Boot_Sector = new BootRecord_Fat16 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  	p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (short)((BootRecord_Fat16)p.Boot_Sector).Sectors_Per_FAT.Value * 2;  	BitStreamReader ms = new BitStreamReader (ReadSectors (p.directoryOffset' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value * 0x20)' false);  	p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value);  	break;  #endregion  case PartitionType.Win95_OSR2_FAT32_adressage_LBA:  case PartitionType.Win95_OSR2_FAT32_adressage_CHS:  	#region FAT32  	p.Boot_Sector = new BootRecord_Fat32 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  	p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (int)((BootRecord_Fat32)p.Boot_Sector).Sectors_Per_FAT.Value * (byte)((BootRecord_Fat32)p.Boot_Sector).Number_of_Fats.Value;  	ms = new BitStreamReader (ReadSectors (p.directoryOffset' 0x40 * 200)' false);  	p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat32)p.Boot_Sector).Root_Directory_Entries.Value);  	break;  #endregion  case PartitionType.Étendue_adressage_LBA:  	#region Extended Partition  	p.Extended_Partition_Master_Boot = ReadMasterBoot ((uint)p.Start_Sector.Value);  	break;  #endregion  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: switch (p.Partition_Type) {  case PartitionType.NTFS:  	#region NTFS  	p.Start_Partition = startPartition;  	p.Boot_Sector = new BootRecord_NTFS (sw' ((uint)p.Start_Sector.Value + startPartition) * SizeBuffer);  	BootRecord_NTFS nt = (BootRecord_NTFS)p.Boot_Sector;  	long startMFT = p.ClusterToSector ((long)nt.MFT_Start.Value);  	int FileRecordsNumber = 0x23;  	p.Master_File_Table = new MFT (new BitStreamReader (ReadSectors (startMFT' FileRecordsNumber * 2 * (short)p.Boot_Sector.Bytes_Per_Sector.Value)' false)' startMFT * SizeBuffer' p' FileRecordsNumber);  	foreach (FILE_RECORD_SEGMENT frs in p.Master_File_Table.File_Records) {  		switch (frs.Name) {  		case "$AttrDef":  			#region Attributes  			foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  				if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.DATA) {  					long st = p.ClusterToSector ((int)(att.Nonresident.Startcluster));  					// * (byte)p.Boot_Sector.Sectors_Per_Cluster.Value + (uint)p.Boot_Sector.Hidden_Sectors.Value);  					byte[] am = ReadSectors (st' 0x40 * 2 * 0x200);  					BitStreamReader sm = new BitStreamReader (am' false);  					frs.Attribute_Definitions = new List<ATTRIBUTE_DEFINITION_DATA> ();  					for (int i = 0; i < 0x10; i++) {  						sm.Position = i * 0xa0;  						// catch with standard length  						ATTRIBUTE_DEFINITION_DATA def = new ATTRIBUTE_DEFINITION_DATA (sm' st * 0x200);  						frs.Attribute_Definitions.Add (def);  					}  					break;  				}  			}  			break;  		#endregion  		case ".":  			#region Root directory  			foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  				if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  					ParseIndexAllocation ((BootRecord_NTFS)p.Boot_Sector' frs' att' p);  					break;  				}  			}  			break;  		#endregion  		}  	}  	break;  #endregion  case PartitionType.Dell_Utility:  case PartitionType.FAT12:  case PartitionType.FAT16:  	#region FAT16  	p.Boot_Sector = new BootRecord_Fat16 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  	p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (short)((BootRecord_Fat16)p.Boot_Sector).Sectors_Per_FAT.Value * 2;  	BitStreamReader ms = new BitStreamReader (ReadSectors (p.directoryOffset' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value * 0x20)' false);  	p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value);  	break;  #endregion  case PartitionType.Win95_OSR2_FAT32_adressage_LBA:  case PartitionType.Win95_OSR2_FAT32_adressage_CHS:  	#region FAT32  	p.Boot_Sector = new BootRecord_Fat32 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  	p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (int)((BootRecord_Fat32)p.Boot_Sector).Sectors_Per_FAT.Value * (byte)((BootRecord_Fat32)p.Boot_Sector).Number_of_Fats.Value;  	ms = new BitStreamReader (ReadSectors (p.directoryOffset' 0x40 * 200)' false);  	p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat32)p.Boot_Sector).Root_Directory_Entries.Value);  	break;  #endregion  case PartitionType.Étendue_adressage_LBA:  	#region Extended Partition  	p.Extended_Partition_Master_Boot = ReadMasterBoot ((uint)p.Start_Sector.Value);  	break;  #endregion  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: p.Master_File_Table = new MFT (new BitStreamReader (ReadSectors (startMFT' FileRecordsNumber * 2 * (short)p.Boot_Sector.Bytes_Per_Sector.Value)' false)' startMFT * SizeBuffer' p' FileRecordsNumber);  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: foreach (FILE_RECORD_SEGMENT frs in p.Master_File_Table.File_Records) {  	switch (frs.Name) {  	case "$AttrDef":  		#region Attributes  		foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  			if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.DATA) {  				long st = p.ClusterToSector ((int)(att.Nonresident.Startcluster));  				// * (byte)p.Boot_Sector.Sectors_Per_Cluster.Value + (uint)p.Boot_Sector.Hidden_Sectors.Value);  				byte[] am = ReadSectors (st' 0x40 * 2 * 0x200);  				BitStreamReader sm = new BitStreamReader (am' false);  				frs.Attribute_Definitions = new List<ATTRIBUTE_DEFINITION_DATA> ();  				for (int i = 0; i < 0x10; i++) {  					sm.Position = i * 0xa0;  					// catch with standard length  					ATTRIBUTE_DEFINITION_DATA def = new ATTRIBUTE_DEFINITION_DATA (sm' st * 0x200);  					frs.Attribute_Definitions.Add (def);  				}  				break;  			}  		}  		break;  	#endregion  	case ".":  		#region Root directory  		foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  			if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  				ParseIndexAllocation ((BootRecord_NTFS)p.Boot_Sector' frs' att' p);  				break;  			}  		}  		break;  	#endregion  	}  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: switch (frs.Name) {  case "$AttrDef":  	#region Attributes  	foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  		if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.DATA) {  			long st = p.ClusterToSector ((int)(att.Nonresident.Startcluster));  			// * (byte)p.Boot_Sector.Sectors_Per_Cluster.Value + (uint)p.Boot_Sector.Hidden_Sectors.Value);  			byte[] am = ReadSectors (st' 0x40 * 2 * 0x200);  			BitStreamReader sm = new BitStreamReader (am' false);  			frs.Attribute_Definitions = new List<ATTRIBUTE_DEFINITION_DATA> ();  			for (int i = 0; i < 0x10; i++) {  				sm.Position = i * 0xa0;  				// catch with standard length  				ATTRIBUTE_DEFINITION_DATA def = new ATTRIBUTE_DEFINITION_DATA (sm' st * 0x200);  				frs.Attribute_Definitions.Add (def);  			}  			break;  		}  	}  	break;  #endregion  case ".":  	#region Root directory  	foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  		if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  			ParseIndexAllocation ((BootRecord_NTFS)p.Boot_Sector' frs' att' p);  			break;  		}  	}  	break;  #endregion  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  	if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.DATA) {  		long st = p.ClusterToSector ((int)(att.Nonresident.Startcluster));  		// * (byte)p.Boot_Sector.Sectors_Per_Cluster.Value + (uint)p.Boot_Sector.Hidden_Sectors.Value);  		byte[] am = ReadSectors (st' 0x40 * 2 * 0x200);  		BitStreamReader sm = new BitStreamReader (am' false);  		frs.Attribute_Definitions = new List<ATTRIBUTE_DEFINITION_DATA> ();  		for (int i = 0; i < 0x10; i++) {  			sm.Position = i * 0xa0;  			// catch with standard length  			ATTRIBUTE_DEFINITION_DATA def = new ATTRIBUTE_DEFINITION_DATA (sm' st * 0x200);  			frs.Attribute_Definitions.Add (def);  		}  		break;  	}  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.DATA) {  	long st = p.ClusterToSector ((int)(att.Nonresident.Startcluster));  	// * (byte)p.Boot_Sector.Sectors_Per_Cluster.Value + (uint)p.Boot_Sector.Hidden_Sectors.Value);  	byte[] am = ReadSectors (st' 0x40 * 2 * 0x200);  	BitStreamReader sm = new BitStreamReader (am' false);  	frs.Attribute_Definitions = new List<ATTRIBUTE_DEFINITION_DATA> ();  	for (int i = 0; i < 0x10; i++) {  		sm.Position = i * 0xa0;  		// catch with standard length  		ATTRIBUTE_DEFINITION_DATA def = new ATTRIBUTE_DEFINITION_DATA (sm' st * 0x200);  		frs.Attribute_Definitions.Add (def);  	}  	break;  }  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (short)((BootRecord_Fat16)p.Boot_Sector).Sectors_Per_FAT.Value * 2;  
Magic Number,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following statement contains a magic number: ms = new BitStreamReader (ReadSectors (p.directoryOffset' 0x40 * 200)' false);  
Magic Number,LowLevel,LowLevelViewer,C:\repos\mbatest_Binhed\LowLevel\Form1.cs,CHSToSector,The following statement contains a magic number: return (chs [0] * (long)numberOfTracks + chs [1]) * (long)numberOfSectors + chs [2] - 1;  
Magic Number,LowLevel,LowLevelViewer,C:\repos\mbatest_Binhed\LowLevel\Form1.cs,SectorToChs,The following statement contains a magic number: chs [2] = (lba % (long)numberOfSectors) + 1;  
Magic Number,LowLevel,LowLevelViewer,C:\repos\mbatest_Binhed\LowLevel\Form1.cs,ReadSector,The following statement contains a magic number: Sector.Text = chs [2].ToString ("x2");  
Magic Number,LowLevel,HardwareViewer,C:\repos\mbatest_Binhed\LowLevel\HardwareViewer.cs,Init,The following statement contains a magic number: processor.Nodes.Add ("Max clock speed : " + ((float)dk.processor.MaxClockSpeed / 1000).ToString () + "Ghz");  
Magic Number,LowLevel,RawAccess,C:\repos\mbatest_Binhed\LowLevel\RawAccess.cs,RawAccess,The following statement contains a magic number: if (DeviceIoControl (handle' 0' IntPtr.Zero' 50' IntPtr.Zero' 50' out lb' IntPtr.Zero)) {  }  
Magic Number,LowLevel,RawAccess,C:\repos\mbatest_Binhed\LowLevel\RawAccess.cs,RawAccess,The following statement contains a magic number: if (DeviceIoControl (handle' 0' IntPtr.Zero' 50' IntPtr.Zero' 50' out lb' IntPtr.Zero)) {  }  
Missing Default,LowLevel,Root16Entry,C:\repos\mbatest_Binhed\LowLevel\FAT.cs,Root16Entry,The following switch statement is missing a default case: switch (((byte[])nameBytes.Value) [0]) {  case 0xE5:  	isDeleted = true;  	break;  case 0x05:  	((byte[])nameBytes.Value) [0] = 0xE5;  	break;  case 0x2E:  	//parent  	break;  }  
Missing Default,LowLevel,FILE_RECORD_SEGMENT,C:\repos\mbatest_Binhed\LowLevel\MFT.cs,FILE_RECORD_SEGMENT,The following switch statement is missing a default case: switch (att.Attribute_Type) {  case ATTRIBUTE_TYPE_CODE.FILE_NAME:  	isFile = att.File_Name.isFile;  	isDirectory = att.File_Name.isDirectory;  	name = (string)att.File_Name.FileName.Value;  	break;  case ATTRIBUTE_TYPE_CODE.DATA:  	if (att.Nonresident != null) {  		startSector = p.ClusterToSector (att.Nonresident.Startcluster);  	}  	else  		startSector = -1;  	break;  }  
Missing Default,LowLevel,Partition,C:\repos\mbatest_Binhed\LowLevel\Partition.cs,ReadFat,The following switch statement is missing a default case: switch (partitionType) {  case PartitionType.FAT12:  case PartitionType.FAT16:  	break;  case LowLevel.PartitionType.Win95_OSR2_FAT32_adressage_LBA:  	break;  }  
Missing Default,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,RequestData,The following switch statement is missing a default case: switch (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.ATTRIBUTE_LIST) {  }  
Missing Default,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ParseBlock,The following switch statement is missing a default case: switch (head) {  case "FILE":  	if (currentPartition == null)  		return null;  	FILE_RECORD_SEGMENT fs = new FILE_RECORD_SEGMENT (new BitStreamReader (data' false)' sector * 0x200' currentPartition' 0);  	dt = fs;  	break;  case "INDX":  	data = ReadSectors (sector' 8 * 0x200);  	INDX indx = new INDX (new BitStreamReader (data' false)' sector * 0x200);  	dt = indx;  	break;  case "RDR":  	break;  }  
Missing Default,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following switch statement is missing a default case: switch (p.Partition_Type) {  case PartitionType.NTFS:  	#region NTFS  	p.Start_Partition = startPartition;  	p.Boot_Sector = new BootRecord_NTFS (sw' ((uint)p.Start_Sector.Value + startPartition) * SizeBuffer);  	BootRecord_NTFS nt = (BootRecord_NTFS)p.Boot_Sector;  	long startMFT = p.ClusterToSector ((long)nt.MFT_Start.Value);  	int FileRecordsNumber = 0x23;  	p.Master_File_Table = new MFT (new BitStreamReader (ReadSectors (startMFT' FileRecordsNumber * 2 * (short)p.Boot_Sector.Bytes_Per_Sector.Value)' false)' startMFT * SizeBuffer' p' FileRecordsNumber);  	foreach (FILE_RECORD_SEGMENT frs in p.Master_File_Table.File_Records) {  		switch (frs.Name) {  		case "$AttrDef":  			#region Attributes  			foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  				if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.DATA) {  					long st = p.ClusterToSector ((int)(att.Nonresident.Startcluster));  					// * (byte)p.Boot_Sector.Sectors_Per_Cluster.Value + (uint)p.Boot_Sector.Hidden_Sectors.Value);  					byte[] am = ReadSectors (st' 0x40 * 2 * 0x200);  					BitStreamReader sm = new BitStreamReader (am' false);  					frs.Attribute_Definitions = new List<ATTRIBUTE_DEFINITION_DATA> ();  					for (int i = 0; i < 0x10; i++) {  						sm.Position = i * 0xa0;  						// catch with standard length  						ATTRIBUTE_DEFINITION_DATA def = new ATTRIBUTE_DEFINITION_DATA (sm' st * 0x200);  						frs.Attribute_Definitions.Add (def);  					}  					break;  				}  			}  			break;  		#endregion  		case ".":  			#region Root directory  			foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  				if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  					ParseIndexAllocation ((BootRecord_NTFS)p.Boot_Sector' frs' att' p);  					break;  				}  			}  			break;  		#endregion  		}  	}  	break;  #endregion  case PartitionType.Dell_Utility:  case PartitionType.FAT12:  case PartitionType.FAT16:  	#region FAT16  	p.Boot_Sector = new BootRecord_Fat16 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  	p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (short)((BootRecord_Fat16)p.Boot_Sector).Sectors_Per_FAT.Value * 2;  	BitStreamReader ms = new BitStreamReader (ReadSectors (p.directoryOffset' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value * 0x20)' false);  	p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat16)p.Boot_Sector).Root_Directory_Entries.Value);  	break;  #endregion  case PartitionType.Win95_OSR2_FAT32_adressage_LBA:  case PartitionType.Win95_OSR2_FAT32_adressage_CHS:  	#region FAT32  	p.Boot_Sector = new BootRecord_Fat32 (sw' (uint)p.Start_Sector.Value * SizeBuffer);  	p.directoryOffset = (uint)p.Start_Sector.Value + (short)p.Boot_Sector.Reserved_Sectors.Value + (int)((BootRecord_Fat32)p.Boot_Sector).Sectors_Per_FAT.Value * (byte)((BootRecord_Fat32)p.Boot_Sector).Number_of_Fats.Value;  	ms = new BitStreamReader (ReadSectors (p.directoryOffset' 0x40 * 200)' false);  	p.Root_Directory = new Directory (ms' p' p.directoryOffset * (short)p.Boot_Sector.Bytes_Per_Sector.Value' (short)((BootRecord_Fat32)p.Boot_Sector).Root_Directory_Entries.Value);  	break;  #endregion  case PartitionType.Étendue_adressage_LBA:  	#region Extended Partition  	p.Extended_Partition_Master_Boot = ReadMasterBoot ((uint)p.Start_Sector.Value);  	break;  #endregion  }  
Missing Default,LowLevel,RawDiskAccess,C:\repos\mbatest_Binhed\LowLevel\RawDiskAccess.cs,ReadMasterBoot,The following switch statement is missing a default case: switch (frs.Name) {  case "$AttrDef":  	#region Attributes  	foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  		if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.DATA) {  			long st = p.ClusterToSector ((int)(att.Nonresident.Startcluster));  			// * (byte)p.Boot_Sector.Sectors_Per_Cluster.Value + (uint)p.Boot_Sector.Hidden_Sectors.Value);  			byte[] am = ReadSectors (st' 0x40 * 2 * 0x200);  			BitStreamReader sm = new BitStreamReader (am' false);  			frs.Attribute_Definitions = new List<ATTRIBUTE_DEFINITION_DATA> ();  			for (int i = 0; i < 0x10; i++) {  				sm.Position = i * 0xa0;  				// catch with standard length  				ATTRIBUTE_DEFINITION_DATA def = new ATTRIBUTE_DEFINITION_DATA (sm' st * 0x200);  				frs.Attribute_Definitions.Add (def);  			}  			break;  		}  	}  	break;  #endregion  case ".":  	#region Root directory  	foreach (ATTRIBUTE_RECORD_HEADER att in frs.Attributes) {  		if (att.Attribute_Type == ATTRIBUTE_TYPE_CODE.INDEX_ALLOCATION) {  			ParseIndexAllocation ((BootRecord_NTFS)p.Boot_Sector' frs' att' p);  			break;  		}  	}  	break;  #endregion  }  
Missing Default,LowLevel,LowLevelViewer,C:\repos\mbatest_Binhed\LowLevel\Form1.cs,treeView1_AfterSelect,The following switch statement is missing a default case: switch (t.Text.ToLower ()) {  case "master boot record":  	secteurNumber = 0;  	secteur.Text = secteurNumber.ToString ("x2");  	ReadsFirstSector ();  	break;  }  
