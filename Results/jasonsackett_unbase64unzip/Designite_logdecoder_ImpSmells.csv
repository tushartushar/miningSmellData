Implementation smell,Namespace,Class,File,Method,Description
Long Statement,logdecoder,Program,C:\repos\jasonsackett_unbase64unzip\logdecoder\Program.cs,Main,The length of the statement  "		Console.WriteLine ("logdecoder takes an input file'\n and runs a System.Convert.FromBase64String on it'\n and runs System.IO.Compression.GZipStream Decompress on the result.\n The output is saved to '{input}x.txt'\n usage: logdecoder.exe {inputfile}"); " is 252.
Magic Number,logdecoder,Program,C:\repos\jasonsackett_unbase64unzip\logdecoder\Program.cs,DecodeLog,The following statement contains a magic number: try {  	var fs = new FileStream (file' FileMode.Open);  	if (fs.CanRead) {  		Console.WriteLine ("reading file: " + file);  		const int blockSize = 16384;  		var offset = 0;  		var fullread = new byte[fs.Length];  		var msFullread = new MemoryStream (fullread);  		while (fs.Length > offset) {  			var lengthToRead = blockSize;  			if (offset + blockSize > fs.Length) {  				lengthToRead = (int)fs.Length - offset;  			}  			var chunk = new byte[blockSize];  			var read = fs.Read (chunk' offset' lengthToRead);  			msFullread.Write (chunk' offset' read);  			offset += read;  		}  		var uncompressedandencoded = Compress.Decompress (Compress.Base64Decode (Compress.GetString (fullread)));  		const string nameAppend = "x.txt";  		var fsout = new FileStream (file + nameAppend' FileMode.Create);  		if (fsout.CanWrite) {  			fsout.Write (uncompressedandencoded' 0' uncompressedandencoded.Length);  			Console.WriteLine ("wrote file: " + file + nameAppend);  		}  		else {  			Console.WriteLine ("cannot write output file: " + file + nameAppend);  		}  	}  	else {  		Console.WriteLine ("cannot read input file: " + file);  	}  }  catch (Exception e) {  	Console.WriteLine ("exception: " + e.Message);  }  
Magic Number,logdecoder,Program,C:\repos\jasonsackett_unbase64unzip\logdecoder\Program.cs,DecodeLog,The following statement contains a magic number: if (fs.CanRead) {  	Console.WriteLine ("reading file: " + file);  	const int blockSize = 16384;  	var offset = 0;  	var fullread = new byte[fs.Length];  	var msFullread = new MemoryStream (fullread);  	while (fs.Length > offset) {  		var lengthToRead = blockSize;  		if (offset + blockSize > fs.Length) {  			lengthToRead = (int)fs.Length - offset;  		}  		var chunk = new byte[blockSize];  		var read = fs.Read (chunk' offset' lengthToRead);  		msFullread.Write (chunk' offset' read);  		offset += read;  	}  	var uncompressedandencoded = Compress.Decompress (Compress.Base64Decode (Compress.GetString (fullread)));  	const string nameAppend = "x.txt";  	var fsout = new FileStream (file + nameAppend' FileMode.Create);  	if (fsout.CanWrite) {  		fsout.Write (uncompressedandencoded' 0' uncompressedandencoded.Length);  		Console.WriteLine ("wrote file: " + file + nameAppend);  	}  	else {  		Console.WriteLine ("cannot write output file: " + file + nameAppend);  	}  }  else {  	Console.WriteLine ("cannot read input file: " + file);  }  
Magic Number,logdecoder,Compress,C:\repos\jasonsackett_unbase64unzip\logdecoder\Program.cs,Decompress,The following statement contains a magic number: ms.Write (gzBuffer' 4' gzBuffer.Length - 4);  
Magic Number,logdecoder,Compress,C:\repos\jasonsackett_unbase64unzip\logdecoder\Program.cs,Decompress,The following statement contains a magic number: ms.Write (gzBuffer' 4' gzBuffer.Length - 4);  
