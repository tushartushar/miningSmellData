Implementation smell,Namespace,Class,File,Method,Description
Long Method,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The method has 74 lines of code.
Long Method,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The method has 363 lines of code.
Long Method,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendRequestToTarget,The method has 130 lines of code.
Long Method,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendResponseToClient,The method has 105 lines of code.
Long Method,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunRules,The method has 81 lines of code.
Long Method,ManagedFusion.Rewriter,ServerVariable,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ServerVariable.cs,GetValue,The method has 68 lines of code.
Complex Method,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,Cyclomatic complexity of the method is 33
Complex Method,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,GetCondition,Cyclomatic complexity of the method is 7
Complex Method,ManagedFusion.Rewriter.Engines,MicrosoftRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\MicrosoftRuleSet.cs,GetRule,Cyclomatic complexity of the method is 9
Complex Method,ManagedFusion.Rewriter.Engines,MicrosoftRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\MicrosoftRuleSet.cs,GetAction,Cyclomatic complexity of the method is 17
Complex Method,ManagedFusion.Rewriter.Engines,MicrosoftRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\MicrosoftRuleSet.cs,GetCondition,Cyclomatic complexity of the method is 17
Complex Method,ManagedFusion.Rewriter,Pattern,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Pattern.cs,GetServerVariable,Cyclomatic complexity of the method is 20
Complex Method,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendRequestToTarget,Cyclomatic complexity of the method is 56
Complex Method,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendResponseToClient,Cyclomatic complexity of the method is 22
Complex Method,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunRules,Cyclomatic complexity of the method is 19
Complex Method,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunOutputRules,Cyclomatic complexity of the method is 13
Complex Method,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,Redirect,Cyclomatic complexity of the method is 26
Complex Method,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,Manager,Cyclomatic complexity of the method is 10
Complex Method,ManagedFusion.Rewriter,ServerVariable,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ServerVariable.cs,GetValue,Cyclomatic complexity of the method is 46
Complex Method,ManagedFusion.Rewriter.Rules.Flags,RedirectFlag,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\Flags\RedirectFlag.cs,RedirectFlag,Cyclomatic complexity of the method is 7
Long Parameter List,ManagedFusion.Rewriter.Conditions,DefaultCondition,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Conditions\DefaultCondition.cs,DefaultCondition,The method has 4 parameters.
Long Parameter List,ManagedFusion.Rewriter,KnownHttpVerb,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\KnownHttpVerb.cs,KnownHttpVerb,The method has 5 parameters.
Long Parameter List,ManagedFusion.Rewriter,RuleContext,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleContext.cs,RuleContext,The method has 4 parameters.
Long Parameter List,ManagedFusion.Rewriter,RuleContext,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleContext.cs,RuleContext,The method has 4 parameters.
Long Parameter List,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,SetServerVariable,The method has 4 parameters.
Long Parameter List,ManagedFusion.Rewriter.Rules,DefaultRule,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\DefaultRule.cs,DefaultRule,The method has 4 parameters.
Long Parameter List,ManagedFusion.Rewriter.Rules,DefaultRule,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\DefaultRule.cs,DefaultRule,The method has 5 parameters.
Long Parameter List,ManagedFusion.Rewriter.Rules.Flags,ResponseCookieFlag,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\Flags\ResponseCookieFlag.cs,ResponseCookieFlag,The method has 5 parameters.
Long Parameter List,ManagedFusion.Rewriter.Rules.Flags,ResponseStatusFlag,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\Flags\ResponseStatusFlag.cs,ResponseStatusFlag,The method has 4 parameters.
Long Statement,ManagedFusion.Rewriter.Configuration,RewriterModulesSection,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Configuration\ManagedFusionRewriterConfiguration.csd.cs,IsElementName,The length of the statement  "	return (elementName == global::ManagedFusion.Rewriter.Configuration.RewriterModulesSection.RewriterModuleItemPropertyName); " is 123.
Long Statement,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The length of the statement  "		string name = info [0]' val = info [1]' domain = info.Length > 2 ? info [2].Trim () : String.Empty' path = info.Length > 4 ? info [4].Trim () : String.Empty; " is 157.
Long Statement,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The length of the statement  "					Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing"); " is 126.
Long Statement,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The length of the statement  "					Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing"); " is 183.
Long Statement,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The length of the statement  "					Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing"); " is 191.
Long Statement,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The length of the statement  "					Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing"); " is 186.
Long Statement,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The length of the statement  "					Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing"); " is 194.
Long Statement,ManagedFusion.Rewriter.Engines,MicrosoftRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\MicrosoftRuleSet.cs,GetAction,The length of the statement  "			throw new RuleSetException ("Action Status Code should not be an int between 300 - 307' use the redirectType for this range."); " is 127.
Long Statement,ManagedFusion.Rewriter.Engines,MicrosoftRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\MicrosoftRuleSet.cs,GetConditions,The length of the statement  "			logicalGrouping = (LogicalGrouping)Enum.Parse (typeof(LogicalGrouping)' conditionsElement.Attributes ["logicalGrouping"].Value' true); " is 134.
Long Statement,ManagedFusion.Rewriter.Engines,ApacheEngine,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheEngine.cs,UseDefinedRules,The length of the statement  "			throw new RewriterEngineException ("Your ApplicationPath' " + item.ApplicationPath + "' in the config file must start with \"/\"."); " is 132.
Long Statement,ManagedFusion.Rewriter.Engines,ApacheEngine,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheEngine.cs,AddRuleSetMonitoring,The length of the statement  "	HttpRuntime.Cache.Insert (relativePath' fullPath' new CacheDependency (fullPath)' Cache.NoAbsoluteExpiration' Cache.NoSlidingExpiration' CacheItemPriority.NotRemovable' RuleSetExpired); " is 185.
Long Statement,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendRequestToTarget,The length of the statement  "		throw new HttpException ((int)HttpStatusCode.BadRequest' String.Format ("The requested url' <{0}>' could not be found."' RequestUrl)); " is 134.
Long Statement,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendRequestToTarget,The length of the statement  "					if (!c.Equals ("Keep-Alive"' StringComparison.OrdinalIgnoreCase) && !c.Equals ("Close"' StringComparison.OrdinalIgnoreCase)) " is 124.
Long Statement,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendRequestToTarget,The length of the statement  "	string currentVia = String.Format ("{0} {1}:{2} ({3})"' currentServerProtocol' currentServerName' currentServerPort' Manager.RewriterNameAndVersion); " is 149.
Long Statement,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendRequestToTarget,The length of the statement  "		using (Stream requestStream = request.GetRequestStream ()' bufferStream = new BufferedStream (context.Request.InputStream' Manager.Configuration.Rewriter.Proxy.BufferSize)) { " is 174.
Long Statement,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendRequestToTarget,The length of the statement  "		throw new HttpException ((int)HttpStatusCode.BadRequest' String.Format ("The requested url' <{0}>' could not be found."' RequestUrl)); " is 134.
Long Statement,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendRequestToTarget,The length of the statement  "		Manager.Log (String.Format ("Received '{0} {1}'"' ((int)httpResponse.StatusCode)' httpResponse.StatusDescription)' "Proxy"); " is 124.
Long Statement,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendResponseToClient,The length of the statement  "					// if the requested location for the host and port is the same as the requested URL we need to update them to the response " is 122.
Long Statement,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendResponseToClient,The length of the statement  "					if (Uri.Compare (requestLocationUrl' RequestUrl' UriComponents.SchemeAndServer' UriFormat.SafeUnescaped' StringComparison.OrdinalIgnoreCase) == 0) { " is 148.
Long Statement,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendResponseToClient,The length of the statement  "		Manager.Log (String.Format ("Responding '{0} {1}'"' ((int)httpResponse.StatusCode)' httpResponse.StatusDescription)' "Proxy"); " is 126.
Long Statement,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunRules,The length of the statement  "		// if the scheme' host' and ports do not match on the request vs the rewrite a redirect needs to be performed instead of a rewrite " is 130.
Long Statement,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunRules,The length of the statement  "		if (Uri.Compare (currentUrl' context.RequestedUrl' UriComponents.SchemeAndServer' UriFormat.SafeUnescaped' StringComparison.OrdinalIgnoreCase) != 0) { " is 150.
Long Statement,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunRules,The length of the statement  "	if (Uri.Compare (currentUrl' url' UriComponents.HttpRequestUrl' UriFormat.SafeUnescaped' StringComparison.OrdinalIgnoreCase) == 0) " is 130.
Long Statement,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,AddRequestHeader,The length of the statement  "				PropertyInfo isReadOnlyProperty = targetType.GetProperty ("IsReadOnly"' BindingFlags.Instance | BindingFlags.NonPublic); " is 120.
Long Statement,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,AddRequestHeader,The length of the statement  "				MethodInfo fillInHeadersCollectionMethod = targetType.GetMethod ("BaseSet"' BindingFlags.Instance | BindingFlags.NonPublic' null' new Type[] { " is 142.
Long Statement,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,SetServerVariable,The length of the statement  "				PropertyInfo isReadOnlyProperty = targetType.GetProperty ("IsReadOnly"' BindingFlags.Instance | BindingFlags.NonPublic); " is 120.
Long Statement,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,SetServerVariable,The length of the statement  "				MethodInfo fillInHeadersCollectionMethod = targetType.GetMethod ("BaseSet"' BindingFlags.Instance | BindingFlags.NonPublic' null' new Type[] { " is 142.
Long Statement,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,ModifyIIS7WorkerRequest,The length of the statement  "				FieldInfo isRewriteModuleEnabledField = wrType.GetField ("_isRewriteModuleEnabled"' BindingFlags.Instance | BindingFlags.NonPublic); " is 132.
Long Statement,ManagedFusion.Rewriter,ServerVariable,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ServerVariable.cs,GetValue,The length of the statement  "				value = context.HttpContext.Request.ServerVariables ["REQUEST_METHOD"] + " " + context.HttpContext.Request.ServerVariables ["PATH_INFO"] + " " + context.HttpContext.Request.ServerVariables ["SERVER_PROTOCOL"]; " is 209.
Long Statement,ManagedFusion.Rewriter,ServerVariable,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ServerVariable.cs,GetValue,The length of the statement  "				value = String.IsNullOrEmpty (context.HttpContext.Request.Headers ["X-Rewriter-Transfer"]) ? Boolean.FalseString : Boolean.TrueString; " is 134.
Long Statement,ManagedFusion.Rewriter.Rules.Flags,ResponseStatusFlag,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\Flags\ResponseStatusFlag.cs,Apply,The length of the statement  "		Manager.LogIf (context.LogLevel >= 2' String.Format ("HTTP Status: {0}.{1} {2}"' response.StatusCode' response.SubStatusCode' response.StatusDescription)' "Rewrite"); " is 166.
Complex Conditional,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendResponseToClient,The conditional expression  "name == "Server" || name == "X-Powered-By" || name == "Date" || name == "Host""  is complex.
Complex Conditional,ManagedFusion.Rewriter.Rules.Flags,ResponseStatusFlag,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\Flags\ResponseStatusFlag.cs,FromCamelCase,The conditional expression  "!first && (Char.IsUpper (ch) || Char.IsDigit (ch) && !Char.IsDigit (lastChar))"  is complex.
Empty Catch Block,ManagedFusion.Rewriter.Engines,ApacheEngine,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheEngine.cs,ScanDirectoriesForRules,The method has an empty catch block.
Empty Catch Block,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendResponseToClient,The method has an empty catch block.
Empty Catch Block,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,AddRequestHeader,The method has an empty catch block.
Empty Catch Block,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,AddRequestHeader,The method has an empty catch block.
Empty Catch Block,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,AddRequestHeader,The method has an empty catch block.
Empty Catch Block,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,SetServerVariable,The method has an empty catch block.
Empty Catch Block,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,SetServerVariable,The method has an empty catch block.
Empty Catch Block,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,SetServerVariable,The method has an empty catch block.
Empty Catch Block,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,ModifyIIS7WorkerRequest,The method has an empty catch block.
Empty Catch Block,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,ModifyIIS7WorkerRequest,The method has an empty catch block.
Empty Catch Block,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,ModifyIIS7WorkerRequest,The method has an empty catch block.
Magic Number,ManagedFusion.Rewriter.Conditions,DefaultCondition,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Conditions\DefaultCondition.cs,Evaluate,The following statement contains a magic number: Manager.LogIf (context.LogLevel >= 2' isMatch ? " Matched" : " Not Matched"' context.LogCategory);  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddConditionFlag,The following statement contains a magic number: Manager.LogIf (LogLevel >= 5' "Error: No flag match was found for " + key' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The following statement contains a magic number: switch (key) {  case "chain":  case "C":  	return new RF.ChainFlag ();  case "cookie":  case "CO": {  	if (value == null)  		return null;  	string[] info = value.Split (new[] {  		':'  	}' 5' StringSplitOptions.None);  	string name = info [0]' val = info [1]' domain = info.Length > 2 ? info [2].Trim () : String.Empty' path = info.Length > 4 ? info [4].Trim () : String.Empty;  	TimeSpan? expires = null;  	int expiresMinutes;  	if (info.Length > 3 && Int32.TryParse (info [3]' out expiresMinutes))  		expires = new TimeSpan (0' expiresMinutes' 0);  	return new RF.ResponseCookieFlag (name' val' domain' expires' path);  }  //case "env":  //case "E": key = "env"; break;  case "forbidden":  case "F":  	return new RF.ResponseStatusFlag ("forbidden");  case "notfound":  case "NF":  	return new RF.ResponseStatusFlag ("notfound");  case "gone":  case "G":  	return new RF.ResponseStatusFlag ("gone");  case "last":  case "L":  	return new RF.LastFlag ();  case "next":  case "N":  	return new RF.NextRuleFlag ();  case "nocase":  case "NC":  	return new RF.NoCaseFlag ();  case "noescape":  case "NE":  	return new RF.NoEscapeFlag ();  case "nosubreq":  case "NS":  	return new RF.NotForInternalSubRequestsFlag ();  case "proxy":  case "P":  	return new RF.ProxyFlag ();  //case "passthrough":  //case "PT": key = "passthrough"; break;  case "qsappend":  case "QSA":  	return new RF.QueryStringAppendFlag ();  case "redirect":  case "R":  	return new RF.RedirectFlag (value);  case "skip":  case "S": {  	int skipIndex;  	if (Int32.TryParse (value' out skipIndex))  		return new RF.SkipRuleFlag (skipIndex);  	Manager.LogIf (LogLevel >= 5' "Error: " + value + " is not a valid skip index."' "Rule Processing");  	return null;  }  case "type":  case "T":  	return new RF.ResponseMimeTypeFlag (value);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The following statement contains a magic number: switch (key) {  case "chain":  case "C":  	return new RF.ChainFlag ();  case "cookie":  case "CO": {  	if (value == null)  		return null;  	string[] info = value.Split (new[] {  		':'  	}' 5' StringSplitOptions.None);  	string name = info [0]' val = info [1]' domain = info.Length > 2 ? info [2].Trim () : String.Empty' path = info.Length > 4 ? info [4].Trim () : String.Empty;  	TimeSpan? expires = null;  	int expiresMinutes;  	if (info.Length > 3 && Int32.TryParse (info [3]' out expiresMinutes))  		expires = new TimeSpan (0' expiresMinutes' 0);  	return new RF.ResponseCookieFlag (name' val' domain' expires' path);  }  //case "env":  //case "E": key = "env"; break;  case "forbidden":  case "F":  	return new RF.ResponseStatusFlag ("forbidden");  case "notfound":  case "NF":  	return new RF.ResponseStatusFlag ("notfound");  case "gone":  case "G":  	return new RF.ResponseStatusFlag ("gone");  case "last":  case "L":  	return new RF.LastFlag ();  case "next":  case "N":  	return new RF.NextRuleFlag ();  case "nocase":  case "NC":  	return new RF.NoCaseFlag ();  case "noescape":  case "NE":  	return new RF.NoEscapeFlag ();  case "nosubreq":  case "NS":  	return new RF.NotForInternalSubRequestsFlag ();  case "proxy":  case "P":  	return new RF.ProxyFlag ();  //case "passthrough":  //case "PT": key = "passthrough"; break;  case "qsappend":  case "QSA":  	return new RF.QueryStringAppendFlag ();  case "redirect":  case "R":  	return new RF.RedirectFlag (value);  case "skip":  case "S": {  	int skipIndex;  	if (Int32.TryParse (value' out skipIndex))  		return new RF.SkipRuleFlag (skipIndex);  	Manager.LogIf (LogLevel >= 5' "Error: " + value + " is not a valid skip index."' "Rule Processing");  	return null;  }  case "type":  case "T":  	return new RF.ResponseMimeTypeFlag (value);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The following statement contains a magic number: switch (key) {  case "chain":  case "C":  	return new RF.ChainFlag ();  case "cookie":  case "CO": {  	if (value == null)  		return null;  	string[] info = value.Split (new[] {  		':'  	}' 5' StringSplitOptions.None);  	string name = info [0]' val = info [1]' domain = info.Length > 2 ? info [2].Trim () : String.Empty' path = info.Length > 4 ? info [4].Trim () : String.Empty;  	TimeSpan? expires = null;  	int expiresMinutes;  	if (info.Length > 3 && Int32.TryParse (info [3]' out expiresMinutes))  		expires = new TimeSpan (0' expiresMinutes' 0);  	return new RF.ResponseCookieFlag (name' val' domain' expires' path);  }  //case "env":  //case "E": key = "env"; break;  case "forbidden":  case "F":  	return new RF.ResponseStatusFlag ("forbidden");  case "notfound":  case "NF":  	return new RF.ResponseStatusFlag ("notfound");  case "gone":  case "G":  	return new RF.ResponseStatusFlag ("gone");  case "last":  case "L":  	return new RF.LastFlag ();  case "next":  case "N":  	return new RF.NextRuleFlag ();  case "nocase":  case "NC":  	return new RF.NoCaseFlag ();  case "noescape":  case "NE":  	return new RF.NoEscapeFlag ();  case "nosubreq":  case "NS":  	return new RF.NotForInternalSubRequestsFlag ();  case "proxy":  case "P":  	return new RF.ProxyFlag ();  //case "passthrough":  //case "PT": key = "passthrough"; break;  case "qsappend":  case "QSA":  	return new RF.QueryStringAppendFlag ();  case "redirect":  case "R":  	return new RF.RedirectFlag (value);  case "skip":  case "S": {  	int skipIndex;  	if (Int32.TryParse (value' out skipIndex))  		return new RF.SkipRuleFlag (skipIndex);  	Manager.LogIf (LogLevel >= 5' "Error: " + value + " is not a valid skip index."' "Rule Processing");  	return null;  }  case "type":  case "T":  	return new RF.ResponseMimeTypeFlag (value);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The following statement contains a magic number: switch (key) {  case "chain":  case "C":  	return new RF.ChainFlag ();  case "cookie":  case "CO": {  	if (value == null)  		return null;  	string[] info = value.Split (new[] {  		':'  	}' 5' StringSplitOptions.None);  	string name = info [0]' val = info [1]' domain = info.Length > 2 ? info [2].Trim () : String.Empty' path = info.Length > 4 ? info [4].Trim () : String.Empty;  	TimeSpan? expires = null;  	int expiresMinutes;  	if (info.Length > 3 && Int32.TryParse (info [3]' out expiresMinutes))  		expires = new TimeSpan (0' expiresMinutes' 0);  	return new RF.ResponseCookieFlag (name' val' domain' expires' path);  }  //case "env":  //case "E": key = "env"; break;  case "forbidden":  case "F":  	return new RF.ResponseStatusFlag ("forbidden");  case "notfound":  case "NF":  	return new RF.ResponseStatusFlag ("notfound");  case "gone":  case "G":  	return new RF.ResponseStatusFlag ("gone");  case "last":  case "L":  	return new RF.LastFlag ();  case "next":  case "N":  	return new RF.NextRuleFlag ();  case "nocase":  case "NC":  	return new RF.NoCaseFlag ();  case "noescape":  case "NE":  	return new RF.NoEscapeFlag ();  case "nosubreq":  case "NS":  	return new RF.NotForInternalSubRequestsFlag ();  case "proxy":  case "P":  	return new RF.ProxyFlag ();  //case "passthrough":  //case "PT": key = "passthrough"; break;  case "qsappend":  case "QSA":  	return new RF.QueryStringAppendFlag ();  case "redirect":  case "R":  	return new RF.RedirectFlag (value);  case "skip":  case "S": {  	int skipIndex;  	if (Int32.TryParse (value' out skipIndex))  		return new RF.SkipRuleFlag (skipIndex);  	Manager.LogIf (LogLevel >= 5' "Error: " + value + " is not a valid skip index."' "Rule Processing");  	return null;  }  case "type":  case "T":  	return new RF.ResponseMimeTypeFlag (value);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The following statement contains a magic number: switch (key) {  case "chain":  case "C":  	return new RF.ChainFlag ();  case "cookie":  case "CO": {  	if (value == null)  		return null;  	string[] info = value.Split (new[] {  		':'  	}' 5' StringSplitOptions.None);  	string name = info [0]' val = info [1]' domain = info.Length > 2 ? info [2].Trim () : String.Empty' path = info.Length > 4 ? info [4].Trim () : String.Empty;  	TimeSpan? expires = null;  	int expiresMinutes;  	if (info.Length > 3 && Int32.TryParse (info [3]' out expiresMinutes))  		expires = new TimeSpan (0' expiresMinutes' 0);  	return new RF.ResponseCookieFlag (name' val' domain' expires' path);  }  //case "env":  //case "E": key = "env"; break;  case "forbidden":  case "F":  	return new RF.ResponseStatusFlag ("forbidden");  case "notfound":  case "NF":  	return new RF.ResponseStatusFlag ("notfound");  case "gone":  case "G":  	return new RF.ResponseStatusFlag ("gone");  case "last":  case "L":  	return new RF.LastFlag ();  case "next":  case "N":  	return new RF.NextRuleFlag ();  case "nocase":  case "NC":  	return new RF.NoCaseFlag ();  case "noescape":  case "NE":  	return new RF.NoEscapeFlag ();  case "nosubreq":  case "NS":  	return new RF.NotForInternalSubRequestsFlag ();  case "proxy":  case "P":  	return new RF.ProxyFlag ();  //case "passthrough":  //case "PT": key = "passthrough"; break;  case "qsappend":  case "QSA":  	return new RF.QueryStringAppendFlag ();  case "redirect":  case "R":  	return new RF.RedirectFlag (value);  case "skip":  case "S": {  	int skipIndex;  	if (Int32.TryParse (value' out skipIndex))  		return new RF.SkipRuleFlag (skipIndex);  	Manager.LogIf (LogLevel >= 5' "Error: " + value + " is not a valid skip index."' "Rule Processing");  	return null;  }  case "type":  case "T":  	return new RF.ResponseMimeTypeFlag (value);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The following statement contains a magic number: switch (key) {  case "chain":  case "C":  	return new RF.ChainFlag ();  case "cookie":  case "CO": {  	if (value == null)  		return null;  	string[] info = value.Split (new[] {  		':'  	}' 5' StringSplitOptions.None);  	string name = info [0]' val = info [1]' domain = info.Length > 2 ? info [2].Trim () : String.Empty' path = info.Length > 4 ? info [4].Trim () : String.Empty;  	TimeSpan? expires = null;  	int expiresMinutes;  	if (info.Length > 3 && Int32.TryParse (info [3]' out expiresMinutes))  		expires = new TimeSpan (0' expiresMinutes' 0);  	return new RF.ResponseCookieFlag (name' val' domain' expires' path);  }  //case "env":  //case "E": key = "env"; break;  case "forbidden":  case "F":  	return new RF.ResponseStatusFlag ("forbidden");  case "notfound":  case "NF":  	return new RF.ResponseStatusFlag ("notfound");  case "gone":  case "G":  	return new RF.ResponseStatusFlag ("gone");  case "last":  case "L":  	return new RF.LastFlag ();  case "next":  case "N":  	return new RF.NextRuleFlag ();  case "nocase":  case "NC":  	return new RF.NoCaseFlag ();  case "noescape":  case "NE":  	return new RF.NoEscapeFlag ();  case "nosubreq":  case "NS":  	return new RF.NotForInternalSubRequestsFlag ();  case "proxy":  case "P":  	return new RF.ProxyFlag ();  //case "passthrough":  //case "PT": key = "passthrough"; break;  case "qsappend":  case "QSA":  	return new RF.QueryStringAppendFlag ();  case "redirect":  case "R":  	return new RF.RedirectFlag (value);  case "skip":  case "S": {  	int skipIndex;  	if (Int32.TryParse (value' out skipIndex))  		return new RF.SkipRuleFlag (skipIndex);  	Manager.LogIf (LogLevel >= 5' "Error: " + value + " is not a valid skip index."' "Rule Processing");  	return null;  }  case "type":  case "T":  	return new RF.ResponseMimeTypeFlag (value);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The following statement contains a magic number: switch (key) {  case "chain":  case "C":  	return new RF.ChainFlag ();  case "cookie":  case "CO": {  	if (value == null)  		return null;  	string[] info = value.Split (new[] {  		':'  	}' 5' StringSplitOptions.None);  	string name = info [0]' val = info [1]' domain = info.Length > 2 ? info [2].Trim () : String.Empty' path = info.Length > 4 ? info [4].Trim () : String.Empty;  	TimeSpan? expires = null;  	int expiresMinutes;  	if (info.Length > 3 && Int32.TryParse (info [3]' out expiresMinutes))  		expires = new TimeSpan (0' expiresMinutes' 0);  	return new RF.ResponseCookieFlag (name' val' domain' expires' path);  }  //case "env":  //case "E": key = "env"; break;  case "forbidden":  case "F":  	return new RF.ResponseStatusFlag ("forbidden");  case "notfound":  case "NF":  	return new RF.ResponseStatusFlag ("notfound");  case "gone":  case "G":  	return new RF.ResponseStatusFlag ("gone");  case "last":  case "L":  	return new RF.LastFlag ();  case "next":  case "N":  	return new RF.NextRuleFlag ();  case "nocase":  case "NC":  	return new RF.NoCaseFlag ();  case "noescape":  case "NE":  	return new RF.NoEscapeFlag ();  case "nosubreq":  case "NS":  	return new RF.NotForInternalSubRequestsFlag ();  case "proxy":  case "P":  	return new RF.ProxyFlag ();  //case "passthrough":  //case "PT": key = "passthrough"; break;  case "qsappend":  case "QSA":  	return new RF.QueryStringAppendFlag ();  case "redirect":  case "R":  	return new RF.RedirectFlag (value);  case "skip":  case "S": {  	int skipIndex;  	if (Int32.TryParse (value' out skipIndex))  		return new RF.SkipRuleFlag (skipIndex);  	Manager.LogIf (LogLevel >= 5' "Error: " + value + " is not a valid skip index."' "Rule Processing");  	return null;  }  case "type":  case "T":  	return new RF.ResponseMimeTypeFlag (value);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The following statement contains a magic number: switch (key) {  case "chain":  case "C":  	return new RF.ChainFlag ();  case "cookie":  case "CO": {  	if (value == null)  		return null;  	string[] info = value.Split (new[] {  		':'  	}' 5' StringSplitOptions.None);  	string name = info [0]' val = info [1]' domain = info.Length > 2 ? info [2].Trim () : String.Empty' path = info.Length > 4 ? info [4].Trim () : String.Empty;  	TimeSpan? expires = null;  	int expiresMinutes;  	if (info.Length > 3 && Int32.TryParse (info [3]' out expiresMinutes))  		expires = new TimeSpan (0' expiresMinutes' 0);  	return new RF.ResponseCookieFlag (name' val' domain' expires' path);  }  //case "env":  //case "E": key = "env"; break;  case "forbidden":  case "F":  	return new RF.ResponseStatusFlag ("forbidden");  case "notfound":  case "NF":  	return new RF.ResponseStatusFlag ("notfound");  case "gone":  case "G":  	return new RF.ResponseStatusFlag ("gone");  case "last":  case "L":  	return new RF.LastFlag ();  case "next":  case "N":  	return new RF.NextRuleFlag ();  case "nocase":  case "NC":  	return new RF.NoCaseFlag ();  case "noescape":  case "NE":  	return new RF.NoEscapeFlag ();  case "nosubreq":  case "NS":  	return new RF.NotForInternalSubRequestsFlag ();  case "proxy":  case "P":  	return new RF.ProxyFlag ();  //case "passthrough":  //case "PT": key = "passthrough"; break;  case "qsappend":  case "QSA":  	return new RF.QueryStringAppendFlag ();  case "redirect":  case "R":  	return new RF.RedirectFlag (value);  case "skip":  case "S": {  	int skipIndex;  	if (Int32.TryParse (value' out skipIndex))  		return new RF.SkipRuleFlag (skipIndex);  	Manager.LogIf (LogLevel >= 5' "Error: " + value + " is not a valid skip index."' "Rule Processing");  	return null;  }  case "type":  case "T":  	return new RF.ResponseMimeTypeFlag (value);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The following statement contains a magic number: if (info.Length > 3 && Int32.TryParse (info [3]' out expiresMinutes))  	expires = new TimeSpan (0' expiresMinutes' 0);  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The following statement contains a magic number: if (info.Length > 3 && Int32.TryParse (info [3]' out expiresMinutes))  	expires = new TimeSpan (0' expiresMinutes' 0);  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The following statement contains a magic number: Manager.LogIf (LogLevel >= 5' "Error: " + value + " is not a valid skip index."' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The following statement contains a magic number: Manager.LogIf (LogLevel >= 5' "Error: No flag match was found for " + key' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: lock (_refreshLock) {  	Manager.LogEnabled = false;  	Manager.LogPath = null;  	string tempBase = PhysicalBase;  	string tempLogPath = null;  	int tempLogLevel = 0;  	int tempMaxInternalTransfers = 10;  	bool tempEngineEnabled = false;  	string line;  	IList<ICondition> conditions = new List<ICondition> (0);  	IList<IRule> rules = new List<IRule> ();  	IList<IRule> outputRules = new List<IRule> ();  	IList<string> unknownLines = new List<string> ();  	ModuleFactory modules = new ModuleFactory ();  	while (reader.Peek () >= 0) {  		line = reader.ReadLine ().Trim ();  		if (String.IsNullOrEmpty (line)) {  			// just plain old ignore empty lines no logging or anything  			continue;  		} else if (line [0] == '#') {  			Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  		} else if (RewriteEngineLine.IsMatch (line)) {  			#region RewriteEngine  			Match match = RewriteEngineLine.Match (line);  			string engineState = match.Groups ["state"].Value;  			// by default the engine is turned off  			if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  				rules.Clear ();  				tempEngineEnabled = false;  				// don't bother processing any other rules if the engine is disabled  				break;  			} else {  				tempEngineEnabled = true;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  			#endregion  		} else if (RewriteOptionsLine.IsMatch (line)) {  			#region RewriteOptions  			Match match = RewriteOptionsLine.Match (line);  			Group variables = match.Groups ["var"];  			if (variables.Success) {  				foreach (Capture var in variables.Captures) {  					string[] parts = var.Value.Split (new[] {  						'='  					}' 2);  					bool variableUnderstood = false;  					if (parts.Length == 2) {  						switch (parts [0]) {  						case "inherit":  							break;  						// obsolete in 2.1 mod_rewrite  						case "MaxRedirects":  							Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  							int maxInternalTransfers;  							if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  								tempMaxInternalTransfers = maxInternalTransfers;  								variableUnderstood = true;  							}  							break;  						}  					}  					if (!variableUnderstood)  						Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  				}  			}  			#endregion  		} else if (RewriteBaseLine.IsMatch (line)) {  			#region RewriteBase  			Match match = RewriteBaseLine.Match (line);  			tempBase = match.Groups ["base"].Value;  			Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  			#endregion  		} else if (RewriteModuleLine.IsMatch (line)) {  			#region RewriteModule  			Match match = RewriteModuleLine.Match (line);  			string moduleName = match.Groups ["name"].Value;  			string moduleType = match.Groups ["type"].Value;  			Type module = Type.GetType (moduleType' false' true);  			if (module == null)  				module = BuildManager.GetType (moduleType' false' true);  			if (module == null) {  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  			} else {  				// add the module to the list  				modules.AddModule (moduleName' module);  				Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  			}  			#endregion  		} else if (RewriteLogLine.IsMatch (line)) {  			#region RewriteLog  			Match match = RewriteLogLine.Match (line);  			tempLogPath = match.Groups ["location"].Value;  			tempLogPath = NormalizeLogLocation (tempLogPath);  			Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  			#endregion  		} else if (RewriteLogLevelLine.IsMatch (line)) {  			#region RewriteLogLevel  			Match match = RewriteLogLevelLine.Match (line);  			int logLevel = 1;  			if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  				tempLogLevel = 0;  				Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  			} else {  				tempLogLevel = logLevel;  			}  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  			#endregion  		} else if (RewriteCondLine.IsMatch (line)) {  			#region RewriteCond  			Match match = RewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (RewriteRuleLine.IsMatch (line)) {  			#region RewriteRule  			Match match = RewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				rules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("RewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("RewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteCondLine.IsMatch (line)) {  			#region OutRewriteCond  			Match match = OutRewriteCondLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IConditionFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitConditionFlags (match.Groups ["flags"].Value);  				else  					flags = new ConditionFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (ConditionFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				string test = match.Groups ["test"].Value;  				string pattern = match.Groups ["pattern"].Value;  				IConditionTestValue testValue;  				ICondition condition;  				// create the second module  				if (moduleType2 == null)  					testValue = GetConditionTestValue (ref test);  				else  					testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  				// create the first module  				if (moduleType1 == null)  					condition = GetCondition (pattern);  				else  					condition = Activator.CreateInstance (moduleType1) as ICondition;  				// initialize the modules  				testValue.Init (test);  				condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  				// add condition to next rule that shows up  				conditions.Add (condition);  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteCond: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else if (OutRewriteRuleLine.IsMatch (line)) {  			#region OutRewriteRule  			Match match = OutRewriteRuleLine.Match (line);  			string module1 = match.Groups ["module1"].Value;  			string module2 = match.Groups ["module2"].Value;  			Type moduleType1 = null;  			Type moduleType2 = null;  			// set the types of the first module  			if (modules.ContainsName (module1))  				moduleType1 = modules.GetModule (module1);  			// make sure the module is of the right type  			if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  				moduleType1 = null;  			// set the types of the second module  			if (modules.ContainsName (module2))  				moduleType2 = modules.GetModule (module2);  			// make sure the module is of the right type  			if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  				moduleType2 = null;  			try {  				RegexOptions patternOptions = Manager.RuleOptions;  				IRuleFlagProcessor flags;  				if (match.Groups ["flags"] != null)  					flags = SplitRuleFlags (match.Groups ["flags"].Value);  				else  					flags = new RuleFlagProcessor ();  				// check to see if the pattern should ignore the case when testing  				if (RuleFlagsProcessor.HasNoCase (flags))  					patternOptions |= RegexOptions.IgnoreCase;  				IRule rule = null;  				IRuleAction substitution = null;  				Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  				// create the first module  				if (moduleType1 == null)  					rule = new DefaultRule ();  				else  					rule = Activator.CreateInstance (moduleType1) as IRule;  				// create the second module  				if (moduleType2 == null)  					substitution = new DefaultOutputRuleAction ();  				else  					substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  				// initialize the modules  				substitution.Init (pattern' match.Groups ["substitution"].Value);  				rule.Init (conditions' substitution' flags);  				// add condition to next rule that shows up  				outputRules.Add (rule);  				// clear conditions for next rule  				conditions.Clear ();  			} catch (Exception exc) {  				if (tempLogLevel >= 3)  					Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  				else  					Manager.Log ("OutRewriteRule: " + exc' "Error");  			} finally {  				Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  			}  			#endregion  		} else {  			unknownLines.Add (line);  		}  	}  	Manager.LogIf (tempLogLevel > 0' "Managed Fusion Rewriter Version: " + Manager.RewriterVersion' "Rule Processing");  	// clear and add new rules  	ClearRules ();  	AddRules (rules);  	AddOutputRules (outputRules);  	// try to process any unknown lines  	if (unknownLines.Count > 0) {  		RefreshUnknownLines (ref unknownLines);  		foreach (var unknownLine in unknownLines)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  	}  	// set the ruleset defining properties  	VirtualBase = tempBase;  	LogLocation = tempLogPath;  	LogLevel = tempLogLevel;  	EngineEnabled = tempEngineEnabled;  	Manager.LogPath = tempLogPath;  	Manager.LogEnabled = tempLogLevel > 0;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: while (reader.Peek () >= 0) {  	line = reader.ReadLine ().Trim ();  	if (String.IsNullOrEmpty (line)) {  		// just plain old ignore empty lines no logging or anything  		continue;  	} else if (line [0] == '#') {  		Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  	} else if (RewriteEngineLine.IsMatch (line)) {  		#region RewriteEngine  		Match match = RewriteEngineLine.Match (line);  		string engineState = match.Groups ["state"].Value;  		// by default the engine is turned off  		if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  			rules.Clear ();  			tempEngineEnabled = false;  			// don't bother processing any other rules if the engine is disabled  			break;  		} else {  			tempEngineEnabled = true;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  		#endregion  	} else if (RewriteOptionsLine.IsMatch (line)) {  		#region RewriteOptions  		Match match = RewriteOptionsLine.Match (line);  		Group variables = match.Groups ["var"];  		if (variables.Success) {  			foreach (Capture var in variables.Captures) {  				string[] parts = var.Value.Split (new[] {  					'='  				}' 2);  				bool variableUnderstood = false;  				if (parts.Length == 2) {  					switch (parts [0]) {  					case "inherit":  						break;  					// obsolete in 2.1 mod_rewrite  					case "MaxRedirects":  						Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  						int maxInternalTransfers;  						if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  							tempMaxInternalTransfers = maxInternalTransfers;  							variableUnderstood = true;  						}  						break;  					}  				}  				if (!variableUnderstood)  					Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  			}  		}  		#endregion  	} else if (RewriteBaseLine.IsMatch (line)) {  		#region RewriteBase  		Match match = RewriteBaseLine.Match (line);  		tempBase = match.Groups ["base"].Value;  		Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  		#endregion  	} else if (RewriteModuleLine.IsMatch (line)) {  		#region RewriteModule  		Match match = RewriteModuleLine.Match (line);  		string moduleName = match.Groups ["name"].Value;  		string moduleType = match.Groups ["type"].Value;  		Type module = Type.GetType (moduleType' false' true);  		if (module == null)  			module = BuildManager.GetType (moduleType' false' true);  		if (module == null) {  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  		} else {  			// add the module to the list  			modules.AddModule (moduleName' module);  			Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  		}  		#endregion  	} else if (RewriteLogLine.IsMatch (line)) {  		#region RewriteLog  		Match match = RewriteLogLine.Match (line);  		tempLogPath = match.Groups ["location"].Value;  		tempLogPath = NormalizeLogLocation (tempLogPath);  		Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  		#endregion  	} else if (RewriteLogLevelLine.IsMatch (line)) {  		#region RewriteLogLevel  		Match match = RewriteLogLevelLine.Match (line);  		int logLevel = 1;  		if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  			tempLogLevel = 0;  			Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  		} else {  			tempLogLevel = logLevel;  		}  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  		#endregion  	} else if (RewriteCondLine.IsMatch (line)) {  		#region RewriteCond  		Match match = RewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (RewriteRuleLine.IsMatch (line)) {  		#region RewriteRule  		Match match = RewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			rules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("RewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("RewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteCondLine.IsMatch (line)) {  		#region OutRewriteCond  		Match match = OutRewriteCondLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IConditionFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitConditionFlags (match.Groups ["flags"].Value);  			else  				flags = new ConditionFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (ConditionFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			string test = match.Groups ["test"].Value;  			string pattern = match.Groups ["pattern"].Value;  			IConditionTestValue testValue;  			ICondition condition;  			// create the second module  			if (moduleType2 == null)  				testValue = GetConditionTestValue (ref test);  			else  				testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  			// create the first module  			if (moduleType1 == null)  				condition = GetCondition (pattern);  			else  				condition = Activator.CreateInstance (moduleType1) as ICondition;  			// initialize the modules  			testValue.Init (test);  			condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  			// add condition to next rule that shows up  			conditions.Add (condition);  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteCond: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else if (OutRewriteRuleLine.IsMatch (line)) {  		#region OutRewriteRule  		Match match = OutRewriteRuleLine.Match (line);  		string module1 = match.Groups ["module1"].Value;  		string module2 = match.Groups ["module2"].Value;  		Type moduleType1 = null;  		Type moduleType2 = null;  		// set the types of the first module  		if (modules.ContainsName (module1))  			moduleType1 = modules.GetModule (module1);  		// make sure the module is of the right type  		if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  			moduleType1 = null;  		// set the types of the second module  		if (modules.ContainsName (module2))  			moduleType2 = modules.GetModule (module2);  		// make sure the module is of the right type  		if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  			moduleType2 = null;  		try {  			RegexOptions patternOptions = Manager.RuleOptions;  			IRuleFlagProcessor flags;  			if (match.Groups ["flags"] != null)  				flags = SplitRuleFlags (match.Groups ["flags"].Value);  			else  				flags = new RuleFlagProcessor ();  			// check to see if the pattern should ignore the case when testing  			if (RuleFlagsProcessor.HasNoCase (flags))  				patternOptions |= RegexOptions.IgnoreCase;  			IRule rule = null;  			IRuleAction substitution = null;  			Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  			// create the first module  			if (moduleType1 == null)  				rule = new DefaultRule ();  			else  				rule = Activator.CreateInstance (moduleType1) as IRule;  			// create the second module  			if (moduleType2 == null)  				substitution = new DefaultOutputRuleAction ();  			else  				substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  			// initialize the modules  			substitution.Init (pattern' match.Groups ["substitution"].Value);  			rule.Init (conditions' substitution' flags);  			// add condition to next rule that shows up  			outputRules.Add (rule);  			// clear conditions for next rule  			conditions.Clear ();  		} catch (Exception exc) {  			if (tempLogLevel >= 3)  				Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  			else  				Manager.Log ("OutRewriteRule: " + exc' "Error");  		} finally {  			Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  		}  		#endregion  	} else {  		unknownLines.Add (line);  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (String.IsNullOrEmpty (line)) {  	// just plain old ignore empty lines no logging or anything  	continue;  } else if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (line [0] == '#') {  	Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  } else if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: Manager.LogIf (tempLogLevel >= 4' "Comment: " + line' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteEngineLine.IsMatch (line)) {  	#region RewriteEngine  	Match match = RewriteEngineLine.Match (line);  	string engineState = match.Groups ["state"].Value;  	// by default the engine is turned off  	if (String.IsNullOrEmpty (engineState) || String.Equals (engineState' "off"' StringComparison.OrdinalIgnoreCase)) {  		rules.Clear ();  		tempEngineEnabled = false;  		// don't bother processing any other rules if the engine is disabled  		break;  	} else {  		tempEngineEnabled = true;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  	#endregion  } else if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: Manager.LogIf (tempLogLevel >= 3' "RewriteEngine: " + (tempEngineEnabled ? "Enabled" : "Disabled")' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteOptionsLine.IsMatch (line)) {  	#region RewriteOptions  	Match match = RewriteOptionsLine.Match (line);  	Group variables = match.Groups ["var"];  	if (variables.Success) {  		foreach (Capture var in variables.Captures) {  			string[] parts = var.Value.Split (new[] {  				'='  			}' 2);  			bool variableUnderstood = false;  			if (parts.Length == 2) {  				switch (parts [0]) {  				case "inherit":  					break;  				// obsolete in 2.1 mod_rewrite  				case "MaxRedirects":  					Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  					int maxInternalTransfers;  					if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  						tempMaxInternalTransfers = maxInternalTransfers;  						variableUnderstood = true;  					}  					break;  				}  			}  			if (!variableUnderstood)  				Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  		}  	}  	#endregion  } else if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (variables.Success) {  	foreach (Capture var in variables.Captures) {  		string[] parts = var.Value.Split (new[] {  			'='  		}' 2);  		bool variableUnderstood = false;  		if (parts.Length == 2) {  			switch (parts [0]) {  			case "inherit":  				break;  			// obsolete in 2.1 mod_rewrite  			case "MaxRedirects":  				Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  				int maxInternalTransfers;  				if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  					tempMaxInternalTransfers = maxInternalTransfers;  					variableUnderstood = true;  				}  				break;  			}  		}  		if (!variableUnderstood)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (variables.Success) {  	foreach (Capture var in variables.Captures) {  		string[] parts = var.Value.Split (new[] {  			'='  		}' 2);  		bool variableUnderstood = false;  		if (parts.Length == 2) {  			switch (parts [0]) {  			case "inherit":  				break;  			// obsolete in 2.1 mod_rewrite  			case "MaxRedirects":  				Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  				int maxInternalTransfers;  				if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  					tempMaxInternalTransfers = maxInternalTransfers;  					variableUnderstood = true;  				}  				break;  			}  		}  		if (!variableUnderstood)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (variables.Success) {  	foreach (Capture var in variables.Captures) {  		string[] parts = var.Value.Split (new[] {  			'='  		}' 2);  		bool variableUnderstood = false;  		if (parts.Length == 2) {  			switch (parts [0]) {  			case "inherit":  				break;  			// obsolete in 2.1 mod_rewrite  			case "MaxRedirects":  				Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  				int maxInternalTransfers;  				if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  					tempMaxInternalTransfers = maxInternalTransfers;  					variableUnderstood = true;  				}  				break;  			}  		}  		if (!variableUnderstood)  			Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: foreach (Capture var in variables.Captures) {  	string[] parts = var.Value.Split (new[] {  		'='  	}' 2);  	bool variableUnderstood = false;  	if (parts.Length == 2) {  		switch (parts [0]) {  		case "inherit":  			break;  		// obsolete in 2.1 mod_rewrite  		case "MaxRedirects":  			Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  			int maxInternalTransfers;  			if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  				tempMaxInternalTransfers = maxInternalTransfers;  				variableUnderstood = true;  			}  			break;  		}  	}  	if (!variableUnderstood)  		Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: foreach (Capture var in variables.Captures) {  	string[] parts = var.Value.Split (new[] {  		'='  	}' 2);  	bool variableUnderstood = false;  	if (parts.Length == 2) {  		switch (parts [0]) {  		case "inherit":  			break;  		// obsolete in 2.1 mod_rewrite  		case "MaxRedirects":  			Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  			int maxInternalTransfers;  			if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  				tempMaxInternalTransfers = maxInternalTransfers;  				variableUnderstood = true;  			}  			break;  		}  	}  	if (!variableUnderstood)  		Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: foreach (Capture var in variables.Captures) {  	string[] parts = var.Value.Split (new[] {  		'='  	}' 2);  	bool variableUnderstood = false;  	if (parts.Length == 2) {  		switch (parts [0]) {  		case "inherit":  			break;  		// obsolete in 2.1 mod_rewrite  		case "MaxRedirects":  			Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  			int maxInternalTransfers;  			if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  				tempMaxInternalTransfers = maxInternalTransfers;  				variableUnderstood = true;  			}  			break;  		}  	}  	if (!variableUnderstood)  		Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (parts.Length == 2) {  	switch (parts [0]) {  	case "inherit":  		break;  	// obsolete in 2.1 mod_rewrite  	case "MaxRedirects":  		Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  		int maxInternalTransfers;  		if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  			tempMaxInternalTransfers = maxInternalTransfers;  			variableUnderstood = true;  		}  		break;  	}  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (!variableUnderstood)  	Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + var.Value' "Unknown");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteBaseLine.IsMatch (line)) {  	#region RewriteBase  	Match match = RewriteBaseLine.Match (line);  	tempBase = match.Groups ["base"].Value;  	Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  	#endregion  } else if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: Manager.LogIf (tempLogLevel >= 3' "RewriteBase: " + VirtualBase' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteModuleLine.IsMatch (line)) {  	#region RewriteModule  	Match match = RewriteModuleLine.Match (line);  	string moduleName = match.Groups ["name"].Value;  	string moduleType = match.Groups ["type"].Value;  	Type module = Type.GetType (moduleType' false' true);  	if (module == null)  		module = BuildManager.GetType (moduleType' false' true);  	if (module == null) {  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  	} else {  		// add the module to the list  		modules.AddModule (moduleName' module);  		Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  	}  	#endregion  } else if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (module == null) {  	Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  } else {  	// add the module to the list  	modules.AddModule (moduleName' module);  	Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (module == null) {  	Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  } else {  	// add the module to the list  	modules.AddModule (moduleName' module);  	Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: Manager.LogIf (tempLogLevel >= 3' "RewriteModule: Error finding " + moduleType' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: Manager.LogIf (tempLogLevel >= 3' "RewriteModule: " + moduleType' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLine.IsMatch (line)) {  	#region RewriteLog  	Match match = RewriteLogLine.Match (line);  	tempLogPath = match.Groups ["location"].Value;  	tempLogPath = NormalizeLogLocation (tempLogPath);  	Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  	#endregion  } else if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: Manager.LogIf (tempLogLevel >= 3' "RewriteLog: " + tempLogPath' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteLogLevelLine.IsMatch (line)) {  	#region RewriteLogLevel  	Match match = RewriteLogLevelLine.Match (line);  	int logLevel = 1;  	if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  		tempLogLevel = 0;  		Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  	} else {  		tempLogLevel = logLevel;  	}  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  	#endregion  } else if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (!Int32.TryParse (match.Groups ["level"].Value' out logLevel)) {  	tempLogLevel = 0;  	Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  } else {  	tempLogLevel = logLevel;  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + match.Groups ["level"].Value + " not understood."' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: Manager.LogIf (tempLogLevel >= 3' "RewriteLogLevel: " + logLevel' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteCondLine.IsMatch (line)) {  	#region RewriteCond  	Match match = RewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: try {  	RegexOptions patternOptions = Manager.RuleOptions;  	IConditionFlagProcessor flags;  	if (match.Groups ["flags"] != null)  		flags = SplitConditionFlags (match.Groups ["flags"].Value);  	else  		flags = new ConditionFlagProcessor ();  	// check to see if the pattern should ignore the case when testing  	if (ConditionFlagsProcessor.HasNoCase (flags))  		patternOptions |= RegexOptions.IgnoreCase;  	string test = match.Groups ["test"].Value;  	string pattern = match.Groups ["pattern"].Value;  	IConditionTestValue testValue;  	ICondition condition;  	// create the second module  	if (moduleType2 == null)  		testValue = GetConditionTestValue (ref test);  	else  		testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  	// create the first module  	if (moduleType1 == null)  		condition = GetCondition (pattern);  	else  		condition = Activator.CreateInstance (moduleType1) as ICondition;  	// initialize the modules  	testValue.Init (test);  	condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  	// add condition to next rule that shows up  	conditions.Add (condition);  } catch (Exception exc) {  	if (tempLogLevel >= 3)  		Manager.Log ("RewriteCond: " + exc.Message' "Error");  	else  		Manager.Log ("RewriteCond: " + exc' "Error");  } finally {  	Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: try {  	RegexOptions patternOptions = Manager.RuleOptions;  	IConditionFlagProcessor flags;  	if (match.Groups ["flags"] != null)  		flags = SplitConditionFlags (match.Groups ["flags"].Value);  	else  		flags = new ConditionFlagProcessor ();  	// check to see if the pattern should ignore the case when testing  	if (ConditionFlagsProcessor.HasNoCase (flags))  		patternOptions |= RegexOptions.IgnoreCase;  	string test = match.Groups ["test"].Value;  	string pattern = match.Groups ["pattern"].Value;  	IConditionTestValue testValue;  	ICondition condition;  	// create the second module  	if (moduleType2 == null)  		testValue = GetConditionTestValue (ref test);  	else  		testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  	// create the first module  	if (moduleType1 == null)  		condition = GetCondition (pattern);  	else  		condition = Activator.CreateInstance (moduleType1) as ICondition;  	// initialize the modules  	testValue.Init (test);  	condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  	// add condition to next rule that shows up  	conditions.Add (condition);  } catch (Exception exc) {  	if (tempLogLevel >= 3)  		Manager.Log ("RewriteCond: " + exc.Message' "Error");  	else  		Manager.Log ("RewriteCond: " + exc' "Error");  } finally {  	Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (tempLogLevel >= 3)  	Manager.Log ("RewriteCond: " + exc.Message' "Error");  else  	Manager.Log ("RewriteCond: " + exc' "Error");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: Manager.LogIf (tempLogLevel >= 3' "RewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (RewriteRuleLine.IsMatch (line)) {  	#region RewriteRule  	Match match = RewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		rules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("RewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("RewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: try {  	RegexOptions patternOptions = Manager.RuleOptions;  	IRuleFlagProcessor flags;  	if (match.Groups ["flags"] != null)  		flags = SplitRuleFlags (match.Groups ["flags"].Value);  	else  		flags = new RuleFlagProcessor ();  	// check to see if the pattern should ignore the case when testing  	if (RuleFlagsProcessor.HasNoCase (flags))  		patternOptions |= RegexOptions.IgnoreCase;  	IRule rule = null;  	IRuleAction substitution = null;  	Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  	// create the first module  	if (moduleType1 == null)  		rule = new DefaultRule ();  	else  		rule = Activator.CreateInstance (moduleType1) as IRule;  	// create the second module  	if (moduleType2 == null)  		substitution = new DefaultRuleAction ();  	else  		substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  	// initialize the modules  	substitution.Init (pattern' match.Groups ["substitution"].Value);  	rule.Init (conditions' substitution' flags);  	// add condition to next rule that shows up  	rules.Add (rule);  	// clear conditions for next rule  	conditions.Clear ();  } catch (Exception exc) {  	if (tempLogLevel >= 3)  		Manager.Log ("RewriteRule: " + exc.Message' "Error");  	else  		Manager.Log ("RewriteRule: " + exc' "Error");  } finally {  	Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: try {  	RegexOptions patternOptions = Manager.RuleOptions;  	IRuleFlagProcessor flags;  	if (match.Groups ["flags"] != null)  		flags = SplitRuleFlags (match.Groups ["flags"].Value);  	else  		flags = new RuleFlagProcessor ();  	// check to see if the pattern should ignore the case when testing  	if (RuleFlagsProcessor.HasNoCase (flags))  		patternOptions |= RegexOptions.IgnoreCase;  	IRule rule = null;  	IRuleAction substitution = null;  	Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  	// create the first module  	if (moduleType1 == null)  		rule = new DefaultRule ();  	else  		rule = Activator.CreateInstance (moduleType1) as IRule;  	// create the second module  	if (moduleType2 == null)  		substitution = new DefaultRuleAction ();  	else  		substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  	// initialize the modules  	substitution.Init (pattern' match.Groups ["substitution"].Value);  	rule.Init (conditions' substitution' flags);  	// add condition to next rule that shows up  	rules.Add (rule);  	// clear conditions for next rule  	conditions.Clear ();  } catch (Exception exc) {  	if (tempLogLevel >= 3)  		Manager.Log ("RewriteRule: " + exc.Message' "Error");  	else  		Manager.Log ("RewriteRule: " + exc' "Error");  } finally {  	Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (tempLogLevel >= 3)  	Manager.Log ("RewriteRule: " + exc.Message' "Error");  else  	Manager.Log ("RewriteRule: " + exc' "Error");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: Manager.LogIf (tempLogLevel >= 3' "RewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (OutRewriteCondLine.IsMatch (line)) {  	#region OutRewriteCond  	Match match = OutRewriteCondLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("ICondition"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IConditionTestValue"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IConditionFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitConditionFlags (match.Groups ["flags"].Value);  		else  			flags = new ConditionFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (ConditionFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		string test = match.Groups ["test"].Value;  		string pattern = match.Groups ["pattern"].Value;  		IConditionTestValue testValue;  		ICondition condition;  		// create the second module  		if (moduleType2 == null)  			testValue = GetConditionTestValue (ref test);  		else  			testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  		// create the first module  		if (moduleType1 == null)  			condition = GetCondition (pattern);  		else  			condition = Activator.CreateInstance (moduleType1) as ICondition;  		// initialize the modules  		testValue.Init (test);  		condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  		// add condition to next rule that shows up  		conditions.Add (condition);  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteCond: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: try {  	RegexOptions patternOptions = Manager.RuleOptions;  	IConditionFlagProcessor flags;  	if (match.Groups ["flags"] != null)  		flags = SplitConditionFlags (match.Groups ["flags"].Value);  	else  		flags = new ConditionFlagProcessor ();  	// check to see if the pattern should ignore the case when testing  	if (ConditionFlagsProcessor.HasNoCase (flags))  		patternOptions |= RegexOptions.IgnoreCase;  	string test = match.Groups ["test"].Value;  	string pattern = match.Groups ["pattern"].Value;  	IConditionTestValue testValue;  	ICondition condition;  	// create the second module  	if (moduleType2 == null)  		testValue = GetConditionTestValue (ref test);  	else  		testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  	// create the first module  	if (moduleType1 == null)  		condition = GetCondition (pattern);  	else  		condition = Activator.CreateInstance (moduleType1) as ICondition;  	// initialize the modules  	testValue.Init (test);  	condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  	// add condition to next rule that shows up  	conditions.Add (condition);  } catch (Exception exc) {  	if (tempLogLevel >= 3)  		Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  	else  		Manager.Log ("OutRewriteCond: " + exc' "Error");  } finally {  	Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: try {  	RegexOptions patternOptions = Manager.RuleOptions;  	IConditionFlagProcessor flags;  	if (match.Groups ["flags"] != null)  		flags = SplitConditionFlags (match.Groups ["flags"].Value);  	else  		flags = new ConditionFlagProcessor ();  	// check to see if the pattern should ignore the case when testing  	if (ConditionFlagsProcessor.HasNoCase (flags))  		patternOptions |= RegexOptions.IgnoreCase;  	string test = match.Groups ["test"].Value;  	string pattern = match.Groups ["pattern"].Value;  	IConditionTestValue testValue;  	ICondition condition;  	// create the second module  	if (moduleType2 == null)  		testValue = GetConditionTestValue (ref test);  	else  		testValue = Activator.CreateInstance (moduleType2) as IConditionTestValue;  	// create the first module  	if (moduleType1 == null)  		condition = GetCondition (pattern);  	else  		condition = Activator.CreateInstance (moduleType1) as ICondition;  	// initialize the modules  	testValue.Init (test);  	condition.Init (new Pattern (pattern' patternOptions)' testValue' flags);  	// add condition to next rule that shows up  	conditions.Add (condition);  } catch (Exception exc) {  	if (tempLogLevel >= 3)  		Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  	else  		Manager.Log ("OutRewriteCond: " + exc' "Error");  } finally {  	Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (tempLogLevel >= 3)  	Manager.Log ("OutRewriteCond: " + exc.Message' "Error");  else  	Manager.Log ("OutRewriteCond: " + exc' "Error");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: Manager.LogIf (tempLogLevel >= 3' "OutRewriteCond: " + match.Groups ["test"].Value + " " + match.Groups ["pattern"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (OutRewriteRuleLine.IsMatch (line)) {  	#region OutRewriteRule  	Match match = OutRewriteRuleLine.Match (line);  	string module1 = match.Groups ["module1"].Value;  	string module2 = match.Groups ["module2"].Value;  	Type moduleType1 = null;  	Type moduleType2 = null;  	// set the types of the first module  	if (modules.ContainsName (module1))  		moduleType1 = modules.GetModule (module1);  	// make sure the module is of the right type  	if (moduleType1 != null && moduleType1.GetInterface ("IRule"' false) == null)  		moduleType1 = null;  	// set the types of the second module  	if (modules.ContainsName (module2))  		moduleType2 = modules.GetModule (module2);  	// make sure the module is of the right type  	if (moduleType2 != null && moduleType2.GetInterface ("IRuleAction"' false) == null)  		moduleType2 = null;  	try {  		RegexOptions patternOptions = Manager.RuleOptions;  		IRuleFlagProcessor flags;  		if (match.Groups ["flags"] != null)  			flags = SplitRuleFlags (match.Groups ["flags"].Value);  		else  			flags = new RuleFlagProcessor ();  		// check to see if the pattern should ignore the case when testing  		if (RuleFlagsProcessor.HasNoCase (flags))  			patternOptions |= RegexOptions.IgnoreCase;  		IRule rule = null;  		IRuleAction substitution = null;  		Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  		// create the first module  		if (moduleType1 == null)  			rule = new DefaultRule ();  		else  			rule = Activator.CreateInstance (moduleType1) as IRule;  		// create the second module  		if (moduleType2 == null)  			substitution = new DefaultOutputRuleAction ();  		else  			substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  		// initialize the modules  		substitution.Init (pattern' match.Groups ["substitution"].Value);  		rule.Init (conditions' substitution' flags);  		// add condition to next rule that shows up  		outputRules.Add (rule);  		// clear conditions for next rule  		conditions.Clear ();  	} catch (Exception exc) {  		if (tempLogLevel >= 3)  			Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  		else  			Manager.Log ("OutRewriteRule: " + exc' "Error");  	} finally {  		Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  	}  	#endregion  } else {  	unknownLines.Add (line);  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: try {  	RegexOptions patternOptions = Manager.RuleOptions;  	IRuleFlagProcessor flags;  	if (match.Groups ["flags"] != null)  		flags = SplitRuleFlags (match.Groups ["flags"].Value);  	else  		flags = new RuleFlagProcessor ();  	// check to see if the pattern should ignore the case when testing  	if (RuleFlagsProcessor.HasNoCase (flags))  		patternOptions |= RegexOptions.IgnoreCase;  	IRule rule = null;  	IRuleAction substitution = null;  	Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  	// create the first module  	if (moduleType1 == null)  		rule = new DefaultRule ();  	else  		rule = Activator.CreateInstance (moduleType1) as IRule;  	// create the second module  	if (moduleType2 == null)  		substitution = new DefaultOutputRuleAction ();  	else  		substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  	// initialize the modules  	substitution.Init (pattern' match.Groups ["substitution"].Value);  	rule.Init (conditions' substitution' flags);  	// add condition to next rule that shows up  	outputRules.Add (rule);  	// clear conditions for next rule  	conditions.Clear ();  } catch (Exception exc) {  	if (tempLogLevel >= 3)  		Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  	else  		Manager.Log ("OutRewriteRule: " + exc' "Error");  } finally {  	Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: try {  	RegexOptions patternOptions = Manager.RuleOptions;  	IRuleFlagProcessor flags;  	if (match.Groups ["flags"] != null)  		flags = SplitRuleFlags (match.Groups ["flags"].Value);  	else  		flags = new RuleFlagProcessor ();  	// check to see if the pattern should ignore the case when testing  	if (RuleFlagsProcessor.HasNoCase (flags))  		patternOptions |= RegexOptions.IgnoreCase;  	IRule rule = null;  	IRuleAction substitution = null;  	Pattern pattern = new Pattern (match.Groups ["pattern"].Value' patternOptions);  	// create the first module  	if (moduleType1 == null)  		rule = new DefaultRule ();  	else  		rule = Activator.CreateInstance (moduleType1) as IRule;  	// create the second module  	if (moduleType2 == null)  		substitution = new DefaultOutputRuleAction ();  	else  		substitution = Activator.CreateInstance (moduleType2) as IRuleAction;  	// initialize the modules  	substitution.Init (pattern' match.Groups ["substitution"].Value);  	rule.Init (conditions' substitution' flags);  	// add condition to next rule that shows up  	outputRules.Add (rule);  	// clear conditions for next rule  	conditions.Clear ();  } catch (Exception exc) {  	if (tempLogLevel >= 3)  		Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  	else  		Manager.Log ("OutRewriteRule: " + exc' "Error");  } finally {  	Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (tempLogLevel >= 3)  	Manager.Log ("OutRewriteRule: " + exc.Message' "Error");  else  	Manager.Log ("OutRewriteRule: " + exc' "Error");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: Manager.LogIf (tempLogLevel >= 3' "OutRewriteRule: " + match.Groups ["pattern"].Value + " " + match.Groups ["substitution"].Value + " [" + match.Groups ["flags"].Value + "]"' "Rule Processing");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: if (unknownLines.Count > 0) {  	RefreshUnknownLines (ref unknownLines);  	foreach (var unknownLine in unknownLines)  		Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  }  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: foreach (var unknownLine in unknownLines)  	Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  
Magic Number,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following statement contains a magic number: Manager.LogIf (tempLogLevel >= 4' "Not Understood: " + unknownLine' "Unknown");  
Magic Number,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendRequestToTarget,The following statement contains a magic number: if (Manager.Configuration.Rewriter.AllowVanityHeader) {  	request.Headers.Add ("X-Reverse-Proxied-By"' Manager.RewriterUserAgent);  	request.Headers.Add ("X-ManagedFusion-Rewriter-Version"' Manager.RewriterVersion.ToString (2));  }  
Magic Number,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendRequestToTarget,The following statement contains a magic number: request.Headers.Add ("X-ManagedFusion-Rewriter-Version"' Manager.RewriterVersion.ToString (2));  
Magic Number,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RuleSet,The following statement contains a magic number: MaxInternalTransfers = 10;  
Magic Number,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunRules,The following statement contains a magic number: if (!EngineEnabled)  	Manager.LogIf (!EngineEnabled && LogLevel >= 9' "Rewrite Engine Is DISABLED"' "Rewrite");  
Magic Number,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunRules,The following statement contains a magic number: Manager.LogIf (!EngineEnabled && LogLevel >= 9' "Rewrite Engine Is DISABLED"' "Rewrite");  
Magic Number,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunRules,The following statement contains a magic number: if (_rules.Count > 0 && EngineEnabled) {  	Manager.LogIf (LogLevel >= 1' "**********************************************************************************");  	Manager.LogIf (LogLevel >= 1' "Input: " + currentUrl' "Rewrite");  	// check if max number of internal transfers have been exceeded  	if (InternalTransferCount (httpContext) > MaxInternalTransfers) {  		string message = "Exceeded the max number of internal transfers.";  		Manager.LogIf (LogLevel >= 1' message' "Error");  		throw new HttpException (500' message);  	}  	var temporyFlags = (IRuleFlagProcessor)null;  	var skipNextChain = false;  	var initialUrl = currentUrl;  	if (!String.IsNullOrEmpty (VirtualBase) && VirtualBase != "/")  		currentUrl = RemoveBase (VirtualBase' currentUrl);  	// process rules according to their settings  	for (int i = 0; i < _rules.Count; i++) {  		var ruleContext = new RuleContext (i' context' currentUrl' _rules [i]);  		temporyFlags = _rules [i].Flags;  		// continue if this rule shouldn't be processed because it doesn't allow internal transfer requests  		if (RuleFlagsProcessor.HasNotForInternalSubRequests (temporyFlags) && IsInternalTransfer (httpContext))  			continue;  		bool containsChain = RuleFlagsProcessor.HasChain (_rules [i].Flags);  		bool previousContainsChain = RuleFlagsProcessor.HasChain (_rules [Math.Max (0' i - 1)].Flags);  		// if the previous rule doesn't contain a chain flag then set the initial URL  		// this will be used to reset a chain if one of the chain rules fail  		if (!previousContainsChain)  			initialUrl = currentUrl;  		// skip if the current rule or the last rule has a chain flag  		// and if the skip next chain is set  		if (skipNextChain && (previousContainsChain || containsChain))  			continue;  		else  			skipNextChain = false;  		if (_rules [i].TryExecute (ruleContext)) {  			var flagResponse = temporyFlags.Apply (ruleContext);  			currentUrl = ruleContext.SubstitutedUrl;  			i = ruleContext.RuleIndex ?? -1;  			bool breakLoop = false;  			// apply the flags to the rules' and only do special processing  			// for the flag responses listed in the switch statement below  			switch (flagResponse) {  			case RuleFlagProcessorResponse.ExitRuleSet:  				return null;  			case RuleFlagProcessorResponse.LastRule:  				breakLoop = true;  				break;  			}  			// break the loop because we have reached the last rule as indicated by a flag  			if (breakLoop)  				break;  		} else if (containsChain) {  			skipNextChain = true;  			// reset the current URL back to the initial URL from the start of the chain  			currentUrl = initialUrl;  		} else if (previousContainsChain) {  			// reset the current URL back to the initial URL from the start of the chain  			currentUrl = initialUrl;  		}  	}  	// if the scheme' host' and ports do not match on the request vs the rewrite a redirect needs to be performed instead of a rewrite  	if (Uri.Compare (currentUrl' context.RequestedUrl' UriComponents.SchemeAndServer' UriFormat.SafeUnescaped' StringComparison.OrdinalIgnoreCase) != 0) {  		Manager.LogIf (LogLevel >= 1' "Output: 302 Redirect to " + currentUrl' "Rewrite");  		Manager.Redirect (httpContext' "found"' currentUrl);  	}  	if (!String.IsNullOrEmpty (VirtualBase) && VirtualBase != "/")  		currentUrl = AddBase (VirtualBase' currentUrl);  	Manager.LogIf (LogLevel >= 1' "Output: " + currentUrl' "Rewrite");  	Manager.LogIf (LogLevel >= 1' "**********************************************************************************");  	Manager.TryToAddXRewriteUrlHeader (httpContext);  	Manager.TryToAddVanityHeader (httpContext);  }  
Magic Number,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunRules,The following statement contains a magic number: if (InternalTransferCount (httpContext) > MaxInternalTransfers) {  	string message = "Exceeded the max number of internal transfers.";  	Manager.LogIf (LogLevel >= 1' message' "Error");  	throw new HttpException (500' message);  }  
Magic Number,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunRules,The following statement contains a magic number: throw new HttpException (500' message);  
Magic Number,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunOutputRules,The following statement contains a magic number: if (!EngineEnabled)  	Manager.LogIf (!EngineEnabled && LogLevel >= 9' "Rewrite Engine Is DISABLED"' "OutRewrite");  
Magic Number,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunOutputRules,The following statement contains a magic number: Manager.LogIf (!EngineEnabled && LogLevel >= 9' "Rewrite Engine Is DISABLED"' "OutRewrite");  
Magic Number,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,TryToAddVanityHeader,The following statement contains a magic number: if (Configuration.Rewriter.AllowVanityHeader) {  	TryAddResponseHeader (context' "X-Rewritten-By"' RewriterUserAgent);  	TryAddResponseHeader (context' "X-ManagedFusion-Rewriter-Version"' RewriterVersion.ToString (2));  }  
Magic Number,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,TryToAddVanityHeader,The following statement contains a magic number: TryAddResponseHeader (context' "X-ManagedFusion-Rewriter-Version"' RewriterVersion.ToString (2));  
Magic Number,ManagedFusion.Rewriter,ServerVariable,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ServerVariable.cs,GetValue,The following statement contains a magic number: Manager.LogIf (context.LogLevel >= 2' "Input: " + value' context.LogCategory);  
Magic Number,ManagedFusion.Rewriter.Rules,RuleFlagProcessor,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\RuleFlagProcessor.cs,RuleFlagProcessor,The following statement contains a magic number: _flags = new OrderedList<IRuleFlag> (Comparison' 5);  
Magic Number,ManagedFusion.Rewriter.Rules,DefaultRule,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\DefaultRule.cs,TryExecute,The following statement contains a magic number: if (Action.IsMatch (context)) {  	Manager.LogIf (context.LogLevel >= 2' "Rule Pattern Matched"' context.LogCategory);  	bool skipOrNext = false;  	string[] conditionValues = new string[_conditions.Count];  	// test to make sure all conditions are met  	for (int i = 0; i < _conditions.Count; i++) {  		ConditionContext conditionContext = new ConditionContext (i' context' _conditions [i]);  		bool containsOrNext = ConditionFlagsProcessor.HasOrNext (_conditions [i].Flags);  		bool previousContainsOrNext = ConditionFlagsProcessor.HasOrNext (_conditions [Math.Max (0' i - 1)].Flags);  		if (skipOrNext && (previousContainsOrNext || containsOrNext))  			continue;  		else  			skipOrNext = false;  		// test the condition if it fails and then terminate  		if (!_conditions [i].Evaluate (conditionContext)) {  			if (containsOrNext)  				continue;  			else  				return false;  		} else if (containsOrNext)  			skipOrNext = true;  	}  	// call an external method that might want to inherit from this rule implimentation  	OnExecuting (context);  	// process the substition for the pattern  	Action.Execute (context);  	// the pattern matched  	return true;  }  
Magic Number,ManagedFusion.Rewriter.Rules,DefaultRule,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\DefaultRule.cs,TryExecute,The following statement contains a magic number: Manager.LogIf (context.LogLevel >= 2' "Rule Pattern Matched"' context.LogCategory);  
Magic Number,ManagedFusion.Rewriter.Rules,DefaultRuleAction,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\DefaultRuleAction.cs,IsMatch,The following statement contains a magic number: Manager.LogIf (context.LogLevel >= 2' "Input: " + testUrl' context.LogCategory);  
Magic Number,ManagedFusion.Rewriter.Rules,DefaultRuleAction,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\DefaultRuleAction.cs,Execute,The following statement contains a magic number: if (_substitution == "-") {  	Manager.LogIf (context.LogLevel >= 2' "Output: " + context.CurrentUrl' context.LogCategory);  	return;  }  
Magic Number,ManagedFusion.Rewriter.Rules,DefaultRuleAction,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\DefaultRuleAction.cs,Execute,The following statement contains a magic number: Manager.LogIf (context.LogLevel >= 2' "Output: " + context.CurrentUrl' context.LogCategory);  
Magic Number,ManagedFusion.Rewriter.Rules,DefaultRuleAction,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\DefaultRuleAction.cs,Execute,The following statement contains a magic number: Manager.LogIf (context.LogLevel >= 2' "Output: " + substituedUrl' context.LogCategory);  
Magic Number,ManagedFusion.Rewriter.Rules.Flags,NextRuleFlag,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\Flags\NextRuleFlag.cs,Apply,The following statement contains a magic number: Manager.LogIf (context.LogLevel >= 2' "Restart Rule Processing"' "Rewrite");  
Magic Number,ManagedFusion.Rewriter.Rules.Flags,RedirectFlag,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\Flags\RedirectFlag.cs,RedirectFlag,The following statement contains a magic number: if (statusCode < 300 || statusCode > 307)  	throw new ArgumentOutOfRangeException ("statusCode"' statusCode' "statusCode should be between 300 - 307.");  
Magic Number,ManagedFusion.Rewriter.Rules.Flags,RedirectFlag,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\Flags\RedirectFlag.cs,RedirectFlag,The following statement contains a magic number: if (statusCode < 300 || statusCode > 307)  	throw new ArgumentOutOfRangeException ("statusCode"' statusCode' "statusCode should be between 300 - 307.");  
Magic Number,ManagedFusion.Rewriter.Rules.Flags,ResponseCookieFlag,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\Flags\ResponseCookieFlag.cs,Apply,The following statement contains a magic number: Manager.LogIf (context.LogLevel >= 2' "Cookie: " + Name + ":" + Value' "Rewrite");  
Magic Number,ManagedFusion.Rewriter.Rules.Flags,ResponseMimeTypeFlag,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\Flags\ResponseMimeTypeFlag.cs,Apply,The following statement contains a magic number: Manager.LogIf (context.LogLevel >= 2' "Content Type: " + Type' "Rewrite");  
Magic Number,ManagedFusion.Rewriter.Rules.Flags,ResponseStatusFlag,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\Flags\ResponseStatusFlag.cs,Apply,The following statement contains a magic number: if (StatusCode > 0U) {  	var response = context.HttpContext.Response;  	response.StatusCode = (int)StatusCode;  	response.SubStatusCode = (int)SubStatusCode;  	response.StatusDescription = StatusReason ?? StatusDescription;  	Manager.LogIf (context.LogLevel >= 2' String.Format ("HTTP Status: {0}.{1} {2}"' response.StatusCode' response.SubStatusCode' response.StatusDescription)' "Rewrite");  }  
Magic Number,ManagedFusion.Rewriter.Rules.Flags,ResponseStatusFlag,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\Flags\ResponseStatusFlag.cs,Apply,The following statement contains a magic number: Manager.LogIf (context.LogLevel >= 2' String.Format ("HTTP Status: {0}.{1} {2}"' response.StatusCode' response.SubStatusCode' response.StatusDescription)' "Rewrite");  
Magic Number,ManagedFusion.Rewriter.Rules.Flags,ServerVariableFlag,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\Flags\ServerVariableFlag.cs,Apply,The following statement contains a magic number: Manager.LogIf (context.LogLevel >= 2' "Set Server Variable: " + Name' "Rewrite");  
Magic Number,ManagedFusion.Rewriter.Rules.Flags,SkipRuleFlag,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Rules\Flags\SkipRuleFlag.cs,Apply,The following statement contains a magic number: Manager.LogIf (context.LogLevel >= 2' "Skip The Next + " + Count + " To Rule " + context.RuleIndex' "Rewrite");  
Duplicate Code,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The method contains a code clone-set at the following line numbers (starting from the method definition): ((113' 159)' (228' 274))
Duplicate Code,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The method contains a code clone-set at the following line numbers (starting from the method definition): ((170' 205)' (285' 320))
Missing Default,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddConditionFlag,The following switch statement is missing a default case: switch (key) {  case "nocase":  case "NC":  	return new CF.NoCaseFlag ();  case "ornext":  case "OR":  	return new CF.OrNextFlag ();  }  
Missing Default,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,AddRuleFlag,The following switch statement is missing a default case: switch (key) {  case "chain":  case "C":  	return new RF.ChainFlag ();  case "cookie":  case "CO": {  	if (value == null)  		return null;  	string[] info = value.Split (new[] {  		':'  	}' 5' StringSplitOptions.None);  	string name = info [0]' val = info [1]' domain = info.Length > 2 ? info [2].Trim () : String.Empty' path = info.Length > 4 ? info [4].Trim () : String.Empty;  	TimeSpan? expires = null;  	int expiresMinutes;  	if (info.Length > 3 && Int32.TryParse (info [3]' out expiresMinutes))  		expires = new TimeSpan (0' expiresMinutes' 0);  	return new RF.ResponseCookieFlag (name' val' domain' expires' path);  }  //case "env":  //case "E": key = "env"; break;  case "forbidden":  case "F":  	return new RF.ResponseStatusFlag ("forbidden");  case "notfound":  case "NF":  	return new RF.ResponseStatusFlag ("notfound");  case "gone":  case "G":  	return new RF.ResponseStatusFlag ("gone");  case "last":  case "L":  	return new RF.LastFlag ();  case "next":  case "N":  	return new RF.NextRuleFlag ();  case "nocase":  case "NC":  	return new RF.NoCaseFlag ();  case "noescape":  case "NE":  	return new RF.NoEscapeFlag ();  case "nosubreq":  case "NS":  	return new RF.NotForInternalSubRequestsFlag ();  case "proxy":  case "P":  	return new RF.ProxyFlag ();  //case "passthrough":  //case "PT": key = "passthrough"; break;  case "qsappend":  case "QSA":  	return new RF.QueryStringAppendFlag ();  case "redirect":  case "R":  	return new RF.RedirectFlag (value);  case "skip":  case "S": {  	int skipIndex;  	if (Int32.TryParse (value' out skipIndex))  		return new RF.SkipRuleFlag (skipIndex);  	Manager.LogIf (LogLevel >= 5' "Error: " + value + " is not a valid skip index."' "Rule Processing");  	return null;  }  case "type":  case "T":  	return new RF.ResponseMimeTypeFlag (value);  }  
Missing Default,ManagedFusion.Rewriter.Engines,ApacheRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\ApacheRuleSet.cs,RefreshRules,The following switch statement is missing a default case: switch (parts [0]) {  case "inherit":  	break;  // obsolete in 2.1 mod_rewrite  case "MaxRedirects":  	Manager.LogIf (tempLogLevel >= 1' "MaxRedirects is obsolete"' "Obsolete");  	int maxInternalTransfers;  	if (Int32.TryParse (parts [1]' out maxInternalTransfers)) {  		tempMaxInternalTransfers = maxInternalTransfers;  		variableUnderstood = true;  	}  	break;  }  
Missing Default,ManagedFusion.Rewriter.Engines,MicrosoftRuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Engines\MicrosoftRuleSet.cs,GetCondition,The following switch statement is missing a default case: switch (matchType) {  case MatchType.IsFile:  	condition = new IsFileCondition ();  	break;  case MatchType.IsDirectory:  	condition = new IsDirectoryCondition ();  	break;  case MatchType.Pattern:  	condition = new DefaultCondition ();  	break;  }  
Missing Default,ManagedFusion.Rewriter,ProxyHandler,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ProxyHandler.cs,SendRequestToTarget,The following switch statement is missing a default case: switch (name) {  case "User-Agent":  	httpRequest.UserAgent = context.Request.UserAgent;  	break;  case "Connection":  	string connection = context.Request.Headers [name];  	if (connection.IndexOf ("Keep-Alive"' StringComparison.OrdinalIgnoreCase) > 0)  		httpRequest.KeepAlive = true;  	var list = new List<string> ();  	foreach (string conn in connection.Split (''')) {  		string c = conn.Trim ();  		if (!c.Equals ("Keep-Alive"' StringComparison.OrdinalIgnoreCase) && !c.Equals ("Close"' StringComparison.OrdinalIgnoreCase))  			list.Add (c);  	}  	if (list.Count > 0)  		httpRequest.Connection = String.Join ("' "' list.ToArray ());  	break;  case "Transfer-Encoding":  	httpRequest.SendChunked = true;  	httpRequest.TransferEncoding = context.Request.Headers [name];  	break;  case "Expect":  	httpRequest.ServicePoint.Expect100Continue = true;  	break;  case "If-Modified-Since":  	DateTime ifModifiedSince;  	if (DateTime.TryParse (context.Request.Headers [name]' out ifModifiedSince))  		httpRequest.IfModifiedSince = ifModifiedSince;  	break;  case "Content-Length":  	httpRequest.ContentLength = context.Request.ContentLength;  	break;  case "Content-Type":  	httpRequest.ContentType = context.Request.ContentType;  	break;  case "Accept":  	httpRequest.Accept = String.Join ("' "' context.Request.AcceptTypes);  	break;  case "Referer":  	httpRequest.Referer = context.Request.UrlReferrer.OriginalString;  	break;  }  
Missing Default,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunRules,The following switch statement is missing a default case: switch (flagResponse) {  case RuleFlagProcessorResponse.ExitRuleSet:  	return null;  case RuleFlagProcessorResponse.LastRule:  	breakLoop = true;  	break;  }  
Missing Default,ManagedFusion.Rewriter,RuleSet,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\RuleSet.cs,RunOutputRules,The following switch statement is missing a default case: switch (flagResponse) {  case RuleFlagProcessorResponse.ExitRuleSet:  	return null;  case RuleFlagProcessorResponse.LastRule:  	breakLoop = true;  	break;  }  
Missing Default,ManagedFusion.Rewriter,Manager,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\Manager.cs,Manager,The following switch statement is missing a default case: switch (Configuration.Rules.Engine) {  case RulesEngine.Apache:  	_rewriterEngine = new ApacheEngine ();  	break;  case RulesEngine.Microsoft:  	_rewriterEngine = new MicrosoftEngine ();  	break;  case RulesEngine.Other: {  	try {  		_rewriterEngine = (IRewriterEngine)Activator.CreateInstance (Type.GetType (Configuration.Rules.EngineType));  		break;  	} catch (Exception exc) {  		throw new RewriterEngineException ("The engine specified in the web.config cannot be found' " + Configuration.Rules.EngineType' exc);  	}  }  }  
Missing Default,ManagedFusion.Rewriter,ServerVariable,D:\newReposJune17\managedfusion_managedfusion-rewriter\src\ServerVariable.cs,GetValue,The following switch statement is missing a default case: switch (_name) {  case "TIME_YEAR":  	value = DateTime.Today.Year.ToString ();  	break;  case "TIME_MON":  	value = DateTime.Today.Month.ToString ();  	break;  case "TIME_DAY":  	value = DateTime.Today.Day.ToString ();  	break;  case "TIME_HOUR":  	value = DateTime.Now.Hour.ToString ();  	break;  case "TIME_MIN":  	value = DateTime.Now.Minute.ToString ();  	break;  case "TIME_SEC":  	value = DateTime.Now.Second.ToString ();  	break;  case "TIME_WDAY":  	value = DateTime.Today.DayOfWeek.ToString ();  	break;  case "TIME":  	value = DateTime.Now.ToString ("f");  	break;  case "API_VERSION":  	value = String.Empty;  	break;  // TODO: figure out how to attack this  case "THE_REQUEST":  	value = context.HttpContext.Request.ServerVariables ["REQUEST_METHOD"] + " " + context.HttpContext.Request.ServerVariables ["PATH_INFO"] + " " + context.HttpContext.Request.ServerVariables ["SERVER_PROTOCOL"];  	break;  case "REQUEST_URI":  	value = context.HttpContext.Request.ServerVariables ["URL"];  	break;  case "REQUEST_FILENAME":  	value = context.HttpContext.Request.ServerVariables ["PATH_TRANSLATED"];  	break;  case "IS_SUBREQ":  	value = String.IsNullOrEmpty (context.HttpContext.Request.Headers ["X-Rewriter-Transfer"]) ? Boolean.FalseString : Boolean.TrueString;  	break;  }  
