Implementation smell,Namespace,Class,File,Method,Description
Long Method,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The method has 147 lines of code.
Long Method,Trajectories,StockAeroUtil,C:\repos\neuoy_KSPTrajectories\Plugin\StockAeroUtil.cs,SimAeroForce,The method has 138 lines of code.
Long Method,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,AddPatch,The method has 329 lines of code.
Complex Method,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,Cyclomatic complexity of the method is 18
Complex Method,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,refreshMesh,Cyclomatic complexity of the method is 9
Complex Method,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,Cyclomatic complexity of the method is 12
Complex Method,Trajectories,NavBallOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\NavBallOverlay.cs,GetCorrection,Cyclomatic complexity of the method is 8
Complex Method,Trajectories,StockAeroUtil,C:\repos\neuoy_KSPTrajectories\Plugin\StockAeroUtil.cs,SimAeroForce,Cyclomatic complexity of the method is 12
Complex Method,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,computeTrajectoryIncrement,Cyclomatic complexity of the method is 9
Complex Method,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,AddPatch,Cyclomatic complexity of the method is 13
Long Parameter List,Trajectories,AeroForceCache,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AeroForceCache.cs,AeroForceCache,The method has 7 parameters. Parameters: maxCacheVelocity' maxCacheAoA' atmosphereDepth' vRes' aoaRes' altRes' model
Long Parameter List,Trajectories,AeroForceCache,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AeroForceCache.cs,Sample2d,The method has 5 parameters. Parameters: vFloor' vFrac' aFloor' aFrac' mFloor
Long Parameter List,Trajectories,AeroForceCache,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AeroForceCache.cs,Sample3d,The method has 6 parameters. Parameters: vFloor' vFrac' aFloor' aFrac' mFloor' mFrac
Long Parameter List,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawMapViewGroundMarker,The method has 6 parameters. Parameters: body' latitude' longitude' c' rotation' radius
Long Parameter List,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawGroundMarker,The method has 7 parameters. Parameters: body' latitude' longitude' c' map' rotation' radius
Long Parameter List,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,GLTriangle,The method has 5 parameters. Parameters: worldVertices1' worldVertices2' worldVertices3' c' map
Long Parameter List,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawPath,The method has 5 parameters. Parameters: mainBody' points' c' map' dashed
Long Parameter List,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,MakeRibbonEdge,The method has 5 parameters. Parameters: prevPos' edgeCenter' width' vertices' startIndex
Long Parameter List,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The method has 6 parameters. Parameters: bodyPosition' mesh' orbit' startTime' duration' color
Long Parameter List,Trajectories,Util,C:\repos\neuoy_KSPTrajectories\Plugin\Util.cs,distanceFromLatitudeAndLongitude,The method has 5 parameters. Parameters: bodyRadius' originLatidue' originLongitude' destinationLatitude' destinationLongitude
Long Identifier,Trajectories,AerodynamicModelFactory,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AerodynamicModelFactory.cs,GetModel,The length of the parameter FARAPI_CalculateVesselAeroForces is 32.
Long Identifier,Trajectories,FARModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\FARModel.cs,,The length of the parameter FARAPI_CalculateVesselAeroForces is 32.
Long Statement,Trajectories,AerodynamicModelFactory,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AerodynamicModelFactory.cs,GetModel,The length of the statement  "                                var FARAPI_CalculateVesselAeroForces = FARAPIType.GetMethodEx("CalculateVesselAeroForces"' BindingFlags.Public | BindingFlags.Static' new Type[] { typeof(Vessel)' typeof(Vector3).MakeByRefType()' typeof(Vector3).MakeByRefType()' typeof(Vector3)' typeof(double) }); " is 264.
Long Statement,Trajectories,AeroForceCache,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AeroForceCache.cs,GetForce,The length of the statement  "            //    Util.PostSingleScreenMessage("altitude cell"' "altitude cell: " + altitude + " / " + MaxAltitude + " * " + (double)(InternalArray.GetLength(2) - 1)); " is 155.
Long Statement,Trajectories,AeroForceCache,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AeroForceCache.cs,ComputeCacheEntry,The length of the statement  "            Vector2 packedForce = Model.PackForces(Model.ComputeForces(currentAltitude' velocity' new Vector3(0' 1' 0)' AoA)' currentAltitude' vel); " is 136.
Long Statement,Trajectories,FARModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\FARModel.cs,ComputeForces_Model,The length of the statement  "                //Debug.LogWarning(string.Format("Trajectories: Getting FAR forces - Velocity: {0} | Altitude: {1}"' airVelocity' altitude)); " is 125.
Long Statement,Trajectories,FARModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\FARModel.cs,PackForces,The length of the statement  "            double rho = StockAeroUtil.GetDensity(altitudeAboveSea' body_); // would be even better to use FAR method of computing the air density (which also depends on velocity)' but this is already better than nothing " is 208.
Long Statement,Trajectories,StockModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\StockModel.cs,PackForces,The length of the statement  "            double invScale = 1.0 / (rho * Math.Max(1.0' velocity * velocity)); // divide by v² and rho before storing the force' to increase accuracy (the reverse operation is performed when reading from the cache) " is 203.
Long Statement,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawGroundMarker,The length of the statement  "            var height = body.pqsController.GetSurfaceHeight(QuaternionD.AngleAxis(longitude' Vector3d.down) * QuaternionD.AngleAxis(latitude' Vector3d.forward) * Vector3d.right); " is 167.
Long Statement,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawGroundMarker,The length of the statement  "            Vector3d camPos = map ? ScaledSpace.ScaledToLocalSpace(PlanetariumCamera.Camera.transform.position) : (Vector3d)FlightCamera.fetch.mainCamera.transform.position; " is 161.
Long Statement,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,GLVertex,The length of the statement  "            Vector3 screenPoint = map ? PlanetariumCamera.Camera.WorldToViewportPoint(ScaledSpace.LocalToScaledSpace(worldPosition)) : FlightCamera.fetch.mainCamera.WorldToViewportPoint(worldPosition); " is 189.
Long Statement,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawPath,The length of the statement  "            Vector3d camPos = map ? ScaledSpace.ScaledToLocalSpace(PlanetariumCamera.Camera.transform.position) : (Vector3d)FlightCamera.fetch.mainCamera.transform.position; " is 161.
Long Statement,Trajectories,DescentProfile,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,Update,The length of the statement  "                    TrajectoriesVesselSettings module = attachedVessel.Parts.SelectMany(p => p.Modules.OfType<TrajectoriesVesselSettings>()).FirstOrDefault(); " is 138.
Long Statement,Trajectories,Node,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,DoGUI,The length of the statement  "                horizon = GUILayout.Toggle(horizon' new GUIContent(horizon ? "Horiz" : "AoA"' "AoA = Angle of Attack = angle relatively to the velocity vector.\nHoriz = angle relatively to the horizon.")' GUILayout.Width(50)); " is 210.
Long Statement,Trajectories,Node,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,DoGUI,The length of the statement  "                angle = (double)(sliderPos * sliderPos * sliderPos * maxAngle); // this helps to have high precision near 0° while still allowing big angles " is 140.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,OnGUI,The length of the statement  "            Settings.fetch.MapGUIWindowPos = new Rect(Settings.fetch.MapGUIWindowPos.xMin' Settings.fetch.MapGUIWindowPos.yMin' Settings.fetch.MapGUIWindowPos.width' Settings.fetch.MapGUIWindowPos.height - 3); " is 197.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,OnGUI,The length of the statement  "            Settings.fetch.MapGUIWindowPos = ClampToScreen(GUILayout.Window(GUIId + 1' Settings.fetch.MapGUIWindowPos' MainWindow' "Trajectories")); " is 136.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,FixedUpdate,The length of the statement  "                Vector3 vel = lastPatch.impactVelocity.Value - lastPatchBody.getRFrmVel(lastPatch.impactPosition.Value + lastPatchBody.position); " is 129.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The length of the statement  "            Settings.fetch.DisplayTrajectories = GUILayout.Toggle(Settings.fetch.DisplayTrajectories' "Show trajectory"' GUILayout.Width(125)); " is 131.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The length of the statement  "                Settings.fetch.DisplayCompleteTrajectory = GUILayout.Toggle(Settings.fetch.DisplayCompleteTrajectory' "complete"' GUILayout.Width(70)); " is 135.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The length of the statement  "                        navigationWaypoint.celestialBody.GetRelSurfacePosition(navigationWaypoint.latitude' navigationWaypoint.longitude' navigationWaypoint.altitude)); " is 144.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The length of the statement  "            bool descentProfileGroup = Settings.fetch.DisplayDescentProfileGUI = ToggleGroup(Settings.fetch.DisplayDescentProfileGUI' "Descent profile"' 120); " is 146.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The length of the statement  "                Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100))); " is 142.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The length of the statement  "                Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100))); " is 150.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The length of the statement  "                Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80)); " is 311.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The length of the statement  "                Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update.")); " is 287.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The length of the statement  "                    Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart")); " is 158.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,TooltipWindow,The length of the statement  "            toolTipStyle.normal.textColor = toolTipStyle.active.textColor = toolTipStyle.hover.textColor = toolTipStyle.focused.textColor = toolTipStyle.onNormal.textColor = toolTipStyle.onHover.textColor = toolTipStyle.onActive.textColor = toolTipStyle.onFocused.textColor = new Color(1' 0.75f' 0); " is 287.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,IsValidScene,The length of the statement  "            return HighLogic.LoadedSceneIsEditor || HighLogic.LoadedSceneIsFlight || HighLogic.LoadedScene == GameScenes.SPACECENTER || HighLogic.LoadedScene == GameScenes.TRACKSTATION; " is 173.
Long Statement,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,ClampToScreen,The length of the statement  "            return new Rect(Mathf.Clamp(window.x' 0' Screen.width - window.width)' Mathf.Clamp(window.y' 0' Screen.height - window.height)' window.width' window.height); " is 157.
Long Statement,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,Update,The length of the statement  "            setDisplayEnabled((HighLogic.LoadedScene == GameScenes.FLIGHT || HighLogic.LoadedScene == GameScenes.TRACKSTATION) && MapView.MapIsEnabled && PlanetariumCamera.Camera != null); " is 176.
Long Statement,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,Update,The length of the statement  "            if (attachedCamera != null && (PlanetariumCamera.Camera == null || PlanetariumCamera.Camera.gameObject != attachedCamera)) " is 122.
Long Statement,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,Update,The length of the statement  "            if ((HighLogic.LoadedScene != GameScenes.FLIGHT && HighLogic.LoadedScene != GameScenes.TRACKSTATION) || !MapView.MapIsEnabled || PlanetariumCamera.Camera == null) " is 162.
Long Statement,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,Render,The length of the statement  "            if ((HighLogic.LoadedScene != GameScenes.FLIGHT && HighLogic.LoadedScene != GameScenes.TRACKSTATION) || !MapView.MapIsEnabled || PlanetariumCamera.Camera == null) " is 162.
Long Statement,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,refreshMesh,The length of the statement  "                //    lineMaterial = new Material("Shader \"Vertex Colors/Alpha\" {Category{Tags {\"Queue\"=\"Transparent\" \"IgnoreProjector\"=\"True\" \"RenderType\"=\"Transparent\"}SubShader {Cull Off ZWrite On Blend SrcAlpha OneMinusSrcAlpha Pass {BindChannels {Bind \"Color\"' color Bind \"Vertex\"' vertex}}}}}"); " is 303.
Long Statement,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,refreshMesh,The length of the statement  "                if (patch.startingState.stockPatch != null && !Settings.fetch.BodyFixedMode && !Settings.fetch.DisplayCompleteTrajectory) " is 121.
Long Statement,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,refreshMesh,The length of the statement  "                    initMeshFromOrbit(patch.startingState.referenceBody.position' mesh' patch.spaceOrbit' patch.startingState.time' patch.endTime - patch.startingState.time' Color.white); " is 167.
Long Statement,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,MakeRibbonEdge,The length of the statement  "            // in 2D mode' if one point is in front of the screen and the other is behind' we don't draw the segment (to achieve this' we draw degenerated triangles' i.e. triangles that have two identical vertices which make them "flat") " is 225.
Long Statement,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The length of the statement  "                // in current implementation' impact positions are displayed only if MapView is in 3D mode (i.e. not zoomed out too far) " is 120.
Long Statement,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The length of the statement  "                vertices[i] = MapView.Draw3DLines ? (Vector3)ScaledSpace.LocalToScaledSpace(vertices[i] + body.position) : new Vector3(0'0'0); " is 126.
Long Statement,Trajectories,NavBallOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\NavBallOverlay.cs,Update,The length of the statement  "            if ((HighLogic.LoadedScene != GameScenes.FLIGHT && HighLogic.LoadedScene != GameScenes.TRACKSTATION) || !FlightGlobals.ActiveVessel) " is 132.
Long Statement,Trajectories,NavBallOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\NavBallOverlay.cs,UpdateNavBall,The length of the statement  "            if (!targetPosition.HasValue || patch == null || !patch.impactPosition.HasValue || patch.startingState.referenceBody != body) " is 125.
Long Statement,Trajectories,NavBallOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\NavBallOverlay.cs,GetCorrection,The length of the statement  "            if (!targetPosition.HasValue || patch == null || !patch.impactPosition.HasValue || patch.startingState.referenceBody != body || !patch.isAtmospheric) " is 149.
Long Statement,Trajectories,NavBallOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\NavBallOverlay.cs,GetCorrection,The length of the statement  "            // Get impact position' or' if some point over the trajectory has not enough clearance' smoothly interpolate to that point depending on how much clearance is missing " is 165.
Long Statement,Trajectories,NavBallOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\NavBallOverlay.cs,GetCorrection,The length of the statement  "            offsetDir *= 0.00005f; // 20km <-> 1 <-> 45° (this is purely indicative' no physical meaning' it would be very complicated to compute an actual correction angle as it depends on the spacecraft behavior in the atmosphere ; a small angle will suffice for a plane' but even a big angle might do almost nothing for a rocket) " is 320.
Long Statement,Trajectories,StockAeroUtil,C:\repos\neuoy_KSPTrajectories\Plugin\StockAeroUtil.cs,GetTemperature,The length of the statement  "            float sunDotCorrected = (1.0f + Vector3.Dot(sunVector' Quaternion.AngleAxis(45f * Mathf.Sign((float)body.rotationPeriod)' body.bodyTransform.up) * up)) * 0.5f; " is 159.
Long Statement,Trajectories,StockAeroUtil,C:\repos\neuoy_KSPTrajectories\Plugin\StockAeroUtil.cs,GetTemperature,The length of the statement  "            double atmosphereTemperatureOffset = (double)body.latitudeTemperatureBiasCurve.Evaluate(time) + (double)body.latitudeTemperatureSunMultCurve.Evaluate(time) * sunDotNormalized + (double)body.axialTemperatureSunMultCurve.Evaluate(sunAxialDot); " is 241.
Long Statement,Trajectories,StockAeroUtil,C:\repos\neuoy_KSPTrajectories\Plugin\StockAeroUtil.cs,GetTemperature,The length of the statement  "            double temperature = body.GetTemperature(altitude) + (double)body.atmosphereTemperatureSunMultCurve.Evaluate((float)altitude) * atmosphereTemperatureOffset; " is 156.
Long Statement,Trajectories,StockAeroUtil,C:\repos\neuoy_KSPTrajectories\Plugin\StockAeroUtil.cs,SimAeroForce,The length of the statement  "                        dragForce = -(Vector3d)sim_dragVectorDir * (double)Mathf.Lerp(p.minimum_drag' p.maximum_drag' Mathf.Abs(Vector3.Dot(p.partTransform.TransformDirection(p.dragReferenceVector)' sim_dragVectorDir))); " is 196.
Long Statement,Trajectories,StockAeroUtil,C:\repos\neuoy_KSPTrajectories\Plugin\StockAeroUtil.cs,SimAeroForce,The length of the statement  "                        dragForce = -(Vector3d)sim_dragVectorDir * (double)Mathf.Lerp(p.minimum_drag' p.maximum_drag' Vector3.Angle(p.partTransform.TransformDirection(p.dragReferenceVector)' sim_dragVectorDir) / 180f); " is 194.
Long Statement,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,SetTarget,The length of the statement  "                foreach (var module in FlightGlobals.ActiveVessel.Parts.SelectMany(p => p.Modules.OfType<TrajectoriesVesselSettings>())) " is 120.
Long Statement,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,createOrbitFromState,The length of the statement  "            orbit.UpdateFromStateVectors(Util.SwapYZ(state.position)' Util.SwapYZ(state.velocity)' state.referenceBody' state.time); " is 120.
Long Statement,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,AddPatch,The length of the statement  "                    //Util.PostSingleScreenMessage("atmo start cond"' "Atmospheric start: vel=" + vel.ToString("0.00") + " (mag=" + vel.magnitude.ToString("0.00") + ")"); " is 150.
Long Statement,Trajectories,Util,C:\repos\neuoy_KSPTrajectories\Plugin\Util.cs,GetMethodEx,The length of the statement  "                throw new Exception("Failed to GetMethod " + methodName + " on type " + type.FullName + " with flags " + flags + ":\n" + e.Message + "\n" + e.StackTrace); " is 154.
Long Statement,Trajectories,Util,C:\repos\neuoy_KSPTrajectories\Plugin\Util.cs,GetMethodEx,The length of the statement  "                throw new Exception("Failed to GetMethod " + methodName + " on type " + type.FullName + " with types " + types.ToString() + ":\n" + e.Message + "\n" + e.StackTrace); " is 165.
Long Statement,Trajectories,Util,C:\repos\neuoy_KSPTrajectories\Plugin\Util.cs,GetMethodEx,The length of the statement  "                throw new Exception("Failed to GetMethod " + methodName + " on type " + type.FullName + " with types " + types.ToString() + ":\n" + e.Message + "\n" + e.StackTrace); " is 165.
Long Statement,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,InitCache,The length of the statement  "            cachedForces = new AeroForceCache(maxCacheVelocity' maxCacheAoA' body_.atmosphereDepth' velocityResolution' angleOfAttackResolution' altitudeResolution' this); " is 159.
Long Statement,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,isValidFor,The length of the statement  "                    nextAllowedAutomaticUpdate = DateTime.Now.AddSeconds(10); // limit updates frequency (could make the game almost unresponsive on some computers) " is 144.
Long Statement,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,GetForces,The length of the statement  "            // adjust force using the more accurate air density that we can compute knowing where the vessel is relatively to the sun and body " is 130.
Long Statement,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,ComputeForces,The length of the statement  "            // this is weird' but the vessel orientation does not match the reference transform (up is forward)' this code fixes it but I don't know if it'll work in all cases " is 163.
Long Statement,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,ComputeForces,The length of the statement  "            Vector3d airVelocityForFixedAoA = (vesselForward * Math.Cos(-angleOfAttack) + vesselUp * Math.Sin(-angleOfAttack)) * airVelocity.magnitude; " is 139.
Long Statement,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,ComputeForces,The length of the statement  "                Debug.Log(string.Format("Trajectories: WARNING: {0} totalForce is NAN (altitude={1}' airVelocity={2}' angleOfAttack={3}"' AerodynamicModelName' altitude' airVelocity.magnitude' angleOfAttack)); " is 193.
Long Statement,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,ComputeForces,The length of the statement  "                return Vector3d.zero; // Don't send NaN into the simulation as it would cause bad things (infinite loops' crash' etc.). I think this case only happens at the atmosphere edge' so the total force should be 0 anyway. " is 213.
Long Statement,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,ComputeForces,The length of the statement  "            // convert the force computed by the model (depends on the current vessel orientation' which is irrelevant for the prediction) to the predicted vessel orientation (which depends on the predicted velocity) " is 204.
Long Statement,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,ComputeForces,The length of the statement  "            Vector3d localForce = new Vector3d(Vector3d.Dot(vesselRight' totalForce)' Vector3d.Dot(vesselUp' totalForce)' Vector3d.Dot(vesselBackward' totalForce)); " is 152.
Long Statement,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,ComputeForces,The length of the statement  "            Vector3d res = predictedVesselRight * localForce.x + predictedVesselUp * localForce.y + predictedVesselBackward * localForce.z; " is 127.
Long Statement,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,ComputeForces,The length of the statement  "                Debug.Log("Trajectories: res is NaN (altitude=" + altitude + "' airVelocity=" + airVelocity.magnitude + "' angleOfAttack=" + angleOfAttack); " is 140.
Long Statement,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,ComputeForces,The length of the statement  "                return new Vector3d(0' 0' 0); // Don't send NaN into the simulation as it would cause bad things (infinite loops' crash' etc.). I think this case only happens at the atmosphere edge' so the total force should be 0 anyway. " is 221.
Complex Conditional,Trajectories,FlightOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\FlightOverlay.cs,FixedUpdate,The conditional expression  "!Settings.fetch.DisplayTrajectories                  || Util.IsMap                  || !Settings.fetch.DisplayTrajectoriesInFlight                  || Trajectory.fetch.patches.Count == 0"  is complex.
Complex Conditional,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,FixedUpdate,The conditional expression  "lastPatchBody != null && targetBody != null && lastPatch.impactPosition.HasValue                      && lastPatchBody == targetBody && traj.targetPosition.HasValue"  is complex.
Complex Conditional,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,Update,The conditional expression  "(HighLogic.LoadedScene != GameScenes.FLIGHT && HighLogic.LoadedScene != GameScenes.TRACKSTATION) || !MapView.MapIsEnabled || PlanetariumCamera.Camera == null"  is complex.
Complex Conditional,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,Render,The conditional expression  "(HighLogic.LoadedScene != GameScenes.FLIGHT && HighLogic.LoadedScene != GameScenes.TRACKSTATION) || !MapView.MapIsEnabled || PlanetariumCamera.Camera == null"  is complex.
Complex Conditional,Trajectories,NavBallOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\NavBallOverlay.cs,UpdateNavBall,The conditional expression  "!targetPosition.HasValue || patch == null || !patch.impactPosition.HasValue || patch.startingState.referenceBody != body"  is complex.
Complex Conditional,Trajectories,NavBallOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\NavBallOverlay.cs,GetCorrection,The conditional expression  "!targetPosition.HasValue || patch == null || !patch.impactPosition.HasValue || patch.startingState.referenceBody != body || !patch.isAtmospheric"  is complex.
Complex Conditional,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,Update,The conditional expression  "HighLogic.LoadedScene == GameScenes.FLIGHT                  && FlightGlobals.ActiveVessel != null                  && FlightGlobals.ActiveVessel.Parts.Count != 0                  && ((Settings.fetch.DisplayTrajectories)                      || Settings.fetch.AlwaysUpdate                      || targetPosition_.HasValue)"  is complex.
Complex Conditional,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,AddPatch,The conditional expression  "hitGround                              || atmosphereCoeff <= 0.0 || atmosphereCoeff >= 1.0                              || iteration == maxIterations || currentTime > patch.endTime"  is complex.
Magic Number,Trajectories,AeroForceCache,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AeroForceCache.cs,GetForce,The following statement contains a magic number: int vFloor = Math.Min(InternalArray.GetLength(0) - 2' (int)vFrac);
Magic Number,Trajectories,AeroForceCache,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AeroForceCache.cs,GetForce,The following statement contains a magic number: float aFrac = (float)((angleOfAttack / MaxAoA * 0.5 + 0.5) * (double)(InternalArray.GetLength(1) - 1));
Magic Number,Trajectories,AeroForceCache,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AeroForceCache.cs,GetForce,The following statement contains a magic number: float aFrac = (float)((angleOfAttack / MaxAoA * 0.5 + 0.5) * (double)(InternalArray.GetLength(1) - 1));
Magic Number,Trajectories,AeroForceCache,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AeroForceCache.cs,GetForce,The following statement contains a magic number: int aFloor = Math.Max(0' Math.Min(InternalArray.GetLength(1) - 2' (int)aFrac));
Magic Number,Trajectories,AeroForceCache,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AeroForceCache.cs,GetForce,The following statement contains a magic number: float mFrac = (float)(altitude / MaxAltitude * (double)(InternalArray.GetLength(2) - 1));
Magic Number,Trajectories,AeroForceCache,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AeroForceCache.cs,GetForce,The following statement contains a magic number: int mFloor = Math.Max(0' Math.Min(InternalArray.GetLength(2) - 2' (int)mFrac));
Magic Number,Trajectories,AeroForceCache,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AeroForceCache.cs,GetForce,The following statement contains a magic number: int mFloor = Math.Max(0' Math.Min(InternalArray.GetLength(2) - 2' (int)mFrac));
Magic Number,Trajectories,AeroForceCache,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AeroForceCache.cs,ComputeCacheEntry,The following statement contains a magic number: double AoA = MaxAoA * ((double)a / (double)(InternalArray.GetLength(1) - 1) * 2.0 - 1.0);
Magic Number,Trajectories,AeroForceCache,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AeroForceCache.cs,ComputeCacheEntry,The following statement contains a magic number: double currentAltitude = MaxAltitude * (double)m / (double)(InternalArray.GetLength(2) - 1);
Magic Number,Trajectories,FARModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\FARModel.cs,PackForces,The following statement contains a magic number: if (rho < 0.0000000001)                  return new Vector2(0' 0);
Magic Number,Trajectories,StockModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\StockModel.cs,PackForces,The following statement contains a magic number: if (rho < 0.0000000001)                  return new Vector2(0' 0);
Magic Number,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawGroundMarker,The following statement contains a magic number: if (radius <= 0) { radius = map ? body.Radius / 15 : 5; }
Magic Number,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawGroundMarker,The following statement contains a magic number: if (radius <= 0) { radius = map ? body.Radius / 15 : 5; }
Magic Number,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawGroundMarker,The following statement contains a magic number: GLTriangle(                  center'                  center + radius * (QuaternionD.AngleAxis(rotation - 10' up) * north)'                  center + radius * (QuaternionD.AngleAxis(rotation + 10' up) * north)              ' c' map);
Magic Number,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawGroundMarker,The following statement contains a magic number: GLTriangle(                  center'                  center + radius * (QuaternionD.AngleAxis(rotation - 10' up) * north)'                  center + radius * (QuaternionD.AngleAxis(rotation + 10' up) * north)              ' c' map);
Magic Number,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawGroundMarker,The following statement contains a magic number: GLTriangle(                  center'                  center + radius * (QuaternionD.AngleAxis(rotation + 110' up) * north)'                  center + radius * (QuaternionD.AngleAxis(rotation + 130' up) * north)              ' c' map);
Magic Number,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawGroundMarker,The following statement contains a magic number: GLTriangle(                  center'                  center + radius * (QuaternionD.AngleAxis(rotation + 110' up) * north)'                  center + radius * (QuaternionD.AngleAxis(rotation + 130' up) * north)              ' c' map);
Magic Number,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawGroundMarker,The following statement contains a magic number: GLTriangle(                  center'                  center + radius * (QuaternionD.AngleAxis(rotation - 110' up) * north)'                  center + radius * (QuaternionD.AngleAxis(rotation - 130' up) * north)              ' c' map);
Magic Number,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawGroundMarker,The following statement contains a magic number: GLTriangle(                  center'                  center + radius * (QuaternionD.AngleAxis(rotation - 110' up) * north)'                  center + radius * (QuaternionD.AngleAxis(rotation - 130' up) * north)              ' c' map);
Magic Number,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,IsOccluded,The following statement contains a magic number: Vector3d VC = (byBody.position - camPos) / (byBody.Radius - 100);
Magic Number,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,IsOccluded,The following statement contains a magic number: Vector3d VT = (worldPosition - camPos) / (byBody.Radius - 100);
Magic Number,Trajectories,GLUtils,C:\repos\neuoy_KSPTrajectories\Plugin\GLUtils.cs,DrawPath,The following statement contains a magic number: int step = (dashed ? 2 : 1);
Magic Number,Trajectories,DescentProfile,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,Reset,The following statement contains a magic number: retrogradeEntry = AoA == 180;
Magic Number,Trajectories,DescentProfile,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,DoQuickControlsGUI,The following statement contains a magic number: bool newPrograde = GUILayout.Toggle(progradeEntry' "Progr."' GUILayout.Width(50));
Magic Number,Trajectories,DescentProfile,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,DoQuickControlsGUI,The following statement contains a magic number: bool newRetrograde = GUILayout.Toggle(retrogradeEntry' "Retro."' GUILayout.Width(50));
Magic Number,Trajectories,DescentProfile,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,DoQuickControlsGUI,The following statement contains a magic number: if (presetActivated)              {                  double setAoA = progradeEntry ? 0 : Math.PI;                    entry.angle = setAoA;                  entry.horizon = false;                  entry.RefreshSliderPos();                  highAltitude.angle = setAoA;                  highAltitude.horizon = false;                  highAltitude.RefreshSliderPos();                  lowAltitude.angle = setAoA;                  lowAltitude.horizon = false;                  lowAltitude.RefreshSliderPos();                  finalApproach.angle = setAoA;                  finalApproach.horizon = false;                  finalApproach.RefreshSliderPos();              }              else              {                  double? AoA = entry.horizon ? (double?)null : entry.angle;                  if (highAltitude.angle != AoA || highAltitude.horizon) AoA = null;                  if (lowAltitude.angle != AoA || lowAltitude.horizon) AoA = null;                  if (finalApproach.angle != AoA || finalApproach.horizon) AoA = null;                    if (!AoA.HasValue || Math.Abs(AoA.Value - 0) > 0.01)                      progradeEntry = false;                  if (!AoA.HasValue || Math.Abs(AoA.Value - Math.PI) > 0.01)                      retrogradeEntry = false;              }
Magic Number,Trajectories,DescentProfile,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,DoQuickControlsGUI,The following statement contains a magic number: if (presetActivated)              {                  double setAoA = progradeEntry ? 0 : Math.PI;                    entry.angle = setAoA;                  entry.horizon = false;                  entry.RefreshSliderPos();                  highAltitude.angle = setAoA;                  highAltitude.horizon = false;                  highAltitude.RefreshSliderPos();                  lowAltitude.angle = setAoA;                  lowAltitude.horizon = false;                  lowAltitude.RefreshSliderPos();                  finalApproach.angle = setAoA;                  finalApproach.horizon = false;                  finalApproach.RefreshSliderPos();              }              else              {                  double? AoA = entry.horizon ? (double?)null : entry.angle;                  if (highAltitude.angle != AoA || highAltitude.horizon) AoA = null;                  if (lowAltitude.angle != AoA || lowAltitude.horizon) AoA = null;                  if (finalApproach.angle != AoA || finalApproach.horizon) AoA = null;                    if (!AoA.HasValue || Math.Abs(AoA.Value - 0) > 0.01)                      progradeEntry = false;                  if (!AoA.HasValue || Math.Abs(AoA.Value - Math.PI) > 0.01)                      retrogradeEntry = false;              }
Magic Number,Trajectories,DescentProfile,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,GetAngleOfAttack,The following statement contains a magic number: if (altitudeRatio > 0.5)              {                  a = entry;                  b = highAltitude;                  aCoeff = Math.Min((altitudeRatio - 0.5) * 2.0' 1.0);              }              else if(altitudeRatio > 0.25)              {                  a = highAltitude;                  b = lowAltitude;                  aCoeff = altitudeRatio * 4.0 - 1.0;              }              else if (altitudeRatio > 0.05)              {                  a = lowAltitude;                  b = finalApproach;                  aCoeff = altitudeRatio * 5.0 - 0.25;                    aCoeff = 1.0 - aCoeff;                  aCoeff = 1.0 - aCoeff * aCoeff;              }              else              {                  return finalApproach.GetAngleOfAttack(position' velocity);              }
Magic Number,Trajectories,DescentProfile,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,GetAngleOfAttack,The following statement contains a magic number: if (altitudeRatio > 0.5)              {                  a = entry;                  b = highAltitude;                  aCoeff = Math.Min((altitudeRatio - 0.5) * 2.0' 1.0);              }              else if(altitudeRatio > 0.25)              {                  a = highAltitude;                  b = lowAltitude;                  aCoeff = altitudeRatio * 4.0 - 1.0;              }              else if (altitudeRatio > 0.05)              {                  a = lowAltitude;                  b = finalApproach;                  aCoeff = altitudeRatio * 5.0 - 0.25;                    aCoeff = 1.0 - aCoeff;                  aCoeff = 1.0 - aCoeff * aCoeff;              }              else              {                  return finalApproach.GetAngleOfAttack(position' velocity);              }
Magic Number,Trajectories,DescentProfile,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,GetAngleOfAttack,The following statement contains a magic number: if (altitudeRatio > 0.5)              {                  a = entry;                  b = highAltitude;                  aCoeff = Math.Min((altitudeRatio - 0.5) * 2.0' 1.0);              }              else if(altitudeRatio > 0.25)              {                  a = highAltitude;                  b = lowAltitude;                  aCoeff = altitudeRatio * 4.0 - 1.0;              }              else if (altitudeRatio > 0.05)              {                  a = lowAltitude;                  b = finalApproach;                  aCoeff = altitudeRatio * 5.0 - 0.25;                    aCoeff = 1.0 - aCoeff;                  aCoeff = 1.0 - aCoeff * aCoeff;              }              else              {                  return finalApproach.GetAngleOfAttack(position' velocity);              }
Magic Number,Trajectories,DescentProfile,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,GetAngleOfAttack,The following statement contains a magic number: if (altitudeRatio > 0.5)              {                  a = entry;                  b = highAltitude;                  aCoeff = Math.Min((altitudeRatio - 0.5) * 2.0' 1.0);              }              else if(altitudeRatio > 0.25)              {                  a = highAltitude;                  b = lowAltitude;                  aCoeff = altitudeRatio * 4.0 - 1.0;              }              else if (altitudeRatio > 0.05)              {                  a = lowAltitude;                  b = finalApproach;                  aCoeff = altitudeRatio * 5.0 - 0.25;                    aCoeff = 1.0 - aCoeff;                  aCoeff = 1.0 - aCoeff * aCoeff;              }              else              {                  return finalApproach.GetAngleOfAttack(position' velocity);              }
Magic Number,Trajectories,DescentProfile,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,GetAngleOfAttack,The following statement contains a magic number: if (altitudeRatio > 0.5)              {                  a = entry;                  b = highAltitude;                  aCoeff = Math.Min((altitudeRatio - 0.5) * 2.0' 1.0);              }              else if(altitudeRatio > 0.25)              {                  a = highAltitude;                  b = lowAltitude;                  aCoeff = altitudeRatio * 4.0 - 1.0;              }              else if (altitudeRatio > 0.05)              {                  a = lowAltitude;                  b = finalApproach;                  aCoeff = altitudeRatio * 5.0 - 0.25;                    aCoeff = 1.0 - aCoeff;                  aCoeff = 1.0 - aCoeff * aCoeff;              }              else              {                  return finalApproach.GetAngleOfAttack(position' velocity);              }
Magic Number,Trajectories,DescentProfile,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,GetAngleOfAttack,The following statement contains a magic number: if (altitudeRatio > 0.5)              {                  a = entry;                  b = highAltitude;                  aCoeff = Math.Min((altitudeRatio - 0.5) * 2.0' 1.0);              }              else if(altitudeRatio > 0.25)              {                  a = highAltitude;                  b = lowAltitude;                  aCoeff = altitudeRatio * 4.0 - 1.0;              }              else if (altitudeRatio > 0.05)              {                  a = lowAltitude;                  b = finalApproach;                  aCoeff = altitudeRatio * 5.0 - 0.25;                    aCoeff = 1.0 - aCoeff;                  aCoeff = 1.0 - aCoeff * aCoeff;              }              else              {                  return finalApproach.GetAngleOfAttack(position' velocity);              }
Magic Number,Trajectories,DescentProfile,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,GetAngleOfAttack,The following statement contains a magic number: if (altitudeRatio > 0.5)              {                  a = entry;                  b = highAltitude;                  aCoeff = Math.Min((altitudeRatio - 0.5) * 2.0' 1.0);              }              else if(altitudeRatio > 0.25)              {                  a = highAltitude;                  b = lowAltitude;                  aCoeff = altitudeRatio * 4.0 - 1.0;              }              else if (altitudeRatio > 0.05)              {                  a = lowAltitude;                  b = finalApproach;                  aCoeff = altitudeRatio * 5.0 - 0.25;                    aCoeff = 1.0 - aCoeff;                  aCoeff = 1.0 - aCoeff * aCoeff;              }              else              {                  return finalApproach.GetAngleOfAttack(position' velocity);              }
Magic Number,Trajectories,DescentProfile,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,GetAngleOfAttack,The following statement contains a magic number: if (altitudeRatio > 0.5)              {                  a = entry;                  b = highAltitude;                  aCoeff = Math.Min((altitudeRatio - 0.5) * 2.0' 1.0);              }              else if(altitudeRatio > 0.25)              {                  a = highAltitude;                  b = lowAltitude;                  aCoeff = altitudeRatio * 4.0 - 1.0;              }              else if (altitudeRatio > 0.05)              {                  a = lowAltitude;                  b = finalApproach;                  aCoeff = altitudeRatio * 5.0 - 0.25;                    aCoeff = 1.0 - aCoeff;                  aCoeff = 1.0 - aCoeff * aCoeff;              }              else              {                  return finalApproach.GetAngleOfAttack(position' velocity);              }
Magic Number,Trajectories,Node,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,GetAngleOfAttack,The following statement contains a magic number: return Math.Acos(Vector3d.Dot(position' velocity) / (position.magnitude * velocity.magnitude)) - Math.PI * 0.5 + angle;
Magic Number,Trajectories,Node,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,DoGUI,The following statement contains a magic number: GUILayout.Label(new GUIContent(name' description)' GUILayout.Width(50));
Magic Number,Trajectories,Node,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,DoGUI,The following statement contains a magic number: horizon = GUILayout.Toggle(horizon' new GUIContent(horizon ? "Horiz" : "AoA"' "AoA = Angle of Attack = angle relatively to the velocity vector.\nHoriz = angle relatively to the horizon.")' GUILayout.Width(50));
Magic Number,Trajectories,Node,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,DoGUI,The following statement contains a magic number: sliderPos = GUILayout.HorizontalSlider(sliderPos' -1.0f' 1.0f' GUILayout.Width(90));
Magic Number,Trajectories,Node,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,DoGUI,The following statement contains a magic number: GUILayout.Label(Math.Round(angle * 180.0 / Math.PI).ToString() + "°"' GUILayout.Width(30));
Magic Number,Trajectories,Node,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,DoGUI,The following statement contains a magic number: GUILayout.Label(Math.Round(angle * 180.0 / Math.PI).ToString() + "°"' GUILayout.Width(30));
Magic Number,Trajectories,Node,C:\repos\neuoy_KSPTrajectories\Plugin\DescentProfile.cs,RefreshSliderPos,The following statement contains a magic number: sliderPos = (float)Math.Pow(Math.Abs(angle) / maxAngle' 1.0 / 3.0);
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,OnGUI,The following statement contains a magic number: Settings.fetch.MapGUIWindowPos = new Rect(Settings.fetch.MapGUIWindowPos.xMin' Settings.fetch.MapGUIWindowPos.yMin' Settings.fetch.MapGUIWindowPos.width' Settings.fetch.MapGUIWindowPos.height - 3);
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,OnGUI,The following statement contains a magic number: if (tooltip != "")              {                  Vector3 mousePos = Input.mousePosition;                  mousePos.y = Screen.height - mousePos.y;                  int tooltipWidth = 400;                  int tooltipHeight = 80;                  Rect tooltipRect = new Rect(mousePos.x - 50' mousePos.y + 10' tooltipWidth' tooltipHeight);                    GUILayout.Window(GUIId + 2' ClampToScreen(tooltipRect)' TooltipWindow' "");              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,OnGUI,The following statement contains a magic number: if (tooltip != "")              {                  Vector3 mousePos = Input.mousePosition;                  mousePos.y = Screen.height - mousePos.y;                  int tooltipWidth = 400;                  int tooltipHeight = 80;                  Rect tooltipRect = new Rect(mousePos.x - 50' mousePos.y + 10' tooltipWidth' tooltipHeight);                    GUILayout.Window(GUIId + 2' ClampToScreen(tooltipRect)' TooltipWindow' "");              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,OnGUI,The following statement contains a magic number: if (tooltip != "")              {                  Vector3 mousePos = Input.mousePosition;                  mousePos.y = Screen.height - mousePos.y;                  int tooltipWidth = 400;                  int tooltipHeight = 80;                  Rect tooltipRect = new Rect(mousePos.x - 50' mousePos.y + 10' tooltipWidth' tooltipHeight);                    GUILayout.Window(GUIId + 2' ClampToScreen(tooltipRect)' TooltipWindow' "");              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,OnGUI,The following statement contains a magic number: if (tooltip != "")              {                  Vector3 mousePos = Input.mousePosition;                  mousePos.y = Screen.height - mousePos.y;                  int tooltipWidth = 400;                  int tooltipHeight = 80;                  Rect tooltipRect = new Rect(mousePos.x - 50' mousePos.y + 10' tooltipWidth' tooltipHeight);                    GUILayout.Window(GUIId + 2' ClampToScreen(tooltipRect)' TooltipWindow' "");              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,OnGUI,The following statement contains a magic number: if (tooltip != "")              {                  Vector3 mousePos = Input.mousePosition;                  mousePos.y = Screen.height - mousePos.y;                  int tooltipWidth = 400;                  int tooltipHeight = 80;                  Rect tooltipRect = new Rect(mousePos.x - 50' mousePos.y + 10' tooltipWidth' tooltipHeight);                    GUILayout.Window(GUIId + 2' ClampToScreen(tooltipRect)' TooltipWindow' "");              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,FixedUpdate,The following statement contains a magic number: guistring_gForce = (traj.MaxAccel / 9.81).ToString("0.00");
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,FixedUpdate,The following statement contains a magic number: if (Settings.fetch.DisplayTargetGUI)              {                  if (lastPatchBody != null && targetBody != null && lastPatch.impactPosition.HasValue                      && lastPatchBody == targetBody && traj.targetPosition.HasValue)                  {                      // Get Latitude and Longitude from impact position                      double impactLat;                      double impatLon;                      double impactAlt;                      impactPos = lastPatch.impactPosition.Value + lastPatchBody.position;                      lastPatchBody.GetLatLonAlt(impactPos' out impactLat' out impatLon' out impactAlt);                        // Get Latitude and Longitude for target position                      double targetLat;                      double targetLon;                      double targetAlt;                      targetPos = traj.targetPosition.Value + targetBody.position;                      targetBody.GetLatLonAlt(targetPos' out targetLat' out targetLon' out targetAlt);                        float targetDistance = (float)(Util.distanceFromLatitudeAndLongitude(targetBody.Radius + impactAlt'                          impactLat' impatLon' targetLat' targetLon) / 1e3);                        float targetDistanceNorth = (float)(Util.distanceFromLatitudeAndLongitude(targetBody.Radius + impactAlt'                          impactLat' targetLon' targetLat' targetLon) / 1e3) * ((targetLat - impactLat) < 0 ? -1.0f : +1.0f);                        float targetDistanceEast = (float)(Util.distanceFromLatitudeAndLongitude(targetBody.Radius + impactAlt'                          targetLat' impatLon' targetLat' targetLon) / 1e3) * ((targetLon - impatLon) < 0 ? -1.0f : +1.0f);                        // format distance to target string                      guistring_targetDistance = String.Format("{0'6:F1}km | {1}: {2'6:F1}km | {3}: {4'6:F1}km"'                          targetDistance'                          targetDistanceNorth > 0.0f ? 'N' : 'S''                          Math.Abs(targetDistanceNorth)'                          targetDistanceEast > 0.0f ? 'E' : 'W''                          Math.Abs(targetDistanceEast));                  }                  else                  {                      guistring_targetDistance = "";                  }              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,FixedUpdate,The following statement contains a magic number: if (Settings.fetch.DisplayTargetGUI)              {                  if (lastPatchBody != null && targetBody != null && lastPatch.impactPosition.HasValue                      && lastPatchBody == targetBody && traj.targetPosition.HasValue)                  {                      // Get Latitude and Longitude from impact position                      double impactLat;                      double impatLon;                      double impactAlt;                      impactPos = lastPatch.impactPosition.Value + lastPatchBody.position;                      lastPatchBody.GetLatLonAlt(impactPos' out impactLat' out impatLon' out impactAlt);                        // Get Latitude and Longitude for target position                      double targetLat;                      double targetLon;                      double targetAlt;                      targetPos = traj.targetPosition.Value + targetBody.position;                      targetBody.GetLatLonAlt(targetPos' out targetLat' out targetLon' out targetAlt);                        float targetDistance = (float)(Util.distanceFromLatitudeAndLongitude(targetBody.Radius + impactAlt'                          impactLat' impatLon' targetLat' targetLon) / 1e3);                        float targetDistanceNorth = (float)(Util.distanceFromLatitudeAndLongitude(targetBody.Radius + impactAlt'                          impactLat' targetLon' targetLat' targetLon) / 1e3) * ((targetLat - impactLat) < 0 ? -1.0f : +1.0f);                        float targetDistanceEast = (float)(Util.distanceFromLatitudeAndLongitude(targetBody.Radius + impactAlt'                          targetLat' impatLon' targetLat' targetLon) / 1e3) * ((targetLon - impatLon) < 0 ? -1.0f : +1.0f);                        // format distance to target string                      guistring_targetDistance = String.Format("{0'6:F1}km | {1}: {2'6:F1}km | {3}: {4'6:F1}km"'                          targetDistance'                          targetDistanceNorth > 0.0f ? 'N' : 'S''                          Math.Abs(targetDistanceNorth)'                          targetDistanceEast > 0.0f ? 'E' : 'W''                          Math.Abs(targetDistanceEast));                  }                  else                  {                      guistring_targetDistance = "";                  }              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,FixedUpdate,The following statement contains a magic number: if (Settings.fetch.DisplayTargetGUI)              {                  if (lastPatchBody != null && targetBody != null && lastPatch.impactPosition.HasValue                      && lastPatchBody == targetBody && traj.targetPosition.HasValue)                  {                      // Get Latitude and Longitude from impact position                      double impactLat;                      double impatLon;                      double impactAlt;                      impactPos = lastPatch.impactPosition.Value + lastPatchBody.position;                      lastPatchBody.GetLatLonAlt(impactPos' out impactLat' out impatLon' out impactAlt);                        // Get Latitude and Longitude for target position                      double targetLat;                      double targetLon;                      double targetAlt;                      targetPos = traj.targetPosition.Value + targetBody.position;                      targetBody.GetLatLonAlt(targetPos' out targetLat' out targetLon' out targetAlt);                        float targetDistance = (float)(Util.distanceFromLatitudeAndLongitude(targetBody.Radius + impactAlt'                          impactLat' impatLon' targetLat' targetLon) / 1e3);                        float targetDistanceNorth = (float)(Util.distanceFromLatitudeAndLongitude(targetBody.Radius + impactAlt'                          impactLat' targetLon' targetLat' targetLon) / 1e3) * ((targetLat - impactLat) < 0 ? -1.0f : +1.0f);                        float targetDistanceEast = (float)(Util.distanceFromLatitudeAndLongitude(targetBody.Radius + impactAlt'                          targetLat' impatLon' targetLat' targetLon) / 1e3) * ((targetLon - impatLon) < 0 ? -1.0f : +1.0f);                        // format distance to target string                      guistring_targetDistance = String.Format("{0'6:F1}km | {1}: {2'6:F1}km | {3}: {4'6:F1}km"'                          targetDistance'                          targetDistanceNorth > 0.0f ? 'N' : 'S''                          Math.Abs(targetDistanceNorth)'                          targetDistanceEast > 0.0f ? 'E' : 'W''                          Math.Abs(targetDistanceEast));                  }                  else                  {                      guistring_targetDistance = "";                  }              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: Settings.fetch.DisplayTrajectories = GUILayout.Toggle(Settings.fetch.DisplayTrajectories' "Show trajectory"' GUILayout.Width(125));
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplayTrajectories)              {                  Settings.fetch.DisplayCompleteTrajectory = GUILayout.Toggle(Settings.fetch.DisplayCompleteTrajectory' "complete"' GUILayout.Width(70));              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: GUILayout.Space(10);
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplayTargetGUI = ToggleGroup(Settings.fetch.DisplayTargetGUI' "Target"))              {                  GUI.enabled = traj.targetPosition.HasValue;                    GUILayout.Label(guistring_targetDistance);                    if (GUILayout.Button("Unset target"))                      traj.SetTarget();                  GUI.enabled = true;                    GUILayout.BeginHorizontal();                  var patch = traj.patches.LastOrDefault();                  GUI.enabled = (patch != null && patch.impactPosition.HasValue);                  if (GUILayout.Button("Set current impact"' GUILayout.Width(150)))                  {                      traj.SetTarget(patch.startingState.referenceBody' patch.impactPosition);                  }                  GUI.enabled = true;                  if (GUILayout.Button("Set KSC"' GUILayout.Width(70)))                  {                      var body = FlightGlobals.Bodies.SingleOrDefault(b => b.isHomeWorld);                      if (body != null)                      {                          Vector3d worldPos = body.GetWorldSurfacePosition(-0.04860002' -74.72425635' 2.0);                          traj.SetTarget(body' worldPos - body.position);                      }                  }                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                    Vessel targetVessel = FlightGlobals.fetch.VesselTarget?.GetVessel();                  GUI.enabled = (patch != null && targetVessel != null && targetVessel.Landed                  // && targetVessel.lastBody == patch.startingState.referenceBody                  );                  if (GUILayout.Button("Target vessel"))                  {                      traj.SetTarget(targetVessel.lastBody' targetVessel.GetWorldPos3D() - targetVessel.lastBody.position);                      ScreenMessages.PostScreenMessage("Targeting vessel " + targetVessel.GetName());                  }                    FinePrint.Waypoint navigationWaypoint = FlightGlobals.ActiveVessel?.navigationWaypoint;                  GUI.enabled = (navigationWaypoint != null);                  if (GUILayout.Button("Active waypoint"))                  {                      traj.SetTarget(navigationWaypoint.celestialBody'                          navigationWaypoint.celestialBody.GetRelSurfacePosition(navigationWaypoint.latitude' navigationWaypoint.longitude' navigationWaypoint.altitude));                      ScreenMessages.PostScreenMessage("Targeting waypoint " + navigationWaypoint.name);                  }                  GUILayout.EndHorizontal();                    GUI.enabled = true;                    GUILayout.BeginHorizontal();                  coords = GUILayout.TextField(coords' GUILayout.Width(170));                  if (GUILayout.Button(new GUIContent("Set"'                          "Enter target latitude and longitude' separated by a comma' in decimal format (with a dot for decimal separator)")'                          GUILayout.Width(50)))                  {                      string[] latLng = coords.Split(new char[] { '''' ';' });                      var body = FlightGlobals.currentMainBody;                      if (latLng.Length == 2 && body != null)                      {                          double lat;                          double lng;                          if (double.TryParse(latLng[0].Trim()' out lat) && double.TryParse(latLng[1].Trim()' out lng))                          {                              Vector3d relPos = body.GetWorldSurfacePosition(lat' lng' 2.0) - body.position;                              double altitude = Trajectory.GetGroundAltitude(body' relPos) + body.Radius;                              traj.SetTarget(body' relPos * (altitude / relPos.magnitude));                          }                      }                  }                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplayTargetGUI = ToggleGroup(Settings.fetch.DisplayTargetGUI' "Target"))              {                  GUI.enabled = traj.targetPosition.HasValue;                    GUILayout.Label(guistring_targetDistance);                    if (GUILayout.Button("Unset target"))                      traj.SetTarget();                  GUI.enabled = true;                    GUILayout.BeginHorizontal();                  var patch = traj.patches.LastOrDefault();                  GUI.enabled = (patch != null && patch.impactPosition.HasValue);                  if (GUILayout.Button("Set current impact"' GUILayout.Width(150)))                  {                      traj.SetTarget(patch.startingState.referenceBody' patch.impactPosition);                  }                  GUI.enabled = true;                  if (GUILayout.Button("Set KSC"' GUILayout.Width(70)))                  {                      var body = FlightGlobals.Bodies.SingleOrDefault(b => b.isHomeWorld);                      if (body != null)                      {                          Vector3d worldPos = body.GetWorldSurfacePosition(-0.04860002' -74.72425635' 2.0);                          traj.SetTarget(body' worldPos - body.position);                      }                  }                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                    Vessel targetVessel = FlightGlobals.fetch.VesselTarget?.GetVessel();                  GUI.enabled = (patch != null && targetVessel != null && targetVessel.Landed                  // && targetVessel.lastBody == patch.startingState.referenceBody                  );                  if (GUILayout.Button("Target vessel"))                  {                      traj.SetTarget(targetVessel.lastBody' targetVessel.GetWorldPos3D() - targetVessel.lastBody.position);                      ScreenMessages.PostScreenMessage("Targeting vessel " + targetVessel.GetName());                  }                    FinePrint.Waypoint navigationWaypoint = FlightGlobals.ActiveVessel?.navigationWaypoint;                  GUI.enabled = (navigationWaypoint != null);                  if (GUILayout.Button("Active waypoint"))                  {                      traj.SetTarget(navigationWaypoint.celestialBody'                          navigationWaypoint.celestialBody.GetRelSurfacePosition(navigationWaypoint.latitude' navigationWaypoint.longitude' navigationWaypoint.altitude));                      ScreenMessages.PostScreenMessage("Targeting waypoint " + navigationWaypoint.name);                  }                  GUILayout.EndHorizontal();                    GUI.enabled = true;                    GUILayout.BeginHorizontal();                  coords = GUILayout.TextField(coords' GUILayout.Width(170));                  if (GUILayout.Button(new GUIContent("Set"'                          "Enter target latitude and longitude' separated by a comma' in decimal format (with a dot for decimal separator)")'                          GUILayout.Width(50)))                  {                      string[] latLng = coords.Split(new char[] { '''' ';' });                      var body = FlightGlobals.currentMainBody;                      if (latLng.Length == 2 && body != null)                      {                          double lat;                          double lng;                          if (double.TryParse(latLng[0].Trim()' out lat) && double.TryParse(latLng[1].Trim()' out lng))                          {                              Vector3d relPos = body.GetWorldSurfacePosition(lat' lng' 2.0) - body.position;                              double altitude = Trajectory.GetGroundAltitude(body' relPos) + body.Radius;                              traj.SetTarget(body' relPos * (altitude / relPos.magnitude));                          }                      }                  }                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplayTargetGUI = ToggleGroup(Settings.fetch.DisplayTargetGUI' "Target"))              {                  GUI.enabled = traj.targetPosition.HasValue;                    GUILayout.Label(guistring_targetDistance);                    if (GUILayout.Button("Unset target"))                      traj.SetTarget();                  GUI.enabled = true;                    GUILayout.BeginHorizontal();                  var patch = traj.patches.LastOrDefault();                  GUI.enabled = (patch != null && patch.impactPosition.HasValue);                  if (GUILayout.Button("Set current impact"' GUILayout.Width(150)))                  {                      traj.SetTarget(patch.startingState.referenceBody' patch.impactPosition);                  }                  GUI.enabled = true;                  if (GUILayout.Button("Set KSC"' GUILayout.Width(70)))                  {                      var body = FlightGlobals.Bodies.SingleOrDefault(b => b.isHomeWorld);                      if (body != null)                      {                          Vector3d worldPos = body.GetWorldSurfacePosition(-0.04860002' -74.72425635' 2.0);                          traj.SetTarget(body' worldPos - body.position);                      }                  }                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                    Vessel targetVessel = FlightGlobals.fetch.VesselTarget?.GetVessel();                  GUI.enabled = (patch != null && targetVessel != null && targetVessel.Landed                  // && targetVessel.lastBody == patch.startingState.referenceBody                  );                  if (GUILayout.Button("Target vessel"))                  {                      traj.SetTarget(targetVessel.lastBody' targetVessel.GetWorldPos3D() - targetVessel.lastBody.position);                      ScreenMessages.PostScreenMessage("Targeting vessel " + targetVessel.GetName());                  }                    FinePrint.Waypoint navigationWaypoint = FlightGlobals.ActiveVessel?.navigationWaypoint;                  GUI.enabled = (navigationWaypoint != null);                  if (GUILayout.Button("Active waypoint"))                  {                      traj.SetTarget(navigationWaypoint.celestialBody'                          navigationWaypoint.celestialBody.GetRelSurfacePosition(navigationWaypoint.latitude' navigationWaypoint.longitude' navigationWaypoint.altitude));                      ScreenMessages.PostScreenMessage("Targeting waypoint " + navigationWaypoint.name);                  }                  GUILayout.EndHorizontal();                    GUI.enabled = true;                    GUILayout.BeginHorizontal();                  coords = GUILayout.TextField(coords' GUILayout.Width(170));                  if (GUILayout.Button(new GUIContent("Set"'                          "Enter target latitude and longitude' separated by a comma' in decimal format (with a dot for decimal separator)")'                          GUILayout.Width(50)))                  {                      string[] latLng = coords.Split(new char[] { '''' ';' });                      var body = FlightGlobals.currentMainBody;                      if (latLng.Length == 2 && body != null)                      {                          double lat;                          double lng;                          if (double.TryParse(latLng[0].Trim()' out lat) && double.TryParse(latLng[1].Trim()' out lng))                          {                              Vector3d relPos = body.GetWorldSurfacePosition(lat' lng' 2.0) - body.position;                              double altitude = Trajectory.GetGroundAltitude(body' relPos) + body.Radius;                              traj.SetTarget(body' relPos * (altitude / relPos.magnitude));                          }                      }                  }                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplayTargetGUI = ToggleGroup(Settings.fetch.DisplayTargetGUI' "Target"))              {                  GUI.enabled = traj.targetPosition.HasValue;                    GUILayout.Label(guistring_targetDistance);                    if (GUILayout.Button("Unset target"))                      traj.SetTarget();                  GUI.enabled = true;                    GUILayout.BeginHorizontal();                  var patch = traj.patches.LastOrDefault();                  GUI.enabled = (patch != null && patch.impactPosition.HasValue);                  if (GUILayout.Button("Set current impact"' GUILayout.Width(150)))                  {                      traj.SetTarget(patch.startingState.referenceBody' patch.impactPosition);                  }                  GUI.enabled = true;                  if (GUILayout.Button("Set KSC"' GUILayout.Width(70)))                  {                      var body = FlightGlobals.Bodies.SingleOrDefault(b => b.isHomeWorld);                      if (body != null)                      {                          Vector3d worldPos = body.GetWorldSurfacePosition(-0.04860002' -74.72425635' 2.0);                          traj.SetTarget(body' worldPos - body.position);                      }                  }                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                    Vessel targetVessel = FlightGlobals.fetch.VesselTarget?.GetVessel();                  GUI.enabled = (patch != null && targetVessel != null && targetVessel.Landed                  // && targetVessel.lastBody == patch.startingState.referenceBody                  );                  if (GUILayout.Button("Target vessel"))                  {                      traj.SetTarget(targetVessel.lastBody' targetVessel.GetWorldPos3D() - targetVessel.lastBody.position);                      ScreenMessages.PostScreenMessage("Targeting vessel " + targetVessel.GetName());                  }                    FinePrint.Waypoint navigationWaypoint = FlightGlobals.ActiveVessel?.navigationWaypoint;                  GUI.enabled = (navigationWaypoint != null);                  if (GUILayout.Button("Active waypoint"))                  {                      traj.SetTarget(navigationWaypoint.celestialBody'                          navigationWaypoint.celestialBody.GetRelSurfacePosition(navigationWaypoint.latitude' navigationWaypoint.longitude' navigationWaypoint.altitude));                      ScreenMessages.PostScreenMessage("Targeting waypoint " + navigationWaypoint.name);                  }                  GUILayout.EndHorizontal();                    GUI.enabled = true;                    GUILayout.BeginHorizontal();                  coords = GUILayout.TextField(coords' GUILayout.Width(170));                  if (GUILayout.Button(new GUIContent("Set"'                          "Enter target latitude and longitude' separated by a comma' in decimal format (with a dot for decimal separator)")'                          GUILayout.Width(50)))                  {                      string[] latLng = coords.Split(new char[] { '''' ';' });                      var body = FlightGlobals.currentMainBody;                      if (latLng.Length == 2 && body != null)                      {                          double lat;                          double lng;                          if (double.TryParse(latLng[0].Trim()' out lat) && double.TryParse(latLng[1].Trim()' out lng))                          {                              Vector3d relPos = body.GetWorldSurfacePosition(lat' lng' 2.0) - body.position;                              double altitude = Trajectory.GetGroundAltitude(body' relPos) + body.Radius;                              traj.SetTarget(body' relPos * (altitude / relPos.magnitude));                          }                      }                  }                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplayTargetGUI = ToggleGroup(Settings.fetch.DisplayTargetGUI' "Target"))              {                  GUI.enabled = traj.targetPosition.HasValue;                    GUILayout.Label(guistring_targetDistance);                    if (GUILayout.Button("Unset target"))                      traj.SetTarget();                  GUI.enabled = true;                    GUILayout.BeginHorizontal();                  var patch = traj.patches.LastOrDefault();                  GUI.enabled = (patch != null && patch.impactPosition.HasValue);                  if (GUILayout.Button("Set current impact"' GUILayout.Width(150)))                  {                      traj.SetTarget(patch.startingState.referenceBody' patch.impactPosition);                  }                  GUI.enabled = true;                  if (GUILayout.Button("Set KSC"' GUILayout.Width(70)))                  {                      var body = FlightGlobals.Bodies.SingleOrDefault(b => b.isHomeWorld);                      if (body != null)                      {                          Vector3d worldPos = body.GetWorldSurfacePosition(-0.04860002' -74.72425635' 2.0);                          traj.SetTarget(body' worldPos - body.position);                      }                  }                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                    Vessel targetVessel = FlightGlobals.fetch.VesselTarget?.GetVessel();                  GUI.enabled = (patch != null && targetVessel != null && targetVessel.Landed                  // && targetVessel.lastBody == patch.startingState.referenceBody                  );                  if (GUILayout.Button("Target vessel"))                  {                      traj.SetTarget(targetVessel.lastBody' targetVessel.GetWorldPos3D() - targetVessel.lastBody.position);                      ScreenMessages.PostScreenMessage("Targeting vessel " + targetVessel.GetName());                  }                    FinePrint.Waypoint navigationWaypoint = FlightGlobals.ActiveVessel?.navigationWaypoint;                  GUI.enabled = (navigationWaypoint != null);                  if (GUILayout.Button("Active waypoint"))                  {                      traj.SetTarget(navigationWaypoint.celestialBody'                          navigationWaypoint.celestialBody.GetRelSurfacePosition(navigationWaypoint.latitude' navigationWaypoint.longitude' navigationWaypoint.altitude));                      ScreenMessages.PostScreenMessage("Targeting waypoint " + navigationWaypoint.name);                  }                  GUILayout.EndHorizontal();                    GUI.enabled = true;                    GUILayout.BeginHorizontal();                  coords = GUILayout.TextField(coords' GUILayout.Width(170));                  if (GUILayout.Button(new GUIContent("Set"'                          "Enter target latitude and longitude' separated by a comma' in decimal format (with a dot for decimal separator)")'                          GUILayout.Width(50)))                  {                      string[] latLng = coords.Split(new char[] { '''' ';' });                      var body = FlightGlobals.currentMainBody;                      if (latLng.Length == 2 && body != null)                      {                          double lat;                          double lng;                          if (double.TryParse(latLng[0].Trim()' out lat) && double.TryParse(latLng[1].Trim()' out lng))                          {                              Vector3d relPos = body.GetWorldSurfacePosition(lat' lng' 2.0) - body.position;                              double altitude = Trajectory.GetGroundAltitude(body' relPos) + body.Radius;                              traj.SetTarget(body' relPos * (altitude / relPos.magnitude));                          }                      }                  }                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplayTargetGUI = ToggleGroup(Settings.fetch.DisplayTargetGUI' "Target"))              {                  GUI.enabled = traj.targetPosition.HasValue;                    GUILayout.Label(guistring_targetDistance);                    if (GUILayout.Button("Unset target"))                      traj.SetTarget();                  GUI.enabled = true;                    GUILayout.BeginHorizontal();                  var patch = traj.patches.LastOrDefault();                  GUI.enabled = (patch != null && patch.impactPosition.HasValue);                  if (GUILayout.Button("Set current impact"' GUILayout.Width(150)))                  {                      traj.SetTarget(patch.startingState.referenceBody' patch.impactPosition);                  }                  GUI.enabled = true;                  if (GUILayout.Button("Set KSC"' GUILayout.Width(70)))                  {                      var body = FlightGlobals.Bodies.SingleOrDefault(b => b.isHomeWorld);                      if (body != null)                      {                          Vector3d worldPos = body.GetWorldSurfacePosition(-0.04860002' -74.72425635' 2.0);                          traj.SetTarget(body' worldPos - body.position);                      }                  }                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                    Vessel targetVessel = FlightGlobals.fetch.VesselTarget?.GetVessel();                  GUI.enabled = (patch != null && targetVessel != null && targetVessel.Landed                  // && targetVessel.lastBody == patch.startingState.referenceBody                  );                  if (GUILayout.Button("Target vessel"))                  {                      traj.SetTarget(targetVessel.lastBody' targetVessel.GetWorldPos3D() - targetVessel.lastBody.position);                      ScreenMessages.PostScreenMessage("Targeting vessel " + targetVessel.GetName());                  }                    FinePrint.Waypoint navigationWaypoint = FlightGlobals.ActiveVessel?.navigationWaypoint;                  GUI.enabled = (navigationWaypoint != null);                  if (GUILayout.Button("Active waypoint"))                  {                      traj.SetTarget(navigationWaypoint.celestialBody'                          navigationWaypoint.celestialBody.GetRelSurfacePosition(navigationWaypoint.latitude' navigationWaypoint.longitude' navigationWaypoint.altitude));                      ScreenMessages.PostScreenMessage("Targeting waypoint " + navigationWaypoint.name);                  }                  GUILayout.EndHorizontal();                    GUI.enabled = true;                    GUILayout.BeginHorizontal();                  coords = GUILayout.TextField(coords' GUILayout.Width(170));                  if (GUILayout.Button(new GUIContent("Set"'                          "Enter target latitude and longitude' separated by a comma' in decimal format (with a dot for decimal separator)")'                          GUILayout.Width(50)))                  {                      string[] latLng = coords.Split(new char[] { '''' ';' });                      var body = FlightGlobals.currentMainBody;                      if (latLng.Length == 2 && body != null)                      {                          double lat;                          double lng;                          if (double.TryParse(latLng[0].Trim()' out lat) && double.TryParse(latLng[1].Trim()' out lng))                          {                              Vector3d relPos = body.GetWorldSurfacePosition(lat' lng' 2.0) - body.position;                              double altitude = Trajectory.GetGroundAltitude(body' relPos) + body.Radius;                              traj.SetTarget(body' relPos * (altitude / relPos.magnitude));                          }                      }                  }                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplayTargetGUI = ToggleGroup(Settings.fetch.DisplayTargetGUI' "Target"))              {                  GUI.enabled = traj.targetPosition.HasValue;                    GUILayout.Label(guistring_targetDistance);                    if (GUILayout.Button("Unset target"))                      traj.SetTarget();                  GUI.enabled = true;                    GUILayout.BeginHorizontal();                  var patch = traj.patches.LastOrDefault();                  GUI.enabled = (patch != null && patch.impactPosition.HasValue);                  if (GUILayout.Button("Set current impact"' GUILayout.Width(150)))                  {                      traj.SetTarget(patch.startingState.referenceBody' patch.impactPosition);                  }                  GUI.enabled = true;                  if (GUILayout.Button("Set KSC"' GUILayout.Width(70)))                  {                      var body = FlightGlobals.Bodies.SingleOrDefault(b => b.isHomeWorld);                      if (body != null)                      {                          Vector3d worldPos = body.GetWorldSurfacePosition(-0.04860002' -74.72425635' 2.0);                          traj.SetTarget(body' worldPos - body.position);                      }                  }                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                    Vessel targetVessel = FlightGlobals.fetch.VesselTarget?.GetVessel();                  GUI.enabled = (patch != null && targetVessel != null && targetVessel.Landed                  // && targetVessel.lastBody == patch.startingState.referenceBody                  );                  if (GUILayout.Button("Target vessel"))                  {                      traj.SetTarget(targetVessel.lastBody' targetVessel.GetWorldPos3D() - targetVessel.lastBody.position);                      ScreenMessages.PostScreenMessage("Targeting vessel " + targetVessel.GetName());                  }                    FinePrint.Waypoint navigationWaypoint = FlightGlobals.ActiveVessel?.navigationWaypoint;                  GUI.enabled = (navigationWaypoint != null);                  if (GUILayout.Button("Active waypoint"))                  {                      traj.SetTarget(navigationWaypoint.celestialBody'                          navigationWaypoint.celestialBody.GetRelSurfacePosition(navigationWaypoint.latitude' navigationWaypoint.longitude' navigationWaypoint.altitude));                      ScreenMessages.PostScreenMessage("Targeting waypoint " + navigationWaypoint.name);                  }                  GUILayout.EndHorizontal();                    GUI.enabled = true;                    GUILayout.BeginHorizontal();                  coords = GUILayout.TextField(coords' GUILayout.Width(170));                  if (GUILayout.Button(new GUIContent("Set"'                          "Enter target latitude and longitude' separated by a comma' in decimal format (with a dot for decimal separator)")'                          GUILayout.Width(50)))                  {                      string[] latLng = coords.Split(new char[] { '''' ';' });                      var body = FlightGlobals.currentMainBody;                      if (latLng.Length == 2 && body != null)                      {                          double lat;                          double lng;                          if (double.TryParse(latLng[0].Trim()' out lat) && double.TryParse(latLng[1].Trim()' out lng))                          {                              Vector3d relPos = body.GetWorldSurfacePosition(lat' lng' 2.0) - body.position;                              double altitude = Trajectory.GetGroundAltitude(body' relPos) + body.Radius;                              traj.SetTarget(body' relPos * (altitude / relPos.magnitude));                          }                      }                  }                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplayTargetGUI = ToggleGroup(Settings.fetch.DisplayTargetGUI' "Target"))              {                  GUI.enabled = traj.targetPosition.HasValue;                    GUILayout.Label(guistring_targetDistance);                    if (GUILayout.Button("Unset target"))                      traj.SetTarget();                  GUI.enabled = true;                    GUILayout.BeginHorizontal();                  var patch = traj.patches.LastOrDefault();                  GUI.enabled = (patch != null && patch.impactPosition.HasValue);                  if (GUILayout.Button("Set current impact"' GUILayout.Width(150)))                  {                      traj.SetTarget(patch.startingState.referenceBody' patch.impactPosition);                  }                  GUI.enabled = true;                  if (GUILayout.Button("Set KSC"' GUILayout.Width(70)))                  {                      var body = FlightGlobals.Bodies.SingleOrDefault(b => b.isHomeWorld);                      if (body != null)                      {                          Vector3d worldPos = body.GetWorldSurfacePosition(-0.04860002' -74.72425635' 2.0);                          traj.SetTarget(body' worldPos - body.position);                      }                  }                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                    Vessel targetVessel = FlightGlobals.fetch.VesselTarget?.GetVessel();                  GUI.enabled = (patch != null && targetVessel != null && targetVessel.Landed                  // && targetVessel.lastBody == patch.startingState.referenceBody                  );                  if (GUILayout.Button("Target vessel"))                  {                      traj.SetTarget(targetVessel.lastBody' targetVessel.GetWorldPos3D() - targetVessel.lastBody.position);                      ScreenMessages.PostScreenMessage("Targeting vessel " + targetVessel.GetName());                  }                    FinePrint.Waypoint navigationWaypoint = FlightGlobals.ActiveVessel?.navigationWaypoint;                  GUI.enabled = (navigationWaypoint != null);                  if (GUILayout.Button("Active waypoint"))                  {                      traj.SetTarget(navigationWaypoint.celestialBody'                          navigationWaypoint.celestialBody.GetRelSurfacePosition(navigationWaypoint.latitude' navigationWaypoint.longitude' navigationWaypoint.altitude));                      ScreenMessages.PostScreenMessage("Targeting waypoint " + navigationWaypoint.name);                  }                  GUILayout.EndHorizontal();                    GUI.enabled = true;                    GUILayout.BeginHorizontal();                  coords = GUILayout.TextField(coords' GUILayout.Width(170));                  if (GUILayout.Button(new GUIContent("Set"'                          "Enter target latitude and longitude' separated by a comma' in decimal format (with a dot for decimal separator)")'                          GUILayout.Width(50)))                  {                      string[] latLng = coords.Split(new char[] { '''' ';' });                      var body = FlightGlobals.currentMainBody;                      if (latLng.Length == 2 && body != null)                      {                          double lat;                          double lng;                          if (double.TryParse(latLng[0].Trim()' out lat) && double.TryParse(latLng[1].Trim()' out lng))                          {                              Vector3d relPos = body.GetWorldSurfacePosition(lat' lng' 2.0) - body.position;                              double altitude = Trajectory.GetGroundAltitude(body' relPos) + body.Radius;                              traj.SetTarget(body' relPos * (altitude / relPos.magnitude));                          }                      }                  }                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplayTargetGUI = ToggleGroup(Settings.fetch.DisplayTargetGUI' "Target"))              {                  GUI.enabled = traj.targetPosition.HasValue;                    GUILayout.Label(guistring_targetDistance);                    if (GUILayout.Button("Unset target"))                      traj.SetTarget();                  GUI.enabled = true;                    GUILayout.BeginHorizontal();                  var patch = traj.patches.LastOrDefault();                  GUI.enabled = (patch != null && patch.impactPosition.HasValue);                  if (GUILayout.Button("Set current impact"' GUILayout.Width(150)))                  {                      traj.SetTarget(patch.startingState.referenceBody' patch.impactPosition);                  }                  GUI.enabled = true;                  if (GUILayout.Button("Set KSC"' GUILayout.Width(70)))                  {                      var body = FlightGlobals.Bodies.SingleOrDefault(b => b.isHomeWorld);                      if (body != null)                      {                          Vector3d worldPos = body.GetWorldSurfacePosition(-0.04860002' -74.72425635' 2.0);                          traj.SetTarget(body' worldPos - body.position);                      }                  }                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                    Vessel targetVessel = FlightGlobals.fetch.VesselTarget?.GetVessel();                  GUI.enabled = (patch != null && targetVessel != null && targetVessel.Landed                  // && targetVessel.lastBody == patch.startingState.referenceBody                  );                  if (GUILayout.Button("Target vessel"))                  {                      traj.SetTarget(targetVessel.lastBody' targetVessel.GetWorldPos3D() - targetVessel.lastBody.position);                      ScreenMessages.PostScreenMessage("Targeting vessel " + targetVessel.GetName());                  }                    FinePrint.Waypoint navigationWaypoint = FlightGlobals.ActiveVessel?.navigationWaypoint;                  GUI.enabled = (navigationWaypoint != null);                  if (GUILayout.Button("Active waypoint"))                  {                      traj.SetTarget(navigationWaypoint.celestialBody'                          navigationWaypoint.celestialBody.GetRelSurfacePosition(navigationWaypoint.latitude' navigationWaypoint.longitude' navigationWaypoint.altitude));                      ScreenMessages.PostScreenMessage("Targeting waypoint " + navigationWaypoint.name);                  }                  GUILayout.EndHorizontal();                    GUI.enabled = true;                    GUILayout.BeginHorizontal();                  coords = GUILayout.TextField(coords' GUILayout.Width(170));                  if (GUILayout.Button(new GUIContent("Set"'                          "Enter target latitude and longitude' separated by a comma' in decimal format (with a dot for decimal separator)")'                          GUILayout.Width(50)))                  {                      string[] latLng = coords.Split(new char[] { '''' ';' });                      var body = FlightGlobals.currentMainBody;                      if (latLng.Length == 2 && body != null)                      {                          double lat;                          double lng;                          if (double.TryParse(latLng[0].Trim()' out lat) && double.TryParse(latLng[1].Trim()' out lng))                          {                              Vector3d relPos = body.GetWorldSurfacePosition(lat' lng' 2.0) - body.position;                              double altitude = Trajectory.GetGroundAltitude(body' relPos) + body.Radius;                              traj.SetTarget(body' relPos * (altitude / relPos.magnitude));                          }                      }                  }                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: GUILayout.Space(10);
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: bool descentProfileGroup = Settings.fetch.DisplayDescentProfileGUI = ToggleGroup(Settings.fetch.DisplayDescentProfileGUI' "Descent profile"' 120);
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: GUILayout.Space(10);
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplaySettingsGUI = ToggleGroup(Settings.fetch.DisplaySettingsGUI' "Settings"))              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("Max patches"' GUILayout.Width(100));                  Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxPatchCount.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  GUILayout.Label("Max frames per patch"' GUILayout.Width(100));                  Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxFramesPerPatch.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update."));                  if (GUILayout.Button("Update now"))                      traj.InvalidateAerodynamicModel();                  GUILayout.EndHorizontal();                    if (ToolbarManager.ToolbarAvailable)                  {                      Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart"));                  }                    if (FlightGlobals.ActiveVessel != null)                  {                      GUILayout.Label("Position:");                      GUILayout.BeginHorizontal();                      GUILayout.Label("lat=" + guistring_Latitude' GUILayout.Width(110));                      GUILayout.Label("lng=" + guistring_Longitude' GUILayout.Width(110));                      GUILayout.EndHorizontal();                  }                    GUILayout.Label("Aerodynamic model: " + traj.AerodynamicModelName);                  GUILayout.BeginHorizontal();                  GUILayout.Label(String.Format("Perf: {0'5:F1}ms ({1'4:F1})%"'                          traj.ComputationTime * 1000.0f'                          traj.ComputationTime / traj.GameFrameTime * 100.0f                      )' GUILayout.Width(130));                  GUILayout.Label(traj.ErrorCount + " error(s)"' GUILayout.Width(80));                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplaySettingsGUI = ToggleGroup(Settings.fetch.DisplaySettingsGUI' "Settings"))              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("Max patches"' GUILayout.Width(100));                  Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxPatchCount.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  GUILayout.Label("Max frames per patch"' GUILayout.Width(100));                  Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxFramesPerPatch.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update."));                  if (GUILayout.Button("Update now"))                      traj.InvalidateAerodynamicModel();                  GUILayout.EndHorizontal();                    if (ToolbarManager.ToolbarAvailable)                  {                      Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart"));                  }                    if (FlightGlobals.ActiveVessel != null)                  {                      GUILayout.Label("Position:");                      GUILayout.BeginHorizontal();                      GUILayout.Label("lat=" + guistring_Latitude' GUILayout.Width(110));                      GUILayout.Label("lng=" + guistring_Longitude' GUILayout.Width(110));                      GUILayout.EndHorizontal();                  }                    GUILayout.Label("Aerodynamic model: " + traj.AerodynamicModelName);                  GUILayout.BeginHorizontal();                  GUILayout.Label(String.Format("Perf: {0'5:F1}ms ({1'4:F1})%"'                          traj.ComputationTime * 1000.0f'                          traj.ComputationTime / traj.GameFrameTime * 100.0f                      )' GUILayout.Width(130));                  GUILayout.Label(traj.ErrorCount + " error(s)"' GUILayout.Width(80));                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplaySettingsGUI = ToggleGroup(Settings.fetch.DisplaySettingsGUI' "Settings"))              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("Max patches"' GUILayout.Width(100));                  Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxPatchCount.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  GUILayout.Label("Max frames per patch"' GUILayout.Width(100));                  Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxFramesPerPatch.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update."));                  if (GUILayout.Button("Update now"))                      traj.InvalidateAerodynamicModel();                  GUILayout.EndHorizontal();                    if (ToolbarManager.ToolbarAvailable)                  {                      Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart"));                  }                    if (FlightGlobals.ActiveVessel != null)                  {                      GUILayout.Label("Position:");                      GUILayout.BeginHorizontal();                      GUILayout.Label("lat=" + guistring_Latitude' GUILayout.Width(110));                      GUILayout.Label("lng=" + guistring_Longitude' GUILayout.Width(110));                      GUILayout.EndHorizontal();                  }                    GUILayout.Label("Aerodynamic model: " + traj.AerodynamicModelName);                  GUILayout.BeginHorizontal();                  GUILayout.Label(String.Format("Perf: {0'5:F1}ms ({1'4:F1})%"'                          traj.ComputationTime * 1000.0f'                          traj.ComputationTime / traj.GameFrameTime * 100.0f                      )' GUILayout.Width(130));                  GUILayout.Label(traj.ErrorCount + " error(s)"' GUILayout.Width(80));                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplaySettingsGUI = ToggleGroup(Settings.fetch.DisplaySettingsGUI' "Settings"))              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("Max patches"' GUILayout.Width(100));                  Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxPatchCount.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  GUILayout.Label("Max frames per patch"' GUILayout.Width(100));                  Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxFramesPerPatch.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update."));                  if (GUILayout.Button("Update now"))                      traj.InvalidateAerodynamicModel();                  GUILayout.EndHorizontal();                    if (ToolbarManager.ToolbarAvailable)                  {                      Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart"));                  }                    if (FlightGlobals.ActiveVessel != null)                  {                      GUILayout.Label("Position:");                      GUILayout.BeginHorizontal();                      GUILayout.Label("lat=" + guistring_Latitude' GUILayout.Width(110));                      GUILayout.Label("lng=" + guistring_Longitude' GUILayout.Width(110));                      GUILayout.EndHorizontal();                  }                    GUILayout.Label("Aerodynamic model: " + traj.AerodynamicModelName);                  GUILayout.BeginHorizontal();                  GUILayout.Label(String.Format("Perf: {0'5:F1}ms ({1'4:F1})%"'                          traj.ComputationTime * 1000.0f'                          traj.ComputationTime / traj.GameFrameTime * 100.0f                      )' GUILayout.Width(130));                  GUILayout.Label(traj.ErrorCount + " error(s)"' GUILayout.Width(80));                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplaySettingsGUI = ToggleGroup(Settings.fetch.DisplaySettingsGUI' "Settings"))              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("Max patches"' GUILayout.Width(100));                  Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxPatchCount.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  GUILayout.Label("Max frames per patch"' GUILayout.Width(100));                  Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxFramesPerPatch.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update."));                  if (GUILayout.Button("Update now"))                      traj.InvalidateAerodynamicModel();                  GUILayout.EndHorizontal();                    if (ToolbarManager.ToolbarAvailable)                  {                      Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart"));                  }                    if (FlightGlobals.ActiveVessel != null)                  {                      GUILayout.Label("Position:");                      GUILayout.BeginHorizontal();                      GUILayout.Label("lat=" + guistring_Latitude' GUILayout.Width(110));                      GUILayout.Label("lng=" + guistring_Longitude' GUILayout.Width(110));                      GUILayout.EndHorizontal();                  }                    GUILayout.Label("Aerodynamic model: " + traj.AerodynamicModelName);                  GUILayout.BeginHorizontal();                  GUILayout.Label(String.Format("Perf: {0'5:F1}ms ({1'4:F1})%"'                          traj.ComputationTime * 1000.0f'                          traj.ComputationTime / traj.GameFrameTime * 100.0f                      )' GUILayout.Width(130));                  GUILayout.Label(traj.ErrorCount + " error(s)"' GUILayout.Width(80));                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplaySettingsGUI = ToggleGroup(Settings.fetch.DisplaySettingsGUI' "Settings"))              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("Max patches"' GUILayout.Width(100));                  Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxPatchCount.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  GUILayout.Label("Max frames per patch"' GUILayout.Width(100));                  Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxFramesPerPatch.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update."));                  if (GUILayout.Button("Update now"))                      traj.InvalidateAerodynamicModel();                  GUILayout.EndHorizontal();                    if (ToolbarManager.ToolbarAvailable)                  {                      Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart"));                  }                    if (FlightGlobals.ActiveVessel != null)                  {                      GUILayout.Label("Position:");                      GUILayout.BeginHorizontal();                      GUILayout.Label("lat=" + guistring_Latitude' GUILayout.Width(110));                      GUILayout.Label("lng=" + guistring_Longitude' GUILayout.Width(110));                      GUILayout.EndHorizontal();                  }                    GUILayout.Label("Aerodynamic model: " + traj.AerodynamicModelName);                  GUILayout.BeginHorizontal();                  GUILayout.Label(String.Format("Perf: {0'5:F1}ms ({1'4:F1})%"'                          traj.ComputationTime * 1000.0f'                          traj.ComputationTime / traj.GameFrameTime * 100.0f                      )' GUILayout.Width(130));                  GUILayout.Label(traj.ErrorCount + " error(s)"' GUILayout.Width(80));                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplaySettingsGUI = ToggleGroup(Settings.fetch.DisplaySettingsGUI' "Settings"))              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("Max patches"' GUILayout.Width(100));                  Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxPatchCount.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  GUILayout.Label("Max frames per patch"' GUILayout.Width(100));                  Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxFramesPerPatch.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update."));                  if (GUILayout.Button("Update now"))                      traj.InvalidateAerodynamicModel();                  GUILayout.EndHorizontal();                    if (ToolbarManager.ToolbarAvailable)                  {                      Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart"));                  }                    if (FlightGlobals.ActiveVessel != null)                  {                      GUILayout.Label("Position:");                      GUILayout.BeginHorizontal();                      GUILayout.Label("lat=" + guistring_Latitude' GUILayout.Width(110));                      GUILayout.Label("lng=" + guistring_Longitude' GUILayout.Width(110));                      GUILayout.EndHorizontal();                  }                    GUILayout.Label("Aerodynamic model: " + traj.AerodynamicModelName);                  GUILayout.BeginHorizontal();                  GUILayout.Label(String.Format("Perf: {0'5:F1}ms ({1'4:F1})%"'                          traj.ComputationTime * 1000.0f'                          traj.ComputationTime / traj.GameFrameTime * 100.0f                      )' GUILayout.Width(130));                  GUILayout.Label(traj.ErrorCount + " error(s)"' GUILayout.Width(80));                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplaySettingsGUI = ToggleGroup(Settings.fetch.DisplaySettingsGUI' "Settings"))              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("Max patches"' GUILayout.Width(100));                  Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxPatchCount.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  GUILayout.Label("Max frames per patch"' GUILayout.Width(100));                  Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxFramesPerPatch.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update."));                  if (GUILayout.Button("Update now"))                      traj.InvalidateAerodynamicModel();                  GUILayout.EndHorizontal();                    if (ToolbarManager.ToolbarAvailable)                  {                      Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart"));                  }                    if (FlightGlobals.ActiveVessel != null)                  {                      GUILayout.Label("Position:");                      GUILayout.BeginHorizontal();                      GUILayout.Label("lat=" + guistring_Latitude' GUILayout.Width(110));                      GUILayout.Label("lng=" + guistring_Longitude' GUILayout.Width(110));                      GUILayout.EndHorizontal();                  }                    GUILayout.Label("Aerodynamic model: " + traj.AerodynamicModelName);                  GUILayout.BeginHorizontal();                  GUILayout.Label(String.Format("Perf: {0'5:F1}ms ({1'4:F1})%"'                          traj.ComputationTime * 1000.0f'                          traj.ComputationTime / traj.GameFrameTime * 100.0f                      )' GUILayout.Width(130));                  GUILayout.Label(traj.ErrorCount + " error(s)"' GUILayout.Width(80));                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplaySettingsGUI = ToggleGroup(Settings.fetch.DisplaySettingsGUI' "Settings"))              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("Max patches"' GUILayout.Width(100));                  Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxPatchCount.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  GUILayout.Label("Max frames per patch"' GUILayout.Width(100));                  Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxFramesPerPatch.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update."));                  if (GUILayout.Button("Update now"))                      traj.InvalidateAerodynamicModel();                  GUILayout.EndHorizontal();                    if (ToolbarManager.ToolbarAvailable)                  {                      Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart"));                  }                    if (FlightGlobals.ActiveVessel != null)                  {                      GUILayout.Label("Position:");                      GUILayout.BeginHorizontal();                      GUILayout.Label("lat=" + guistring_Latitude' GUILayout.Width(110));                      GUILayout.Label("lng=" + guistring_Longitude' GUILayout.Width(110));                      GUILayout.EndHorizontal();                  }                    GUILayout.Label("Aerodynamic model: " + traj.AerodynamicModelName);                  GUILayout.BeginHorizontal();                  GUILayout.Label(String.Format("Perf: {0'5:F1}ms ({1'4:F1})%"'                          traj.ComputationTime * 1000.0f'                          traj.ComputationTime / traj.GameFrameTime * 100.0f                      )' GUILayout.Width(130));                  GUILayout.Label(traj.ErrorCount + " error(s)"' GUILayout.Width(80));                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplaySettingsGUI = ToggleGroup(Settings.fetch.DisplaySettingsGUI' "Settings"))              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("Max patches"' GUILayout.Width(100));                  Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxPatchCount.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  GUILayout.Label("Max frames per patch"' GUILayout.Width(100));                  Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxFramesPerPatch.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update."));                  if (GUILayout.Button("Update now"))                      traj.InvalidateAerodynamicModel();                  GUILayout.EndHorizontal();                    if (ToolbarManager.ToolbarAvailable)                  {                      Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart"));                  }                    if (FlightGlobals.ActiveVessel != null)                  {                      GUILayout.Label("Position:");                      GUILayout.BeginHorizontal();                      GUILayout.Label("lat=" + guistring_Latitude' GUILayout.Width(110));                      GUILayout.Label("lng=" + guistring_Longitude' GUILayout.Width(110));                      GUILayout.EndHorizontal();                  }                    GUILayout.Label("Aerodynamic model: " + traj.AerodynamicModelName);                  GUILayout.BeginHorizontal();                  GUILayout.Label(String.Format("Perf: {0'5:F1}ms ({1'4:F1})%"'                          traj.ComputationTime * 1000.0f'                          traj.ComputationTime / traj.GameFrameTime * 100.0f                      )' GUILayout.Width(130));                  GUILayout.Label(traj.ErrorCount + " error(s)"' GUILayout.Width(80));                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplaySettingsGUI = ToggleGroup(Settings.fetch.DisplaySettingsGUI' "Settings"))              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("Max patches"' GUILayout.Width(100));                  Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxPatchCount.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  GUILayout.Label("Max frames per patch"' GUILayout.Width(100));                  Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxFramesPerPatch.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update."));                  if (GUILayout.Button("Update now"))                      traj.InvalidateAerodynamicModel();                  GUILayout.EndHorizontal();                    if (ToolbarManager.ToolbarAvailable)                  {                      Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart"));                  }                    if (FlightGlobals.ActiveVessel != null)                  {                      GUILayout.Label("Position:");                      GUILayout.BeginHorizontal();                      GUILayout.Label("lat=" + guistring_Latitude' GUILayout.Width(110));                      GUILayout.Label("lng=" + guistring_Longitude' GUILayout.Width(110));                      GUILayout.EndHorizontal();                  }                    GUILayout.Label("Aerodynamic model: " + traj.AerodynamicModelName);                  GUILayout.BeginHorizontal();                  GUILayout.Label(String.Format("Perf: {0'5:F1}ms ({1'4:F1})%"'                          traj.ComputationTime * 1000.0f'                          traj.ComputationTime / traj.GameFrameTime * 100.0f                      )' GUILayout.Width(130));                  GUILayout.Label(traj.ErrorCount + " error(s)"' GUILayout.Width(80));                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplaySettingsGUI = ToggleGroup(Settings.fetch.DisplaySettingsGUI' "Settings"))              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("Max patches"' GUILayout.Width(100));                  Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxPatchCount.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  GUILayout.Label("Max frames per patch"' GUILayout.Width(100));                  Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxFramesPerPatch.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update."));                  if (GUILayout.Button("Update now"))                      traj.InvalidateAerodynamicModel();                  GUILayout.EndHorizontal();                    if (ToolbarManager.ToolbarAvailable)                  {                      Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart"));                  }                    if (FlightGlobals.ActiveVessel != null)                  {                      GUILayout.Label("Position:");                      GUILayout.BeginHorizontal();                      GUILayout.Label("lat=" + guistring_Latitude' GUILayout.Width(110));                      GUILayout.Label("lng=" + guistring_Longitude' GUILayout.Width(110));                      GUILayout.EndHorizontal();                  }                    GUILayout.Label("Aerodynamic model: " + traj.AerodynamicModelName);                  GUILayout.BeginHorizontal();                  GUILayout.Label(String.Format("Perf: {0'5:F1}ms ({1'4:F1})%"'                          traj.ComputationTime * 1000.0f'                          traj.ComputationTime / traj.GameFrameTime * 100.0f                      )' GUILayout.Width(130));                  GUILayout.Label(traj.ErrorCount + " error(s)"' GUILayout.Width(80));                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplaySettingsGUI = ToggleGroup(Settings.fetch.DisplaySettingsGUI' "Settings"))              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("Max patches"' GUILayout.Width(100));                  Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxPatchCount.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  GUILayout.Label("Max frames per patch"' GUILayout.Width(100));                  Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxFramesPerPatch.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update."));                  if (GUILayout.Button("Update now"))                      traj.InvalidateAerodynamicModel();                  GUILayout.EndHorizontal();                    if (ToolbarManager.ToolbarAvailable)                  {                      Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart"));                  }                    if (FlightGlobals.ActiveVessel != null)                  {                      GUILayout.Label("Position:");                      GUILayout.BeginHorizontal();                      GUILayout.Label("lat=" + guistring_Latitude' GUILayout.Width(110));                      GUILayout.Label("lng=" + guistring_Longitude' GUILayout.Width(110));                      GUILayout.EndHorizontal();                  }                    GUILayout.Label("Aerodynamic model: " + traj.AerodynamicModelName);                  GUILayout.BeginHorizontal();                  GUILayout.Label(String.Format("Perf: {0'5:F1}ms ({1'4:F1})%"'                          traj.ComputationTime * 1000.0f'                          traj.ComputationTime / traj.GameFrameTime * 100.0f                      )' GUILayout.Width(130));                  GUILayout.Label(traj.ErrorCount + " error(s)"' GUILayout.Width(80));                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapGUI,C:\repos\neuoy_KSPTrajectories\Plugin\MapGUI.cs,MainWindow,The following statement contains a magic number: if (Settings.fetch.DisplaySettingsGUI = ToggleGroup(Settings.fetch.DisplaySettingsGUI' "Settings"))              {                  GUILayout.BeginHorizontal();                  GUILayout.Label("Max patches"' GUILayout.Width(100));                  Settings.fetch.MaxPatchCount = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxPatchCount' 3' 10' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxPatchCount.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  GUILayout.Label("Max frames per patch"' GUILayout.Width(100));                  Settings.fetch.MaxFramesPerPatch = Mathf.RoundToInt(GUILayout.HorizontalSlider((float)Settings.fetch.MaxFramesPerPatch' 1' 50' GUILayout.Width(100)));                  GUILayout.Label(Settings.fetch.MaxFramesPerPatch.ToString()' GUILayout.Width(15));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.UseCache = GUILayout.Toggle(Settings.fetch.UseCache' new GUIContent("Use Cache"' "Toggle cache usage. Trajectory will be more precise when cache disabled' but computation time will be higher. It's not recommended to keep it unchecked' unless your CPU can handle the load.")' GUILayout.Width(80));                  GUILayout.EndHorizontal();                    GUILayout.BeginHorizontal();                  Settings.fetch.AutoUpdateAerodynamicModel = GUILayout.Toggle(Settings.fetch.AutoUpdateAerodynamicModel' new GUIContent("Auto update"' "Auto-update of the aerodynamic model. For example if a part is decoupled' the model needs to be updated. This is independent from trajectory update."));                  if (GUILayout.Button("Update now"))                      traj.InvalidateAerodynamicModel();                  GUILayout.EndHorizontal();                    if (ToolbarManager.ToolbarAvailable)                  {                      Settings.fetch.UseBlizzyToolbar = GUILayout.Toggle(Settings.fetch.UseBlizzyToolbar' new GUIContent("Use Blizzy's toolbar"' "Will take effect after restart"));                  }                    if (FlightGlobals.ActiveVessel != null)                  {                      GUILayout.Label("Position:");                      GUILayout.BeginHorizontal();                      GUILayout.Label("lat=" + guistring_Latitude' GUILayout.Width(110));                      GUILayout.Label("lng=" + guistring_Longitude' GUILayout.Width(110));                      GUILayout.EndHorizontal();                  }                    GUILayout.Label("Aerodynamic model: " + traj.AerodynamicModelName);                  GUILayout.BeginHorizontal();                  GUILayout.Label(String.Format("Perf: {0'5:F1}ms ({1'4:F1})%"'                          traj.ComputationTime * 1000.0f'                          traj.ComputationTime / traj.GameFrameTime * 100.0f                      )' GUILayout.Width(130));                  GUILayout.Label(traj.ErrorCount + " error(s)"' GUILayout.Width(80));                  GUILayout.EndHorizontal();              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,GetMesh,The following statement contains a magic number: if (obj == null)              {                  //ScreenMessages.PostScreenMessage("adding trajectory mesh " + meshes.Count);                    var newMesh = new GameObject();                  newMesh.AddComponent<MeshFilter>();                  var renderer = newMesh.AddComponent<MeshRenderer>();                  renderer.enabled = displayEnabled;                  //renderer.castShadows = false;                  renderer.receiveShadows = false;                  newMesh.layer = 31;                    meshes.Add(newMesh);                    obj = newMesh;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,refreshMesh,The following statement contains a magic number: foreach (var patch in Trajectory.fetch.patches)              {                  if (patch.startingState.stockPatch != null && !Settings.fetch.BodyFixedMode && !Settings.fetch.DisplayCompleteTrajectory)                      continue;                    if (patch.isAtmospheric && patch.atmosphericTrajectory.Length < 2)                      continue;                    var obj = GetMesh(patch.startingState.referenceBody' lineMaterial);                  var mesh = obj.GetComponent<MeshFilter>().mesh;                    if (patch.isAtmospheric)                  {                      initMeshFromTrajectory(patch.startingState.referenceBody.position' mesh' patch.atmosphericTrajectory' Color.red);                  }                  else                  {                      initMeshFromOrbit(patch.startingState.referenceBody.position' mesh' patch.spaceOrbit' patch.startingState.time' patch.endTime - patch.startingState.time' Color.white);                  }                    if (patch.impactPosition.HasValue)                  {                      obj = GetMesh(patch.startingState.referenceBody' lineMaterial);                      mesh = obj.GetComponent<MeshFilter>().mesh;                      initMeshFromImpact(patch.startingState.referenceBody' mesh' patch.impactPosition.Value' Color.red);                  }              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,MakeRibbonEdge,The following statement contains a magic number: if (!MapView.Draw3DLines)              {                  var dist = Screen.height / 2 + 0.01f;                  start.z = start.z >= 0.15f ? dist : -dist;                  end.z = end.z >= 0.15f ? dist : -dist;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,MakeRibbonEdge,The following statement contains a magic number: if (!MapView.Draw3DLines && (start.z > 0) != (end.z > 0))              {                  vertices[startIndex + 0] = vertices[startIndex + 1];                  if (startIndex >= 2)                      vertices[startIndex - 2] = vertices[startIndex - 1];              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,MakeRibbonEdge,The following statement contains a magic number: if (!MapView.Draw3DLines && (start.z > 0) != (end.z > 0))              {                  vertices[startIndex + 0] = vertices[startIndex + 1];                  if (startIndex >= 2)                      vertices[startIndex - 2] = vertices[startIndex - 1];              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: int steps = 128;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: double[] stepUT = new double[steps * 4];
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: double maxDTA = 2.0 * Math.PI / (double)steps;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: while(true)              {                  double time = prevTime + maxDT;                  for (int count = 0; count < 100; ++count)                  {                      if (count == 99)                          Debug.Log("WARNING: infinite loop? (Trajectories.MapOverlay.initMeshFromOrbit)");                      double ta = orbit.TrueAnomalyAtUT(time);                      while (ta < prevTA)                          ta += 2.0 * Math.PI;                      if (ta - prevTA <= maxDTA)                      {                          prevTA = ta;                          break;                      }                      time = (prevTime + time) * 0.5;                  }                    if (time > startTime + duration - (time-prevTime) * 0.5)                      break;                    prevTime = time;                    stepUT[utIdx++] = time;                  if (utIdx >= stepUT.Length - 1)                  {                      //Util.PostSingleScreenMessage("ut overflow"' "ut overflow");                      break; // this should never happen' but better stop than overflow if it does                  }              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: while(true)              {                  double time = prevTime + maxDT;                  for (int count = 0; count < 100; ++count)                  {                      if (count == 99)                          Debug.Log("WARNING: infinite loop? (Trajectories.MapOverlay.initMeshFromOrbit)");                      double ta = orbit.TrueAnomalyAtUT(time);                      while (ta < prevTA)                          ta += 2.0 * Math.PI;                      if (ta - prevTA <= maxDTA)                      {                          prevTA = ta;                          break;                      }                      time = (prevTime + time) * 0.5;                  }                    if (time > startTime + duration - (time-prevTime) * 0.5)                      break;                    prevTime = time;                    stepUT[utIdx++] = time;                  if (utIdx >= stepUT.Length - 1)                  {                      //Util.PostSingleScreenMessage("ut overflow"' "ut overflow");                      break; // this should never happen' but better stop than overflow if it does                  }              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: while(true)              {                  double time = prevTime + maxDT;                  for (int count = 0; count < 100; ++count)                  {                      if (count == 99)                          Debug.Log("WARNING: infinite loop? (Trajectories.MapOverlay.initMeshFromOrbit)");                      double ta = orbit.TrueAnomalyAtUT(time);                      while (ta < prevTA)                          ta += 2.0 * Math.PI;                      if (ta - prevTA <= maxDTA)                      {                          prevTA = ta;                          break;                      }                      time = (prevTime + time) * 0.5;                  }                    if (time > startTime + duration - (time-prevTime) * 0.5)                      break;                    prevTime = time;                    stepUT[utIdx++] = time;                  if (utIdx >= stepUT.Length - 1)                  {                      //Util.PostSingleScreenMessage("ut overflow"' "ut overflow");                      break; // this should never happen' but better stop than overflow if it does                  }              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: while(true)              {                  double time = prevTime + maxDT;                  for (int count = 0; count < 100; ++count)                  {                      if (count == 99)                          Debug.Log("WARNING: infinite loop? (Trajectories.MapOverlay.initMeshFromOrbit)");                      double ta = orbit.TrueAnomalyAtUT(time);                      while (ta < prevTA)                          ta += 2.0 * Math.PI;                      if (ta - prevTA <= maxDTA)                      {                          prevTA = ta;                          break;                      }                      time = (prevTime + time) * 0.5;                  }                    if (time > startTime + duration - (time-prevTime) * 0.5)                      break;                    prevTime = time;                    stepUT[utIdx++] = time;                  if (utIdx >= stepUT.Length - 1)                  {                      //Util.PostSingleScreenMessage("ut overflow"' "ut overflow");                      break; // this should never happen' but better stop than overflow if it does                  }              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: while(true)              {                  double time = prevTime + maxDT;                  for (int count = 0; count < 100; ++count)                  {                      if (count == 99)                          Debug.Log("WARNING: infinite loop? (Trajectories.MapOverlay.initMeshFromOrbit)");                      double ta = orbit.TrueAnomalyAtUT(time);                      while (ta < prevTA)                          ta += 2.0 * Math.PI;                      if (ta - prevTA <= maxDTA)                      {                          prevTA = ta;                          break;                      }                      time = (prevTime + time) * 0.5;                  }                    if (time > startTime + duration - (time-prevTime) * 0.5)                      break;                    prevTime = time;                    stepUT[utIdx++] = time;                  if (utIdx >= stepUT.Length - 1)                  {                      //Util.PostSingleScreenMessage("ut overflow"' "ut overflow");                      break; // this should never happen' but better stop than overflow if it does                  }              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: var vertices = new Vector3[utIdx * 2 + 2];
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: var vertices = new Vector3[utIdx * 2 + 2];
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: var uvs = new Vector2[utIdx * 2 + 2];
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: var uvs = new Vector2[utIdx * 2 + 2];
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: var triangles = new int[utIdx * 6];
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: for(int i = 0; i < utIdx; ++i)              {                  double time = stepUT[i];                    Vector3 curMeshPos = Util.SwapYZ(orbit.getRelativePositionAtUT(time));                  if (Settings.fetch.BodyFixedMode) {                      curMeshPos = Trajectory.calculateRotatedPosition(orbit.referenceBody' curMeshPos' time);                  }                  curMeshPos += bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: for(int i = 0; i < utIdx; ++i)              {                  double time = stepUT[i];                    Vector3 curMeshPos = Util.SwapYZ(orbit.getRelativePositionAtUT(time));                  if (Settings.fetch.BodyFixedMode) {                      curMeshPos = Trajectory.calculateRotatedPosition(orbit.referenceBody' curMeshPos' time);                  }                  curMeshPos += bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: for(int i = 0; i < utIdx; ++i)              {                  double time = stepUT[i];                    Vector3 curMeshPos = Util.SwapYZ(orbit.getRelativePositionAtUT(time));                  if (Settings.fetch.BodyFixedMode) {                      curMeshPos = Trajectory.calculateRotatedPosition(orbit.referenceBody' curMeshPos' time);                  }                  curMeshPos += bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: for(int i = 0; i < utIdx; ++i)              {                  double time = stepUT[i];                    Vector3 curMeshPos = Util.SwapYZ(orbit.getRelativePositionAtUT(time));                  if (Settings.fetch.BodyFixedMode) {                      curMeshPos = Trajectory.calculateRotatedPosition(orbit.referenceBody' curMeshPos' time);                  }                  curMeshPos += bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: for(int i = 0; i < utIdx; ++i)              {                  double time = stepUT[i];                    Vector3 curMeshPos = Util.SwapYZ(orbit.getRelativePositionAtUT(time));                  if (Settings.fetch.BodyFixedMode) {                      curMeshPos = Trajectory.calculateRotatedPosition(orbit.referenceBody' curMeshPos' time);                  }                  curMeshPos += bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: for(int i = 0; i < utIdx; ++i)              {                  double time = stepUT[i];                    Vector3 curMeshPos = Util.SwapYZ(orbit.getRelativePositionAtUT(time));                  if (Settings.fetch.BodyFixedMode) {                      curMeshPos = Trajectory.calculateRotatedPosition(orbit.referenceBody' curMeshPos' time);                  }                  curMeshPos += bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: for(int i = 0; i < utIdx; ++i)              {                  double time = stepUT[i];                    Vector3 curMeshPos = Util.SwapYZ(orbit.getRelativePositionAtUT(time));                  if (Settings.fetch.BodyFixedMode) {                      curMeshPos = Trajectory.calculateRotatedPosition(orbit.referenceBody' curMeshPos' time);                  }                  curMeshPos += bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: for(int i = 0; i < utIdx; ++i)              {                  double time = stepUT[i];                    Vector3 curMeshPos = Util.SwapYZ(orbit.getRelativePositionAtUT(time));                  if (Settings.fetch.BodyFixedMode) {                      curMeshPos = Trajectory.calculateRotatedPosition(orbit.referenceBody' curMeshPos' time);                  }                  curMeshPos += bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: for(int i = 0; i < utIdx; ++i)              {                  double time = stepUT[i];                    Vector3 curMeshPos = Util.SwapYZ(orbit.getRelativePositionAtUT(time));                  if (Settings.fetch.BodyFixedMode) {                      curMeshPos = Trajectory.calculateRotatedPosition(orbit.referenceBody' curMeshPos' time);                  }                  curMeshPos += bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: for(int i = 0; i < utIdx; ++i)              {                  double time = stepUT[i];                    Vector3 curMeshPos = Util.SwapYZ(orbit.getRelativePositionAtUT(time));                  if (Settings.fetch.BodyFixedMode) {                      curMeshPos = Trajectory.calculateRotatedPosition(orbit.referenceBody' curMeshPos' time);                  }                  curMeshPos += bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: for(int i = 0; i < utIdx; ++i)              {                  double time = stepUT[i];                    Vector3 curMeshPos = Util.SwapYZ(orbit.getRelativePositionAtUT(time));                  if (Settings.fetch.BodyFixedMode) {                      curMeshPos = Trajectory.calculateRotatedPosition(orbit.referenceBody' curMeshPos' time);                  }                  curMeshPos += bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: for(int i = 0; i < utIdx; ++i)              {                  double time = stepUT[i];                    Vector3 curMeshPos = Util.SwapYZ(orbit.getRelativePositionAtUT(time));                  if (Settings.fetch.BodyFixedMode) {                      curMeshPos = Trajectory.calculateRotatedPosition(orbit.referenceBody' curMeshPos' time);                  }                  curMeshPos += bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: for(int i = 0; i < utIdx; ++i)              {                  double time = stepUT[i];                    Vector3 curMeshPos = Util.SwapYZ(orbit.getRelativePositionAtUT(time));                  if (Settings.fetch.BodyFixedMode) {                      curMeshPos = Trajectory.calculateRotatedPosition(orbit.referenceBody' curMeshPos' time);                  }                  curMeshPos += bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromOrbit,The following statement contains a magic number: for(int i = 0; i < utIdx; ++i)              {                  double time = stepUT[i];                    Vector3 curMeshPos = Util.SwapYZ(orbit.getRelativePositionAtUT(time));                  if (Settings.fetch.BodyFixedMode) {                      curMeshPos = Trajectory.calculateRotatedPosition(orbit.referenceBody' curMeshPos' time);                  }                  curMeshPos += bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: var vertices = new Vector3[trajectory.Length * 2];
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: var uvs = new Vector2[trajectory.Length * 2];
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: var triangles = new int[(trajectory.Length-1) * 6];
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: for(int i = 0; i < trajectory.Length; ++i)              {                  // the fixed-body rotation transformation has already been applied in AddPatch.                  Vector3 curMeshPos = trajectory[i].pos + bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: for(int i = 0; i < trajectory.Length; ++i)              {                  // the fixed-body rotation transformation has already been applied in AddPatch.                  Vector3 curMeshPos = trajectory[i].pos + bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: for(int i = 0; i < trajectory.Length; ++i)              {                  // the fixed-body rotation transformation has already been applied in AddPatch.                  Vector3 curMeshPos = trajectory[i].pos + bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: for(int i = 0; i < trajectory.Length; ++i)              {                  // the fixed-body rotation transformation has already been applied in AddPatch.                  Vector3 curMeshPos = trajectory[i].pos + bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: for(int i = 0; i < trajectory.Length; ++i)              {                  // the fixed-body rotation transformation has already been applied in AddPatch.                  Vector3 curMeshPos = trajectory[i].pos + bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: for(int i = 0; i < trajectory.Length; ++i)              {                  // the fixed-body rotation transformation has already been applied in AddPatch.                  Vector3 curMeshPos = trajectory[i].pos + bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: for(int i = 0; i < trajectory.Length; ++i)              {                  // the fixed-body rotation transformation has already been applied in AddPatch.                  Vector3 curMeshPos = trajectory[i].pos + bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: for(int i = 0; i < trajectory.Length; ++i)              {                  // the fixed-body rotation transformation has already been applied in AddPatch.                  Vector3 curMeshPos = trajectory[i].pos + bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: for(int i = 0; i < trajectory.Length; ++i)              {                  // the fixed-body rotation transformation has already been applied in AddPatch.                  Vector3 curMeshPos = trajectory[i].pos + bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: for(int i = 0; i < trajectory.Length; ++i)              {                  // the fixed-body rotation transformation has already been applied in AddPatch.                  Vector3 curMeshPos = trajectory[i].pos + bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: for(int i = 0; i < trajectory.Length; ++i)              {                  // the fixed-body rotation transformation has already been applied in AddPatch.                  Vector3 curMeshPos = trajectory[i].pos + bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: for(int i = 0; i < trajectory.Length; ++i)              {                  // the fixed-body rotation transformation has already been applied in AddPatch.                  Vector3 curMeshPos = trajectory[i].pos + bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: for(int i = 0; i < trajectory.Length; ++i)              {                  // the fixed-body rotation transformation has already been applied in AddPatch.                  Vector3 curMeshPos = trajectory[i].pos + bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromTrajectory,The following statement contains a magic number: for(int i = 0; i < trajectory.Length; ++i)              {                  // the fixed-body rotation transformation has already been applied in AddPatch.                  Vector3 curMeshPos = trajectory[i].pos + bodyPosition;                    // add a segment to the trajectory mesh                  MakeRibbonEdge(prevMeshPos' curMeshPos' lineWidth' vertices' i * 2);                  uvs[i * 2 + 0] = new Vector2(0.8f' 0);                  uvs[i * 2 + 1] = new Vector2(0.8f' 1);                    if (i > 0)                  {                      int idx = (i - 1) * 6;                      triangles[idx + 0] = (i - 1) * 2 + 0;                      triangles[idx + 1] = (i - 1) * 2 + 1;                      triangles[idx + 2] = i * 2 + 1;                        triangles[idx + 3] = (i - 1) * 2 + 0;                      triangles[idx + 4] = i * 2 + 1;                      triangles[idx + 5] = i * 2 + 0;                  }                    prevMeshPos = curMeshPos;              }
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: var vertices = new Vector3[8];
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: var uvs = new Vector2[8];
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: var triangles = new int[12];
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: altitude = altitude * 1.0 + 1200;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: vertices[2] = impactPosition + crossV1 * crossSize + crossV2 * crossThickness;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: uvs[2] = new Vector2(0.8f' 1);
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: vertices[3] = impactPosition + crossV1 * crossSize - crossV2 * crossThickness;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: uvs[3] = new Vector2(0.8f' 0);
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[2] = 3;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[2] = 3;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[3] = 0;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[4] = 3;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[4] = 3;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[5] = 2;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[5] = 2;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: vertices[4] = impactPosition - crossV2 * crossSize - crossV1 * crossThickness;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: uvs[4] = new Vector2(0.8f' 0);
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: vertices[5] = impactPosition - crossV2 * crossSize + crossV1 * crossThickness;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: uvs[5] = new Vector2(0.8f' 1);
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: vertices[6] = impactPosition + crossV2 * crossSize - crossV1 * crossThickness;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: uvs[6] = new Vector2(0.8f' 0);
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: vertices[7] = impactPosition + crossV2 * crossSize + crossV1 * crossThickness;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: uvs[7] = new Vector2(0.8f' 1);
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[6] = 4;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[6] = 4;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[7] = 5;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[7] = 5;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[8] = 7;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[8] = 7;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[9] = 4;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[9] = 4;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[10] = 7;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[10] = 7;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[11] = 6;
Magic Number,Trajectories,MapOverlay,C:\repos\neuoy_KSPTrajectories\Plugin\MapOverlay.cs,initMeshFromImpact,The following statement contains a magic number: triangles[11] = 6;
Magic Number,Trajectories,StockAeroUtil,C:\repos\neuoy_KSPTrajectories\Plugin\StockAeroUtil.cs,GetDensity,The following statement contains a magic number: double sunDot = 0.5;
Magic Number,Trajectories,StockAeroUtil,C:\repos\neuoy_KSPTrajectories\Plugin\StockAeroUtil.cs,SimAeroForce,The following statement contains a magic number: double latitude = body.GetLatitude(position) / 180.0 * Math.PI;
Magic Number,Trajectories,StockAeroUtil,C:\repos\neuoy_KSPTrajectories\Plugin\StockAeroUtil.cs,SimAeroForce,The following statement contains a magic number: double dyn_pressure = 0.0005 * rho * v_wrld_vel.sqrMagnitude;
Magic Number,Trajectories,StockAeroUtil,C:\repos\neuoy_KSPTrajectories\Plugin\StockAeroUtil.cs,SimAeroForce,The following statement contains a magic number: if (mach > 25.0) { mach = 25.0; }
Magic Number,Trajectories,StockAeroUtil,C:\repos\neuoy_KSPTrajectories\Plugin\StockAeroUtil.cs,SimAeroForce,The following statement contains a magic number: if (mach > 25.0) { mach = 25.0; }
Magic Number,Trajectories,StockAeroUtil,C:\repos\neuoy_KSPTrajectories\Plugin\StockAeroUtil.cs,SimAeroForce,The following statement contains a magic number: for (int i = 0; i < _vessel.Parts.Count; ++i)              {                  // need checks on shielded components                  Part p = _vessel.Parts[i];                  #if DEBUG                  TrajectoriesDebug partDebug = VesselAerodynamicModel.DebugParts ? p.FindModuleImplementing<TrajectoriesDebug>() : null;                  if (partDebug != null)                  {                      partDebug.Drag = 0;                      partDebug.Lift = 0;                  }                  #endif                    if (p.ShieldedFromAirstream || p.Rigidbody == null)                  {                      continue;                  }                    // Get Drag                  Vector3 sim_dragVectorDir = v_wrld_vel.normalized;                  Vector3 sim_dragVectorDirLocal = -(p.transform.InverseTransformDirection(sim_dragVectorDir));                    Vector3 liftForce = new Vector3(0' 0' 0);                  Vector3d dragForce;                    switch(p.dragModel)                  {                      case Part.DragModel.DEFAULT:                      case Part.DragModel.CUBE:                          DragCubeList cubes = p.DragCubes;                            DragCubeList.CubeData p_drag_data = new DragCubeList.CubeData();                            float drag;                          if (cubes.None) // since 1.0.5' some parts don't have drag cubes (for example fuel lines and struts)                          {                              drag = p.maximum_drag;                          }                          else                          {                              try                              {                                  cubes.AddSurfaceDragDirection(-sim_dragVectorDirLocal' (float)mach' ref p_drag_data);                              }                              catch (Exception)                              {                                  cubes.SetDrag(sim_dragVectorDirLocal' (float)mach);                                  cubes.ForceUpdate(true' true);                                  cubes.AddSurfaceDragDirection(-sim_dragVectorDirLocal' (float)mach' ref p_drag_data);                                  //Debug.Log(String.Format("Trajectories: Caught NRE on Drag Initialization.  Should be fixed now.  {0}"' e));                              }                                float pseudoreynolds = (float)(rho * Mathf.Abs(v_wrld_vel.magnitude));                              float pseudoredragmult = PhysicsGlobals.DragCurvePseudoReynolds.Evaluate(pseudoreynolds);                              drag = p_drag_data.areaDrag * PhysicsGlobals.DragCubeMultiplier * pseudoredragmult;                                liftForce = p_drag_data.liftForce;                          }                            double sim_dragScalar = dyn_pressure * (double)drag * PhysicsGlobals.DragMultiplier;                          dragForce = -(Vector3d)sim_dragVectorDir * sim_dragScalar;                            break;                        case Part.DragModel.SPHERICAL:                          dragForce = -(Vector3d)sim_dragVectorDir * (double)p.maximum_drag;                          break;                        case Part.DragModel.CYLINDRICAL:                          dragForce = -(Vector3d)sim_dragVectorDir * (double)Mathf.Lerp(p.minimum_drag' p.maximum_drag' Mathf.Abs(Vector3.Dot(p.partTransform.TransformDirection(p.dragReferenceVector)' sim_dragVectorDir)));                          break;                        case Part.DragModel.CONIC:                          dragForce = -(Vector3d)sim_dragVectorDir * (double)Mathf.Lerp(p.minimum_drag' p.maximum_drag' Vector3.Angle(p.partTransform.TransformDirection(p.dragReferenceVector)' sim_dragVectorDir) / 180f);                          break;                        default:                          // no drag to apply                          dragForce = new Vector3d();                          break;                  }                    #if DEBUG                  if (partDebug != null)                  {                      partDebug.Drag += (float)dragForce.magnitude;                  }                  #endif                  total_drag += dragForce;                    // If it isn't a wing or lifter' get body lift.                  if (!p.hasLiftModule)                  {                      float simbodyLiftScalar = p.bodyLiftMultiplier * PhysicsGlobals.BodyLiftMultiplier * (float)dyn_pressure;                      simbodyLiftScalar *= PhysicsGlobals.GetLiftingSurfaceCurve("BodyLift").liftMachCurve.Evaluate((float)mach);                      Vector3 bodyLift = p.transform.rotation * (simbodyLiftScalar * liftForce);                      bodyLift = Vector3.ProjectOnPlane(bodyLift' sim_dragVectorDir);                      // Only accumulate forces for non-LiftModules                      total_lift += bodyLift;                  }                    // Find ModuleLifingSurface for wings and liftforce.                  // Should catch control surface as it is a subclass                  for (int j = 0; j < p.Modules.Count; ++j)                  {                      var m = p.Modules[j];                      float mcs_mod;                      if (m is ModuleLiftingSurface)                      {                          mcs_mod = 1.0f;                          double liftQ = dyn_pressure * 1000;                          ModuleLiftingSurface wing = (ModuleLiftingSurface)m;                          Vector3 nVel = Vector3.zero;                          Vector3 liftVector = Vector3.zero;                          float liftdot;                          float absdot;                          wing.SetupCoefficients(v_wrld_vel' out nVel' out liftVector' out liftdot' out absdot);                            double prevMach = p.machNumber;                          p.machNumber = mach;                          Vector3 local_lift = mcs_mod * wing.GetLiftVector(liftVector' liftdot' absdot' liftQ' (float)mach);                          Vector3 local_drag = mcs_mod * wing.GetDragVector(nVel' absdot' liftQ);                          p.machNumber = prevMach;                            total_lift += local_lift;                          total_drag += local_drag;                            #if DEBUG                          if (partDebug != null)                          {                              partDebug.Lift += (float)local_lift.magnitude;                              partDebug.Drag += (float)local_drag.magnitude;                          }                          #endif                      }                  }                }
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,GetGroundAltitude,The following statement contains a magic number: double lat = body.GetLatitude(relativePosition + body.position) / 180.0 * Math.PI;
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,GetGroundAltitude,The following statement contains a magic number: double lon = body.GetLongitude(relativePosition + body.position) / 180.0 * Math.PI;
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,FindOrbitBodyIntersection,The following statement contains a magic number: while (to - from > 0.1)              {                  ++loopCount;                  if (loopCount > 1000)                  {                      UnityEngine.Debug.Log("WARNING: infinite loop? (Trajectories.Trajectory.AddPatch' atmosphere limit search)");                      ++errorCount_;                      break;                  }                  double middle = (from + to) * 0.5;                  if (orbit.getRelativePositionAtUT(middle).magnitude < bodyAltitude)                  {                      to = middle;                  }                  else                  {                      from = middle;                  }              }
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,FindOrbitBodyIntersection,The following statement contains a magic number: while (to - from > 0.1)              {                  ++loopCount;                  if (loopCount > 1000)                  {                      UnityEngine.Debug.Log("WARNING: infinite loop? (Trajectories.Trajectory.AddPatch' atmosphere limit search)");                      ++errorCount_;                      break;                  }                  double middle = (from + to) * 0.5;                  if (orbit.getRelativePositionAtUT(middle).magnitude < bodyAltitude)                  {                      to = middle;                  }                  else                  {                      from = middle;                  }              }
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,FindOrbitBodyIntersection,The following statement contains a magic number: while (to - from > 0.1)              {                  ++loopCount;                  if (loopCount > 1000)                  {                      UnityEngine.Debug.Log("WARNING: infinite loop? (Trajectories.Trajectory.AddPatch' atmosphere limit search)");                      ++errorCount_;                      break;                  }                  double middle = (from + to) * 0.5;                  if (orbit.getRelativePositionAtUT(middle).magnitude < bodyAltitude)                  {                      to = middle;                  }                  else                  {                      from = middle;                  }              }
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,AddPatch,The following statement contains a magic number: if (minAltitude < maxAtmosphereAltitude)              {                  double entryTime;                  if (startingState.position.magnitude <= body.Radius + maxAtmosphereAltitude)                  {                      // whole orbit is inside the atmosphere                      entryTime = startingState.time;                  }                  else                  {                      entryTime = FindOrbitBodyIntersection(                          patch.spaceOrbit'                          startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                          body.Radius + maxAtmosphereAltitude);                  }                    if (entryTime > startingState.time + 0.1 || !body.atmosphere)                  {                      if (body.atmosphere)                      {                          // add the space patch before atmospheric entry                            patch.endTime = entryTime;                          patchesBackBuffer_.Add(patch);                          AddPatch_outState = new VesselState                          {                              position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime))'                              referenceBody = body'                              time = entryTime'                              velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime))                          };                          yield break;                      }                      else                      {                          // the body has no atmosphere' so what we actually computed is the entry                          // inside the "ground sphere" (defined by the maximal ground altitude)                          // now we iterate until the inner ground sphere (minimal altitude)' and                          // check if we hit the ground along the way                          double groundRangeExit = FindOrbitBodyIntersection(                              patch.spaceOrbit'                              startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                              body.Radius - maxAtmosphereAltitude);                            if (groundRangeExit <= entryTime)                              groundRangeExit = startingState.time + patch.spaceOrbit.timeToPe;                            double iterationSize = (groundRangeExit - entryTime) / 100.0;                          double t;                          bool groundImpact = false;                          for(t = entryTime; t < groundRangeExit; t += iterationSize)                          {                              Vector3d pos = patch.spaceOrbit.getRelativePositionAtUT(t);                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' Util.SwapYZ(pos)' t))                                  + body.Radius;                              if (pos.magnitude < groundAltitude)                              {                                  t -= iterationSize;                                  groundImpact = true;                                  break;                              }                          }                            if (groundImpact)                          {                              patch.endTime = t;                              patch.rawImpactPosition = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(t));                              patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' t);                              patch.impactVelocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(t));                              patchesBackBuffer_.Add(patch);                              AddPatch_outState = null;                              yield break;                          }                          else                          {                              // no impact' just add the space orbit                              patchesBackBuffer_.Add(patch);                              if (nextPatch != null)                              {                                  AddPatch_outState = new VesselState                                  {                                      position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                                      velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                                      referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                                      time = patch.endTime'                                      stockPatch = nextPatch                                  };                                  yield break;                              }                              else                              {                                  AddPatch_outState = null;                                  yield break;                              }                          }                      }                  }                  else                  {                      if (patch.startingState.referenceBody != vessel_.mainBody)                      {                          // currently' we can't handle predictions for another body' so we stop                          AddPatch_outState = null;                          yield break;                      }                        // simulate atmospheric flight (drag and lift)' until impact or atmosphere exit                      // (typically for an aerobraking maneuver) assuming a constant angle of attack                      patch.isAtmospheric = true;                      patch.startingState.stockPatch = null;                        // lower dt would be more accurate' but a tradeoff has to be found between performances and accuracy                      double dt = 0.1;                        // some shallow entries can result in very long flight. For performances reasons'                      // we limit the prediction duration                      int maxIterations = (int)(30.0 * 60.0 / dt);                        int chunkSize = 128;                        // time between two consecutive stored positions (more intermediate positions are computed for better accuracy)'                      // also used for ground collision checks                      double trajectoryInterval = 10.0;                        var buffer = new List<Point[]>();                      buffer.Add(new Point[chunkSize]);                      int nextPosIdx = 0;                        Vector3d pos = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime));                      Vector3d vel = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime));                        //Util.PostSingleScreenMessage("atmo start cond"' "Atmospheric start: vel=" + vel.ToString("0.00") + " (mag=" + vel.magnitude.ToString("0.00") + ")");                        Vector3d prevPos = pos - vel * dt;                      double currentTime = entryTime;                      double lastPositionStoredUT = 0;                      Vector3d lastPositionStored = new Vector3d();                      bool hitGround = false;                      int iteration = 0;                      int incrementIterations = 0;                      int minIterationsPerIncrement = maxIterations / Settings.fetch.MaxFramesPerPatch;                      double accumulatedForces = 0;                      while (true)                      {                          ++iteration;                          ++incrementIterations;                            if (incrementIterations > minIterationsPerIncrement && incrementTime_.ElapsedMilliseconds > MaxIncrementTime)                          {                              yield return false;                              incrementIterations = 0;                          }                            double R = pos.magnitude;                          double altitude = R - body.Radius;                          double atmosphereCoeff = altitude / maxAtmosphereAltitude;                          if (hitGround                              || atmosphereCoeff <= 0.0 || atmosphereCoeff >= 1.0                              || iteration == maxIterations || currentTime > patch.endTime)                          {                              //Util.PostSingleScreenMessage("atmo force"' "Atmospheric accumulated force: " + accumulatedForces.ToString("0.00"));                                if (hitGround || atmosphereCoeff <= 0.0)                              {                                  patch.rawImpactPosition = pos;                                  patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' currentTime);                                  patch.impactVelocity = vel;                              }                                patch.endTime = Math.Min(currentTime' patch.endTime);                                int totalCount = (buffer.Count - 1) * chunkSize + nextPosIdx;                              patch.atmosphericTrajectory = new Point[totalCount];                              int outIdx = 0;                              foreach (var chunk in buffer)                              {                                  foreach (var p in chunk)                                  {                                      if (outIdx == totalCount)                                          break;                                      patch.atmosphericTrajectory[outIdx++] = p;                                  }                              }                                if (iteration == maxIterations)                              {                                  ScreenMessages.PostScreenMessage("WARNING: trajectory prediction stopped' too many iterations");                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else if (atmosphereCoeff <= 0.0 || hitGround)                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = new VesselState                                  {                                      position = pos'                                      velocity = vel'                                      referenceBody = body'                                      time = patch.endTime                                  };                                  yield break;                              }                          }                            Vector3d gravityAccel = pos * (-body.gravParameter / (R * R * R));                            //Util.PostSingleScreenMessage("prediction vel"' "prediction vel = " + vel);                          Vector3d airVelocity = vel - body.getRFrmVel(body.position + pos);                          double angleOfAttack = profile.GetAngleOfAttack(body' pos' airVelocity);                          Vector3d aerodynamicForce = aerodynamicModel_.GetForces(body' pos' airVelocity' angleOfAttack);                          accumulatedForces += aerodynamicForce.magnitude * dt;                          Vector3d acceleration = gravityAccel + aerodynamicForce / aerodynamicModel_.mass;                            // acceleration in the vessel reference frame is acceleration - gravityAccel                          maxAccelBackBuffer_ = Math.Max(                              (float) (aerodynamicForce.magnitude / aerodynamicModel_.mass)'                              maxAccelBackBuffer_);                              //vel += acceleration * dt;                          //pos += vel * dt;                            // Verlet integration (more precise than using the velocity)                          Vector3d ppos = prevPos;                          prevPos = pos;                          pos = pos + pos - ppos + acceleration * (dt * dt);                          vel = (pos - prevPos) / dt;                            currentTime += dt;                            double interval = altitude < 10000.0 ? trajectoryInterval * 0.1 : trajectoryInterval;                          if (currentTime >= lastPositionStoredUT + interval)                          {                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' pos' currentTime));                              if (lastPositionStoredUT > 0)                              {                                  // check terrain collision' to detect impact on mountains etc.                                  Vector3 rayOrigin = lastPositionStored;                                  Vector3 rayEnd = pos;                                  double absGroundAltitude = groundAltitude + body.Radius;                                  if (absGroundAltitude > rayEnd.magnitude)                                  {                                      hitGround = true;                                      float coeff = Math.Max(0.01f' (float)((absGroundAltitude - rayOrigin.magnitude)                                          / (rayEnd.magnitude - rayOrigin.magnitude)));                                      pos = rayEnd * coeff + rayOrigin * (1.0f - coeff);                                      currentTime = currentTime * coeff + lastPositionStoredUT * (1.0f - coeff);                                  }                              }                                lastPositionStoredUT = currentTime;                              if (nextPosIdx == chunkSize)                              {                                  buffer.Add(new Point[chunkSize]);                                  nextPosIdx = 0;                              }                              Vector3d nextPos = pos;                              if (Settings.fetch.BodyFixedMode)                              {                                  nextPos = calculateRotatedPosition(body' nextPos' currentTime);                              }                              buffer.Last()[nextPosIdx].aerodynamicForce = aerodynamicForce;                              buffer.Last()[nextPosIdx].orbitalVelocity = vel;                              buffer.Last()[nextPosIdx].groundAltitude = (float)groundAltitude;                              buffer.Last()[nextPosIdx].time = currentTime;                              buffer.Last()[nextPosIdx++].pos = nextPos;                              lastPositionStored = pos;                          }                      }                  }              }              else              {                  // no atmospheric entry' just add the space orbit                  patchesBackBuffer_.Add(patch);                  if (nextPatch != null)                  {                      AddPatch_outState = new VesselState                      {                          position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                          velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                          referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                          time = patch.endTime'                          stockPatch = nextPatch                      };                      yield break;                  }                  else                  {                      AddPatch_outState = null;                      yield break;                  }              }
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,AddPatch,The following statement contains a magic number: if (minAltitude < maxAtmosphereAltitude)              {                  double entryTime;                  if (startingState.position.magnitude <= body.Radius + maxAtmosphereAltitude)                  {                      // whole orbit is inside the atmosphere                      entryTime = startingState.time;                  }                  else                  {                      entryTime = FindOrbitBodyIntersection(                          patch.spaceOrbit'                          startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                          body.Radius + maxAtmosphereAltitude);                  }                    if (entryTime > startingState.time + 0.1 || !body.atmosphere)                  {                      if (body.atmosphere)                      {                          // add the space patch before atmospheric entry                            patch.endTime = entryTime;                          patchesBackBuffer_.Add(patch);                          AddPatch_outState = new VesselState                          {                              position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime))'                              referenceBody = body'                              time = entryTime'                              velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime))                          };                          yield break;                      }                      else                      {                          // the body has no atmosphere' so what we actually computed is the entry                          // inside the "ground sphere" (defined by the maximal ground altitude)                          // now we iterate until the inner ground sphere (minimal altitude)' and                          // check if we hit the ground along the way                          double groundRangeExit = FindOrbitBodyIntersection(                              patch.spaceOrbit'                              startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                              body.Radius - maxAtmosphereAltitude);                            if (groundRangeExit <= entryTime)                              groundRangeExit = startingState.time + patch.spaceOrbit.timeToPe;                            double iterationSize = (groundRangeExit - entryTime) / 100.0;                          double t;                          bool groundImpact = false;                          for(t = entryTime; t < groundRangeExit; t += iterationSize)                          {                              Vector3d pos = patch.spaceOrbit.getRelativePositionAtUT(t);                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' Util.SwapYZ(pos)' t))                                  + body.Radius;                              if (pos.magnitude < groundAltitude)                              {                                  t -= iterationSize;                                  groundImpact = true;                                  break;                              }                          }                            if (groundImpact)                          {                              patch.endTime = t;                              patch.rawImpactPosition = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(t));                              patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' t);                              patch.impactVelocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(t));                              patchesBackBuffer_.Add(patch);                              AddPatch_outState = null;                              yield break;                          }                          else                          {                              // no impact' just add the space orbit                              patchesBackBuffer_.Add(patch);                              if (nextPatch != null)                              {                                  AddPatch_outState = new VesselState                                  {                                      position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                                      velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                                      referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                                      time = patch.endTime'                                      stockPatch = nextPatch                                  };                                  yield break;                              }                              else                              {                                  AddPatch_outState = null;                                  yield break;                              }                          }                      }                  }                  else                  {                      if (patch.startingState.referenceBody != vessel_.mainBody)                      {                          // currently' we can't handle predictions for another body' so we stop                          AddPatch_outState = null;                          yield break;                      }                        // simulate atmospheric flight (drag and lift)' until impact or atmosphere exit                      // (typically for an aerobraking maneuver) assuming a constant angle of attack                      patch.isAtmospheric = true;                      patch.startingState.stockPatch = null;                        // lower dt would be more accurate' but a tradeoff has to be found between performances and accuracy                      double dt = 0.1;                        // some shallow entries can result in very long flight. For performances reasons'                      // we limit the prediction duration                      int maxIterations = (int)(30.0 * 60.0 / dt);                        int chunkSize = 128;                        // time between two consecutive stored positions (more intermediate positions are computed for better accuracy)'                      // also used for ground collision checks                      double trajectoryInterval = 10.0;                        var buffer = new List<Point[]>();                      buffer.Add(new Point[chunkSize]);                      int nextPosIdx = 0;                        Vector3d pos = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime));                      Vector3d vel = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime));                        //Util.PostSingleScreenMessage("atmo start cond"' "Atmospheric start: vel=" + vel.ToString("0.00") + " (mag=" + vel.magnitude.ToString("0.00") + ")");                        Vector3d prevPos = pos - vel * dt;                      double currentTime = entryTime;                      double lastPositionStoredUT = 0;                      Vector3d lastPositionStored = new Vector3d();                      bool hitGround = false;                      int iteration = 0;                      int incrementIterations = 0;                      int minIterationsPerIncrement = maxIterations / Settings.fetch.MaxFramesPerPatch;                      double accumulatedForces = 0;                      while (true)                      {                          ++iteration;                          ++incrementIterations;                            if (incrementIterations > minIterationsPerIncrement && incrementTime_.ElapsedMilliseconds > MaxIncrementTime)                          {                              yield return false;                              incrementIterations = 0;                          }                            double R = pos.magnitude;                          double altitude = R - body.Radius;                          double atmosphereCoeff = altitude / maxAtmosphereAltitude;                          if (hitGround                              || atmosphereCoeff <= 0.0 || atmosphereCoeff >= 1.0                              || iteration == maxIterations || currentTime > patch.endTime)                          {                              //Util.PostSingleScreenMessage("atmo force"' "Atmospheric accumulated force: " + accumulatedForces.ToString("0.00"));                                if (hitGround || atmosphereCoeff <= 0.0)                              {                                  patch.rawImpactPosition = pos;                                  patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' currentTime);                                  patch.impactVelocity = vel;                              }                                patch.endTime = Math.Min(currentTime' patch.endTime);                                int totalCount = (buffer.Count - 1) * chunkSize + nextPosIdx;                              patch.atmosphericTrajectory = new Point[totalCount];                              int outIdx = 0;                              foreach (var chunk in buffer)                              {                                  foreach (var p in chunk)                                  {                                      if (outIdx == totalCount)                                          break;                                      patch.atmosphericTrajectory[outIdx++] = p;                                  }                              }                                if (iteration == maxIterations)                              {                                  ScreenMessages.PostScreenMessage("WARNING: trajectory prediction stopped' too many iterations");                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else if (atmosphereCoeff <= 0.0 || hitGround)                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = new VesselState                                  {                                      position = pos'                                      velocity = vel'                                      referenceBody = body'                                      time = patch.endTime                                  };                                  yield break;                              }                          }                            Vector3d gravityAccel = pos * (-body.gravParameter / (R * R * R));                            //Util.PostSingleScreenMessage("prediction vel"' "prediction vel = " + vel);                          Vector3d airVelocity = vel - body.getRFrmVel(body.position + pos);                          double angleOfAttack = profile.GetAngleOfAttack(body' pos' airVelocity);                          Vector3d aerodynamicForce = aerodynamicModel_.GetForces(body' pos' airVelocity' angleOfAttack);                          accumulatedForces += aerodynamicForce.magnitude * dt;                          Vector3d acceleration = gravityAccel + aerodynamicForce / aerodynamicModel_.mass;                            // acceleration in the vessel reference frame is acceleration - gravityAccel                          maxAccelBackBuffer_ = Math.Max(                              (float) (aerodynamicForce.magnitude / aerodynamicModel_.mass)'                              maxAccelBackBuffer_);                              //vel += acceleration * dt;                          //pos += vel * dt;                            // Verlet integration (more precise than using the velocity)                          Vector3d ppos = prevPos;                          prevPos = pos;                          pos = pos + pos - ppos + acceleration * (dt * dt);                          vel = (pos - prevPos) / dt;                            currentTime += dt;                            double interval = altitude < 10000.0 ? trajectoryInterval * 0.1 : trajectoryInterval;                          if (currentTime >= lastPositionStoredUT + interval)                          {                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' pos' currentTime));                              if (lastPositionStoredUT > 0)                              {                                  // check terrain collision' to detect impact on mountains etc.                                  Vector3 rayOrigin = lastPositionStored;                                  Vector3 rayEnd = pos;                                  double absGroundAltitude = groundAltitude + body.Radius;                                  if (absGroundAltitude > rayEnd.magnitude)                                  {                                      hitGround = true;                                      float coeff = Math.Max(0.01f' (float)((absGroundAltitude - rayOrigin.magnitude)                                          / (rayEnd.magnitude - rayOrigin.magnitude)));                                      pos = rayEnd * coeff + rayOrigin * (1.0f - coeff);                                      currentTime = currentTime * coeff + lastPositionStoredUT * (1.0f - coeff);                                  }                              }                                lastPositionStoredUT = currentTime;                              if (nextPosIdx == chunkSize)                              {                                  buffer.Add(new Point[chunkSize]);                                  nextPosIdx = 0;                              }                              Vector3d nextPos = pos;                              if (Settings.fetch.BodyFixedMode)                              {                                  nextPos = calculateRotatedPosition(body' nextPos' currentTime);                              }                              buffer.Last()[nextPosIdx].aerodynamicForce = aerodynamicForce;                              buffer.Last()[nextPosIdx].orbitalVelocity = vel;                              buffer.Last()[nextPosIdx].groundAltitude = (float)groundAltitude;                              buffer.Last()[nextPosIdx].time = currentTime;                              buffer.Last()[nextPosIdx++].pos = nextPos;                              lastPositionStored = pos;                          }                      }                  }              }              else              {                  // no atmospheric entry' just add the space orbit                  patchesBackBuffer_.Add(patch);                  if (nextPatch != null)                  {                      AddPatch_outState = new VesselState                      {                          position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                          velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                          referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                          time = patch.endTime'                          stockPatch = nextPatch                      };                      yield break;                  }                  else                  {                      AddPatch_outState = null;                      yield break;                  }              }
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,AddPatch,The following statement contains a magic number: if (minAltitude < maxAtmosphereAltitude)              {                  double entryTime;                  if (startingState.position.magnitude <= body.Radius + maxAtmosphereAltitude)                  {                      // whole orbit is inside the atmosphere                      entryTime = startingState.time;                  }                  else                  {                      entryTime = FindOrbitBodyIntersection(                          patch.spaceOrbit'                          startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                          body.Radius + maxAtmosphereAltitude);                  }                    if (entryTime > startingState.time + 0.1 || !body.atmosphere)                  {                      if (body.atmosphere)                      {                          // add the space patch before atmospheric entry                            patch.endTime = entryTime;                          patchesBackBuffer_.Add(patch);                          AddPatch_outState = new VesselState                          {                              position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime))'                              referenceBody = body'                              time = entryTime'                              velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime))                          };                          yield break;                      }                      else                      {                          // the body has no atmosphere' so what we actually computed is the entry                          // inside the "ground sphere" (defined by the maximal ground altitude)                          // now we iterate until the inner ground sphere (minimal altitude)' and                          // check if we hit the ground along the way                          double groundRangeExit = FindOrbitBodyIntersection(                              patch.spaceOrbit'                              startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                              body.Radius - maxAtmosphereAltitude);                            if (groundRangeExit <= entryTime)                              groundRangeExit = startingState.time + patch.spaceOrbit.timeToPe;                            double iterationSize = (groundRangeExit - entryTime) / 100.0;                          double t;                          bool groundImpact = false;                          for(t = entryTime; t < groundRangeExit; t += iterationSize)                          {                              Vector3d pos = patch.spaceOrbit.getRelativePositionAtUT(t);                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' Util.SwapYZ(pos)' t))                                  + body.Radius;                              if (pos.magnitude < groundAltitude)                              {                                  t -= iterationSize;                                  groundImpact = true;                                  break;                              }                          }                            if (groundImpact)                          {                              patch.endTime = t;                              patch.rawImpactPosition = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(t));                              patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' t);                              patch.impactVelocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(t));                              patchesBackBuffer_.Add(patch);                              AddPatch_outState = null;                              yield break;                          }                          else                          {                              // no impact' just add the space orbit                              patchesBackBuffer_.Add(patch);                              if (nextPatch != null)                              {                                  AddPatch_outState = new VesselState                                  {                                      position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                                      velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                                      referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                                      time = patch.endTime'                                      stockPatch = nextPatch                                  };                                  yield break;                              }                              else                              {                                  AddPatch_outState = null;                                  yield break;                              }                          }                      }                  }                  else                  {                      if (patch.startingState.referenceBody != vessel_.mainBody)                      {                          // currently' we can't handle predictions for another body' so we stop                          AddPatch_outState = null;                          yield break;                      }                        // simulate atmospheric flight (drag and lift)' until impact or atmosphere exit                      // (typically for an aerobraking maneuver) assuming a constant angle of attack                      patch.isAtmospheric = true;                      patch.startingState.stockPatch = null;                        // lower dt would be more accurate' but a tradeoff has to be found between performances and accuracy                      double dt = 0.1;                        // some shallow entries can result in very long flight. For performances reasons'                      // we limit the prediction duration                      int maxIterations = (int)(30.0 * 60.0 / dt);                        int chunkSize = 128;                        // time between two consecutive stored positions (more intermediate positions are computed for better accuracy)'                      // also used for ground collision checks                      double trajectoryInterval = 10.0;                        var buffer = new List<Point[]>();                      buffer.Add(new Point[chunkSize]);                      int nextPosIdx = 0;                        Vector3d pos = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime));                      Vector3d vel = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime));                        //Util.PostSingleScreenMessage("atmo start cond"' "Atmospheric start: vel=" + vel.ToString("0.00") + " (mag=" + vel.magnitude.ToString("0.00") + ")");                        Vector3d prevPos = pos - vel * dt;                      double currentTime = entryTime;                      double lastPositionStoredUT = 0;                      Vector3d lastPositionStored = new Vector3d();                      bool hitGround = false;                      int iteration = 0;                      int incrementIterations = 0;                      int minIterationsPerIncrement = maxIterations / Settings.fetch.MaxFramesPerPatch;                      double accumulatedForces = 0;                      while (true)                      {                          ++iteration;                          ++incrementIterations;                            if (incrementIterations > minIterationsPerIncrement && incrementTime_.ElapsedMilliseconds > MaxIncrementTime)                          {                              yield return false;                              incrementIterations = 0;                          }                            double R = pos.magnitude;                          double altitude = R - body.Radius;                          double atmosphereCoeff = altitude / maxAtmosphereAltitude;                          if (hitGround                              || atmosphereCoeff <= 0.0 || atmosphereCoeff >= 1.0                              || iteration == maxIterations || currentTime > patch.endTime)                          {                              //Util.PostSingleScreenMessage("atmo force"' "Atmospheric accumulated force: " + accumulatedForces.ToString("0.00"));                                if (hitGround || atmosphereCoeff <= 0.0)                              {                                  patch.rawImpactPosition = pos;                                  patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' currentTime);                                  patch.impactVelocity = vel;                              }                                patch.endTime = Math.Min(currentTime' patch.endTime);                                int totalCount = (buffer.Count - 1) * chunkSize + nextPosIdx;                              patch.atmosphericTrajectory = new Point[totalCount];                              int outIdx = 0;                              foreach (var chunk in buffer)                              {                                  foreach (var p in chunk)                                  {                                      if (outIdx == totalCount)                                          break;                                      patch.atmosphericTrajectory[outIdx++] = p;                                  }                              }                                if (iteration == maxIterations)                              {                                  ScreenMessages.PostScreenMessage("WARNING: trajectory prediction stopped' too many iterations");                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else if (atmosphereCoeff <= 0.0 || hitGround)                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = new VesselState                                  {                                      position = pos'                                      velocity = vel'                                      referenceBody = body'                                      time = patch.endTime                                  };                                  yield break;                              }                          }                            Vector3d gravityAccel = pos * (-body.gravParameter / (R * R * R));                            //Util.PostSingleScreenMessage("prediction vel"' "prediction vel = " + vel);                          Vector3d airVelocity = vel - body.getRFrmVel(body.position + pos);                          double angleOfAttack = profile.GetAngleOfAttack(body' pos' airVelocity);                          Vector3d aerodynamicForce = aerodynamicModel_.GetForces(body' pos' airVelocity' angleOfAttack);                          accumulatedForces += aerodynamicForce.magnitude * dt;                          Vector3d acceleration = gravityAccel + aerodynamicForce / aerodynamicModel_.mass;                            // acceleration in the vessel reference frame is acceleration - gravityAccel                          maxAccelBackBuffer_ = Math.Max(                              (float) (aerodynamicForce.magnitude / aerodynamicModel_.mass)'                              maxAccelBackBuffer_);                              //vel += acceleration * dt;                          //pos += vel * dt;                            // Verlet integration (more precise than using the velocity)                          Vector3d ppos = prevPos;                          prevPos = pos;                          pos = pos + pos - ppos + acceleration * (dt * dt);                          vel = (pos - prevPos) / dt;                            currentTime += dt;                            double interval = altitude < 10000.0 ? trajectoryInterval * 0.1 : trajectoryInterval;                          if (currentTime >= lastPositionStoredUT + interval)                          {                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' pos' currentTime));                              if (lastPositionStoredUT > 0)                              {                                  // check terrain collision' to detect impact on mountains etc.                                  Vector3 rayOrigin = lastPositionStored;                                  Vector3 rayEnd = pos;                                  double absGroundAltitude = groundAltitude + body.Radius;                                  if (absGroundAltitude > rayEnd.magnitude)                                  {                                      hitGround = true;                                      float coeff = Math.Max(0.01f' (float)((absGroundAltitude - rayOrigin.magnitude)                                          / (rayEnd.magnitude - rayOrigin.magnitude)));                                      pos = rayEnd * coeff + rayOrigin * (1.0f - coeff);                                      currentTime = currentTime * coeff + lastPositionStoredUT * (1.0f - coeff);                                  }                              }                                lastPositionStoredUT = currentTime;                              if (nextPosIdx == chunkSize)                              {                                  buffer.Add(new Point[chunkSize]);                                  nextPosIdx = 0;                              }                              Vector3d nextPos = pos;                              if (Settings.fetch.BodyFixedMode)                              {                                  nextPos = calculateRotatedPosition(body' nextPos' currentTime);                              }                              buffer.Last()[nextPosIdx].aerodynamicForce = aerodynamicForce;                              buffer.Last()[nextPosIdx].orbitalVelocity = vel;                              buffer.Last()[nextPosIdx].groundAltitude = (float)groundAltitude;                              buffer.Last()[nextPosIdx].time = currentTime;                              buffer.Last()[nextPosIdx++].pos = nextPos;                              lastPositionStored = pos;                          }                      }                  }              }              else              {                  // no atmospheric entry' just add the space orbit                  patchesBackBuffer_.Add(patch);                  if (nextPatch != null)                  {                      AddPatch_outState = new VesselState                      {                          position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                          velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                          referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                          time = patch.endTime'                          stockPatch = nextPatch                      };                      yield break;                  }                  else                  {                      AddPatch_outState = null;                      yield break;                  }              }
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,AddPatch,The following statement contains a magic number: if (minAltitude < maxAtmosphereAltitude)              {                  double entryTime;                  if (startingState.position.magnitude <= body.Radius + maxAtmosphereAltitude)                  {                      // whole orbit is inside the atmosphere                      entryTime = startingState.time;                  }                  else                  {                      entryTime = FindOrbitBodyIntersection(                          patch.spaceOrbit'                          startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                          body.Radius + maxAtmosphereAltitude);                  }                    if (entryTime > startingState.time + 0.1 || !body.atmosphere)                  {                      if (body.atmosphere)                      {                          // add the space patch before atmospheric entry                            patch.endTime = entryTime;                          patchesBackBuffer_.Add(patch);                          AddPatch_outState = new VesselState                          {                              position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime))'                              referenceBody = body'                              time = entryTime'                              velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime))                          };                          yield break;                      }                      else                      {                          // the body has no atmosphere' so what we actually computed is the entry                          // inside the "ground sphere" (defined by the maximal ground altitude)                          // now we iterate until the inner ground sphere (minimal altitude)' and                          // check if we hit the ground along the way                          double groundRangeExit = FindOrbitBodyIntersection(                              patch.spaceOrbit'                              startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                              body.Radius - maxAtmosphereAltitude);                            if (groundRangeExit <= entryTime)                              groundRangeExit = startingState.time + patch.spaceOrbit.timeToPe;                            double iterationSize = (groundRangeExit - entryTime) / 100.0;                          double t;                          bool groundImpact = false;                          for(t = entryTime; t < groundRangeExit; t += iterationSize)                          {                              Vector3d pos = patch.spaceOrbit.getRelativePositionAtUT(t);                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' Util.SwapYZ(pos)' t))                                  + body.Radius;                              if (pos.magnitude < groundAltitude)                              {                                  t -= iterationSize;                                  groundImpact = true;                                  break;                              }                          }                            if (groundImpact)                          {                              patch.endTime = t;                              patch.rawImpactPosition = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(t));                              patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' t);                              patch.impactVelocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(t));                              patchesBackBuffer_.Add(patch);                              AddPatch_outState = null;                              yield break;                          }                          else                          {                              // no impact' just add the space orbit                              patchesBackBuffer_.Add(patch);                              if (nextPatch != null)                              {                                  AddPatch_outState = new VesselState                                  {                                      position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                                      velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                                      referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                                      time = patch.endTime'                                      stockPatch = nextPatch                                  };                                  yield break;                              }                              else                              {                                  AddPatch_outState = null;                                  yield break;                              }                          }                      }                  }                  else                  {                      if (patch.startingState.referenceBody != vessel_.mainBody)                      {                          // currently' we can't handle predictions for another body' so we stop                          AddPatch_outState = null;                          yield break;                      }                        // simulate atmospheric flight (drag and lift)' until impact or atmosphere exit                      // (typically for an aerobraking maneuver) assuming a constant angle of attack                      patch.isAtmospheric = true;                      patch.startingState.stockPatch = null;                        // lower dt would be more accurate' but a tradeoff has to be found between performances and accuracy                      double dt = 0.1;                        // some shallow entries can result in very long flight. For performances reasons'                      // we limit the prediction duration                      int maxIterations = (int)(30.0 * 60.0 / dt);                        int chunkSize = 128;                        // time between two consecutive stored positions (more intermediate positions are computed for better accuracy)'                      // also used for ground collision checks                      double trajectoryInterval = 10.0;                        var buffer = new List<Point[]>();                      buffer.Add(new Point[chunkSize]);                      int nextPosIdx = 0;                        Vector3d pos = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime));                      Vector3d vel = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime));                        //Util.PostSingleScreenMessage("atmo start cond"' "Atmospheric start: vel=" + vel.ToString("0.00") + " (mag=" + vel.magnitude.ToString("0.00") + ")");                        Vector3d prevPos = pos - vel * dt;                      double currentTime = entryTime;                      double lastPositionStoredUT = 0;                      Vector3d lastPositionStored = new Vector3d();                      bool hitGround = false;                      int iteration = 0;                      int incrementIterations = 0;                      int minIterationsPerIncrement = maxIterations / Settings.fetch.MaxFramesPerPatch;                      double accumulatedForces = 0;                      while (true)                      {                          ++iteration;                          ++incrementIterations;                            if (incrementIterations > minIterationsPerIncrement && incrementTime_.ElapsedMilliseconds > MaxIncrementTime)                          {                              yield return false;                              incrementIterations = 0;                          }                            double R = pos.magnitude;                          double altitude = R - body.Radius;                          double atmosphereCoeff = altitude / maxAtmosphereAltitude;                          if (hitGround                              || atmosphereCoeff <= 0.0 || atmosphereCoeff >= 1.0                              || iteration == maxIterations || currentTime > patch.endTime)                          {                              //Util.PostSingleScreenMessage("atmo force"' "Atmospheric accumulated force: " + accumulatedForces.ToString("0.00"));                                if (hitGround || atmosphereCoeff <= 0.0)                              {                                  patch.rawImpactPosition = pos;                                  patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' currentTime);                                  patch.impactVelocity = vel;                              }                                patch.endTime = Math.Min(currentTime' patch.endTime);                                int totalCount = (buffer.Count - 1) * chunkSize + nextPosIdx;                              patch.atmosphericTrajectory = new Point[totalCount];                              int outIdx = 0;                              foreach (var chunk in buffer)                              {                                  foreach (var p in chunk)                                  {                                      if (outIdx == totalCount)                                          break;                                      patch.atmosphericTrajectory[outIdx++] = p;                                  }                              }                                if (iteration == maxIterations)                              {                                  ScreenMessages.PostScreenMessage("WARNING: trajectory prediction stopped' too many iterations");                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else if (atmosphereCoeff <= 0.0 || hitGround)                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = new VesselState                                  {                                      position = pos'                                      velocity = vel'                                      referenceBody = body'                                      time = patch.endTime                                  };                                  yield break;                              }                          }                            Vector3d gravityAccel = pos * (-body.gravParameter / (R * R * R));                            //Util.PostSingleScreenMessage("prediction vel"' "prediction vel = " + vel);                          Vector3d airVelocity = vel - body.getRFrmVel(body.position + pos);                          double angleOfAttack = profile.GetAngleOfAttack(body' pos' airVelocity);                          Vector3d aerodynamicForce = aerodynamicModel_.GetForces(body' pos' airVelocity' angleOfAttack);                          accumulatedForces += aerodynamicForce.magnitude * dt;                          Vector3d acceleration = gravityAccel + aerodynamicForce / aerodynamicModel_.mass;                            // acceleration in the vessel reference frame is acceleration - gravityAccel                          maxAccelBackBuffer_ = Math.Max(                              (float) (aerodynamicForce.magnitude / aerodynamicModel_.mass)'                              maxAccelBackBuffer_);                              //vel += acceleration * dt;                          //pos += vel * dt;                            // Verlet integration (more precise than using the velocity)                          Vector3d ppos = prevPos;                          prevPos = pos;                          pos = pos + pos - ppos + acceleration * (dt * dt);                          vel = (pos - prevPos) / dt;                            currentTime += dt;                            double interval = altitude < 10000.0 ? trajectoryInterval * 0.1 : trajectoryInterval;                          if (currentTime >= lastPositionStoredUT + interval)                          {                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' pos' currentTime));                              if (lastPositionStoredUT > 0)                              {                                  // check terrain collision' to detect impact on mountains etc.                                  Vector3 rayOrigin = lastPositionStored;                                  Vector3 rayEnd = pos;                                  double absGroundAltitude = groundAltitude + body.Radius;                                  if (absGroundAltitude > rayEnd.magnitude)                                  {                                      hitGround = true;                                      float coeff = Math.Max(0.01f' (float)((absGroundAltitude - rayOrigin.magnitude)                                          / (rayEnd.magnitude - rayOrigin.magnitude)));                                      pos = rayEnd * coeff + rayOrigin * (1.0f - coeff);                                      currentTime = currentTime * coeff + lastPositionStoredUT * (1.0f - coeff);                                  }                              }                                lastPositionStoredUT = currentTime;                              if (nextPosIdx == chunkSize)                              {                                  buffer.Add(new Point[chunkSize]);                                  nextPosIdx = 0;                              }                              Vector3d nextPos = pos;                              if (Settings.fetch.BodyFixedMode)                              {                                  nextPos = calculateRotatedPosition(body' nextPos' currentTime);                              }                              buffer.Last()[nextPosIdx].aerodynamicForce = aerodynamicForce;                              buffer.Last()[nextPosIdx].orbitalVelocity = vel;                              buffer.Last()[nextPosIdx].groundAltitude = (float)groundAltitude;                              buffer.Last()[nextPosIdx].time = currentTime;                              buffer.Last()[nextPosIdx++].pos = nextPos;                              lastPositionStored = pos;                          }                      }                  }              }              else              {                  // no atmospheric entry' just add the space orbit                  patchesBackBuffer_.Add(patch);                  if (nextPatch != null)                  {                      AddPatch_outState = new VesselState                      {                          position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                          velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                          referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                          time = patch.endTime'                          stockPatch = nextPatch                      };                      yield break;                  }                  else                  {                      AddPatch_outState = null;                      yield break;                  }              }
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,AddPatch,The following statement contains a magic number: if (minAltitude < maxAtmosphereAltitude)              {                  double entryTime;                  if (startingState.position.magnitude <= body.Radius + maxAtmosphereAltitude)                  {                      // whole orbit is inside the atmosphere                      entryTime = startingState.time;                  }                  else                  {                      entryTime = FindOrbitBodyIntersection(                          patch.spaceOrbit'                          startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                          body.Radius + maxAtmosphereAltitude);                  }                    if (entryTime > startingState.time + 0.1 || !body.atmosphere)                  {                      if (body.atmosphere)                      {                          // add the space patch before atmospheric entry                            patch.endTime = entryTime;                          patchesBackBuffer_.Add(patch);                          AddPatch_outState = new VesselState                          {                              position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime))'                              referenceBody = body'                              time = entryTime'                              velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime))                          };                          yield break;                      }                      else                      {                          // the body has no atmosphere' so what we actually computed is the entry                          // inside the "ground sphere" (defined by the maximal ground altitude)                          // now we iterate until the inner ground sphere (minimal altitude)' and                          // check if we hit the ground along the way                          double groundRangeExit = FindOrbitBodyIntersection(                              patch.spaceOrbit'                              startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                              body.Radius - maxAtmosphereAltitude);                            if (groundRangeExit <= entryTime)                              groundRangeExit = startingState.time + patch.spaceOrbit.timeToPe;                            double iterationSize = (groundRangeExit - entryTime) / 100.0;                          double t;                          bool groundImpact = false;                          for(t = entryTime; t < groundRangeExit; t += iterationSize)                          {                              Vector3d pos = patch.spaceOrbit.getRelativePositionAtUT(t);                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' Util.SwapYZ(pos)' t))                                  + body.Radius;                              if (pos.magnitude < groundAltitude)                              {                                  t -= iterationSize;                                  groundImpact = true;                                  break;                              }                          }                            if (groundImpact)                          {                              patch.endTime = t;                              patch.rawImpactPosition = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(t));                              patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' t);                              patch.impactVelocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(t));                              patchesBackBuffer_.Add(patch);                              AddPatch_outState = null;                              yield break;                          }                          else                          {                              // no impact' just add the space orbit                              patchesBackBuffer_.Add(patch);                              if (nextPatch != null)                              {                                  AddPatch_outState = new VesselState                                  {                                      position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                                      velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                                      referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                                      time = patch.endTime'                                      stockPatch = nextPatch                                  };                                  yield break;                              }                              else                              {                                  AddPatch_outState = null;                                  yield break;                              }                          }                      }                  }                  else                  {                      if (patch.startingState.referenceBody != vessel_.mainBody)                      {                          // currently' we can't handle predictions for another body' so we stop                          AddPatch_outState = null;                          yield break;                      }                        // simulate atmospheric flight (drag and lift)' until impact or atmosphere exit                      // (typically for an aerobraking maneuver) assuming a constant angle of attack                      patch.isAtmospheric = true;                      patch.startingState.stockPatch = null;                        // lower dt would be more accurate' but a tradeoff has to be found between performances and accuracy                      double dt = 0.1;                        // some shallow entries can result in very long flight. For performances reasons'                      // we limit the prediction duration                      int maxIterations = (int)(30.0 * 60.0 / dt);                        int chunkSize = 128;                        // time between two consecutive stored positions (more intermediate positions are computed for better accuracy)'                      // also used for ground collision checks                      double trajectoryInterval = 10.0;                        var buffer = new List<Point[]>();                      buffer.Add(new Point[chunkSize]);                      int nextPosIdx = 0;                        Vector3d pos = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime));                      Vector3d vel = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime));                        //Util.PostSingleScreenMessage("atmo start cond"' "Atmospheric start: vel=" + vel.ToString("0.00") + " (mag=" + vel.magnitude.ToString("0.00") + ")");                        Vector3d prevPos = pos - vel * dt;                      double currentTime = entryTime;                      double lastPositionStoredUT = 0;                      Vector3d lastPositionStored = new Vector3d();                      bool hitGround = false;                      int iteration = 0;                      int incrementIterations = 0;                      int minIterationsPerIncrement = maxIterations / Settings.fetch.MaxFramesPerPatch;                      double accumulatedForces = 0;                      while (true)                      {                          ++iteration;                          ++incrementIterations;                            if (incrementIterations > minIterationsPerIncrement && incrementTime_.ElapsedMilliseconds > MaxIncrementTime)                          {                              yield return false;                              incrementIterations = 0;                          }                            double R = pos.magnitude;                          double altitude = R - body.Radius;                          double atmosphereCoeff = altitude / maxAtmosphereAltitude;                          if (hitGround                              || atmosphereCoeff <= 0.0 || atmosphereCoeff >= 1.0                              || iteration == maxIterations || currentTime > patch.endTime)                          {                              //Util.PostSingleScreenMessage("atmo force"' "Atmospheric accumulated force: " + accumulatedForces.ToString("0.00"));                                if (hitGround || atmosphereCoeff <= 0.0)                              {                                  patch.rawImpactPosition = pos;                                  patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' currentTime);                                  patch.impactVelocity = vel;                              }                                patch.endTime = Math.Min(currentTime' patch.endTime);                                int totalCount = (buffer.Count - 1) * chunkSize + nextPosIdx;                              patch.atmosphericTrajectory = new Point[totalCount];                              int outIdx = 0;                              foreach (var chunk in buffer)                              {                                  foreach (var p in chunk)                                  {                                      if (outIdx == totalCount)                                          break;                                      patch.atmosphericTrajectory[outIdx++] = p;                                  }                              }                                if (iteration == maxIterations)                              {                                  ScreenMessages.PostScreenMessage("WARNING: trajectory prediction stopped' too many iterations");                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else if (atmosphereCoeff <= 0.0 || hitGround)                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = new VesselState                                  {                                      position = pos'                                      velocity = vel'                                      referenceBody = body'                                      time = patch.endTime                                  };                                  yield break;                              }                          }                            Vector3d gravityAccel = pos * (-body.gravParameter / (R * R * R));                            //Util.PostSingleScreenMessage("prediction vel"' "prediction vel = " + vel);                          Vector3d airVelocity = vel - body.getRFrmVel(body.position + pos);                          double angleOfAttack = profile.GetAngleOfAttack(body' pos' airVelocity);                          Vector3d aerodynamicForce = aerodynamicModel_.GetForces(body' pos' airVelocity' angleOfAttack);                          accumulatedForces += aerodynamicForce.magnitude * dt;                          Vector3d acceleration = gravityAccel + aerodynamicForce / aerodynamicModel_.mass;                            // acceleration in the vessel reference frame is acceleration - gravityAccel                          maxAccelBackBuffer_ = Math.Max(                              (float) (aerodynamicForce.magnitude / aerodynamicModel_.mass)'                              maxAccelBackBuffer_);                              //vel += acceleration * dt;                          //pos += vel * dt;                            // Verlet integration (more precise than using the velocity)                          Vector3d ppos = prevPos;                          prevPos = pos;                          pos = pos + pos - ppos + acceleration * (dt * dt);                          vel = (pos - prevPos) / dt;                            currentTime += dt;                            double interval = altitude < 10000.0 ? trajectoryInterval * 0.1 : trajectoryInterval;                          if (currentTime >= lastPositionStoredUT + interval)                          {                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' pos' currentTime));                              if (lastPositionStoredUT > 0)                              {                                  // check terrain collision' to detect impact on mountains etc.                                  Vector3 rayOrigin = lastPositionStored;                                  Vector3 rayEnd = pos;                                  double absGroundAltitude = groundAltitude + body.Radius;                                  if (absGroundAltitude > rayEnd.magnitude)                                  {                                      hitGround = true;                                      float coeff = Math.Max(0.01f' (float)((absGroundAltitude - rayOrigin.magnitude)                                          / (rayEnd.magnitude - rayOrigin.magnitude)));                                      pos = rayEnd * coeff + rayOrigin * (1.0f - coeff);                                      currentTime = currentTime * coeff + lastPositionStoredUT * (1.0f - coeff);                                  }                              }                                lastPositionStoredUT = currentTime;                              if (nextPosIdx == chunkSize)                              {                                  buffer.Add(new Point[chunkSize]);                                  nextPosIdx = 0;                              }                              Vector3d nextPos = pos;                              if (Settings.fetch.BodyFixedMode)                              {                                  nextPos = calculateRotatedPosition(body' nextPos' currentTime);                              }                              buffer.Last()[nextPosIdx].aerodynamicForce = aerodynamicForce;                              buffer.Last()[nextPosIdx].orbitalVelocity = vel;                              buffer.Last()[nextPosIdx].groundAltitude = (float)groundAltitude;                              buffer.Last()[nextPosIdx].time = currentTime;                              buffer.Last()[nextPosIdx++].pos = nextPos;                              lastPositionStored = pos;                          }                      }                  }              }              else              {                  // no atmospheric entry' just add the space orbit                  patchesBackBuffer_.Add(patch);                  if (nextPatch != null)                  {                      AddPatch_outState = new VesselState                      {                          position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                          velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                          referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                          time = patch.endTime'                          stockPatch = nextPatch                      };                      yield break;                  }                  else                  {                      AddPatch_outState = null;                      yield break;                  }              }
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,AddPatch,The following statement contains a magic number: if (minAltitude < maxAtmosphereAltitude)              {                  double entryTime;                  if (startingState.position.magnitude <= body.Radius + maxAtmosphereAltitude)                  {                      // whole orbit is inside the atmosphere                      entryTime = startingState.time;                  }                  else                  {                      entryTime = FindOrbitBodyIntersection(                          patch.spaceOrbit'                          startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                          body.Radius + maxAtmosphereAltitude);                  }                    if (entryTime > startingState.time + 0.1 || !body.atmosphere)                  {                      if (body.atmosphere)                      {                          // add the space patch before atmospheric entry                            patch.endTime = entryTime;                          patchesBackBuffer_.Add(patch);                          AddPatch_outState = new VesselState                          {                              position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime))'                              referenceBody = body'                              time = entryTime'                              velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime))                          };                          yield break;                      }                      else                      {                          // the body has no atmosphere' so what we actually computed is the entry                          // inside the "ground sphere" (defined by the maximal ground altitude)                          // now we iterate until the inner ground sphere (minimal altitude)' and                          // check if we hit the ground along the way                          double groundRangeExit = FindOrbitBodyIntersection(                              patch.spaceOrbit'                              startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                              body.Radius - maxAtmosphereAltitude);                            if (groundRangeExit <= entryTime)                              groundRangeExit = startingState.time + patch.spaceOrbit.timeToPe;                            double iterationSize = (groundRangeExit - entryTime) / 100.0;                          double t;                          bool groundImpact = false;                          for(t = entryTime; t < groundRangeExit; t += iterationSize)                          {                              Vector3d pos = patch.spaceOrbit.getRelativePositionAtUT(t);                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' Util.SwapYZ(pos)' t))                                  + body.Radius;                              if (pos.magnitude < groundAltitude)                              {                                  t -= iterationSize;                                  groundImpact = true;                                  break;                              }                          }                            if (groundImpact)                          {                              patch.endTime = t;                              patch.rawImpactPosition = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(t));                              patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' t);                              patch.impactVelocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(t));                              patchesBackBuffer_.Add(patch);                              AddPatch_outState = null;                              yield break;                          }                          else                          {                              // no impact' just add the space orbit                              patchesBackBuffer_.Add(patch);                              if (nextPatch != null)                              {                                  AddPatch_outState = new VesselState                                  {                                      position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                                      velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                                      referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                                      time = patch.endTime'                                      stockPatch = nextPatch                                  };                                  yield break;                              }                              else                              {                                  AddPatch_outState = null;                                  yield break;                              }                          }                      }                  }                  else                  {                      if (patch.startingState.referenceBody != vessel_.mainBody)                      {                          // currently' we can't handle predictions for another body' so we stop                          AddPatch_outState = null;                          yield break;                      }                        // simulate atmospheric flight (drag and lift)' until impact or atmosphere exit                      // (typically for an aerobraking maneuver) assuming a constant angle of attack                      patch.isAtmospheric = true;                      patch.startingState.stockPatch = null;                        // lower dt would be more accurate' but a tradeoff has to be found between performances and accuracy                      double dt = 0.1;                        // some shallow entries can result in very long flight. For performances reasons'                      // we limit the prediction duration                      int maxIterations = (int)(30.0 * 60.0 / dt);                        int chunkSize = 128;                        // time between two consecutive stored positions (more intermediate positions are computed for better accuracy)'                      // also used for ground collision checks                      double trajectoryInterval = 10.0;                        var buffer = new List<Point[]>();                      buffer.Add(new Point[chunkSize]);                      int nextPosIdx = 0;                        Vector3d pos = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime));                      Vector3d vel = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime));                        //Util.PostSingleScreenMessage("atmo start cond"' "Atmospheric start: vel=" + vel.ToString("0.00") + " (mag=" + vel.magnitude.ToString("0.00") + ")");                        Vector3d prevPos = pos - vel * dt;                      double currentTime = entryTime;                      double lastPositionStoredUT = 0;                      Vector3d lastPositionStored = new Vector3d();                      bool hitGround = false;                      int iteration = 0;                      int incrementIterations = 0;                      int minIterationsPerIncrement = maxIterations / Settings.fetch.MaxFramesPerPatch;                      double accumulatedForces = 0;                      while (true)                      {                          ++iteration;                          ++incrementIterations;                            if (incrementIterations > minIterationsPerIncrement && incrementTime_.ElapsedMilliseconds > MaxIncrementTime)                          {                              yield return false;                              incrementIterations = 0;                          }                            double R = pos.magnitude;                          double altitude = R - body.Radius;                          double atmosphereCoeff = altitude / maxAtmosphereAltitude;                          if (hitGround                              || atmosphereCoeff <= 0.0 || atmosphereCoeff >= 1.0                              || iteration == maxIterations || currentTime > patch.endTime)                          {                              //Util.PostSingleScreenMessage("atmo force"' "Atmospheric accumulated force: " + accumulatedForces.ToString("0.00"));                                if (hitGround || atmosphereCoeff <= 0.0)                              {                                  patch.rawImpactPosition = pos;                                  patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' currentTime);                                  patch.impactVelocity = vel;                              }                                patch.endTime = Math.Min(currentTime' patch.endTime);                                int totalCount = (buffer.Count - 1) * chunkSize + nextPosIdx;                              patch.atmosphericTrajectory = new Point[totalCount];                              int outIdx = 0;                              foreach (var chunk in buffer)                              {                                  foreach (var p in chunk)                                  {                                      if (outIdx == totalCount)                                          break;                                      patch.atmosphericTrajectory[outIdx++] = p;                                  }                              }                                if (iteration == maxIterations)                              {                                  ScreenMessages.PostScreenMessage("WARNING: trajectory prediction stopped' too many iterations");                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else if (atmosphereCoeff <= 0.0 || hitGround)                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = new VesselState                                  {                                      position = pos'                                      velocity = vel'                                      referenceBody = body'                                      time = patch.endTime                                  };                                  yield break;                              }                          }                            Vector3d gravityAccel = pos * (-body.gravParameter / (R * R * R));                            //Util.PostSingleScreenMessage("prediction vel"' "prediction vel = " + vel);                          Vector3d airVelocity = vel - body.getRFrmVel(body.position + pos);                          double angleOfAttack = profile.GetAngleOfAttack(body' pos' airVelocity);                          Vector3d aerodynamicForce = aerodynamicModel_.GetForces(body' pos' airVelocity' angleOfAttack);                          accumulatedForces += aerodynamicForce.magnitude * dt;                          Vector3d acceleration = gravityAccel + aerodynamicForce / aerodynamicModel_.mass;                            // acceleration in the vessel reference frame is acceleration - gravityAccel                          maxAccelBackBuffer_ = Math.Max(                              (float) (aerodynamicForce.magnitude / aerodynamicModel_.mass)'                              maxAccelBackBuffer_);                              //vel += acceleration * dt;                          //pos += vel * dt;                            // Verlet integration (more precise than using the velocity)                          Vector3d ppos = prevPos;                          prevPos = pos;                          pos = pos + pos - ppos + acceleration * (dt * dt);                          vel = (pos - prevPos) / dt;                            currentTime += dt;                            double interval = altitude < 10000.0 ? trajectoryInterval * 0.1 : trajectoryInterval;                          if (currentTime >= lastPositionStoredUT + interval)                          {                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' pos' currentTime));                              if (lastPositionStoredUT > 0)                              {                                  // check terrain collision' to detect impact on mountains etc.                                  Vector3 rayOrigin = lastPositionStored;                                  Vector3 rayEnd = pos;                                  double absGroundAltitude = groundAltitude + body.Radius;                                  if (absGroundAltitude > rayEnd.magnitude)                                  {                                      hitGround = true;                                      float coeff = Math.Max(0.01f' (float)((absGroundAltitude - rayOrigin.magnitude)                                          / (rayEnd.magnitude - rayOrigin.magnitude)));                                      pos = rayEnd * coeff + rayOrigin * (1.0f - coeff);                                      currentTime = currentTime * coeff + lastPositionStoredUT * (1.0f - coeff);                                  }                              }                                lastPositionStoredUT = currentTime;                              if (nextPosIdx == chunkSize)                              {                                  buffer.Add(new Point[chunkSize]);                                  nextPosIdx = 0;                              }                              Vector3d nextPos = pos;                              if (Settings.fetch.BodyFixedMode)                              {                                  nextPos = calculateRotatedPosition(body' nextPos' currentTime);                              }                              buffer.Last()[nextPosIdx].aerodynamicForce = aerodynamicForce;                              buffer.Last()[nextPosIdx].orbitalVelocity = vel;                              buffer.Last()[nextPosIdx].groundAltitude = (float)groundAltitude;                              buffer.Last()[nextPosIdx].time = currentTime;                              buffer.Last()[nextPosIdx++].pos = nextPos;                              lastPositionStored = pos;                          }                      }                  }              }              else              {                  // no atmospheric entry' just add the space orbit                  patchesBackBuffer_.Add(patch);                  if (nextPatch != null)                  {                      AddPatch_outState = new VesselState                      {                          position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                          velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                          referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                          time = patch.endTime'                          stockPatch = nextPatch                      };                      yield break;                  }                  else                  {                      AddPatch_outState = null;                      yield break;                  }              }
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,AddPatch,The following statement contains a magic number: if (minAltitude < maxAtmosphereAltitude)              {                  double entryTime;                  if (startingState.position.magnitude <= body.Radius + maxAtmosphereAltitude)                  {                      // whole orbit is inside the atmosphere                      entryTime = startingState.time;                  }                  else                  {                      entryTime = FindOrbitBodyIntersection(                          patch.spaceOrbit'                          startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                          body.Radius + maxAtmosphereAltitude);                  }                    if (entryTime > startingState.time + 0.1 || !body.atmosphere)                  {                      if (body.atmosphere)                      {                          // add the space patch before atmospheric entry                            patch.endTime = entryTime;                          patchesBackBuffer_.Add(patch);                          AddPatch_outState = new VesselState                          {                              position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime))'                              referenceBody = body'                              time = entryTime'                              velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime))                          };                          yield break;                      }                      else                      {                          // the body has no atmosphere' so what we actually computed is the entry                          // inside the "ground sphere" (defined by the maximal ground altitude)                          // now we iterate until the inner ground sphere (minimal altitude)' and                          // check if we hit the ground along the way                          double groundRangeExit = FindOrbitBodyIntersection(                              patch.spaceOrbit'                              startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                              body.Radius - maxAtmosphereAltitude);                            if (groundRangeExit <= entryTime)                              groundRangeExit = startingState.time + patch.spaceOrbit.timeToPe;                            double iterationSize = (groundRangeExit - entryTime) / 100.0;                          double t;                          bool groundImpact = false;                          for(t = entryTime; t < groundRangeExit; t += iterationSize)                          {                              Vector3d pos = patch.spaceOrbit.getRelativePositionAtUT(t);                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' Util.SwapYZ(pos)' t))                                  + body.Radius;                              if (pos.magnitude < groundAltitude)                              {                                  t -= iterationSize;                                  groundImpact = true;                                  break;                              }                          }                            if (groundImpact)                          {                              patch.endTime = t;                              patch.rawImpactPosition = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(t));                              patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' t);                              patch.impactVelocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(t));                              patchesBackBuffer_.Add(patch);                              AddPatch_outState = null;                              yield break;                          }                          else                          {                              // no impact' just add the space orbit                              patchesBackBuffer_.Add(patch);                              if (nextPatch != null)                              {                                  AddPatch_outState = new VesselState                                  {                                      position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                                      velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                                      referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                                      time = patch.endTime'                                      stockPatch = nextPatch                                  };                                  yield break;                              }                              else                              {                                  AddPatch_outState = null;                                  yield break;                              }                          }                      }                  }                  else                  {                      if (patch.startingState.referenceBody != vessel_.mainBody)                      {                          // currently' we can't handle predictions for another body' so we stop                          AddPatch_outState = null;                          yield break;                      }                        // simulate atmospheric flight (drag and lift)' until impact or atmosphere exit                      // (typically for an aerobraking maneuver) assuming a constant angle of attack                      patch.isAtmospheric = true;                      patch.startingState.stockPatch = null;                        // lower dt would be more accurate' but a tradeoff has to be found between performances and accuracy                      double dt = 0.1;                        // some shallow entries can result in very long flight. For performances reasons'                      // we limit the prediction duration                      int maxIterations = (int)(30.0 * 60.0 / dt);                        int chunkSize = 128;                        // time between two consecutive stored positions (more intermediate positions are computed for better accuracy)'                      // also used for ground collision checks                      double trajectoryInterval = 10.0;                        var buffer = new List<Point[]>();                      buffer.Add(new Point[chunkSize]);                      int nextPosIdx = 0;                        Vector3d pos = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime));                      Vector3d vel = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime));                        //Util.PostSingleScreenMessage("atmo start cond"' "Atmospheric start: vel=" + vel.ToString("0.00") + " (mag=" + vel.magnitude.ToString("0.00") + ")");                        Vector3d prevPos = pos - vel * dt;                      double currentTime = entryTime;                      double lastPositionStoredUT = 0;                      Vector3d lastPositionStored = new Vector3d();                      bool hitGround = false;                      int iteration = 0;                      int incrementIterations = 0;                      int minIterationsPerIncrement = maxIterations / Settings.fetch.MaxFramesPerPatch;                      double accumulatedForces = 0;                      while (true)                      {                          ++iteration;                          ++incrementIterations;                            if (incrementIterations > minIterationsPerIncrement && incrementTime_.ElapsedMilliseconds > MaxIncrementTime)                          {                              yield return false;                              incrementIterations = 0;                          }                            double R = pos.magnitude;                          double altitude = R - body.Radius;                          double atmosphereCoeff = altitude / maxAtmosphereAltitude;                          if (hitGround                              || atmosphereCoeff <= 0.0 || atmosphereCoeff >= 1.0                              || iteration == maxIterations || currentTime > patch.endTime)                          {                              //Util.PostSingleScreenMessage("atmo force"' "Atmospheric accumulated force: " + accumulatedForces.ToString("0.00"));                                if (hitGround || atmosphereCoeff <= 0.0)                              {                                  patch.rawImpactPosition = pos;                                  patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' currentTime);                                  patch.impactVelocity = vel;                              }                                patch.endTime = Math.Min(currentTime' patch.endTime);                                int totalCount = (buffer.Count - 1) * chunkSize + nextPosIdx;                              patch.atmosphericTrajectory = new Point[totalCount];                              int outIdx = 0;                              foreach (var chunk in buffer)                              {                                  foreach (var p in chunk)                                  {                                      if (outIdx == totalCount)                                          break;                                      patch.atmosphericTrajectory[outIdx++] = p;                                  }                              }                                if (iteration == maxIterations)                              {                                  ScreenMessages.PostScreenMessage("WARNING: trajectory prediction stopped' too many iterations");                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else if (atmosphereCoeff <= 0.0 || hitGround)                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = new VesselState                                  {                                      position = pos'                                      velocity = vel'                                      referenceBody = body'                                      time = patch.endTime                                  };                                  yield break;                              }                          }                            Vector3d gravityAccel = pos * (-body.gravParameter / (R * R * R));                            //Util.PostSingleScreenMessage("prediction vel"' "prediction vel = " + vel);                          Vector3d airVelocity = vel - body.getRFrmVel(body.position + pos);                          double angleOfAttack = profile.GetAngleOfAttack(body' pos' airVelocity);                          Vector3d aerodynamicForce = aerodynamicModel_.GetForces(body' pos' airVelocity' angleOfAttack);                          accumulatedForces += aerodynamicForce.magnitude * dt;                          Vector3d acceleration = gravityAccel + aerodynamicForce / aerodynamicModel_.mass;                            // acceleration in the vessel reference frame is acceleration - gravityAccel                          maxAccelBackBuffer_ = Math.Max(                              (float) (aerodynamicForce.magnitude / aerodynamicModel_.mass)'                              maxAccelBackBuffer_);                              //vel += acceleration * dt;                          //pos += vel * dt;                            // Verlet integration (more precise than using the velocity)                          Vector3d ppos = prevPos;                          prevPos = pos;                          pos = pos + pos - ppos + acceleration * (dt * dt);                          vel = (pos - prevPos) / dt;                            currentTime += dt;                            double interval = altitude < 10000.0 ? trajectoryInterval * 0.1 : trajectoryInterval;                          if (currentTime >= lastPositionStoredUT + interval)                          {                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' pos' currentTime));                              if (lastPositionStoredUT > 0)                              {                                  // check terrain collision' to detect impact on mountains etc.                                  Vector3 rayOrigin = lastPositionStored;                                  Vector3 rayEnd = pos;                                  double absGroundAltitude = groundAltitude + body.Radius;                                  if (absGroundAltitude > rayEnd.magnitude)                                  {                                      hitGround = true;                                      float coeff = Math.Max(0.01f' (float)((absGroundAltitude - rayOrigin.magnitude)                                          / (rayEnd.magnitude - rayOrigin.magnitude)));                                      pos = rayEnd * coeff + rayOrigin * (1.0f - coeff);                                      currentTime = currentTime * coeff + lastPositionStoredUT * (1.0f - coeff);                                  }                              }                                lastPositionStoredUT = currentTime;                              if (nextPosIdx == chunkSize)                              {                                  buffer.Add(new Point[chunkSize]);                                  nextPosIdx = 0;                              }                              Vector3d nextPos = pos;                              if (Settings.fetch.BodyFixedMode)                              {                                  nextPos = calculateRotatedPosition(body' nextPos' currentTime);                              }                              buffer.Last()[nextPosIdx].aerodynamicForce = aerodynamicForce;                              buffer.Last()[nextPosIdx].orbitalVelocity = vel;                              buffer.Last()[nextPosIdx].groundAltitude = (float)groundAltitude;                              buffer.Last()[nextPosIdx].time = currentTime;                              buffer.Last()[nextPosIdx++].pos = nextPos;                              lastPositionStored = pos;                          }                      }                  }              }              else              {                  // no atmospheric entry' just add the space orbit                  patchesBackBuffer_.Add(patch);                  if (nextPatch != null)                  {                      AddPatch_outState = new VesselState                      {                          position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                          velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                          referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                          time = patch.endTime'                          stockPatch = nextPatch                      };                      yield break;                  }                  else                  {                      AddPatch_outState = null;                      yield break;                  }              }
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,AddPatch,The following statement contains a magic number: if (minAltitude < maxAtmosphereAltitude)              {                  double entryTime;                  if (startingState.position.magnitude <= body.Radius + maxAtmosphereAltitude)                  {                      // whole orbit is inside the atmosphere                      entryTime = startingState.time;                  }                  else                  {                      entryTime = FindOrbitBodyIntersection(                          patch.spaceOrbit'                          startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                          body.Radius + maxAtmosphereAltitude);                  }                    if (entryTime > startingState.time + 0.1 || !body.atmosphere)                  {                      if (body.atmosphere)                      {                          // add the space patch before atmospheric entry                            patch.endTime = entryTime;                          patchesBackBuffer_.Add(patch);                          AddPatch_outState = new VesselState                          {                              position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime))'                              referenceBody = body'                              time = entryTime'                              velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime))                          };                          yield break;                      }                      else                      {                          // the body has no atmosphere' so what we actually computed is the entry                          // inside the "ground sphere" (defined by the maximal ground altitude)                          // now we iterate until the inner ground sphere (minimal altitude)' and                          // check if we hit the ground along the way                          double groundRangeExit = FindOrbitBodyIntersection(                              patch.spaceOrbit'                              startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                              body.Radius - maxAtmosphereAltitude);                            if (groundRangeExit <= entryTime)                              groundRangeExit = startingState.time + patch.spaceOrbit.timeToPe;                            double iterationSize = (groundRangeExit - entryTime) / 100.0;                          double t;                          bool groundImpact = false;                          for(t = entryTime; t < groundRangeExit; t += iterationSize)                          {                              Vector3d pos = patch.spaceOrbit.getRelativePositionAtUT(t);                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' Util.SwapYZ(pos)' t))                                  + body.Radius;                              if (pos.magnitude < groundAltitude)                              {                                  t -= iterationSize;                                  groundImpact = true;                                  break;                              }                          }                            if (groundImpact)                          {                              patch.endTime = t;                              patch.rawImpactPosition = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(t));                              patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' t);                              patch.impactVelocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(t));                              patchesBackBuffer_.Add(patch);                              AddPatch_outState = null;                              yield break;                          }                          else                          {                              // no impact' just add the space orbit                              patchesBackBuffer_.Add(patch);                              if (nextPatch != null)                              {                                  AddPatch_outState = new VesselState                                  {                                      position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                                      velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                                      referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                                      time = patch.endTime'                                      stockPatch = nextPatch                                  };                                  yield break;                              }                              else                              {                                  AddPatch_outState = null;                                  yield break;                              }                          }                      }                  }                  else                  {                      if (patch.startingState.referenceBody != vessel_.mainBody)                      {                          // currently' we can't handle predictions for another body' so we stop                          AddPatch_outState = null;                          yield break;                      }                        // simulate atmospheric flight (drag and lift)' until impact or atmosphere exit                      // (typically for an aerobraking maneuver) assuming a constant angle of attack                      patch.isAtmospheric = true;                      patch.startingState.stockPatch = null;                        // lower dt would be more accurate' but a tradeoff has to be found between performances and accuracy                      double dt = 0.1;                        // some shallow entries can result in very long flight. For performances reasons'                      // we limit the prediction duration                      int maxIterations = (int)(30.0 * 60.0 / dt);                        int chunkSize = 128;                        // time between two consecutive stored positions (more intermediate positions are computed for better accuracy)'                      // also used for ground collision checks                      double trajectoryInterval = 10.0;                        var buffer = new List<Point[]>();                      buffer.Add(new Point[chunkSize]);                      int nextPosIdx = 0;                        Vector3d pos = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime));                      Vector3d vel = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime));                        //Util.PostSingleScreenMessage("atmo start cond"' "Atmospheric start: vel=" + vel.ToString("0.00") + " (mag=" + vel.magnitude.ToString("0.00") + ")");                        Vector3d prevPos = pos - vel * dt;                      double currentTime = entryTime;                      double lastPositionStoredUT = 0;                      Vector3d lastPositionStored = new Vector3d();                      bool hitGround = false;                      int iteration = 0;                      int incrementIterations = 0;                      int minIterationsPerIncrement = maxIterations / Settings.fetch.MaxFramesPerPatch;                      double accumulatedForces = 0;                      while (true)                      {                          ++iteration;                          ++incrementIterations;                            if (incrementIterations > minIterationsPerIncrement && incrementTime_.ElapsedMilliseconds > MaxIncrementTime)                          {                              yield return false;                              incrementIterations = 0;                          }                            double R = pos.magnitude;                          double altitude = R - body.Radius;                          double atmosphereCoeff = altitude / maxAtmosphereAltitude;                          if (hitGround                              || atmosphereCoeff <= 0.0 || atmosphereCoeff >= 1.0                              || iteration == maxIterations || currentTime > patch.endTime)                          {                              //Util.PostSingleScreenMessage("atmo force"' "Atmospheric accumulated force: " + accumulatedForces.ToString("0.00"));                                if (hitGround || atmosphereCoeff <= 0.0)                              {                                  patch.rawImpactPosition = pos;                                  patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' currentTime);                                  patch.impactVelocity = vel;                              }                                patch.endTime = Math.Min(currentTime' patch.endTime);                                int totalCount = (buffer.Count - 1) * chunkSize + nextPosIdx;                              patch.atmosphericTrajectory = new Point[totalCount];                              int outIdx = 0;                              foreach (var chunk in buffer)                              {                                  foreach (var p in chunk)                                  {                                      if (outIdx == totalCount)                                          break;                                      patch.atmosphericTrajectory[outIdx++] = p;                                  }                              }                                if (iteration == maxIterations)                              {                                  ScreenMessages.PostScreenMessage("WARNING: trajectory prediction stopped' too many iterations");                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else if (atmosphereCoeff <= 0.0 || hitGround)                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = new VesselState                                  {                                      position = pos'                                      velocity = vel'                                      referenceBody = body'                                      time = patch.endTime                                  };                                  yield break;                              }                          }                            Vector3d gravityAccel = pos * (-body.gravParameter / (R * R * R));                            //Util.PostSingleScreenMessage("prediction vel"' "prediction vel = " + vel);                          Vector3d airVelocity = vel - body.getRFrmVel(body.position + pos);                          double angleOfAttack = profile.GetAngleOfAttack(body' pos' airVelocity);                          Vector3d aerodynamicForce = aerodynamicModel_.GetForces(body' pos' airVelocity' angleOfAttack);                          accumulatedForces += aerodynamicForce.magnitude * dt;                          Vector3d acceleration = gravityAccel + aerodynamicForce / aerodynamicModel_.mass;                            // acceleration in the vessel reference frame is acceleration - gravityAccel                          maxAccelBackBuffer_ = Math.Max(                              (float) (aerodynamicForce.magnitude / aerodynamicModel_.mass)'                              maxAccelBackBuffer_);                              //vel += acceleration * dt;                          //pos += vel * dt;                            // Verlet integration (more precise than using the velocity)                          Vector3d ppos = prevPos;                          prevPos = pos;                          pos = pos + pos - ppos + acceleration * (dt * dt);                          vel = (pos - prevPos) / dt;                            currentTime += dt;                            double interval = altitude < 10000.0 ? trajectoryInterval * 0.1 : trajectoryInterval;                          if (currentTime >= lastPositionStoredUT + interval)                          {                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' pos' currentTime));                              if (lastPositionStoredUT > 0)                              {                                  // check terrain collision' to detect impact on mountains etc.                                  Vector3 rayOrigin = lastPositionStored;                                  Vector3 rayEnd = pos;                                  double absGroundAltitude = groundAltitude + body.Radius;                                  if (absGroundAltitude > rayEnd.magnitude)                                  {                                      hitGround = true;                                      float coeff = Math.Max(0.01f' (float)((absGroundAltitude - rayOrigin.magnitude)                                          / (rayEnd.magnitude - rayOrigin.magnitude)));                                      pos = rayEnd * coeff + rayOrigin * (1.0f - coeff);                                      currentTime = currentTime * coeff + lastPositionStoredUT * (1.0f - coeff);                                  }                              }                                lastPositionStoredUT = currentTime;                              if (nextPosIdx == chunkSize)                              {                                  buffer.Add(new Point[chunkSize]);                                  nextPosIdx = 0;                              }                              Vector3d nextPos = pos;                              if (Settings.fetch.BodyFixedMode)                              {                                  nextPos = calculateRotatedPosition(body' nextPos' currentTime);                              }                              buffer.Last()[nextPosIdx].aerodynamicForce = aerodynamicForce;                              buffer.Last()[nextPosIdx].orbitalVelocity = vel;                              buffer.Last()[nextPosIdx].groundAltitude = (float)groundAltitude;                              buffer.Last()[nextPosIdx].time = currentTime;                              buffer.Last()[nextPosIdx++].pos = nextPos;                              lastPositionStored = pos;                          }                      }                  }              }              else              {                  // no atmospheric entry' just add the space orbit                  patchesBackBuffer_.Add(patch);                  if (nextPatch != null)                  {                      AddPatch_outState = new VesselState                      {                          position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                          velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                          referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                          time = patch.endTime'                          stockPatch = nextPatch                      };                      yield break;                  }                  else                  {                      AddPatch_outState = null;                      yield break;                  }              }
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,AddPatch,The following statement contains a magic number: if (minAltitude < maxAtmosphereAltitude)              {                  double entryTime;                  if (startingState.position.magnitude <= body.Radius + maxAtmosphereAltitude)                  {                      // whole orbit is inside the atmosphere                      entryTime = startingState.time;                  }                  else                  {                      entryTime = FindOrbitBodyIntersection(                          patch.spaceOrbit'                          startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                          body.Radius + maxAtmosphereAltitude);                  }                    if (entryTime > startingState.time + 0.1 || !body.atmosphere)                  {                      if (body.atmosphere)                      {                          // add the space patch before atmospheric entry                            patch.endTime = entryTime;                          patchesBackBuffer_.Add(patch);                          AddPatch_outState = new VesselState                          {                              position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime))'                              referenceBody = body'                              time = entryTime'                              velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime))                          };                          yield break;                      }                      else                      {                          // the body has no atmosphere' so what we actually computed is the entry                          // inside the "ground sphere" (defined by the maximal ground altitude)                          // now we iterate until the inner ground sphere (minimal altitude)' and                          // check if we hit the ground along the way                          double groundRangeExit = FindOrbitBodyIntersection(                              patch.spaceOrbit'                              startingState.time' startingState.time + patch.spaceOrbit.timeToPe'                              body.Radius - maxAtmosphereAltitude);                            if (groundRangeExit <= entryTime)                              groundRangeExit = startingState.time + patch.spaceOrbit.timeToPe;                            double iterationSize = (groundRangeExit - entryTime) / 100.0;                          double t;                          bool groundImpact = false;                          for(t = entryTime; t < groundRangeExit; t += iterationSize)                          {                              Vector3d pos = patch.spaceOrbit.getRelativePositionAtUT(t);                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' Util.SwapYZ(pos)' t))                                  + body.Radius;                              if (pos.magnitude < groundAltitude)                              {                                  t -= iterationSize;                                  groundImpact = true;                                  break;                              }                          }                            if (groundImpact)                          {                              patch.endTime = t;                              patch.rawImpactPosition = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(t));                              patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' t);                              patch.impactVelocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(t));                              patchesBackBuffer_.Add(patch);                              AddPatch_outState = null;                              yield break;                          }                          else                          {                              // no impact' just add the space orbit                              patchesBackBuffer_.Add(patch);                              if (nextPatch != null)                              {                                  AddPatch_outState = new VesselState                                  {                                      position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                                      velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                                      referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                                      time = patch.endTime'                                      stockPatch = nextPatch                                  };                                  yield break;                              }                              else                              {                                  AddPatch_outState = null;                                  yield break;                              }                          }                      }                  }                  else                  {                      if (patch.startingState.referenceBody != vessel_.mainBody)                      {                          // currently' we can't handle predictions for another body' so we stop                          AddPatch_outState = null;                          yield break;                      }                        // simulate atmospheric flight (drag and lift)' until impact or atmosphere exit                      // (typically for an aerobraking maneuver) assuming a constant angle of attack                      patch.isAtmospheric = true;                      patch.startingState.stockPatch = null;                        // lower dt would be more accurate' but a tradeoff has to be found between performances and accuracy                      double dt = 0.1;                        // some shallow entries can result in very long flight. For performances reasons'                      // we limit the prediction duration                      int maxIterations = (int)(30.0 * 60.0 / dt);                        int chunkSize = 128;                        // time between two consecutive stored positions (more intermediate positions are computed for better accuracy)'                      // also used for ground collision checks                      double trajectoryInterval = 10.0;                        var buffer = new List<Point[]>();                      buffer.Add(new Point[chunkSize]);                      int nextPosIdx = 0;                        Vector3d pos = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(entryTime));                      Vector3d vel = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(entryTime));                        //Util.PostSingleScreenMessage("atmo start cond"' "Atmospheric start: vel=" + vel.ToString("0.00") + " (mag=" + vel.magnitude.ToString("0.00") + ")");                        Vector3d prevPos = pos - vel * dt;                      double currentTime = entryTime;                      double lastPositionStoredUT = 0;                      Vector3d lastPositionStored = new Vector3d();                      bool hitGround = false;                      int iteration = 0;                      int incrementIterations = 0;                      int minIterationsPerIncrement = maxIterations / Settings.fetch.MaxFramesPerPatch;                      double accumulatedForces = 0;                      while (true)                      {                          ++iteration;                          ++incrementIterations;                            if (incrementIterations > minIterationsPerIncrement && incrementTime_.ElapsedMilliseconds > MaxIncrementTime)                          {                              yield return false;                              incrementIterations = 0;                          }                            double R = pos.magnitude;                          double altitude = R - body.Radius;                          double atmosphereCoeff = altitude / maxAtmosphereAltitude;                          if (hitGround                              || atmosphereCoeff <= 0.0 || atmosphereCoeff >= 1.0                              || iteration == maxIterations || currentTime > patch.endTime)                          {                              //Util.PostSingleScreenMessage("atmo force"' "Atmospheric accumulated force: " + accumulatedForces.ToString("0.00"));                                if (hitGround || atmosphereCoeff <= 0.0)                              {                                  patch.rawImpactPosition = pos;                                  patch.impactPosition = calculateRotatedPosition(body' patch.rawImpactPosition.Value' currentTime);                                  patch.impactVelocity = vel;                              }                                patch.endTime = Math.Min(currentTime' patch.endTime);                                int totalCount = (buffer.Count - 1) * chunkSize + nextPosIdx;                              patch.atmosphericTrajectory = new Point[totalCount];                              int outIdx = 0;                              foreach (var chunk in buffer)                              {                                  foreach (var p in chunk)                                  {                                      if (outIdx == totalCount)                                          break;                                      patch.atmosphericTrajectory[outIdx++] = p;                                  }                              }                                if (iteration == maxIterations)                              {                                  ScreenMessages.PostScreenMessage("WARNING: trajectory prediction stopped' too many iterations");                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else if (atmosphereCoeff <= 0.0 || hitGround)                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = null;                                  yield break;                              }                              else                              {                                  patchesBackBuffer_.Add(patch);                                  AddPatch_outState = new VesselState                                  {                                      position = pos'                                      velocity = vel'                                      referenceBody = body'                                      time = patch.endTime                                  };                                  yield break;                              }                          }                            Vector3d gravityAccel = pos * (-body.gravParameter / (R * R * R));                            //Util.PostSingleScreenMessage("prediction vel"' "prediction vel = " + vel);                          Vector3d airVelocity = vel - body.getRFrmVel(body.position + pos);                          double angleOfAttack = profile.GetAngleOfAttack(body' pos' airVelocity);                          Vector3d aerodynamicForce = aerodynamicModel_.GetForces(body' pos' airVelocity' angleOfAttack);                          accumulatedForces += aerodynamicForce.magnitude * dt;                          Vector3d acceleration = gravityAccel + aerodynamicForce / aerodynamicModel_.mass;                            // acceleration in the vessel reference frame is acceleration - gravityAccel                          maxAccelBackBuffer_ = Math.Max(                              (float) (aerodynamicForce.magnitude / aerodynamicModel_.mass)'                              maxAccelBackBuffer_);                              //vel += acceleration * dt;                          //pos += vel * dt;                            // Verlet integration (more precise than using the velocity)                          Vector3d ppos = prevPos;                          prevPos = pos;                          pos = pos + pos - ppos + acceleration * (dt * dt);                          vel = (pos - prevPos) / dt;                            currentTime += dt;                            double interval = altitude < 10000.0 ? trajectoryInterval * 0.1 : trajectoryInterval;                          if (currentTime >= lastPositionStoredUT + interval)                          {                              double groundAltitude = GetGroundAltitude(body' calculateRotatedPosition(body' pos' currentTime));                              if (lastPositionStoredUT > 0)                              {                                  // check terrain collision' to detect impact on mountains etc.                                  Vector3 rayOrigin = lastPositionStored;                                  Vector3 rayEnd = pos;                                  double absGroundAltitude = groundAltitude + body.Radius;                                  if (absGroundAltitude > rayEnd.magnitude)                                  {                                      hitGround = true;                                      float coeff = Math.Max(0.01f' (float)((absGroundAltitude - rayOrigin.magnitude)                                          / (rayEnd.magnitude - rayOrigin.magnitude)));                                      pos = rayEnd * coeff + rayOrigin * (1.0f - coeff);                                      currentTime = currentTime * coeff + lastPositionStoredUT * (1.0f - coeff);                                  }                              }                                lastPositionStoredUT = currentTime;                              if (nextPosIdx == chunkSize)                              {                                  buffer.Add(new Point[chunkSize]);                                  nextPosIdx = 0;                              }                              Vector3d nextPos = pos;                              if (Settings.fetch.BodyFixedMode)                              {                                  nextPos = calculateRotatedPosition(body' nextPos' currentTime);                              }                              buffer.Last()[nextPosIdx].aerodynamicForce = aerodynamicForce;                              buffer.Last()[nextPosIdx].orbitalVelocity = vel;                              buffer.Last()[nextPosIdx].groundAltitude = (float)groundAltitude;                              buffer.Last()[nextPosIdx].time = currentTime;                              buffer.Last()[nextPosIdx++].pos = nextPos;                              lastPositionStored = pos;                          }                      }                  }              }              else              {                  // no atmospheric entry' just add the space orbit                  patchesBackBuffer_.Add(patch);                  if (nextPatch != null)                  {                      AddPatch_outState = new VesselState                      {                          position = Util.SwapYZ(patch.spaceOrbit.getRelativePositionAtUT(patch.endTime))'                          velocity = Util.SwapYZ(patch.spaceOrbit.getOrbitalVelocityAtUT(patch.endTime))'                          referenceBody = nextPatch == null ? body : nextPatch.referenceBody'                          time = patch.endTime'                          stockPatch = nextPatch                      };                      yield break;                  }                  else                  {                      AddPatch_outState = null;                      yield break;                  }              }
Magic Number,Trajectories,Trajectory,C:\repos\neuoy_KSPTrajectories\Plugin\Trajectory.cs,calculateRotatedPosition,The following statement contains a magic number: float angle = (float)(-(time - Planetarium.GetUniversalTime()) * body.angularVelocity.magnitude / Math.PI * 180.0);
Magic Number,Trajectories,Util,C:\repos\neuoy_KSPTrajectories\Plugin\Util.cs,Microseconds,The following statement contains a magic number: return clocks * 1000000.0 / Stopwatch.Frequency;
Magic Number,Trajectories,Util,C:\repos\neuoy_KSPTrajectories\Plugin\Util.cs,Milliseconds,The following statement contains a magic number: return clocks * 1000.0 / Stopwatch.Frequency;
Magic Number,Trajectories,Util,C:\repos\neuoy_KSPTrajectories\Plugin\Util.cs,FastRandomFloat,The following statement contains a magic number: fast_float_seed *= 16807;
Magic Number,Trajectories,Util,C:\repos\neuoy_KSPTrajectories\Plugin\Util.cs,distanceFromLatitudeAndLongitude,The following statement contains a magic number: double sin1 = Math.Sin(Math.PI / 180.0 * (originLatidue - destinationLatitude) / 2);
Magic Number,Trajectories,Util,C:\repos\neuoy_KSPTrajectories\Plugin\Util.cs,distanceFromLatitudeAndLongitude,The following statement contains a magic number: double sin1 = Math.Sin(Math.PI / 180.0 * (originLatidue - destinationLatitude) / 2);
Magic Number,Trajectories,Util,C:\repos\neuoy_KSPTrajectories\Plugin\Util.cs,distanceFromLatitudeAndLongitude,The following statement contains a magic number: double sin2 = Math.Sin(Math.PI / 180.0 * (originLongitude - destinationLongitude) / 2);
Magic Number,Trajectories,Util,C:\repos\neuoy_KSPTrajectories\Plugin\Util.cs,distanceFromLatitudeAndLongitude,The following statement contains a magic number: double sin2 = Math.Sin(Math.PI / 180.0 * (originLongitude - destinationLongitude) / 2);
Magic Number,Trajectories,Util,C:\repos\neuoy_KSPTrajectories\Plugin\Util.cs,distanceFromLatitudeAndLongitude,The following statement contains a magic number: double cos1 = Math.Cos(Math.PI / 180.0 * destinationLatitude);
Magic Number,Trajectories,Util,C:\repos\neuoy_KSPTrajectories\Plugin\Util.cs,distanceFromLatitudeAndLongitude,The following statement contains a magic number: double cos2 = Math.Cos(Math.PI / 180.0 * originLatidue);
Magic Number,Trajectories,Util,C:\repos\neuoy_KSPTrajectories\Plugin\Util.cs,distanceFromLatitudeAndLongitude,The following statement contains a magic number: double lateralDist = 2 * bodyRadius *                  Math.Asin(Math.Sqrt(sin1 * sin1 + cos1 * cos2 * sin2 * sin2));
Magic Number,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,InitCache,The following statement contains a magic number: double maxCacheVelocity = 10000.0;
Magic Number,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,InitCache,The following statement contains a magic number: double maxCacheAoA = 180.0 / 180.0 * Math.PI;
Magic Number,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,InitCache,The following statement contains a magic number: double maxCacheAoA = 180.0 / 180.0 * Math.PI;
Magic Number,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,InitCache,The following statement contains a magic number: int velocityResolution = 32;
Magic Number,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,InitCache,The following statement contains a magic number: int angleOfAttackResolution = 33;
Magic Number,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,InitCache,The following statement contains a magic number: int altitudeResolution = 32;
Magic Number,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,isValidFor,The following statement contains a magic number: if (Settings.fetch.AutoUpdateAerodynamicModel)              {                  double newRefDrag = ComputeReferenceDrag();                  if (referenceDrag == 0)                  {                      referenceDrag = newRefDrag;                  }                  double ratio = Math.Max(newRefDrag' referenceDrag) / Math.Max(1' Math.Min(newRefDrag' referenceDrag));                  if (ratio > 1.2 && DateTime.Now > nextAllowedAutomaticUpdate || referencePartCount != vessel.Parts.Count)                  {                      nextAllowedAutomaticUpdate = DateTime.Now.AddSeconds(10); // limit updates frequency (could make the game almost unresponsive on some computers)  #if DEBUG                      ScreenMessages.PostScreenMessage("Trajectory aerodynamic model auto-updated");  #endif                      isValid = false;                  }              }
Magic Number,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,isValidFor,The following statement contains a magic number: if (Settings.fetch.AutoUpdateAerodynamicModel)              {                  double newRefDrag = ComputeReferenceDrag();                  if (referenceDrag == 0)                  {                      referenceDrag = newRefDrag;                  }                  double ratio = Math.Max(newRefDrag' referenceDrag) / Math.Max(1' Math.Min(newRefDrag' referenceDrag));                  if (ratio > 1.2 && DateTime.Now > nextAllowedAutomaticUpdate || referencePartCount != vessel.Parts.Count)                  {                      nextAllowedAutomaticUpdate = DateTime.Now.AddSeconds(10); // limit updates frequency (could make the game almost unresponsive on some computers)  #if DEBUG                      ScreenMessages.PostScreenMessage("Trajectory aerodynamic model auto-updated");  #endif                      isValid = false;                  }              }
Magic Number,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,ComputeReferenceDrag,The following statement contains a magic number: Vector3 forces = ComputeForces(3000' new Vector3d(3000.0' 0' 0)' new Vector3(0' 1' 0)' 0);
Magic Number,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,ComputeReferenceDrag,The following statement contains a magic number: Vector3 forces = ComputeForces(3000' new Vector3d(3000.0' 0' 0)' new Vector3(0' 1' 0)' 0);
Magic Number,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,ComputeForces,The following statement contains a magic number: if (velRight.sqrMagnitude < 0.001)              {                  velRight = Vector3d.Cross(vesselUp' velBackward);                  if (velRight.sqrMagnitude < 0.001)                  {                      velRight = Vector3d.Cross(vesselBackward' velBackward).normalized;                  }                  else                  {                      velRight = velRight.normalized;                  }              }              else                  velRight = velRight.normalized;
Magic Number,Trajectories,VesselAerodynamicModel,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\VesselAerodynamicModel.cs,ComputeForces,The following statement contains a magic number: if (velRight.sqrMagnitude < 0.001)              {                  velRight = Vector3d.Cross(vesselUp' velBackward);                  if (velRight.sqrMagnitude < 0.001)                  {                      velRight = Vector3d.Cross(vesselBackward' velBackward).normalized;                  }                  else                  {                      velRight = velRight.normalized;                  }              }              else                  velRight = velRight.normalized;
Missing Default,Trajectories,AerodynamicModelFactory,C:\repos\neuoy_KSPTrajectories\Plugin\AerodynamicModel\AerodynamicModelFactory.cs,GetModel,The following switch statement is missing a default case: switch (loadedAssembly.name)                      {                          case "FerramAerospaceResearch":                              var FARAPIType = loadedAssembly.assembly.GetType("FerramAerospaceResearch.FARAPI");                                    var FARAPI_CalculateVesselAeroForces = FARAPIType.GetMethodEx("CalculateVesselAeroForces"' BindingFlags.Public | BindingFlags.Static' new Type[] { typeof(Vessel)' typeof(Vector3).MakeByRefType()' typeof(Vector3).MakeByRefType()' typeof(Vector3)' typeof(double) });                                return new FARModel(ship' body' FARAPI_CalculateVesselAeroForces);                            //case "MyModAssembly":                          // implement here your atmo mod detection                          // return new MyModModel(ship' body' any other parameter);                      }
